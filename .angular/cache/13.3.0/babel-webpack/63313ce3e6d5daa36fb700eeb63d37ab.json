{"ast":null,"code":"/* eslint-disable */\nimport { Injectable, Input as Input$1, Output, Directive, NgModule, EventEmitter, ElementRef, NgZone, ViewContainerRef, ViewChild, Optional, Component, ContentChildren, QueryList, ChangeDetectionStrategy, ViewChildren, ChangeDetectorRef, Injector, Inject, forwardRef, ContentChild } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { NgControl, FormsModule } from '@angular/forms';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/forms';\nimport * as ɵngcc2 from '@angular/common';\nvar _c0 = [\"initElement\"];\n\nfunction MbscInput_span_5_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"span\", 5);\n  }\n}\n\nfunction MbscInput_span_6_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\", 6);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r2 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r2.errorMessage);\n  }\n}\n\nvar _c1 = [\"*\"];\n\nfunction MbscCalendarComponent_mbsc_input_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"mbsc-input\", 1);\n    ɵngcc0.ɵɵprojection(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"controlNg\", false)(\"name\", ctx_r0.name)(\"theme\", ctx_r0.theme)(\"themeVariant\", ctx_r0.themeVariant)(\"label-style\", ctx_r0.labelStyle)(\"input-style\", ctx_r0.inputStyle)(\"disabled\", ctx_r0.disabled)(\"dropdown\", ctx_r0.dropdown)(\"placeholder\", ctx_r0.placeholder)(\"error\", ctx_r0.error)(\"errorMessage\", ctx_r0.errorMessage)(\"icon\", ctx_r0.inputIcon)(\"icon-align\", ctx_r0.iconAlign);\n  }\n}\n\nfunction MbscColorComponent_mbsc_input_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"mbsc-input\", 1);\n    ɵngcc0.ɵɵprojection(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"controlNg\", false)(\"name\", ctx_r0.name)(\"theme\", ctx_r0.theme)(\"themeVariant\", ctx_r0.themeVariant)(\"label-style\", ctx_r0.labelStyle)(\"input-style\", ctx_r0.inputStyle)(\"disabled\", ctx_r0.disabled)(\"dropdown\", ctx_r0.dropdown)(\"placeholder\", ctx_r0.placeholder)(\"error\", ctx_r0.error)(\"errorMessage\", ctx_r0.errorMessage)(\"icon\", ctx_r0.inputIcon)(\"icon-align\", ctx_r0.iconAlign);\n  }\n}\n\nfunction MbscDateComponent_mbsc_input_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"mbsc-input\", 1);\n    ɵngcc0.ɵɵprojection(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"controlNg\", false)(\"name\", ctx_r0.name)(\"theme\", ctx_r0.theme)(\"themeVariant\", ctx_r0.themeVariant)(\"label-style\", ctx_r0.labelStyle)(\"input-style\", ctx_r0.inputStyle)(\"disabled\", ctx_r0.disabled)(\"dropdown\", ctx_r0.dropdown)(\"placeholder\", ctx_r0.placeholder)(\"error\", ctx_r0.error)(\"errorMessage\", ctx_r0.errorMessage)(\"icon\", ctx_r0.inputIcon)(\"icon-align\", ctx_r0.iconAlign);\n  }\n}\n\nfunction MbscTimeComponent_mbsc_input_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"mbsc-input\", 1);\n    ɵngcc0.ɵɵprojection(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"controlNg\", false)(\"name\", ctx_r0.name)(\"theme\", ctx_r0.theme)(\"themeVariant\", ctx_r0.themeVariant)(\"label-style\", ctx_r0.labelStyle)(\"input-style\", ctx_r0.inputStyle)(\"disabled\", ctx_r0.disabled)(\"dropdown\", ctx_r0.dropdown)(\"placeholder\", ctx_r0.placeholder)(\"error\", ctx_r0.error)(\"errorMessage\", ctx_r0.errorMessage)(\"icon\", ctx_r0.inputIcon)(\"icon-align\", ctx_r0.iconAlign);\n  }\n}\n\nfunction MbscDatetimeComponent_mbsc_input_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"mbsc-input\", 1);\n    ɵngcc0.ɵɵprojection(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"controlNg\", false)(\"name\", ctx_r0.name)(\"theme\", ctx_r0.theme)(\"themeVariant\", ctx_r0.themeVariant)(\"label-style\", ctx_r0.labelStyle)(\"input-style\", ctx_r0.inputStyle)(\"disabled\", ctx_r0.disabled)(\"dropdown\", ctx_r0.dropdown)(\"placeholder\", ctx_r0.placeholder)(\"error\", ctx_r0.error)(\"errorMessage\", ctx_r0.errorMessage)(\"icon\", ctx_r0.inputIcon)(\"icon-align\", ctx_r0.iconAlign);\n  }\n}\n\nvar _c2 = [\"rootElement\"];\n\nfunction MbscTextarea_span_5_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\", 4);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r1.errorMessage);\n  }\n}\n\nfunction MbscDropdown_span_6_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\", 4);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r1.errorMessage);\n  }\n}\n\nfunction MbscCheckbox_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\", 4);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r1.errorMessage);\n  }\n}\n\nfunction MbscSwitch_span_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\", 4);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r0.errorMessage);\n  }\n}\n\nfunction MbscRadio_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"span\", 4);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate(ctx_r1.errorMessage);\n  }\n}\n\nfunction MbscSegmented_span_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"span\");\n  }\n\n  if (rf & 2) {\n    var ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵclassMap(\"mbsc-ic mbsc-ic-\" + ctx_r1.icon);\n  }\n}\n\nvar _c3 = [\"inputElements\"];\n\nfunction MbscSlider_input_2_Template(rf, ctx) {\n  if (rf & 1) {\n    var _r4 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵelementStart(0, \"input\", 2, 3);\n    ɵngcc0.ɵɵlistener(\"blur\", function MbscSlider_input_2_Template_input_blur_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r4);\n      var ctx_r3 = ɵngcc0.ɵɵnextContext();\n      return ctx_r3.onTouch($event);\n    });\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var v_r1 = ctx.$implicit;\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"disabled\", ctx_r0.disabled);\n    ɵngcc0.ɵɵattribute(\"value\", ctx_r0.dummyArray.length > 1 && ctx_r0.initialValue ? ctx_r0.initialValue[v_r1] : ctx_r0.initialValue)(\"data-step-labels\", ctx_r0.dataStepLabels)(\"data-template\", ctx_r0.valueTemplate)(\"data-tooltip\", ctx_r0.tooltip ? \"true\" : null)(\"data-highlight\", ctx_r0.highlight)(\"data-live\", ctx_r0.live)(\"data-icon\", ctx_r0.icon ? ctx_r0.icon : null)(\"data-val\", ctx_r0.val ? ctx_r0.val : null)(\"data-label-style\", ctx_r0.labelStyle)(\"data-input-style\", ctx_r0.inputStyle)(\"name\", ctx_r0.name)(\"max\", ctx_r0.max !== undefined ? ctx_r0.max : null)(\"min\", ctx_r0.min !== undefined ? ctx_r0.min : null)(\"step\", ctx_r0.step !== undefined ? ctx_r0.step : null);\n  }\n}\n\nvar _c4 = [\"itemWrapper\"];\n\nfunction MbscImageComponent_mbsc_input_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"mbsc-input\", 2);\n    ɵngcc0.ɵɵtext(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"name\", ctx_r0.name)(\"theme\", ctx_r0.theme)(\"disabled\", ctx_r0.disabled)(\"error\", ctx_r0.error)(\"errorMessage\", ctx_r0.errorMessage)(\"icon\", ctx_r0.inputIcon)(\"icon-align\", ctx_r0.iconAlign)(\"placeholder\", ctx_r0.placeholder)(\"controlNg\", false);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\"\", ctx_r0.label, \" \");\n  }\n}\n\nfunction MbscMeasurementComponent_mbsc_input_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"mbsc-input\", 1);\n    ɵngcc0.ɵɵprojection(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"controlNg\", false)(\"name\", ctx_r0.name)(\"theme\", ctx_r0.theme)(\"themeVariant\", ctx_r0.themeVariant)(\"label-style\", ctx_r0.labelStyle)(\"input-style\", ctx_r0.inputStyle)(\"disabled\", ctx_r0.disabled)(\"dropdown\", ctx_r0.dropdown)(\"placeholder\", ctx_r0.placeholder)(\"error\", ctx_r0.error)(\"errorMessage\", ctx_r0.errorMessage)(\"icon\", ctx_r0.inputIcon)(\"icon-align\", ctx_r0.iconAlign);\n  }\n}\n\nfunction MbscTemperatureComponent_mbsc_input_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"mbsc-input\", 1);\n    ɵngcc0.ɵɵprojection(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"controlNg\", false)(\"name\", ctx_r0.name)(\"theme\", ctx_r0.theme)(\"themeVariant\", ctx_r0.themeVariant)(\"label-style\", ctx_r0.labelStyle)(\"input-style\", ctx_r0.inputStyle)(\"disabled\", ctx_r0.disabled)(\"dropdown\", ctx_r0.dropdown)(\"placeholder\", ctx_r0.placeholder)(\"error\", ctx_r0.error)(\"errorMessage\", ctx_r0.errorMessage)(\"icon\", ctx_r0.inputIcon)(\"icon-align\", ctx_r0.iconAlign);\n  }\n}\n\nfunction MbscDistanceComponent_mbsc_input_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"mbsc-input\", 1);\n    ɵngcc0.ɵɵprojection(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"controlNg\", false)(\"name\", ctx_r0.name)(\"theme\", ctx_r0.theme)(\"themeVariant\", ctx_r0.themeVariant)(\"label-style\", ctx_r0.labelStyle)(\"input-style\", ctx_r0.inputStyle)(\"disabled\", ctx_r0.disabled)(\"dropdown\", ctx_r0.dropdown)(\"placeholder\", ctx_r0.placeholder)(\"error\", ctx_r0.error)(\"errorMessage\", ctx_r0.errorMessage)(\"icon\", ctx_r0.inputIcon)(\"icon-align\", ctx_r0.iconAlign);\n  }\n}\n\nfunction MbscSpeedComponent_mbsc_input_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"mbsc-input\", 1);\n    ɵngcc0.ɵɵprojection(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"controlNg\", false)(\"name\", ctx_r0.name)(\"theme\", ctx_r0.theme)(\"themeVariant\", ctx_r0.themeVariant)(\"label-style\", ctx_r0.labelStyle)(\"input-style\", ctx_r0.inputStyle)(\"disabled\", ctx_r0.disabled)(\"dropdown\", ctx_r0.dropdown)(\"placeholder\", ctx_r0.placeholder)(\"error\", ctx_r0.error)(\"errorMessage\", ctx_r0.errorMessage)(\"icon\", ctx_r0.inputIcon)(\"icon-align\", ctx_r0.iconAlign);\n  }\n}\n\nfunction MbscForceComponent_mbsc_input_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"mbsc-input\", 1);\n    ɵngcc0.ɵɵprojection(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"controlNg\", false)(\"name\", ctx_r0.name)(\"theme\", ctx_r0.theme)(\"themeVariant\", ctx_r0.themeVariant)(\"label-style\", ctx_r0.labelStyle)(\"input-style\", ctx_r0.inputStyle)(\"disabled\", ctx_r0.disabled)(\"dropdown\", ctx_r0.dropdown)(\"placeholder\", ctx_r0.placeholder)(\"error\", ctx_r0.error)(\"errorMessage\", ctx_r0.errorMessage)(\"icon\", ctx_r0.inputIcon)(\"icon-align\", ctx_r0.iconAlign);\n  }\n}\n\nfunction MbscMassComponent_mbsc_input_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"mbsc-input\", 1);\n    ɵngcc0.ɵɵprojection(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"controlNg\", false)(\"name\", ctx_r0.name)(\"theme\", ctx_r0.theme)(\"themeVariant\", ctx_r0.themeVariant)(\"label-style\", ctx_r0.labelStyle)(\"input-style\", ctx_r0.inputStyle)(\"disabled\", ctx_r0.disabled)(\"dropdown\", ctx_r0.dropdown)(\"placeholder\", ctx_r0.placeholder)(\"error\", ctx_r0.error)(\"errorMessage\", ctx_r0.errorMessage)(\"icon\", ctx_r0.inputIcon)(\"icon-align\", ctx_r0.iconAlign);\n  }\n}\n\nfunction MbscNumberComponent_mbsc_input_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"mbsc-input\", 1);\n    ɵngcc0.ɵɵprojection(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"controlNg\", false)(\"name\", ctx_r0.name)(\"theme\", ctx_r0.theme)(\"themeVariant\", ctx_r0.themeVariant)(\"label-style\", ctx_r0.labelStyle)(\"input-style\", ctx_r0.inputStyle)(\"disabled\", ctx_r0.disabled)(\"dropdown\", ctx_r0.dropdown)(\"placeholder\", ctx_r0.placeholder)(\"error\", ctx_r0.error)(\"errorMessage\", ctx_r0.errorMessage)(\"icon\", ctx_r0.inputIcon)(\"icon-align\", ctx_r0.iconAlign);\n  }\n}\n\nfunction MbscNumpadComponent_mbsc_input_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"mbsc-input\", 1);\n    ɵngcc0.ɵɵprojection(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"controlNg\", false)(\"name\", ctx_r0.name)(\"theme\", ctx_r0.theme)(\"themeVariant\", ctx_r0.themeVariant)(\"label-style\", ctx_r0.labelStyle)(\"input-style\", ctx_r0.inputStyle)(\"disabled\", ctx_r0.disabled)(\"dropdown\", ctx_r0.dropdown)(\"placeholder\", ctx_r0.placeholder)(\"error\", ctx_r0.error)(\"errorMessage\", ctx_r0.errorMessage)(\"icon\", ctx_r0.inputIcon)(\"icon-align\", ctx_r0.iconAlign);\n  }\n}\n\nfunction MbscNumpadDecimalComponent_mbsc_input_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"mbsc-input\", 1);\n    ɵngcc0.ɵɵprojection(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"controlNg\", false)(\"name\", ctx_r0.name)(\"theme\", ctx_r0.theme)(\"themeVariant\", ctx_r0.themeVariant)(\"label-style\", ctx_r0.labelStyle)(\"input-style\", ctx_r0.inputStyle)(\"disabled\", ctx_r0.disabled)(\"dropdown\", ctx_r0.dropdown)(\"placeholder\", ctx_r0.placeholder)(\"error\", ctx_r0.error)(\"errorMessage\", ctx_r0.errorMessage)(\"icon\", ctx_r0.inputIcon)(\"icon-align\", ctx_r0.iconAlign);\n  }\n}\n\nfunction MbscNumpadDateComponent_mbsc_input_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"mbsc-input\", 1);\n    ɵngcc0.ɵɵprojection(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"controlNg\", false)(\"name\", ctx_r0.name)(\"theme\", ctx_r0.theme)(\"themeVariant\", ctx_r0.themeVariant)(\"label-style\", ctx_r0.labelStyle)(\"input-style\", ctx_r0.inputStyle)(\"disabled\", ctx_r0.disabled)(\"dropdown\", ctx_r0.dropdown)(\"placeholder\", ctx_r0.placeholder)(\"error\", ctx_r0.error)(\"errorMessage\", ctx_r0.errorMessage)(\"icon\", ctx_r0.inputIcon)(\"icon-align\", ctx_r0.iconAlign);\n  }\n}\n\nfunction MbscNumpadTimeComponent_mbsc_input_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"mbsc-input\", 1);\n    ɵngcc0.ɵɵprojection(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"controlNg\", false)(\"name\", ctx_r0.name)(\"theme\", ctx_r0.theme)(\"themeVariant\", ctx_r0.themeVariant)(\"label-style\", ctx_r0.labelStyle)(\"input-style\", ctx_r0.inputStyle)(\"disabled\", ctx_r0.disabled)(\"dropdown\", ctx_r0.dropdown)(\"placeholder\", ctx_r0.placeholder)(\"error\", ctx_r0.error)(\"errorMessage\", ctx_r0.errorMessage)(\"icon\", ctx_r0.inputIcon)(\"icon-align\", ctx_r0.iconAlign);\n  }\n}\n\nfunction MbscNumpadTimespanComponent_mbsc_input_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"mbsc-input\", 1);\n    ɵngcc0.ɵɵprojection(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"controlNg\", false)(\"name\", ctx_r0.name)(\"theme\", ctx_r0.theme)(\"themeVariant\", ctx_r0.themeVariant)(\"label-style\", ctx_r0.labelStyle)(\"input-style\", ctx_r0.inputStyle)(\"disabled\", ctx_r0.disabled)(\"dropdown\", ctx_r0.dropdown)(\"placeholder\", ctx_r0.placeholder)(\"error\", ctx_r0.error)(\"errorMessage\", ctx_r0.errorMessage)(\"icon\", ctx_r0.inputIcon)(\"icon-align\", ctx_r0.iconAlign);\n  }\n}\n\nfunction MbscRangeComponent_mbsc_input_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"mbsc-input\", 1);\n    ɵngcc0.ɵɵprojection(1, 2);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"controlNg\", false)(\"name\", ctx_r0.name)(\"theme\", ctx_r0.theme)(\"disabled\", ctx_r0.disabled)(\"dropdown\", ctx_r0.dropdown)(\"placeholder\", ctx_r0.placeholder)(\"error\", ctx_r0.error)(\"errorMessage\", ctx_r0.errorMessage)(\"icon\", ctx_r0.inputIcon)(\"icon-align\", ctx_r0.iconAlign);\n  }\n}\n\nvar _c5 = [[[\"mbsc-range-start\"]], [[\"mbsc-range-end\"]], \"*\"];\nvar _c6 = [\"mbsc-range-start\", \"mbsc-range-end\", \"*\"];\n\nfunction MbscScrollerComponent_mbsc_input_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"mbsc-input\", 1);\n    ɵngcc0.ɵɵprojection(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"controlNg\", false)(\"name\", ctx_r0.name)(\"theme\", ctx_r0.theme)(\"themeVariant\", ctx_r0.themeVariant)(\"label-style\", ctx_r0.labelStyle)(\"input-style\", ctx_r0.inputStyle)(\"disabled\", ctx_r0.disabled)(\"dropdown\", ctx_r0.dropdown)(\"placeholder\", ctx_r0.placeholder)(\"error\", ctx_r0.error)(\"errorMessage\", ctx_r0.errorMessage)(\"icon\", ctx_r0.inputIcon)(\"icon-align\", ctx_r0.iconAlign);\n  }\n}\n\nfunction MbscSelectComponent_mbsc_input_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"mbsc-input\", 1);\n    ɵngcc0.ɵɵprojection(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"controlNg\", false)(\"name\", ctx_r0.name)(\"theme\", ctx_r0.theme)(\"themeVariant\", ctx_r0.themeVariant)(\"label-style\", ctx_r0.labelStyle)(\"input-style\", ctx_r0.inputStyle)(\"disabled\", ctx_r0.disabled)(\"dropdown\", ctx_r0.dropdown)(\"placeholder\", ctx_r0.placeholder)(\"error\", ctx_r0.error)(\"errorMessage\", ctx_r0.errorMessage)(\"icon\", ctx_r0.inputIcon)(\"icon-align\", ctx_r0.iconAlign);\n  }\n}\n\nfunction MbscTimerComponent_mbsc_input_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"mbsc-input\", 1);\n    ɵngcc0.ɵɵprojection(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"controlNg\", false)(\"name\", ctx_r0.name)(\"theme\", ctx_r0.theme)(\"themeVariant\", ctx_r0.themeVariant)(\"label-style\", ctx_r0.labelStyle)(\"input-style\", ctx_r0.inputStyle)(\"disabled\", ctx_r0.disabled)(\"dropdown\", ctx_r0.dropdown)(\"placeholder\", ctx_r0.placeholder)(\"error\", ctx_r0.error)(\"errorMessage\", ctx_r0.errorMessage)(\"icon\", ctx_r0.inputIcon)(\"icon-align\", ctx_r0.iconAlign);\n  }\n}\n\nfunction MbscTimespanComponent_mbsc_input_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"mbsc-input\", 1);\n    ɵngcc0.ɵɵprojection(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"controlNg\", false)(\"name\", ctx_r0.name)(\"theme\", ctx_r0.theme)(\"themeVariant\", ctx_r0.themeVariant)(\"label-style\", ctx_r0.labelStyle)(\"input-style\", ctx_r0.inputStyle)(\"disabled\", ctx_r0.disabled)(\"dropdown\", ctx_r0.dropdown)(\"placeholder\", ctx_r0.placeholder)(\"error\", ctx_r0.error)(\"errorMessage\", ctx_r0.errorMessage)(\"icon\", ctx_r0.inputIcon)(\"icon-align\", ctx_r0.iconAlign);\n  }\n}\n\nfunction MbscTreelistComponent_mbsc_input_0_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementStart(0, \"mbsc-input\", 1);\n    ɵngcc0.ɵɵprojection(1);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    var ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵproperty(\"controlNg\", false)(\"name\", ctx_r0.name)(\"theme\", ctx_r0.theme)(\"themeVariant\", ctx_r0.themeVariant)(\"label-style\", ctx_r0.labelStyle)(\"input-style\", ctx_r0.inputStyle)(\"disabled\", ctx_r0.disabled)(\"dropdown\", ctx_r0.dropdown)(\"placeholder\", ctx_r0.placeholder)(\"error\", ctx_r0.error)(\"errorMessage\", ctx_r0.errorMessage)(\"icon\", ctx_r0.inputIcon)(\"icon-align\", ctx_r0.iconAlign);\n  }\n}\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nfunction __param(paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n}\n\nfunction __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nvar mobiscroll = mobiscroll || {},\n    util = {},\n    calendars = {};\n\nvar os,\n    vers,\n    majorVersion,\n    minorVersion,\n    version = [],\n    isBrowser = typeof window !== 'undefined',\n    isDark = isBrowser && window.matchMedia && window.matchMedia('(prefers-color-scheme:dark)').matches,\n    userAgent = isBrowser ? navigator.userAgent : '',\n    platform = isBrowser ? navigator.platform : '',\n    maxTouchPoints = isBrowser ? navigator.maxTouchPoints : 0,\n    isSafari = /Safari/.test(userAgent),\n    device = userAgent.match(/Android|iPhone|iPad|iPod|Windows Phone|Windows|MSIE/i),\n    raf = isBrowser && window.requestAnimationFrame || function (func) {\n  return setTimeout(func, 20);\n},\n    rafc = isBrowser && window.cancelAnimationFrame || function (id) {\n  clearTimeout(id);\n};\n\nif (/Android/i.test(device)) {\n  os = 'android';\n  vers = userAgent.match(/Android\\s+([\\d.]+)/i);\n\n  if (vers) {\n    version = vers[0].replace('Android ', '').split('.');\n  }\n} else if (/iPhone|iPad|iPod/i.test(device) || /iPhone|iPad|iPod/i.test(platform) || platform === 'MacIntel' && maxTouchPoints > 1) {\n  // On iPad with iOS 13 desktop site request is automatically enabled in Safari,\n  // so 'iPad' is no longer present in the user agent string.\n  // In this case we check `navigator.platform` and `navigator.maxTouchPoints`.\n  // maxTouchPoints is needed to exclude desktop Mac OS X.\n  os = 'ios';\n  vers = userAgent.match(/OS\\s+([\\d_]+)/i);\n\n  if (vers) {\n    version = vers[0].replace(/_/g, '.').replace('OS ', '').split('.');\n  }\n} else if (/Windows Phone/i.test(device)) {\n  os = 'wp';\n} else if (/Windows|MSIE/i.test(device)) {\n  os = 'windows';\n}\n\nmajorVersion = version[0];\nminorVersion = version[1];\n\nfunction testProps(props) {\n  var i;\n\n  for (i in props) {\n    if (mod[props[i]] !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction testPrefix() {\n  var prefixes = ['Webkit', 'Moz', 'O', 'ms'],\n      p;\n\n  for (p in prefixes) {\n    if (testProps([prefixes[p] + 'Transform'])) {\n      return '-' + prefixes[p].toLowerCase() + '-';\n    }\n  }\n\n  return '';\n}\n\nfunction testTouch(e, elm) {\n  if (e.type == 'touchstart') {\n    elm.__mbscTouched = 1;\n  } else if (elm.__mbscTouched) {\n    delete elm.__mbscTouched;\n    return false;\n  }\n\n  return true;\n}\n\nfunction getPosition(t, vertical) {\n  var prefixes = ['t', 'webkitT', 'MozT', 'OT', 'msT'],\n      style = getComputedStyle(t[0]),\n      i = 0,\n      matrix,\n      px,\n      v;\n\n  while (!matrix && i < prefixes.length) {\n    v = prefixes[i];\n\n    if (style[v + 'ransform'] !== undefined) {\n      matrix = style[v + 'ransform'];\n    }\n\n    i++;\n  }\n\n  matrix = matrix.split(')')[0].split(', ');\n  px = vertical ? matrix[13] || matrix[5] : matrix[12] || matrix[4];\n  return px;\n}\n\nfunction getTextColor(color) {\n  if (color) {\n    // Cache calculated text colors, because it is slow\n    if (textColors[color]) {\n      return textColors[color];\n    }\n\n    var ctx = canvas && canvas.getContext('2d');\n\n    if (!ctx) {\n      return '#fff';\n    } // Use canvas element, since it does not require DOM append\n\n\n    ctx.fillStyle = color;\n    ctx.fillRect(0, 0, 1, 1);\n    var rgb = ctx.getImageData(0, 0, 1, 1).data;\n    var delta = +rgb[0] * 0.299 + +rgb[1] * 0.587 + +rgb[2] * 0.114;\n    var textColor = delta < 130 ? '#fff' : '#000';\n    textColors[color] = textColor;\n    return textColor;\n  }\n}\n\nfunction scrollStep(el, startTime, from, to, callback) {\n  var elapsed = Math.min(1, (new Date() - startTime) / 468),\n      eased = 0.5 * (1 - Math.cos(Math.PI * elapsed)),\n      current = from + (to - from) * eased;\n  el.scrollTop = current;\n\n  if (current !== to) {\n    raf(function () {\n      scrollStep(el, startTime, from, to, callback);\n    });\n  } else if (callback) {\n    callback();\n  }\n}\n\nfunction smoothScroll(el, to, prevAnim, callback) {\n  if (prevAnim) {\n    el.scrollTop = to;\n\n    if (callback) {\n      callback();\n    }\n  } else {\n    scrollStep(el, new Date(), el.scrollTop, to, callback);\n  }\n}\n\nfunction listen(el, event, handler, opt) {\n  if (el) {\n    el.addEventListener(event, handler, opt);\n  }\n}\n\nfunction unlisten(el, event, handler, opt) {\n  if (el) {\n    el.removeEventListener(event, handler, opt);\n  }\n}\n\nfunction matches(element, selector) {\n  if (!selector || !element || element.nodeType !== 1) {\n    return false;\n  }\n\n  var matchesSelector = element.matches || element.matchesSelector || element.webkitMatchesSelector || element.mozMatchesSelector || element.msMatchesSelector;\n  return matchesSelector.call(element, selector);\n}\n\nfunction closest(el, target, selector) {\n  while (target) {\n    if (matches(target, selector)) {\n      return target;\n    }\n\n    target = target !== el ? target.parentNode : null;\n  }\n\n  return null;\n}\n\nfunction trigger(elm, name, data) {\n  var evt;\n\n  try {\n    evt = new CustomEvent(name, {\n      detail: data,\n      bubbles: true,\n      cancelable: true\n    });\n  } catch (e) {\n    evt = document.createEvent('Event');\n    evt.initEvent(name, true, true);\n    evt.detail = data;\n  }\n\n  elm.dispatchEvent(evt);\n}\n\nfunction setFocusInvisible() {\n  win.__mbscFocusVisible = false;\n}\n\nfunction setFocusVisible() {\n  win.__mbscFocusVisible = true;\n}\n\nfunction addWindowFocus() {\n  var focusCount = win.__mbscFocusCount || 0;\n\n  if (focusCount === 0) {\n    listen(win, 'mousedown', setFocusInvisible, true);\n    listen(win, 'keydown', setFocusVisible, true);\n  }\n\n  win.__mbscFocusCount = ++focusCount;\n}\n\nfunction removeWindowFocus() {\n  var focusCount = win.__mbscFocusCount || 0;\n  win.__mbscFocusCount = --focusCount;\n\n  if (win.__mbscFocusCount === 0) {\n    unlisten(win, 'mousedown', setFocusInvisible);\n    unlisten(win, 'keydown', setFocusVisible);\n  }\n}\n\nvar animEnd,\n    canvas,\n    mod,\n    cssPrefix,\n    hasGhostClick,\n    hasTransition,\n    isWebView,\n    isWkWebView,\n    jsPrefix,\n    win,\n    textColors = {};\n\nif (isBrowser) {\n  win = window;\n  canvas = document.createElement('canvas');\n  mod = document.createElement('modernizr').style;\n  cssPrefix = testPrefix();\n  jsPrefix = cssPrefix.replace(/^-/, '').replace(/-$/, '').replace('moz', 'Moz');\n  animEnd = mod.animation !== undefined ? 'animationend' : 'webkitAnimationEnd';\n  hasTransition = mod.transition !== undefined; // UIWebView on iOS still has the ghost click, \n  // WkWebView does not have a ghost click, but it's hard to tell if it's UIWebView or WkWebView\n  // In addition in iOS 12.2 if we enable tap handling, it brakes the form inputs\n  // (keyboard appears, but the cursor is not in the input).\n\n  isWebView = os === 'ios' && !isSafari;\n  isWkWebView = isWebView && win.webkit && win.webkit.messageHandlers;\n  hasGhostClick = mod.touchAction === undefined || isWebView && !isWkWebView;\n}\n\nvar cssNumber = {\n  'column-count': 1,\n  'columns': 1,\n  'font-weight': 1,\n  'line-height': 1,\n  'opacity': 1,\n  'z-index': 1,\n  'zoom': 1\n},\n    propMap = {\n  'readonly': 'readOnly'\n},\n    emptyArray = [],\n    _slice = Array.prototype.slice;\n\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\n\nfunction isObject(obj) {\n  return typeof obj === \"object\";\n}\n\nfunction likeArray(obj) {\n  return typeof obj.length == 'number';\n}\n\nfunction camelize(str) {\n  return str.replace(/-+(.)?/g, function (match, chr) {\n    return chr ? chr.toUpperCase() : '';\n  });\n}\n\nfunction extend(target, source, deep) {\n  for (var key in source) {\n    if (deep && ($.isPlainObject(source[key]) || $.isArray(source[key]))) {\n      if ($.isPlainObject(source[key]) && !$.isPlainObject(target[key]) || $.isArray(source[key]) && !$.isArray(target[key])) {\n        target[key] = {};\n      }\n\n      extend(target[key], source[key], deep);\n    } else if (source[key] !== undefined) {\n      target[key] = source[key];\n    }\n  }\n}\n\nfunction dasherize(str) {\n  return str.replace(/::/g, '/').replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2').replace(/([a-z\\d])([A-Z])/g, '$1_$2').replace(/_/g, '-').toLowerCase();\n}\n\nfunction maybeAddPx(name, value) {\n  return typeof value == \"number\" && !cssNumber[dasherize(name)] ? value + \"px\" : value;\n}\n\nvar Dom = function () {\n  var Dom = function Dom(arr) {\n    var _this = this,\n        i = 0; // Create array-like object\n\n\n    for (i = 0; i < arr.length; i++) {\n      _this[i] = arr[i];\n    }\n\n    _this.length = arr.length; // Return collection with methods\n\n    return $(this);\n  };\n\n  var $ = function $(selector, context) {\n    var arr = [],\n        i = 0;\n\n    if (selector && !context) {\n      if (selector instanceof Dom) {\n        return selector;\n      }\n    }\n\n    if (isFunction(selector)) {\n      return $(document).ready(selector);\n    }\n\n    if (selector) {\n      // String\n      if (typeof selector === 'string') {\n        var els, tempParent, html;\n        selector = html = selector.trim();\n\n        if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {\n          var toCreate = 'div';\n\n          if (html.indexOf('<li') === 0) {\n            toCreate = 'ul';\n          }\n\n          if (html.indexOf('<tr') === 0) {\n            toCreate = 'tbody';\n          }\n\n          if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) {\n            toCreate = 'tr';\n          }\n\n          if (html.indexOf('<tbody') === 0) {\n            toCreate = 'table';\n          }\n\n          if (html.indexOf('<option') === 0) {\n            toCreate = 'select';\n          }\n\n          tempParent = document.createElement(toCreate);\n          tempParent.innerHTML = html;\n\n          for (i = 0; i < tempParent.childNodes.length; i++) {\n            arr.push(tempParent.childNodes[i]);\n          }\n        } else {\n          if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {\n            // Pure ID selector\n            els = [document.getElementById(selector.split('#')[1])];\n          } else {\n            if (context instanceof Dom) {\n              context = context[0];\n            } // Other selectors\n\n\n            els = (context || document).querySelectorAll(selector);\n          }\n\n          for (i = 0; i < els.length; i++) {\n            if (els[i]) {\n              arr.push(els[i]);\n            }\n          }\n        }\n      } // Node/element\n      else if (selector.nodeType || selector === window || selector === document) {\n        arr.push(selector);\n      } //Array of elements or instance of Dom\n      else if (selector.length > 0 && selector[0].nodeType) {\n        for (i = 0; i < selector.length; i++) {\n          arr.push(selector[i]);\n        }\n      } else if ($.isArray(selector)) {\n        arr = selector;\n      }\n    }\n\n    return new Dom(arr);\n  };\n\n  Dom.prototype = {\n    ready: function ready(callback) {\n      if (document.attachEvent ? document.readyState == 'complete' : document.readyState != 'loading') {\n        callback($);\n      } else {\n        document.addEventListener('DOMContentLoaded', function () {\n          callback($);\n        }, false);\n      }\n\n      return this;\n    },\n    concat: emptyArray.concat,\n    empty: function empty() {\n      return this.each(function () {\n        this.innerHTML = '';\n      });\n    },\n    map: function map(fn) {\n      return $($.map(this, function (el, i) {\n        return fn.call(el, i, el);\n      }));\n    },\n    slice: function slice() {\n      return $(_slice.apply(this, arguments));\n    },\n    // Classes and attriutes\n    // NOTE: element.classList attribure is not supported on android 2.3!!!\n    addClass: function addClass(className) {\n      if (typeof className === 'undefined') {\n        return this;\n      }\n\n      var classes = className.split(' ');\n\n      for (var i = 0; i < classes.length; i++) {\n        for (var j = 0; j < this.length; j++) {\n          if (typeof this[j].classList !== 'undefined' && classes[i] !== '') {\n            this[j].classList.add(classes[i]);\n          }\n        }\n      }\n\n      return this;\n    },\n    removeClass: function removeClass(className) {\n      if (typeof className === 'undefined') {\n        return this;\n      }\n\n      var classes = className.split(' ');\n\n      for (var i = 0; i < classes.length; i++) {\n        for (var j = 0; j < this.length; j++) {\n          if (typeof this[j].classList !== 'undefined' && classes[i] !== '') {\n            this[j].classList.remove(classes[i]);\n          }\n        }\n      }\n\n      return this;\n    },\n    hasClass: function hasClass(className) {\n      return this[0] ? this[0].classList.contains(className) : false;\n    },\n    toggleClass: function toggleClass(className) {\n      var classes = className.split(' ');\n\n      for (var i = 0; i < classes.length; i++) {\n        for (var j = 0; j < this.length; j++) {\n          if (typeof this[j].classList !== 'undefined') {\n            this[j].classList.toggle(classes[i]);\n          }\n        }\n      }\n\n      return this;\n    },\n    closest: function closest(selector, context) {\n      var node = this[0],\n          collection = false;\n\n      if (isObject(selector)) {\n        collection = $(selector);\n      }\n\n      while (node && !(collection ? collection.indexOf(node) >= 0 : matches(node, selector))) {\n        node = node !== context && node.nodeType !== node.DOCUMENT_NODE && node.parentNode;\n      }\n\n      return $(node);\n    },\n    attr: function attr(attrs, value) {\n      var attr;\n\n      if (arguments.length === 1 && typeof attrs === 'string') {\n        // Get attr\n        if (this.length) {\n          attr = this[0].getAttribute(attrs);\n          return attr || attr === '' ? attr : undefined;\n        }\n      } else {\n        // Set attrs\n        for (var i = 0; i < this.length; i++) {\n          if (arguments.length === 2) {\n            // String\n            this[i].setAttribute(attrs, value);\n          } else {\n            // Object\n            for (var attrName in attrs) {\n              this[i][attrName] = attrs[attrName];\n              this[i].setAttribute(attrName, attrs[attrName]);\n            }\n          }\n        }\n\n        return this;\n      }\n    },\n    removeAttr: function removeAttr(attr) {\n      for (var i = 0; i < this.length; i++) {\n        this[i].removeAttribute(attr);\n      }\n\n      return this;\n    },\n    prop: function prop(props, value) {\n      props = propMap[props] || props;\n\n      if (arguments.length === 1 && typeof props === 'string') {\n        // Get prop\n        return this[0] ? this[0][props] : undefined;\n      } else {\n        // Set props\n        for (var i = 0; i < this.length; i++) {\n          this[i][props] = value;\n        }\n\n        return this;\n      }\n    },\n    val: function val(value) {\n      if (typeof value === 'undefined') {\n        if (this.length && this[0].multiple) {\n          return $.map(this.find('option:checked'), function (v) {\n            return v.value;\n          });\n        }\n\n        return this[0] ? this[0].value : undefined;\n      }\n\n      if (this.length && this[0].multiple) {\n        $.each(this[0].options, function () {\n          this.selected = value.indexOf(this.value) != -1;\n        });\n      } else {\n        for (var i = 0; i < this.length; i++) {\n          this[i].value = value;\n        }\n      }\n\n      return this;\n    },\n    //Events\n    on: function on(eventName, targetSelector, listener, capture) {\n      var boundListener,\n          elm,\n          event,\n          events = eventName.split(' '),\n          i,\n          j;\n\n      function handleLiveEvent(e) {\n        var target = e.target;\n\n        while (target) {\n          if ($(target).is(targetSelector)) {\n            listener.call(target, e);\n          }\n\n          target = target !== this ? target.parentNode : null;\n        }\n      }\n\n      function handleNamespaces(el, name, listener, capture) {\n        var namespace = name.split('.');\n\n        if (!el.DomNameSpaces) {\n          el.DomNameSpaces = [];\n        }\n\n        el.DomNameSpaces.push({\n          namespace: namespace[1],\n          event: namespace[0],\n          listener: listener,\n          capture: capture\n        });\n        el.addEventListener(namespace[0], listener, capture);\n      }\n\n      for (i = 0; i < this.length; i++) {\n        elm = this[i];\n\n        if (isFunction(targetSelector) || targetSelector === false) {\n          // Usual events\n          if (isFunction(targetSelector)) {\n            capture = listener || false;\n            listener = targetSelector;\n          }\n\n          for (j = 0; j < events.length; j++) {\n            event = events[j]; // check for namespaces\n\n            if (event.indexOf('.') != -1) {\n              handleNamespaces(elm, event, listener, capture);\n            } else {\n              elm.addEventListener(event, listener, capture);\n            }\n          }\n        } else {\n          // Live events\n          boundListener = handleLiveEvent.bind(elm);\n\n          for (j = 0; j < events.length; j++) {\n            event = events[j];\n\n            if (!elm.DomLiveListeners) {\n              elm.DomLiveListeners = [];\n            }\n\n            elm.DomLiveListeners.push({\n              listener: listener,\n              liveListener: boundListener\n            });\n\n            if (event.indexOf('.') != -1) {\n              handleNamespaces(elm, event, boundListener, capture);\n            } else {\n              elm.addEventListener(event, boundListener, capture);\n            }\n          }\n        }\n      }\n\n      return this;\n    },\n    off: function off(eventName, targetSelector, listener, capture) {\n      var elm,\n          event,\n          events,\n          i,\n          j,\n          k,\n          liveListeners,\n          that = this;\n\n      function removeEvents(event) {\n        var el,\n            i,\n            j,\n            item,\n            nameSpaces,\n            parts = event.split('.'),\n            name = parts[0],\n            ns = parts[1];\n\n        for (i = 0; i < that.length; ++i) {\n          el = that[i];\n          nameSpaces = el.DomNameSpaces;\n\n          if (nameSpaces) {\n            for (j = 0; j < nameSpaces.length; ++j) {\n              item = nameSpaces[j];\n\n              if (item.namespace == ns && (item.event == name || !name)) {\n                el.removeEventListener(item.event, item.listener, item.capture);\n                item.removed = true;\n              }\n            } // remove the events from the DomNameSpaces array\n\n\n            for (j = nameSpaces.length - 1; j >= 0; --j) {\n              if (nameSpaces[j].removed) {\n                nameSpaces.splice(j, 1);\n              }\n            }\n          }\n        }\n      }\n\n      events = eventName.split(' ');\n\n      for (i = 0; i < events.length; i++) {\n        event = events[i];\n\n        for (j = 0; j < this.length; j++) {\n          elm = this[j];\n          liveListeners = elm.DomLiveListeners;\n\n          if (isFunction(targetSelector) || targetSelector === false) {\n            // Usual events\n            if (isFunction(targetSelector)) {\n              capture = listener || false;\n              listener = targetSelector;\n            }\n\n            if (event.indexOf('.') === 0) {\n              // remove namespace events\n              removeEvents(event.substr(1));\n            } else {\n              elm.removeEventListener(event, listener, capture);\n            }\n          } else {\n            // Live event\n            if (liveListeners) {\n              for (k = 0; k < liveListeners.length; k++) {\n                if (liveListeners[k].listener === listener) {\n                  elm.removeEventListener(event, liveListeners[k].liveListener, capture);\n                }\n              }\n            }\n\n            if (elm.DomNameSpaces && elm.DomNameSpaces.length && event) {\n              removeEvents(event);\n            }\n          }\n        }\n      }\n\n      return this;\n    },\n    trigger: function trigger$1(eventName, eventData) {\n      var events = eventName.split(' ');\n\n      for (var i = 0; i < events.length; i++) {\n        for (var j = 0; j < this.length; j++) {\n          trigger(this[j], events[i], eventData);\n        }\n      }\n\n      return this;\n    },\n    // Sizing/Styles\n    width: function width(dim) {\n      if (dim !== undefined) {\n        return this.css('width', dim);\n      }\n\n      if (this[0] === window) {\n        return window.innerWidth;\n      } else if (this[0] === document) {\n        return document.documentElement.scrollWidth;\n      } else {\n        return this.length > 0 ? parseFloat(this.css('width')) : null;\n      }\n    },\n    height: function height(dim) {\n      if (dim !== undefined) {\n        return this.css('height', dim);\n      }\n\n      if (this[0] === window) {\n        return window.innerHeight;\n      } else if (this[0] === document) {\n        var body = document.body,\n            html = document.documentElement;\n        return Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);\n      } else {\n        return this.length > 0 ? parseFloat(this.css('height')) : null;\n      }\n    },\n    innerWidth: function innerWidth() {\n      var elm = this;\n\n      if (this.length > 0) {\n        if (this[0].innerWidth) {\n          return this[0].innerWidth;\n        } else {\n          var size = this[0].offsetWidth,\n              sides = ['left', 'right'];\n          sides.forEach(function (side) {\n            size -= parseInt(elm.css(camelize('border-' + side + '-width')) || 0, 10);\n          });\n          return size;\n        }\n      }\n    },\n    innerHeight: function innerHeight() {\n      var elm = this;\n\n      if (this.length > 0) {\n        if (this[0].innerHeight) {\n          return this[0].innerHeight;\n        } else {\n          var size = this[0].offsetHeight,\n              sides = ['top', 'bottom'];\n          sides.forEach(function (side) {\n            size -= parseInt(elm.css(camelize('border-' + side + '-width')) || 0, 10);\n          });\n          return size;\n        }\n      }\n    },\n    offset: function offset() {\n      if (this.length > 0) {\n        var el = this[0],\n            box = el.getBoundingClientRect(),\n            doc = document.documentElement;\n        return {\n          top: box.top + window.pageYOffset - doc.clientTop,\n          left: box.left + window.pageXOffset - doc.clientLeft\n        };\n      }\n    },\n    hide: function hide() {\n      for (var i = 0; i < this.length; i++) {\n        this[i].style.display = 'none';\n      }\n\n      return this;\n    },\n    show: function show() {\n      for (var i = 0; i < this.length; i++) {\n        if (this[i].style.display == \"none\") {\n          this[i].style.display = '';\n        }\n\n        if (getComputedStyle(this[i], '').getPropertyValue(\"display\") == \"none\") {\n          this[i].style.display = 'block';\n        }\n      }\n\n      return this;\n    },\n    clone: function clone() {\n      return this.map(function () {\n        return this.cloneNode(true);\n      });\n    },\n    styles: function styles() {\n      return this[0] ? window.getComputedStyle(this[0], null) : undefined;\n    },\n    css: function css(property, value) {\n      var i,\n          key,\n          element = this[0],\n          css = '';\n\n      if (arguments.length < 2) {\n        if (!element) {\n          return;\n        }\n\n        if (typeof property === 'string') {\n          return element.style[property] || getComputedStyle(element, '').getPropertyValue(property);\n        }\n      }\n\n      if (typeof property === 'string') {\n        if (!value && value !== 0) {\n          this.each(function () {\n            this.style.removeProperty(dasherize(property));\n          });\n        } else {\n          css = dasherize(property) + \":\" + maybeAddPx(property, value);\n        }\n      } else {\n        for (key in property) {\n          if (!property[key] && property[key] !== 0) {\n            for (i = 0; i < this.length; i++) {\n              this[i].style.removeProperty(dasherize(key));\n            }\n          } else {\n            css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';';\n          }\n        }\n      }\n\n      return this.each(function () {\n        this.style.cssText += ';' + css;\n      });\n    },\n    each: function each(callback) {\n      for (var i = 0; i < this.length; i++) {\n        if (callback.apply(this[i], [i, this[i]]) === false) {\n          break;\n        }\n      }\n\n      return this;\n    },\n    filter: function filter(callback) {\n      var matchedItems = [];\n\n      for (var i = 0; i < this.length; i++) {\n        if (isFunction(callback)) {\n          if (callback.call(this[i], i, this[i])) {\n            matchedItems.push(this[i]);\n          }\n        } else if (matches(this[i], callback)) {\n          matchedItems.push(this[i]);\n        }\n      }\n\n      return new Dom(matchedItems);\n    },\n    html: function html(_html) {\n      if (typeof _html === 'undefined') {\n        return this[0] ? this[0].innerHTML : undefined;\n      } else {\n        this.empty();\n\n        for (var i = 0; i < this.length; i++) {\n          this[i].innerHTML = _html;\n        }\n\n        return this;\n      }\n    },\n    text: function text(_text) {\n      if (typeof _text === 'undefined') {\n        return this[0] ? this[0].textContent.trim() : null;\n      } else {\n        for (var i = 0; i < this.length; i++) {\n          this[i].textContent = _text;\n        }\n\n        return this;\n      }\n    },\n    is: function is(selector) {\n      return this.length > 0 && matches(this[0], selector);\n    },\n    not: function not(selector) {\n      var nodes = [];\n\n      if (isFunction(selector) && selector.call !== undefined) {\n        this.each(function (idx) {\n          if (!selector.call(this, idx)) {\n            nodes.push(this);\n          }\n        });\n      } else {\n        var excludes = typeof selector == 'string' ? this.filter(selector) : likeArray(selector) && isFunction(selector.item) ? _slice.call(selector) : $(selector);\n\n        if (isObject(excludes)) {\n          excludes = $.map(excludes, function (el) {\n            return el;\n          });\n        }\n\n        this.each(function (i, el) {\n          if (excludes.indexOf(el) < 0) {\n            nodes.push(el);\n          }\n        });\n      }\n\n      return $(nodes);\n    },\n    indexOf: function indexOf(el) {\n      for (var i = 0; i < this.length; i++) {\n        if (this[i] === el) {\n          return i;\n        }\n      }\n    },\n    index: function index(element) {\n      return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0]);\n    },\n    get: function get(idx) {\n      return idx === undefined ? _slice.call(this) : this[idx >= 0 ? idx : idx + this.length];\n    },\n    eq: function eq(index) {\n      if (typeof index === 'undefined') {\n        return this;\n      }\n\n      var length = this.length,\n          returnIndex;\n\n      if (index > length - 1) {\n        return new Dom([]);\n      }\n\n      if (index < 0) {\n        returnIndex = length + index;\n        return returnIndex < 0 ? new Dom([]) : new Dom([this[returnIndex]]);\n      }\n\n      return new Dom([this[index]]);\n    },\n    append: function append(newChild) {\n      var i, j;\n\n      for (i = 0; i < this.length; i++) {\n        if (typeof newChild === 'string') {\n          var tempDiv = document.createElement('div');\n          tempDiv.innerHTML = newChild;\n\n          while (tempDiv.firstChild) {\n            this[i].appendChild(tempDiv.firstChild);\n          }\n        } else if (newChild instanceof Dom) {\n          for (j = 0; j < newChild.length; j++) {\n            this[i].appendChild(newChild[j]);\n          }\n        } else {\n          this[i].appendChild(newChild);\n        }\n      }\n\n      return this;\n    },\n    appendTo: function appendTo(parent) {\n      $(parent).append(this);\n      return this;\n    },\n    prepend: function prepend(newChild) {\n      var i, j;\n\n      for (i = 0; i < this.length; i++) {\n        if (typeof newChild === 'string') {\n          var tempDiv = document.createElement('div');\n          tempDiv.innerHTML = newChild;\n\n          for (j = tempDiv.childNodes.length - 1; j >= 0; j--) {\n            this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);\n          } // this[i].insertAdjacentHTML('afterbegin', newChild);\n\n        } else if (newChild instanceof Dom) {\n          for (j = 0; j < newChild.length; j++) {\n            this[i].insertBefore(newChild[j], this[i].childNodes[0]);\n          }\n        } else {\n          this[i].insertBefore(newChild, this[i].childNodes[0]);\n        }\n      }\n\n      return this;\n    },\n    prependTo: function prependTo(parent) {\n      $(parent).prepend(this);\n      return this;\n    },\n    insertBefore: function insertBefore(selector) {\n      var before = $(selector);\n\n      for (var i = 0; i < this.length; i++) {\n        if (before.length === 1) {\n          before[0].parentNode.insertBefore(this[i], before[0]);\n        } else if (before.length > 1) {\n          for (var j = 0; j < before.length; j++) {\n            before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);\n          }\n        }\n      }\n\n      return this;\n    },\n    insertAfter: function insertAfter(selector) {\n      var after = $(selector);\n\n      for (var i = 0; i < this.length; i++) {\n        if (after.length === 1) {\n          after[0].parentNode.insertBefore(this[i], after[0].nextSibling);\n        } else if (after.length > 1) {\n          for (var j = 0; j < after.length; j++) {\n            after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);\n          }\n        }\n      }\n\n      return this;\n    },\n    next: function next(selector) {\n      if (this.length > 0) {\n        if (selector) {\n          if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {\n            return new Dom([this[0].nextElementSibling]);\n          } else {\n            return new Dom([]);\n          }\n        } else {\n          if (this[0].nextElementSibling) {\n            return new Dom([this[0].nextElementSibling]);\n          } else {\n            return new Dom([]);\n          }\n        }\n      } else {\n        return new Dom([]);\n      }\n    },\n    nextAll: function nextAll(selector) {\n      var nextEls = [],\n          el = this[0];\n\n      if (!el) {\n        return new Dom([]);\n      }\n\n      while (el.nextElementSibling) {\n        var next = el.nextElementSibling;\n\n        if (selector) {\n          if ($(next).is(selector)) {\n            nextEls.push(next);\n          }\n        } else {\n          nextEls.push(next);\n        }\n\n        el = next;\n      }\n\n      return new Dom(nextEls);\n    },\n    prev: function prev(selector) {\n      if (this.length > 0) {\n        if (selector) {\n          if (this[0].previousElementSibling && $(this[0].previousElementSibling).is(selector)) {\n            return new Dom([this[0].previousElementSibling]);\n          } else {\n            return new Dom([]);\n          }\n        } else {\n          if (this[0].previousElementSibling) {\n            return new Dom([this[0].previousElementSibling]);\n          } else {\n            return new Dom([]);\n          }\n        }\n      } else {\n        return new Dom([]);\n      }\n    },\n    prevAll: function prevAll(selector) {\n      var prevEls = [];\n      var el = this[0];\n\n      if (!el) {\n        return new Dom([]);\n      }\n\n      while (el.previousElementSibling) {\n        var prev = el.previousElementSibling;\n\n        if (selector) {\n          if ($(prev).is(selector)) {\n            prevEls.push(prev);\n          }\n        } else {\n          prevEls.push(prev);\n        }\n\n        el = prev;\n      }\n\n      return new Dom(prevEls);\n    },\n    parent: function parent(selector) {\n      var parents = [];\n\n      for (var i = 0; i < this.length; i++) {\n        if (this[i].parentNode !== null) {\n          if (selector) {\n            if ($(this[i].parentNode).is(selector)) {\n              parents.push(this[i].parentNode);\n            }\n          } else {\n            parents.push(this[i].parentNode);\n          }\n        }\n      }\n\n      return $($.unique(parents));\n    },\n    parents: function parents(selector) {\n      var parents = [];\n\n      for (var i = 0; i < this.length; i++) {\n        var parent = this[i].parentNode;\n\n        while (parent) {\n          if (selector) {\n            if ($(parent).is(selector)) {\n              parents.push(parent);\n            }\n          } else {\n            parents.push(parent);\n          }\n\n          parent = parent.parentNode;\n        }\n      }\n\n      return $($.unique(parents));\n    },\n    find: function find(selector) {\n      var foundElements = [];\n\n      for (var i = 0; i < this.length; i++) {\n        var found = this[i].querySelectorAll(selector);\n\n        for (var j = 0; j < found.length; j++) {\n          foundElements.push(found[j]);\n        }\n      }\n\n      return new Dom(foundElements);\n    },\n    children: function children(selector) {\n      var children = [];\n\n      for (var i = 0; i < this.length; i++) {\n        var childNodes = this[i].childNodes;\n\n        for (var j = 0; j < childNodes.length; j++) {\n          if (!selector) {\n            if (childNodes[j].nodeType === 1) {\n              children.push(childNodes[j]);\n            }\n          } else {\n            if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {\n              children.push(childNodes[j]);\n            }\n          }\n        }\n      }\n\n      return new Dom($.unique(children));\n    },\n    remove: function remove() {\n      for (var i = 0; i < this.length; i++) {\n        if (this[i].parentNode) {\n          this[i].parentNode.removeChild(this[i]);\n        }\n      }\n\n      return this;\n    },\n    add: function add() {\n      var dom = this;\n      var i, j;\n\n      for (i = 0; i < arguments.length; i++) {\n        var toAdd = $(arguments[i]);\n\n        for (j = 0; j < toAdd.length; j++) {\n          dom[dom.length] = toAdd[j];\n          dom.length++;\n        }\n      }\n\n      return dom;\n    },\n    before: function before(elm) {\n      $(elm).insertBefore(this);\n      return this;\n    },\n    after: function after(elm) {\n      $(elm).insertAfter(this);\n      return this;\n    },\n    scrollTop: function scrollTop(value) {\n      if (!this.length) {\n        return;\n      }\n\n      var hasScrollTop = ('scrollTop' in this[0]);\n\n      if (value === undefined) {\n        return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset;\n      }\n\n      return this.each(hasScrollTop ? function () {\n        this.scrollTop = value;\n      } : function () {\n        this.scrollTo(this.scrollX, value);\n      });\n    },\n    scrollLeft: function scrollLeft(value) {\n      if (!this.length) {\n        return;\n      }\n\n      var hasScrollLeft = ('scrollLeft' in this[0]);\n\n      if (value === undefined) {\n        return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset;\n      }\n\n      return this.each(hasScrollLeft ? function () {\n        this.scrollLeft = value;\n      } : function () {\n        this.scrollTo(value, this.scrollY);\n      });\n    },\n    contents: function contents() {\n      return this.map(function (i, v) {\n        return _slice.call(v.childNodes);\n      });\n    },\n    nextUntil: function nextUntil(selector) {\n      var n = this,\n          array = [];\n\n      while (n.length && !n.filter(selector).length) {\n        array.push(n[0]);\n        n = n.next();\n      }\n\n      return $(array);\n    },\n    prevUntil: function prevUntil(selector) {\n      var n = this,\n          array = [];\n\n      while (n.length && !$(n).filter(selector).length) {\n        array.push(n[0]);\n        n = n.prev();\n      }\n\n      return $(array);\n    },\n    detach: function detach() {\n      return this.remove();\n    }\n  }; // Link to prototype\n\n  $.fn = Dom.prototype;\n  return $;\n}(); // Export to local scope\n\n\nvar $ = Dom; // Export to mobiscroll\n\nmobiscroll.$ = Dom; // DOM Library Utilites\n\n$.inArray = function (elem, array, i) {\n  return emptyArray.indexOf.call(array, elem, i);\n};\n\n$.extend = function (target) {\n  var deep,\n      args = _slice.call(arguments, 1);\n\n  if (typeof target == 'boolean') {\n    deep = target;\n    target = args.shift();\n  }\n\n  target = target || {};\n  args.forEach(function (arg) {\n    extend(target, arg, deep);\n  });\n  return target;\n};\n\n$.isFunction = isFunction;\n\n$.isArray = function (arr) {\n  return Object.prototype.toString.apply(arr) === '[object Array]';\n};\n\n$.isPlainObject = function (obj) {\n  return isObject(obj) && obj !== null && obj !== obj.window && Object.getPrototypeOf(obj) == Object.prototype;\n};\n\n$.each = function (obj, callback) {\n  var i, prop;\n\n  if (!isObject(obj) || !callback) {\n    return;\n  }\n\n  if ($.isArray(obj) || obj instanceof Dom) {\n    // Array\n    for (i = 0; i < obj.length; i++) {\n      if (callback.call(obj[i], i, obj[i]) === false) {\n        break;\n      }\n    }\n  } else {\n    // Object\n    for (prop in obj) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (obj.hasOwnProperty(prop) && prop !== 'length') {\n        if (callback.call(obj[prop], prop, obj[prop]) === false) {\n          break;\n        }\n      }\n    }\n  }\n\n  return this;\n};\n\n$.unique = function (arr) {\n  var unique = [];\n\n  for (var i = 0; i < arr.length; i++) {\n    if (unique.indexOf(arr[i]) === -1) {\n      unique.push(arr[i]);\n    }\n  }\n\n  return unique;\n};\n\n$.map = function (elements, callback) {\n  var value,\n      values = [],\n      i,\n      key;\n\n  if (likeArray(elements)) {\n    for (i = 0; i < elements.length; i++) {\n      value = callback(elements[i], i);\n\n      if (value !== null) {\n        values.push(value);\n      }\n    }\n  } else {\n    for (key in elements) {\n      value = callback(elements[key], key);\n\n      if (value !== null) {\n        values.push(value);\n      }\n    }\n  }\n\n  return values.length > 0 ? $.fn.concat.apply([], values) : values;\n};\n\nfunction noop() {}\n\nfunction objectToArray(obj) {\n  var arr = [],\n      i;\n\n  for (i in obj) {\n    arr.push(obj[i]);\n  }\n\n  return arr;\n}\n\nfunction arrayToObject(arr) {\n  var obj = {},\n      i;\n\n  if (arr) {\n    for (i = 0; i < arr.length; i++) {\n      obj[arr[i]] = arr[i];\n    }\n  }\n\n  return obj;\n}\n\nfunction isNumeric(a) {\n  return a - parseFloat(a) >= 0;\n}\n\nfunction isString(s) {\n  return typeof s === 'string';\n}\n\nfunction constrain(val, min, max) {\n  return Math.max(min, Math.min(val, max));\n}\n\nfunction pad(num, size) {\n  num = num + '';\n  size = size || 2;\n\n  while (num.length < size) {\n    num = '0' + num;\n  }\n\n  return num;\n}\n\nfunction throttle(fn, threshhold) {\n  var last, timer;\n  threshhold = threshhold || 100;\n  return function () {\n    var context = this,\n        now = +new Date(),\n        args = arguments;\n\n    if (last && now < last + threshhold) {\n      clearTimeout(timer);\n      timer = setTimeout(function () {\n        last = now;\n        fn.apply(context, args);\n      }, threshhold);\n    } else {\n      last = now;\n      fn.apply(context, args);\n    }\n  };\n}\n\nfunction vibrate(time) {\n  if ('vibrate' in navigator) {\n    navigator.vibrate(time || 50);\n  }\n}\n\nfunction getPercent(v, min, max) {\n  return (v - min) * 100 / (max - min);\n}\n\nfunction getBoolAttr(attr, def, $elm) {\n  var v = $elm.attr(attr);\n  return v === undefined || v === '' ? def : v === 'true';\n}\n\nvar tapped = 0;\nvar allowQuick;\n\nfunction preventClick() {\n  // Prevent ghost click\n  tapped++;\n  setTimeout(function () {\n    tapped--;\n  }, 500);\n}\n\nfunction triggerClick(ev, control) {\n  // Prevent duplicate triggers on the same element\n  // e.g. a form checkbox inside a listview item\n  if (control.mbscClick) {\n    return;\n  }\n\n  var touch = (ev.originalEvent || ev).changedTouches[0],\n      evt = document.createEvent('MouseEvents');\n  evt.initMouseEvent('click', true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);\n  evt.isMbscTap = true; // Prevent ionic to bust our click\n  // This works for Ionic 1 - 3, not sure about 4\n\n  evt.isIonicTap = true; // This will allow a click fired together with this click\n  // We need this, because clicking on a label will trigger a click\n  // on the associated input as well, which should not be busted\n\n  allowQuick = true;\n  control.mbscChange = true;\n  control.mbscClick = true;\n  control.dispatchEvent(evt);\n  allowQuick = false; // Prevent ghost click\n\n  preventClick();\n  setTimeout(function () {\n    delete control.mbscClick;\n  });\n}\n\nfunction getCoord(e, c, page) {\n  var ev = e.originalEvent || e,\n      prop = (page ? 'page' : 'client') + c; // Multi touch support\n\n  if (ev.targetTouches && ev.targetTouches[0]) {\n    return ev.targetTouches[0][prop];\n  }\n\n  if (ev.changedTouches && ev.changedTouches[0]) {\n    return ev.changedTouches[0][prop];\n  }\n\n  return e[prop];\n}\n\nfunction getControlType($elm) {\n  var attrs = ['switch', 'range', 'rating', 'segmented', 'stepper'];\n  var elm = $elm[0];\n  var role = $elm.attr('data-role');\n  var type = $elm.attr('type') || elm.nodeName.toLowerCase();\n\n  if (/(switch|range|rating|segmented|stepper|select)/.test(role)) {\n    type = role;\n  } else {\n    for (var i = 0; i < attrs.length; i++) {\n      if ($elm.is('[mbsc-' + attrs[i] + ']')) {\n        type = attrs[i];\n      }\n    }\n  }\n\n  return type;\n}\n\nfunction activateControl(control, type, ev) {\n  control.focus();\n\n  if (/(button|submit|checkbox|switch|radio)/.test(type)) {\n    ev.preventDefault();\n  }\n\n  if (!/select/.test(type)) {\n    triggerClick(ev, control);\n  }\n}\n\nfunction tap(that, el, handler, prevent, tolerance, time) {\n  var startX,\n      startY,\n      target,\n      moved,\n      startTime,\n      $ = mobiscroll.$,\n      $elm = $(el);\n  tolerance = tolerance || 9;\n\n  function onStart(ev) {\n    if (!target) {\n      // Can't always call preventDefault here, it kills page scroll\n      // if (prevent) {\n      //     ev.preventDefault();\n      // }\n      target = this;\n      startX = getCoord(ev, 'X');\n      startY = getCoord(ev, 'Y');\n      moved = false;\n      startTime = new Date();\n    }\n  }\n\n  function onMove(ev) {\n    // If movement is more than 20px, don't fire the click event handler\n    if (target && !moved && (Math.abs(getCoord(ev, 'X') - startX) > tolerance || Math.abs(getCoord(ev, 'Y') - startY) > tolerance)) {\n      moved = true;\n    }\n  }\n\n  function onEnd(ev) {\n    if (target) {\n      if (time && new Date() - startTime < 100 || !moved) {\n        // ev.preventDefault();\n        // handler.call(target, ev, that);\n        triggerClick(ev, ev.target);\n      } else {\n        preventClick();\n      }\n\n      target = false;\n    }\n  }\n\n  function onClick(ev) {\n    if (prevent) {\n      ev.preventDefault();\n    } // If handler was not called on touchend, call it on click;\n\n\n    handler.call(this, ev, that);\n  }\n\n  function onCancel() {\n    target = false;\n  }\n\n  $elm.each(function (i, elm) {\n    if (that.settings.tap) {\n      listen(elm, 'touchstart', onStart, {\n        passive: true\n      });\n      listen(elm, 'touchcancel', onCancel);\n      listen(elm, 'touchmove', onMove, {\n        passive: true\n      });\n      listen(elm, 'touchend', onEnd);\n    }\n\n    listen(elm, 'click', onClick);\n\n    elm.__mbscOff = function () {\n      unlisten(elm, 'touchstart', onStart, {\n        passive: true\n      });\n      unlisten(elm, 'touchcancel', onCancel);\n      unlisten(elm, 'touchmove', onMove, {\n        passive: true\n      });\n      unlisten(elm, 'touchend', onEnd);\n      unlisten(elm, 'click', onClick);\n      delete elm.__mbscOff;\n    };\n  });\n}\n\nfunction tapOff($elm) {\n  if ($elm && $elm[0] && $elm[0].__mbscOff) {\n    $elm[0].__mbscOff();\n  }\n} // Prevent standard behaviour on body click\n\n\nfunction bustClick(ev) {\n  // Textarea needs the mousedown event\n  if (tapped && !allowQuick && !ev.isMbscTap && !(ev.target.nodeName == 'TEXTAREA' && ev.type == 'mousedown')) {\n    ev.stopPropagation();\n    ev.preventDefault();\n    return false;\n  }\n}\n\nif (isBrowser) {\n  ['mouseover', 'mousedown', 'mouseup', 'click'].forEach(function (ev) {\n    document.addEventListener(ev, bustClick, true);\n  });\n\n  if (os == 'android' && majorVersion < 5) {\n    document.addEventListener('change', function (ev) {\n      if (tapped && ev.target.type == 'checkbox' && !ev.target.mbscChange) {\n        ev.stopPropagation();\n        ev.preventDefault();\n      }\n\n      delete ev.target.mbscChange;\n    }, true);\n  }\n}\n/*!\r\n * Mobiscroll v4.10.6\r\n * http://mobiscroll.com\r\n *\r\n *\r\n * Copyright 2010-2018, Acid Media\r\n *\r\n */\n\n\nmobiscroll.uid = \"b1ead642\";\n\nfunction getWidth(el) {\n  return el[0].innerWidth || el.innerWidth();\n}\n\nfunction getThemeName(s) {\n  var themeName = s.theme,\n      themeVariant = s.themeVariant;\n\n  if (themeName == 'auto' || !themeName) {\n    themeName = ms.autoTheme;\n  }\n\n  if (themeName == 'default') {\n    themeName = 'mobiscroll';\n  }\n\n  if ((themeVariant === 'dark' || isDark && themeVariant === 'auto') && ms.themes.form[themeName + '-dark']) {\n    themeName = themeName + '-dark';\n  } else if (themeVariant === 'light' && /.+-dark$/.test(themeName)) {\n    themeName = themeName.replace(/-dark$/, '');\n  }\n\n  return themeName;\n}\n\nfunction autoInit(selector, Component, hasRefresh) {\n  if (isBrowser) {\n    $$1(function () {\n      $$1(selector).each(function () {\n        new Component(this, {});\n      });\n      $$1(document).on('mbsc-enhance', function (ev, settings) {\n        if ($$1(ev.target).is(selector)) {\n          new Component(ev.target, settings || {});\n        } else {\n          $$1(selector, ev.target).each(function () {\n            new Component(this, settings || {});\n          });\n        }\n      });\n\n      if (hasRefresh) {\n        $$1(document).on('mbsc-refresh', function (ev) {\n          var inst;\n\n          if ($$1(ev.target).is(selector)) {\n            inst = instances[ev.target.id];\n\n            if (inst) {\n              inst.refresh();\n            }\n          } else {\n            $$1(selector, ev.target).each(function () {\n              inst = instances[this.id];\n\n              if (inst) {\n                inst.refresh();\n              }\n            });\n          }\n        });\n      }\n    });\n  }\n}\n\nvar ms,\n    $$1 = mobiscroll.$,\n    id = +new Date(),\n    instances = {},\n    classes = {},\n    empty = {},\n    breakpoints = {\n  xsmall: 0,\n  small: 576,\n  medium: 768,\n  large: 992,\n  xlarge: 1200\n},\n    extend$1 = $$1.extend;\nextend$1(util, {\n  getCoord: getCoord,\n  preventClick: preventClick,\n  vibrate: vibrate\n});\nms = extend$1(mobiscroll, {\n  $: $$1,\n  version: '4.10.6',\n  autoTheme: 'mobiscroll',\n  themes: {\n    form: {},\n    page: {},\n    frame: {},\n    scroller: {},\n    listview: {},\n    navigation: {},\n    progress: {},\n    card: {}\n  },\n  platform: {\n    name: os,\n    majorVersion: majorVersion,\n    minorVersion: minorVersion\n  },\n  i18n: {},\n  instances: instances,\n  classes: classes,\n  util: util,\n  settings: {},\n  setDefaults: function setDefaults(o) {\n    extend$1(this.settings, o);\n  },\n  customTheme: function customTheme(name, baseTheme) {\n    var i,\n        themes = mobiscroll.themes,\n        comps = ['frame', 'scroller', 'listview', 'navigation', 'form', 'page', 'progress', 'card'];\n\n    for (i = 0; i < comps.length; i++) {\n      themes[comps[i]][name] = extend$1({}, themes[comps[i]][baseTheme], {\n        baseTheme: baseTheme\n      });\n    }\n  }\n});\n\nvar Base = function Base(el, settings) {\n  var ctx,\n      lang,\n      preset,\n      resp,\n      s,\n      theme,\n      themeName,\n      trigger,\n      defaults,\n      that = this;\n  that.settings = {};\n  that.element = el;\n  that._init = noop;\n  that._destroy = noop;\n  that._processSettings = noop;\n\n  that._checkResp = function (width) {\n    if (that && that._responsive) {\n      var newResp = getResponsiveSettings(width);\n\n      if (resp !== newResp) {\n        resp = newResp;\n        that.init({});\n        return true;\n      }\n    }\n  };\n\n  that._getRespCont = function () {\n    return $$1(s.context == 'body' ? window : s.context);\n  };\n\n  that.init = function (newSettings, newValue) {\n    var key, value; // In case of settings update save the old value\n\n    if (newSettings && that.getVal) {\n      value = that.getVal();\n    } // Reset settings object\n\n\n    for (key in that.settings) {\n      delete that.settings[key];\n    }\n\n    s = that.settings; // Update original user settings\n\n    extend$1(settings, newSettings); // Load user defaults\n\n    if (that._hasDef) {\n      defaults = ms.settings;\n    } // Create settings object\n\n\n    extend$1(s, that._defaults, defaults, settings); // Get theme defaults\n\n    if (that._hasTheme) {\n      themeName = getThemeName(s);\n      settings.theme = themeName;\n      theme = ms.themes[that._class] ? ms.themes[that._class][themeName] : {};\n    } // Get language defaults\n\n\n    if (that._hasLang) {\n      lang = ms.i18n[s.lang];\n    } // Update settings object\n\n\n    extend$1(s, theme, lang, defaults, settings);\n    ctx = that._getRespCont();\n\n    if (that._responsive) {\n      if (!resp) {\n        resp = getResponsiveSettings();\n      }\n\n      extend$1(s, resp);\n    }\n\n    that._processSettings(resp || {}); // Load preset settings\n\n\n    if (that._presets) {\n      preset = that._presets[s.preset];\n\n      if (preset) {\n        preset = preset.call(el, that, settings);\n        extend$1(s, preset, settings, resp);\n      }\n    }\n\n    that._init(newSettings); // In case of settings update reset the value.\n    // This is needed to adapt the value for the updated settings\n    // E.g. min/max, date format, etc.\n\n\n    if (newSettings && that.setVal) {\n      that.setVal(newValue === undefined ? value : newValue, true);\n    }\n\n    trigger('onInit');\n  };\n\n  that.destroy = function () {\n    if (that) {\n      that._destroy();\n\n      trigger('onDestroy'); // Delete scroller instance\n\n      delete instances[el.id];\n      that = null;\n    }\n  };\n  /**\r\n   * Attach tap event to the given element.\r\n   */\n\n\n  that.tap = function (el, handler, prevent, tolerance, time) {\n    tap(that, el, handler, prevent, tolerance, time);\n  };\n  /**\r\n   * Triggers an event\r\n   */\n\n\n  that.trigger = function (name, ev) {\n    var ret,\n        i,\n        v,\n        s = [defaults, theme, preset, settings];\n\n    for (i = 0; i < 4; i++) {\n      v = s[i];\n\n      if (v && v[name]) {\n        ret = v[name].call(el, ev || {}, that);\n      }\n    }\n\n    return ret;\n  };\n  /**\r\n   * Sets one ore more options.\r\n   */\n\n\n  that.option = function (opt, value, newValue) {\n    var obj = {},\n        // preserve settings that are possible to change runtime\n    dynamic = ['data', 'invalid', 'valid', 'readonly'];\n\n    if (/calendar|eventcalendar|range/.test(s.preset)) {\n      dynamic.push('marked', 'labels', 'colors');\n    }\n\n    if (typeof opt === 'object') {\n      obj = opt;\n    } else {\n      obj[opt] = value;\n    }\n\n    dynamic.forEach(function (v) {\n      settings[v] = s[v];\n    });\n    that.init(obj, newValue);\n  };\n  /**\r\n   * Returns the mobiscroll instance.\r\n   */\n\n\n  that.getInst = function () {\n    return that;\n  };\n\n  settings = settings || {};\n  trigger = that.trigger;\n\n  function getResponsiveSettings(w) {\n    var result = empty,\n        width;\n\n    if (s.responsive) {\n      width = w || getWidth(ctx);\n      $$1.each(s.responsive, function (key, value) {\n        if (width >= (value.breakpoint || breakpoints[key])) {\n          result = value;\n        }\n      });\n    }\n\n    return result;\n  }\n\n  function construct() {\n    $$1(el).addClass('mbsc-comp'); // Autogenerate id\n\n    if (!el.id) {\n      el.id = 'mobiscroll' + ++id;\n    } else if (instances[el.id]) {\n      instances[el.id].destroy();\n    } // Save instance\n\n\n    instances[el.id] = that;\n    that.__ready = true;\n  }\n\n  if (!that.__ready) {\n    construct();\n  }\n};\n\nvar Observable = function () {\n  function Observable() {\n    this.keyCount = 0;\n    this.subscribers = new Map();\n  }\n\n  Observable.prototype.subscribe = function (handler) {\n    var key = this.keyCount++;\n    this.subscribers.set(key, handler);\n    return key;\n  };\n\n  Observable.prototype.unsubscribe = function (handler) {\n    if (typeof handler === 'number') {\n      this.subscribers.delete(handler);\n    } else {\n      var foundKey_1 = null;\n      this.subscribers.forEach(function (fn, key) {\n        if (fn === handler) {\n          foundKey_1 = key;\n        }\n      });\n      this.subscribers.delete(foundKey_1);\n    }\n  };\n\n  Observable.prototype.next = function (value) {\n    this.subscribers.forEach(function (handler) {\n      handler(value);\n    });\n  };\n\n  return Observable;\n}();\n\nvar MbscRouterToken = function () {\n  function MbscRouterToken() {}\n\n  return MbscRouterToken;\n}();\n\nvar MbscOptionsService = function () {\n  function MbscOptionsService() {}\n\n  Object.defineProperty(MbscOptionsService.prototype, \"options\", {\n    get: function () {\n      return this._options;\n    },\n    set: function (o) {\n      this._options = o;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscOptionsService.ɵfac = function MbscOptionsService_Factory(t) {\n    return new (t || MbscOptionsService)();\n  };\n\n  MbscOptionsService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: MbscOptionsService,\n    factory: function (t) {\n      return MbscOptionsService.ɵfac(t);\n    }\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscOptionsService;\n}();\n\nvar MbscInputService = function () {\n  function MbscInputService() {\n    this._controlSet = false;\n    this._componentRef = undefined;\n  }\n\n  Object.defineProperty(MbscInputService.prototype, \"isControlSet\", {\n    get: function () {\n      return this._controlSet;\n    },\n    set: function (v) {\n      this._controlSet = v;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MbscInputService.prototype, \"input\", {\n    get: function () {\n      return this._componentRef;\n    },\n    set: function (v) {\n      this._componentRef = v;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscInputService.ɵfac = function MbscInputService_Factory(t) {\n    return new (t || MbscInputService)();\n  };\n\n  MbscInputService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: MbscInputService,\n    factory: function (t) {\n      return MbscInputService.ɵfac(t);\n    }\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscInputService;\n}();\n\nvar MbscListService = function () {\n  function MbscListService() {\n    this.addRemoveObservable = new Observable();\n  }\n\n  MbscListService.prototype.notifyAddRemove = function (item) {\n    this.addRemoveObservable.next(item);\n  };\n\n  MbscListService.prototype.onAddRemove = function () {\n    return this.addRemoveObservable;\n  };\n\n  MbscListService.ɵfac = function MbscListService_Factory(t) {\n    return new (t || MbscListService)();\n  };\n\n  MbscListService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: MbscListService,\n    factory: function (t) {\n      return MbscListService.ɵfac(t);\n    }\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscListService;\n}();\n\nvar MbscBase = function () {\n  function MbscBase(initialElem, zone) {\n    this.initialElem = initialElem;\n    this.zone = zone;\n    this.options = {};\n    this.onInit = new EventEmitter();\n    this.onDestroy = new EventEmitter();\n    this.inlineOptionsObj = {};\n    this.pendingValue = undefined;\n    this.themeClassesSet = false;\n    this.instance = null;\n    this.element = null;\n    this.inlineOptionsObj.zone = zone;\n  }\n\n  MbscBase.prototype.getInlineEvents = function () {\n    var _this = this;\n\n    var _loop_1 = function (prop) {\n      if (this_1[prop] instanceof EventEmitter && (!this_1.options || !this_1.options[prop])) {\n        this_1.inlineOptionsObj[prop] = function (event, inst) {\n          event.inst = inst;\n\n          _this[prop].emit(event);\n        };\n      }\n    };\n\n    var this_1 = this;\n\n    for (var prop in this) {\n      _loop_1(prop);\n    }\n  };\n\n  MbscBase.prototype.setThemeClasses = function () {\n    $$1(this.initialElem.nativeElement).addClass(this.getThemeClasses());\n    this.themeClassesSet = true;\n  };\n\n  MbscBase.prototype.clearThemeClasses = function () {\n    $$1(this.initialElem.nativeElement).removeClass(this.getThemeClasses());\n  };\n\n  MbscBase.prototype.getThemeClasses = function () {\n    var s = this.instance.settings;\n    return 'mbsc-control-ng mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : '');\n  };\n\n  MbscBase.prototype.setElement = function () {\n    this.element = this.initialElem.nativeElement;\n    var contentInput = $$1('input', this.initialElem.nativeElement);\n\n    if (contentInput.length) {\n      this.element = contentInput[0];\n    }\n  };\n\n  MbscBase.prototype.ngAfterViewInit = function () {\n    this.setElement();\n    this.startInit();\n  };\n\n  MbscBase.prototype.startInit = function () {\n    var _this = this;\n\n    this.getInlineEvents();\n    var ionInput = this.getIonInput();\n\n    if (ionInput && (ionInput.getInputElement || ionInput.then) && this.element.nodeName !== \"INPUT\") {\n      if (ionInput.getInputElement) {\n        ionInput.getInputElement().then(function (inp) {\n          _this.setElement();\n\n          _this.initControl();\n        });\n      } else {\n        ionInput.then(function (ionInpComponent) {\n          ionInpComponent.getInputElement().then(function (inp) {\n            _this.setElement();\n\n            _this.initControl();\n          });\n        });\n      }\n    } else if (!this.instance) {\n      this.initControl();\n    }\n  };\n\n  MbscBase.prototype.getIonInput = function () {\n    var v = this._view;\n    var native = this.initialElem.nativeElement;\n    var ionInputNode = native.nodeName === \"ION-INPUT\";\n    var inp1 = ionInputNode && v && v._data && v._data.componentView && v._data.componentView.component;\n    var inp2 = ionInputNode && native.componentOnReady && native.componentOnReady();\n    return inp1 || inp2;\n  };\n\n  MbscBase.prototype.initControl = function () {};\n\n  MbscBase.prototype.ngOnDestroy = function () {\n    if (this.instance) {\n      this.instance.destroy();\n    }\n  };\n\n  MbscBase.prototype.updateOptions = function (newOptions, optionChanged, invalidChanged, dataChanged) {\n    var _this = this;\n\n    if (optionChanged || invalidChanged) {\n      setTimeout(function () {\n        if (newOptions.theme && _this.themeClassesSet) {\n          _this.clearThemeClasses();\n        }\n\n        _this.instance.option(newOptions, undefined, _this.pendingValue);\n\n        if (newOptions.theme && _this.themeClassesSet) {\n          _this.setThemeClasses();\n        }\n      });\n    } else if (dataChanged) {\n      this.refreshData(this.data);\n    } else if (this.instance.redraw) {\n      this.instance.redraw();\n    }\n  };\n\n  MbscBase.prototype.ngOnChanges = function (changes) {\n    var optionChange = false,\n        cloneChange = false,\n        invalidChange = false,\n        dataChange = false,\n        newOptions = {};\n\n    for (var prop in changes) {\n      if (!changes[prop].firstChange && prop !== 'options' && prop !== 'value') {\n        if (this.cloneDictionary && this.cloneDictionary[prop]) {\n          this.makeClone(prop, changes[prop].currentValue);\n\n          if (this.instance) {\n            this.instance.settings[prop] = changes[prop].currentValue;\n          }\n\n          if (prop == 'invalid') {\n            invalidChange = true;\n          }\n\n          if (prop == 'data') {\n            dataChange = true;\n          }\n\n          cloneChange = true;\n        } else {\n          newOptions[prop] = changes[prop].currentValue;\n          optionChange = true;\n        }\n      } else if (!changes[prop].firstChange && prop !== 'value') {\n        newOptions = extend$1(changes[prop].currentValue, newOptions);\n        optionChange = true;\n      } else if (changes[prop].firstChange) {\n        if (prop !== 'options' && prop !== 'value') {\n          this.inlineOptionsObj[prop] = changes[prop].currentValue;\n        }\n      }\n    }\n\n    if (cloneChange) {\n      extend$1(newOptions, this.cloneDictionary);\n    }\n\n    if (optionChange || cloneChange) {\n      this.updateOptions(newOptions, optionChange, invalidChange, dataChange);\n    }\n  };\n\n  __decorate([Input$1('mbsc-options'), __metadata(\"design:type\", Object)], MbscBase.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscBase.prototype, \"cssClass\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscBase.prototype, \"theme\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscBase.prototype, \"themeVariant\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscBase.prototype, \"lang\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscBase.prototype, \"rtl\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscBase.prototype, \"responsive\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscBase.prototype, \"onInit\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscBase.prototype, \"onDestroy\", void 0);\n\n  MbscBase = __decorate([__metadata(\"design:paramtypes\", [ElementRef, NgZone])], MbscBase);\n\n  MbscBase.ɵfac = function MbscBase_Factory(t) {\n    return new (t || MbscBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  MbscBase.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscBase,\n    selectors: [[\"\", \"mbsc-b\", \"\"]],\n    inputs: {\n      options: [\"mbsc-options\", \"options\"],\n      cssClass: \"cssClass\",\n      theme: \"theme\",\n      themeVariant: \"themeVariant\",\n      lang: \"lang\",\n      rtl: \"rtl\",\n      responsive: \"responsive\"\n    },\n    outputs: {\n      onInit: \"onInit\",\n      onDestroy: \"onDestroy\"\n    },\n    features: [ɵngcc0.ɵɵNgOnChangesFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscBase;\n}();\n\nvar MbscValueBase = function (_super) {\n  __extends(MbscValueBase, _super);\n\n  function MbscValueBase(initialElem, zone) {\n    var _this = _super.call(this, initialElem, zone) || this;\n\n    _this.initialValue = undefined;\n    return _this;\n  }\n\n  MbscValueBase.prototype.setNewValue = function (v) {};\n\n  MbscValueBase.prototype.setNewValueProxy = function (v) {\n    if (!this.instance) {\n      this.initialValue = v;\n    }\n\n    this.setNewValue(v);\n  };\n\n  MbscValueBase = __decorate([__metadata(\"design:paramtypes\", [ElementRef, NgZone])], MbscValueBase);\n\n  MbscValueBase.ɵfac = function MbscValueBase_Factory(t) {\n    return new (t || MbscValueBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  MbscValueBase.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscValueBase,\n    selectors: [[\"\", \"mbsc-v-b\", \"\"]],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscValueBase;\n}(MbscBase);\n\nvar MbscCloneBase = function (_super) {\n  __extends(MbscCloneBase, _super);\n\n  function MbscCloneBase(initElem, zone) {\n    var _this = _super.call(this, initElem, zone) || this;\n\n    _this.cloneDictionary = {};\n    return _this;\n  }\n\n  MbscCloneBase.prototype.makeClone = function (setting, value) {\n    if (value) {\n      this.cloneDictionary[setting] = [];\n\n      for (var i = 0; i < value.length; i++) {\n        this.cloneDictionary[setting].push(value[i]);\n      }\n    } else {\n      this.cloneDictionary[setting] = value;\n    }\n  };\n\n  MbscCloneBase.prototype.ngDoCheck = function () {\n    var changed = false,\n        data = false,\n        invalid = false;\n\n    for (var key in this.cloneDictionary) {\n      if (this[key] !== undefined && !deepEqualsArray(this[key], this.cloneDictionary[key])) {\n        this.makeClone(key, this[key]);\n        this.instance.settings[key] = this[key];\n        changed = true;\n\n        if (key == 'invalid') {\n          invalid = true;\n        }\n\n        if (key == 'data') {\n          data = true;\n        }\n      }\n    }\n\n    if (changed && this.instance) {\n      this.updateOptions(this.cloneDictionary, false, invalid, data);\n    }\n  };\n\n  MbscCloneBase.prototype.ngOnInit = function () {\n    for (var key in this.cloneDictionary) {\n      this.makeClone(key, this[key]);\n    }\n  };\n\n  MbscCloneBase = __decorate([__metadata(\"design:paramtypes\", [ElementRef, NgZone])], MbscCloneBase);\n\n  MbscCloneBase.ɵfac = function MbscCloneBase_Factory(t) {\n    return new (t || MbscCloneBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  MbscCloneBase.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscCloneBase,\n    selectors: [[\"\", \"mbsc-c-b\", \"\"]],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscCloneBase;\n}(MbscValueBase);\n\nvar MbscControlBase = function (_super) {\n  __extends(MbscControlBase, _super);\n\n  function MbscControlBase(initialElement, zone, control, _inputService, _view) {\n    var _this = _super.call(this, initialElement, zone) || this;\n\n    _this.control = control;\n    _this._inputService = _inputService;\n    _this._view = _view;\n    _this._needsTimeout = true;\n\n    _this.onChange = function () {};\n\n    _this.onTouch = function () {};\n\n    _this.onChangeEmitter = new EventEmitter();\n    _this.oldAccessor = null;\n\n    _this.overwriteAccessor();\n\n    if (_inputService) {\n      _inputService.isControlSet = true;\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(MbscControlBase.prototype, \"optionExtensions\", {\n    get: function () {\n      var _this = this;\n\n      var externalOnClose = this.options && this.options.onClose;\n      var externalOnFill = this.options && this.options.onFill;\n      var onCloseEmitter = this.onClose;\n      return {\n        onFill: function (event, inst) {\n          if (_this.oldAccessor) {\n            _this.oldAccessor.writeValue(event.valueText);\n          } else {\n            var ionInput = _this.getIonInput();\n\n            if (ionInput) {\n              ionInput.value = event.valueText;\n            }\n          }\n\n          if (externalOnFill) {\n            externalOnFill(event, inst);\n          }\n        },\n        onClose: function (event, inst) {\n          _this.onTouch();\n\n          if (externalOnClose) {\n            externalOnClose(event, inst);\n          }\n\n          if (onCloseEmitter) {\n            event.inst = inst;\n            onCloseEmitter.emit(event);\n          }\n        }\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MbscControlBase.prototype, \"enableManualEdit\", {\n    get: function () {\n      var nsf = this.showOnFocus === false || this.options.showOnFocus === false,\n          nst = this.showOnTap === false || this.options.showOnTap === false;\n      return nsf && nst;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscControlBase.prototype.handleChange = function (element) {\n    var that = this;\n    $$1(element || this.element).on('change', function () {\n      that.zone.run(function () {\n        if (that.element.value !== that.instance._value && that.enableManualEdit) {\n          that.instance.setVal(that.element.value, true, true);\n        } else {\n          var value = that.instance.getVal();\n\n          if (that.control) {\n            if (!valueEquals(value, that.control.model)) {\n              that.onChange(value);\n              that.control.control.patchValue(value);\n            }\n          } else {\n            that.onChangeEmitter.emit(value);\n          }\n        }\n      });\n    });\n\n    function valueEquals(v1, v2) {\n      if (v1 === v2) {\n        return true;\n      }\n\n      if (v1 instanceof Date && v2 instanceof Date) {\n        return +v1 === +v2;\n      }\n\n      return false;\n    }\n  };\n\n  MbscControlBase.prototype.overwriteAccessor = function () {\n    if (this.control) {\n      if (this.control.valueAccessor !== this) {\n        this.oldAccessor = this.control.valueAccessor;\n      }\n\n      this.control.valueAccessor = this;\n    }\n  };\n\n  MbscControlBase.prototype.ngAfterViewInit = function () {\n    _super.prototype.ngAfterViewInit.call(this);\n\n    this.handleChange();\n    this.overwriteAccessor();\n\n    if (this.control && this.control._setUpControl) {\n      this.control._setUpControl();\n    }\n  };\n\n  MbscControlBase.prototype.registerOnChange = function (fn) {\n    this.onChange = fn;\n  };\n\n  MbscControlBase.prototype.registerOnTouched = function (fn) {\n    this.onTouch = fn;\n  };\n\n  MbscControlBase.prototype.setDisabledState = function (isDisabled) {\n    this.disabled = isDisabled;\n\n    if (this.oldAccessor && this.oldAccessor.setDisabledState) {\n      this.oldAccessor.setDisabledState(isDisabled);\n    }\n\n    if (this.instance && this.instance.disable && this.instance.enable) {\n      if (isDisabled) {\n        this.instance.disable();\n      } else {\n        this.instance.enable();\n      }\n    }\n  };\n\n  MbscControlBase.prototype.writeValue = function (v) {\n    var _this = this;\n\n    if (this._needsTimeout) {\n      this.pendingValue = v;\n      setTimeout(function () {\n        _this.pendingValue = undefined;\n\n        _this.setNewValueProxy(v);\n      });\n    } else {\n      this.setNewValueProxy(v);\n    }\n  };\n\n  __decorate([Input$1('label-style'), __metadata(\"design:type\", String)], MbscControlBase.prototype, \"labelStyle\", void 0);\n\n  __decorate([Input$1('input-style'), __metadata(\"design:type\", String)], MbscControlBase.prototype, \"inputStyle\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscControlBase.prototype, \"showOnFocus\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscControlBase.prototype, \"showOnTap\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscControlBase.prototype, \"disabled\", void 0);\n\n  MbscControlBase = __decorate([__metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, ViewContainerRef])], MbscControlBase);\n\n  MbscControlBase.ɵfac = function MbscControlBase_Factory(t) {\n    return new (t || MbscControlBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl), ɵngcc0.ɵɵdirectiveInject(MbscInputService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscControlBase.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscControlBase,\n    selectors: [[\"\", \"mbsc-cc-b\", \"\"]],\n    inputs: {\n      disabled: \"disabled\",\n      labelStyle: [\"label-style\", \"labelStyle\"],\n      inputStyle: [\"input-style\", \"inputStyle\"],\n      showOnFocus: \"showOnFocus\",\n      showOnTap: \"showOnTap\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscControlBase;\n}(MbscCloneBase);\n\nvar MbscFrameBase = function (_super) {\n  __extends(MbscFrameBase, _super);\n\n  function MbscFrameBase(initialElem, zone, control, _inputService, view) {\n    var _this = _super.call(this, initialElem, zone, control, _inputService, view) || this;\n\n    _this.onBeforeClose = new EventEmitter();\n    _this.onBeforeShow = new EventEmitter();\n    _this.onCancel = new EventEmitter();\n    _this.onClose = new EventEmitter();\n    _this.onFill = new EventEmitter();\n    _this.onMarkupReady = new EventEmitter();\n    _this.onPosition = new EventEmitter();\n    _this.onShow = new EventEmitter();\n    return _this;\n  }\n\n  Object.defineProperty(MbscFrameBase.prototype, \"inline\", {\n    get: function () {\n      return (this.display || this.options && this.options.display) === 'inline';\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscFrameBase.prototype.ngOnInit = function () {\n    this.cloneDictionary.invalid = [];\n    this.cloneDictionary.valid = [];\n\n    _super.prototype.ngOnInit.call(this);\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscFrameBase.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscFrameBase.prototype, \"dropdown\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscFrameBase.prototype, \"anchor\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscFrameBase.prototype, \"animate\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscFrameBase.prototype, \"buttons\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscFrameBase.prototype, \"closeOnOverlayTap\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscFrameBase.prototype, \"context\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscFrameBase.prototype, \"display\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscFrameBase.prototype, \"showInput\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscFrameBase.prototype, \"focusOnClose\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscFrameBase.prototype, \"focusTrap\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscFrameBase.prototype, \"headerText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscFrameBase.prototype, \"scrollLock\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscFrameBase.prototype, \"touchUi\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscFrameBase.prototype, \"onBeforeClose\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscFrameBase.prototype, \"onBeforeShow\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscFrameBase.prototype, \"onCancel\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscFrameBase.prototype, \"onClose\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscFrameBase.prototype, \"onFill\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscFrameBase.prototype, \"onMarkupReady\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscFrameBase.prototype, \"onPosition\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscFrameBase.prototype, \"onShow\", void 0);\n\n  MbscFrameBase = __decorate([__metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, ViewContainerRef])], MbscFrameBase);\n\n  MbscFrameBase.ɵfac = function MbscFrameBase_Factory(t) {\n    return new (t || MbscFrameBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl), ɵngcc0.ɵɵdirectiveInject(MbscInputService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscFrameBase.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscFrameBase,\n    selectors: [[\"\", \"mbsc-fr-b\", \"\"]],\n    inputs: {\n      options: \"options\",\n      dropdown: \"dropdown\",\n      anchor: \"anchor\",\n      animate: \"animate\",\n      buttons: \"buttons\",\n      closeOnOverlayTap: \"closeOnOverlayTap\",\n      context: \"context\",\n      display: \"display\",\n      showInput: \"showInput\",\n      focusOnClose: \"focusOnClose\",\n      focusTrap: \"focusTrap\",\n      headerText: \"headerText\",\n      scrollLock: \"scrollLock\",\n      touchUi: \"touchUi\"\n    },\n    outputs: {\n      onBeforeClose: \"onBeforeClose\",\n      onBeforeShow: \"onBeforeShow\",\n      onCancel: \"onCancel\",\n      onClose: \"onClose\",\n      onFill: \"onFill\",\n      onMarkupReady: \"onMarkupReady\",\n      onPosition: \"onPosition\",\n      onShow: \"onShow\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscFrameBase;\n}(MbscControlBase);\n\nvar MbscScrollerBase = function (_super) {\n  __extends(MbscScrollerBase, _super);\n\n  function MbscScrollerBase(initialElement, zone, control, _inputService, view) {\n    var _this = _super.call(this, initialElement, zone, control, _inputService, view) || this;\n\n    _this.onWheelChange = new EventEmitter();\n    _this.onSet = new EventEmitter();\n    _this.onItemTap = new EventEmitter();\n    _this.onClear = new EventEmitter();\n    return _this;\n  }\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscScrollerBase.prototype, \"circular\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscScrollerBase.prototype, \"height\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscScrollerBase.prototype, \"layout\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscScrollerBase.prototype, \"maxWidth\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscScrollerBase.prototype, \"minWidth\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscScrollerBase.prototype, \"multiline\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscScrollerBase.prototype, \"readonly\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscScrollerBase.prototype, \"rows\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscScrollerBase.prototype, \"showLabel\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscScrollerBase.prototype, \"showScrollArrows\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscScrollerBase.prototype, \"wheels\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscScrollerBase.prototype, \"width\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Function)], MbscScrollerBase.prototype, \"validate\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscScrollerBase.prototype, \"cancelText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscScrollerBase.prototype, \"clearText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscScrollerBase.prototype, \"selectedText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscScrollerBase.prototype, \"setText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Function)], MbscScrollerBase.prototype, \"formatValue\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Function)], MbscScrollerBase.prototype, \"parseValue\", void 0);\n\n  __decorate([Output('onChange'), __metadata(\"design:type\", EventEmitter)], MbscScrollerBase.prototype, \"onWheelChange\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscScrollerBase.prototype, \"onSet\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscScrollerBase.prototype, \"onItemTap\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscScrollerBase.prototype, \"onClear\", void 0);\n\n  MbscScrollerBase = __decorate([__metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, ViewContainerRef])], MbscScrollerBase);\n\n  MbscScrollerBase.ɵfac = function MbscScrollerBase_Factory(t) {\n    return new (t || MbscScrollerBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl), ɵngcc0.ɵɵdirectiveInject(MbscInputService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscScrollerBase.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscScrollerBase,\n    selectors: [[\"\", \"mbsc-s-b\", \"\"]],\n    inputs: {\n      circular: \"circular\",\n      height: \"height\",\n      layout: \"layout\",\n      maxWidth: \"maxWidth\",\n      minWidth: \"minWidth\",\n      multiline: \"multiline\",\n      readonly: \"readonly\",\n      rows: \"rows\",\n      showLabel: \"showLabel\",\n      showScrollArrows: \"showScrollArrows\",\n      wheels: \"wheels\",\n      width: \"width\",\n      validate: \"validate\",\n      cancelText: \"cancelText\",\n      clearText: \"clearText\",\n      selectedText: \"selectedText\",\n      setText: \"setText\",\n      formatValue: \"formatValue\",\n      parseValue: \"parseValue\"\n    },\n    outputs: {\n      onWheelChange: \"onChange\",\n      onSet: \"onSet\",\n      onItemTap: \"onItemTap\",\n      onClear: \"onClear\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscScrollerBase;\n}(MbscFrameBase);\n\nvar MbscBaseModule = function () {\n  function MbscBaseModule() {}\n\n  MbscBaseModule.ɵfac = function MbscBaseModule_Factory(t) {\n    return new (t || MbscBaseModule)();\n  };\n\n  MbscBaseModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscBaseModule\n  });\n  MbscBaseModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscBaseModule, {\n      declarations: function () {\n        return [MbscBase, MbscValueBase, MbscCloneBase, MbscControlBase];\n      },\n      imports: function () {\n        return [CommonModule];\n      }\n    });\n  })();\n\n  return MbscBaseModule;\n}();\n\nvar MbscFrameBaseModule = function () {\n  function MbscFrameBaseModule() {}\n\n  MbscFrameBaseModule.ɵfac = function MbscFrameBaseModule_Factory(t) {\n    return new (t || MbscFrameBaseModule)();\n  };\n\n  MbscFrameBaseModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscFrameBaseModule\n  });\n  MbscFrameBaseModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, MbscBaseModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscFrameBaseModule, {\n      declarations: function () {\n        return [MbscFrameBase];\n      },\n      imports: function () {\n        return [CommonModule, MbscBaseModule];\n      }\n    });\n  })();\n\n  return MbscFrameBaseModule;\n}();\n\nvar MbscScrollerBaseModule = function () {\n  function MbscScrollerBaseModule() {}\n\n  MbscScrollerBaseModule.ɵfac = function MbscScrollerBaseModule_Factory(t) {\n    return new (t || MbscScrollerBaseModule)();\n  };\n\n  MbscScrollerBaseModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscScrollerBaseModule\n  });\n  MbscScrollerBaseModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, MbscFrameBaseModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscScrollerBaseModule, {\n      declarations: function () {\n        return [MbscScrollerBase];\n      },\n      imports: function () {\n        return [CommonModule, MbscFrameBaseModule];\n      }\n    });\n  })();\n\n  return MbscScrollerBaseModule;\n}();\n\nfunction deepEqualsArray(a1, a2) {\n  if (a1 === a2) {\n    return true;\n  } else if (!a1 || !a2 || a1.length !== a2.length) {\n    return false;\n  } else {\n    for (var i = 0; i < a1.length; i++) {\n      if (a1[i] !== a2[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\n\nfunction isDateEqual(d1, d2) {\n  if (d1 && !d2 || d2 && !d1) {\n    return false;\n  } else if (!d1 && !d2) {\n    return true;\n  } else {\n    return d1 && d2 && d1.toString() === d2.toString();\n  }\n}\n\nfunction emptyOrTrue(val) {\n  return typeof val === 'string' && (val === 'true' || val === '') || !!val;\n}\n\nvar INPUT_TEMPLATE = \"<mbsc-input *ngIf=\\\"!inline || showInput\\\"\\n    [controlNg]=\\\"false\\\" [name]=\\\"name\\\" [theme]=\\\"theme\\\" [themeVariant]=\\\"themeVariant\\\" [label-style]=\\\"labelStyle\\\" [input-style]=\\\"inputStyle\\\" [disabled]=\\\"disabled\\\" [dropdown]=\\\"dropdown\\\" [placeholder]=\\\"placeholder\\\"\\n    [error]=\\\"error\\\" [errorMessage]=\\\"errorMessage\\\"\\n    [icon]=\\\"inputIcon\\\" [icon-align]=\\\"iconAlign\\\">\\n    <ng-content></ng-content>\\n</mbsc-input>\";\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nvar wrapClass = 'mbsc-input-wrap';\nvar events = ['touchend', 'touchcancel', 'mousedown', 'mousemove', 'mouseup', 'mouseleave'];\nvar defaults = {\n  tap: hasGhostClick\n};\nvar $active;\n\nfunction addIcon($control, ic) {\n  var icons = {},\n      control = $control[0],\n      $parent = $control.parent(),\n      errorMsg = $parent.find('.mbsc-err-msg'),\n      align = $control.attr('data-icon-align') || 'left',\n      icon = $control.attr('data-icon');\n\n  if ($parent.hasClass(wrapClass)) {\n    $parent = $parent.parent();\n  } else {\n    // Wrap input\n    $$1('<span class=\"' + wrapClass + '\"></span>').insertAfter($control).append($control);\n  }\n\n  if (errorMsg) {\n    $parent.find('.' + wrapClass).append(errorMsg);\n  }\n\n  if (icon) {\n    if (icon.indexOf('{') !== -1) {\n      icons = JSON.parse(icon);\n    } else {\n      icons[align] = icon;\n    }\n  }\n\n  if (control.type == 'file') {\n    // Set icon\n    icons.right = $control.attr('data-icon-upload') || 'upload';\n  }\n\n  if (icon || ic) {\n    extend$1(icons, ic);\n    $parent.addClass((icons.right ? 'mbsc-ic-right ' : '') + (icons.left ? ' mbsc-ic-left' : '')).find('.' + wrapClass).append('<span class=\"mbsc-input-fill\"></span>').append(icons.left ? '<span class=\"mbsc-input-ic mbsc-left-ic mbsc-ic mbsc-ic-' + icons.left + '\"></span>' : '').append(icons.right ? '<span class=\"mbsc-input-ic mbsc-right-ic mbsc-ic mbsc-ic-' + icons.right + '\"></span>' : '');\n  }\n}\n\nfunction addIconToggle(that, $parent, $control) {\n  var icons = {},\n      control = $control[0],\n      toggle = $control.attr('data-password-toggle'),\n      iconShow = $control.attr('data-icon-show') || 'eye',\n      iconHide = $control.attr('data-icon-hide') || 'eye-blocked';\n\n  if (toggle) {\n    icons.right = control.type == 'password' ? iconShow : iconHide;\n  }\n\n  addIcon($control, icons);\n\n  if (toggle) {\n    tap(that, $parent.find('.mbsc-right-ic').addClass('mbsc-input-toggle'), function () {\n      if (control.type == \"text\") {\n        control.type = \"password\";\n        $$1(this).addClass('mbsc-ic-' + iconShow).removeClass('mbsc-ic-' + iconHide);\n      } else {\n        control.type = \"text\";\n        $$1(this).removeClass('mbsc-ic-' + iconShow).addClass('mbsc-ic-' + iconHide);\n      }\n    });\n  }\n}\n\nfunction wrapLabel($parent, type, inputStyle, labelStyle, elm) {\n  // Wrap non-empty text nodes in span with mbsc-label class\n  if (type == 'segmented') {\n    $parent.closest('.mbsc-segmented').addClass(inputStyle == 'box' ? 'mbsc-input-box' : '').addClass(inputStyle == 'outline' ? 'mbsc-input-outline' : '');\n  } else if (type != 'button' && type != 'submit') {\n    $parent.addClass('mbsc-control-w').addClass(inputStyle == 'box' ? 'mbsc-input-box' : '').addClass(inputStyle == 'outline' ? 'mbsc-input-outline' : '').addClass(labelStyle == 'inline' ? 'mbsc-label-inline' : '').addClass(labelStyle == 'stacked' ? 'mbsc-label-stacked' : '').addClass(labelStyle == 'floating' ? 'mbsc-label-floating' : '').addClass(labelStyle == 'floating' && elm.value ? 'mbsc-label-floating-active' : '').find('label').addClass('mbsc-label').each(function (i, v) {\n      $$1(v).attr('title', $$1(v).text());\n    });\n    $parent.contents().filter(function () {\n      return this.nodeType == 3 && this.nodeValue && /\\S/.test(this.nodeValue);\n    }).each(function () {\n      $$1('<span class=\"mbsc-label\" title=\"' + this.textContent.trim() + '\"></span>').insertAfter(this).append(this);\n    });\n  }\n}\n\nfunction getRipple(theme) {\n  var ripple = mobiscroll.themes.form[theme];\n  return ripple && ripple.addRipple ? ripple : null;\n}\n\nfunction getAttr($elm, attr, def) {\n  var v = $elm.attr(attr);\n  return v === undefined || v === '' ? def : v;\n}\n\nfunction getCssClass(s) {\n  var theme = getThemeName(s);\n  var baseTheme = mobiscroll.themes.form[theme].baseTheme;\n  return 'mbsc-' + theme + (baseTheme ? ' mbsc-' + baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr');\n}\n\nvar FormControl = /*#__PURE__*/function () {\n  function FormControl(elm, settings) {\n    var _this = this;\n\n    var s = extend$1({}, defaults, mobiscroll.settings, settings);\n    var $elm = $$1(elm);\n    var $p = $elm.parent();\n    var $parent = $p.hasClass('mbsc-input-wrap') ? $p.parent() : $p; // Check for inline mobiscroll components\n\n    var $frame = $elm.next().hasClass('mbsc-fr') ? $elm.next() : null;\n    var type = getControlType($elm);\n    var inputStyle = getAttr($elm, 'data-input-style', s.inputStyle);\n    var labelStyle = getAttr($elm, 'data-label-style', s.labelStyle);\n\n    if (elm.mbscInst) {\n      elm.mbscInst.destroy();\n    }\n\n    if ($frame) {\n      $frame.insertAfter($parent);\n    }\n\n    s.theme = getThemeName(s);\n\n    if (s.rtl === undefined && s.lang && mobiscroll.i18n[s.lang]) {\n      s.rtl = mobiscroll.i18n[s.lang].rtl;\n    }\n\n    wrapLabel($parent, type, inputStyle, labelStyle, elm);\n    $elm.addClass('mbsc-control'); // Attach events\n\n    this._handle = this._handle.bind(this); // Prevent 300ms click latency\n\n    events.forEach(function (ev) {\n      $elm.on(ev, _this._handle);\n    }); // Touch events are added separately, needs to be passive listener\n\n    listen(elm, 'touchstart', this._handle, {\n      passive: true\n    });\n    listen(elm, 'touchmove', this._handle, {\n      passive: true\n    });\n    this.settings = s;\n    this._type = type;\n    this._elm = elm;\n    this._$elm = $elm;\n    this._$parent = $parent;\n    this._$frame = $frame;\n    this._ripple = getRipple(s.theme);\n    this._isFloating = labelStyle == 'floating' || $parent.hasClass('mbsc-label-floating');\n    this.cssClass = getCssClass(s);\n    this.getClassElm().addClass(this.cssClass);\n    elm.mbscInst = this;\n  }\n\n  var _proto = FormControl.prototype;\n\n  _proto.getClassElm = function getClassElm() {\n    return this._$parent;\n  };\n\n  _proto.destroy = function destroy() {\n    var _this2 = this;\n\n    var $elm = this._$elm;\n    var elm = this._elm;\n    $elm.removeClass('mbsc-control');\n    this.getClassElm().removeClass(this.cssClass);\n    events.forEach(function (ev) {\n      $elm.off(ev, _this2._handle);\n    });\n    unlisten(elm, 'touchstart', this._handle, {\n      passive: true\n    });\n    unlisten(elm, 'touchmove', this._handle, {\n      passive: true\n    });\n    delete elm.mbscInst;\n  };\n\n  _proto.option = function option(s) {\n    extend$1(this.settings, s);\n    var classElm = this.getClassElm();\n\n    if (this.cssClass) {\n      classElm.removeClass(this.cssClass);\n    }\n\n    this.cssClass = getCssClass(this.settings);\n    classElm.addClass(this.cssClass);\n    this._ripple = getRipple(this.settings.theme);\n  };\n\n  _proto._handle = function _handle(ev) {\n    switch (ev.type) {\n      case 'touchstart':\n      case 'mousedown':\n        this._onStart(ev);\n\n        break;\n\n      case 'touchmove':\n      case 'mousemove':\n        this._onMove(ev);\n\n        break;\n\n      case 'touchend':\n      case 'touchcancel':\n      case 'mouseup':\n      case 'mouseleave':\n        this._onEnd(ev);\n\n        break;\n    }\n  };\n\n  _proto._addRipple = function _addRipple(ev) {\n    if (this._ripple && this._$rippleElm) {\n      this._ripple.addRipple(this._$rippleElm, ev);\n    }\n  };\n\n  _proto._removeRipple = function _removeRipple() {\n    if (this._ripple && this._$rippleElm) {\n      this._ripple.removeRipple();\n    }\n  };\n\n  _proto._onStart = function _onStart(ev) {\n    var elm = this._elm;\n\n    if (testTouch(ev, elm)) {\n      this._startX = getCoord(ev, 'X');\n      this._startY = getCoord(ev, 'Y');\n\n      if ($active) {\n        $active.removeClass('mbsc-active');\n      }\n\n      if (!elm.disabled) {\n        this._isActive = true;\n        $active = this._$elm;\n        $active.addClass('mbsc-active');\n\n        this._addRipple(ev);\n      }\n    }\n\n    if (ev.type == 'touchstart') {\n      this._$elm.closest('.mbsc-no-touch').removeClass('mbsc-no-touch');\n    }\n  };\n\n  _proto._onMove = function _onMove(ev) {\n    // If movement is more than 9px, don't fire the click event handler\n    if (this._isActive && Math.abs(getCoord(ev, 'X') - this._startX) > 9 || Math.abs(getCoord(ev, 'Y') - this._startY) > 9) {\n      this._$elm.removeClass('mbsc-active');\n\n      this._removeRipple();\n\n      this._isActive = false;\n    }\n  };\n\n  _proto._onEnd = function _onEnd(ev) {\n    var _this3 = this;\n\n    var control = this._elm;\n    var type = this._type;\n\n    if (this._isActive && this.settings.tap && ev.type == 'touchend' && !control.readOnly) {\n      activateControl(control, type, ev);\n    }\n\n    if (this._isActive) {\n      setTimeout(function () {\n        _this3._$elm.removeClass('mbsc-active');\n\n        _this3._removeRipple();\n      }, 100);\n    }\n\n    this._isActive = false;\n    $active = null;\n  };\n\n  return FormControl;\n}();\n\nmobiscroll.themes.form.mobiscroll = {};\nvar events$1 = ['focus', 'change', 'blur', 'animationstart'];\n\nvar Input = /*#__PURE__*/function (_FormControl) {\n  _inheritsLoose(Input, _FormControl);\n\n  function Input(elm, settings) {\n    var _this;\n\n    _this = _FormControl.call(this, elm, settings) || this;\n    var $elm = _this._$elm;\n    var $parent = _this._$parent;\n    var $dummy = $parent.find('.mbsc-select-input, .mbsc-color-input');\n    addIconToggle(_assertThisInitialized(_this), $parent, $elm);\n    _this._checkLabel = _this._checkLabel.bind(_assertThisInitialized(_this));\n    _this._mouseDown = _this._mouseDown.bind(_assertThisInitialized(_this));\n    _this._setText = _this._setText.bind(_assertThisInitialized(_this));\n\n    if (elm.type == 'file') {\n      // Copy attributes and create dummy input\n      var $existing = $parent.find('.mbsc-file-input');\n      _this._$input = $existing.length ? $existing : $$1('<input type=\"text\" class=\"' + ($elm.attr('class') || '') + ' mbsc-file-input\" placeholder=\"' + ($elm.attr('placeholder') || '') + '\"/>').insertAfter($elm); // Copy value on file upload\n\n      $elm.on('change', _this._setText);\n    }\n\n    $parent.addClass('mbsc-input').on('mousedown', _this._mouseDown); // Attach events\n\n    events$1.forEach(function (ev) {\n      $elm.on(ev, _this._checkLabel);\n    }); // Move the dummy input after the element for correct styling\n\n    if ($dummy.length) {\n      $elm.after($dummy);\n\n      if ($dummy.hasClass('mbsc-select-input')) {\n        _this._delm = $dummy[0];\n\n        _this.refresh();\n      }\n    }\n\n    return _this;\n  }\n\n  var _proto = Input.prototype;\n\n  _proto._setText = function _setText(ev) {\n    var files = ev.target.files;\n    var names = [];\n\n    for (var i = 0; i < files.length; ++i) {\n      names.push(files[i].name);\n    }\n\n    this._$input.val(names);\n  };\n\n  _proto._checkLabel = function _checkLabel(ev) {\n    if (this._isFloating) {\n      // In case of select we need to check the dummy element\n      var elm = this._delm || this._elm; // In case of autofill in webkit browsers the animationstart event will fire \n      // due to the empty animation added in the css,\n      // because there's no other event in case of the initial autofill\n\n      if (elm.value || document.activeElement === elm || ev && (ev.type == 'focus' || ev.type == 'animationstart' && this._$elm.is('*:-webkit-autofill'))) {\n        this._$parent.addClass('mbsc-label-floating-active');\n      } else {\n        this._$parent.removeClass('mbsc-label-floating-active');\n      }\n    }\n  };\n\n  _proto._mouseDown = function _mouseDown(ev) {\n    // Will prevent floating label animation when loosing focus only for a brief moment\n    if (document.activeElement === this._elm && ev.target !== this._elm) {\n      ev.preventDefault();\n    }\n  };\n\n  _proto.refresh = function refresh() {\n    this._checkLabel();\n  };\n\n  _proto.destroy = function destroy() {\n    var _this2 = this;\n\n    _FormControl.prototype.destroy.call(this);\n\n    this._$parent.off('mousedown', this._mouseDown).removeClass('mbsc-ic-left mbsc-ic-right').find('.mbsc-input-ic').remove();\n\n    this._$parent.find('.mbsc-input-fill').remove();\n\n    events$1.forEach(function (ev) {\n      _this2._$elm.off(ev, _this2._checkLabel);\n    });\n\n    this._$elm.off('change', this._setText);\n  };\n\n  return Input;\n}(FormControl); // Init mbsc-input elements on page load\n\n\nautoInit('[mbsc-input]', Input);\n\nvar MbscFormBase = function (_super) {\n  __extends(MbscFormBase, _super);\n\n  function MbscFormBase(hostElem, _formService, zone) {\n    var _this = _super.call(this, hostElem, zone) || this;\n\n    _this._formService = _formService;\n    _this.disabled = false;\n    return _this;\n  }\n\n  MbscFormBase.prototype.ngOnInit = function () {\n    this._inheritedOptions = this._formService ? this._formService.options : {};\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscFormBase.prototype, \"color\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscFormBase.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscFormBase.prototype, \"disabled\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscFormBase.prototype, \"name\", void 0);\n\n  __decorate([ViewChild('initElement', {\n    static: false\n  }), __metadata(\"design:type\", ElementRef)], MbscFormBase.prototype, \"_initElem\", void 0);\n\n  MbscFormBase = __decorate([__metadata(\"design:paramtypes\", [ElementRef, MbscOptionsService, NgZone])], MbscFormBase);\n\n  MbscFormBase.ɵfac = function MbscFormBase_Factory(t) {\n    return new (t || MbscFormBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  MbscFormBase.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscFormBase,\n    selectors: [[\"\", \"mbsc-f-b\", \"\"]],\n    viewQuery: function MbscFormBase_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._initElem = _t.first);\n      }\n    },\n    inputs: {\n      color: \"color\",\n      options: \"options\",\n      disabled: \"disabled\",\n      name: \"name\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscFormBase;\n}(MbscBase);\n\nvar MbscFormValueBase = function (_super) {\n  __extends(MbscFormValueBase, _super);\n\n  function MbscFormValueBase(hostElem, _formService, _inputService, _control, zone) {\n    var _this = _super.call(this, hostElem, _formService, zone) || this;\n\n    _this._control = _control;\n\n    _this.onChange = function () {};\n\n    _this.onTouch = function () {};\n\n    _this.errorMessage = '';\n    _this.valueChangeEmitter = new EventEmitter();\n\n    if (_control && (!_inputService || !_inputService.isControlSet)) {\n      if (_control.valueAccessor && _control.valueAccessor.oldAccessor !== undefined) {\n        _control.valueAccessor.oldAccessor = _this;\n      } else {\n        _control.valueAccessor = _this;\n      }\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(MbscFormValueBase.prototype, \"readonly\", {\n    set: function (val) {\n      this._readonly = emptyOrTrue(val);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MbscFormValueBase.prototype, \"innerValue\", {\n    get: function () {\n      return this._value;\n    },\n    set: function (v) {\n      this._value = v;\n      this.onChange(v);\n      this.valueChangeEmitter.emit(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MbscFormValueBase.prototype, \"value\", {\n    set: function (v) {\n      this._value = v;\n      this.refresh();\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscFormValueBase.prototype.registerOnChange = function (fn) {\n    this.onChange = fn;\n  };\n\n  MbscFormValueBase.prototype.registerOnTouched = function (fn) {\n    this.onTouch = fn;\n  };\n\n  MbscFormValueBase.prototype.setDisabledState = function (isDisabled) {\n    this.disabled = isDisabled;\n  };\n\n  MbscFormValueBase.prototype.writeValue = function (v) {\n    this._value = v;\n    this.refresh();\n  };\n\n  MbscFormValueBase.prototype.refresh = function () {\n    var _this = this;\n\n    if (this.instance && this.instance.refresh) {\n      setTimeout(function () {\n        _this.instance.refresh();\n      });\n    }\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], MbscFormValueBase.prototype, \"readonly\", null);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], MbscFormValueBase.prototype, \"value\", null);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscFormValueBase.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscFormValueBase.prototype, \"errorMessage\", void 0);\n\n  __decorate([Output('valueChange'), __metadata(\"design:type\", EventEmitter)], MbscFormValueBase.prototype, \"valueChangeEmitter\", void 0);\n\n  MbscFormValueBase = __decorate([__param(1, Optional()), __param(2, Optional()), __metadata(\"design:paramtypes\", [ElementRef, MbscOptionsService, MbscInputService, NgControl, NgZone])], MbscFormValueBase);\n\n  MbscFormValueBase.ɵfac = function MbscFormValueBase_Factory(t) {\n    return new (t || MbscFormValueBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  MbscFormValueBase.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscFormValueBase,\n    selectors: [[\"\", \"mbsc-fv-b\", \"\"]],\n    inputs: {\n      readonly: \"readonly\",\n      value: \"value\",\n      error: \"error\",\n      errorMessage: \"errorMessage\"\n    },\n    outputs: {\n      valueChangeEmitter: \"valueChange\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscFormValueBase;\n}(MbscFormBase);\n\nvar MbscInputBase = function (_super) {\n  __extends(MbscInputBase, _super);\n\n  function MbscInputBase(initialElem, _formService, _inputService, _control, zone) {\n    var _this = _super.call(this, initialElem, _formService, _inputService, _control, zone) || this;\n\n    _this.type = 'text';\n    _this.placeholder = '';\n    return _this;\n  }\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscInputBase.prototype, \"autocomplete\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscInputBase.prototype, \"autocapitalize\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscInputBase.prototype, \"autocorrect\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscInputBase.prototype, \"spellcheck\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscInputBase.prototype, \"autofocus\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscInputBase.prototype, \"minlength\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscInputBase.prototype, \"maxlength\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscInputBase.prototype, \"required\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscInputBase.prototype, \"icon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscInputBase.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscInputBase.prototype, \"type\", void 0);\n\n  __decorate([Input$1('password-toggle'), __metadata(\"design:type\", Boolean)], MbscInputBase.prototype, \"passwordToggle\", void 0);\n\n  __decorate([Input$1('icon-show'), __metadata(\"design:type\", String)], MbscInputBase.prototype, \"iconShow\", void 0);\n\n  __decorate([Input$1('icon-hide'), __metadata(\"design:type\", String)], MbscInputBase.prototype, \"iconHide\", void 0);\n\n  __decorate([Input$1('icon-upload'), __metadata(\"design:type\", Boolean)], MbscInputBase.prototype, \"iconUpload\", void 0);\n\n  __decorate([Input$1('input-style'), __metadata(\"design:type\", String)], MbscInputBase.prototype, \"inputStyle\", void 0);\n\n  __decorate([Input$1('label-style'), __metadata(\"design:type\", String)], MbscInputBase.prototype, \"labelStyle\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscInputBase.prototype, \"placeholder\", void 0);\n\n  MbscInputBase = __decorate([__param(1, Optional()), __param(2, Optional()), __metadata(\"design:paramtypes\", [ElementRef, MbscOptionsService, MbscInputService, NgControl, NgZone])], MbscInputBase);\n\n  MbscInputBase.ɵfac = function MbscInputBase_Factory(t) {\n    return new (t || MbscInputBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  MbscInputBase.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscInputBase,\n    selectors: [[\"\", \"mbsc-i-b\", \"\"]],\n    inputs: {\n      autocomplete: \"autocomplete\",\n      autocapitalize: \"autocapitalize\",\n      autocorrect: \"autocorrect\",\n      spellcheck: \"spellcheck\",\n      autofocus: \"autofocus\",\n      minlength: \"minlength\",\n      maxlength: \"maxlength\",\n      required: \"required\",\n      icon: \"icon\",\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      type: \"type\",\n      passwordToggle: [\"password-toggle\", \"passwordToggle\"],\n      iconShow: [\"icon-show\", \"iconShow\"],\n      iconHide: [\"icon-hide\", \"iconHide\"],\n      iconUpload: [\"icon-upload\", \"iconUpload\"],\n      inputStyle: [\"input-style\", \"inputStyle\"],\n      labelStyle: [\"label-style\", \"labelStyle\"],\n      placeholder: \"placeholder\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscInputBase;\n}(MbscFormValueBase);\n\nvar MbscInput = function (_super) {\n  __extends(MbscInput, _super);\n\n  function MbscInput(initialElem, _formService, _inputService, _control, zone) {\n    var _this = _super.call(this, initialElem, _formService, _inputService, _control, zone) || this;\n\n    _this._inputService = _inputService;\n    _this.controlNg = true;\n    _this.dropdown = false;\n    _inputService.input = _this;\n    return _this;\n  }\n\n  MbscInput.prototype.initControl = function () {\n    var _this = this;\n\n    var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);\n    this.instance = new Input(this._initElem.nativeElement, options);\n    setTimeout(function () {\n      _this.instance.refresh();\n    });\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscInput.prototype, \"min\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscInput.prototype, \"max\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscInput.prototype, \"step\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscInput.prototype, \"pattern\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscInput.prototype, \"accept\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscInput.prototype, \"multiple\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscInput.prototype, \"controlNg\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscInput.prototype, \"dropdown\", void 0);\n\n  MbscInput = __decorate([__param(1, Optional()), __param(3, Optional()), __metadata(\"design:paramtypes\", [ElementRef, MbscOptionsService, MbscInputService, NgControl, NgZone])], MbscInput);\n\n  MbscInput.ɵfac = function MbscInput_Factory(t) {\n    return new (t || MbscInput)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  MbscInput.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscInput,\n    selectors: [[\"mbsc-input\"]],\n    hostVars: 4,\n    hostBindings: function MbscInput_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"mbsc-control-ng\", ctx.controlNg)(\"mbsc-err\", ctx.error);\n      }\n    },\n    inputs: {\n      min: \"min\",\n      max: \"max\",\n      step: \"step\",\n      pattern: \"pattern\",\n      accept: \"accept\",\n      multiple: \"multiple\",\n      controlNg: \"controlNg\",\n      dropdown: \"dropdown\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([MbscInputService]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 7,\n    vars: 42,\n    consts: [[1, \"mbsc-input-wrap\"], [3, \"type\", \"placeholder\", \"ngModel\", \"disabled\", \"readonly\", \"ngModelChange\", \"blur\"], [\"initElement\", \"\"], [\"class\", \"mbsc-select-ic mbsc-ic mbsc-ic-arrow-down5\", 4, \"ngIf\"], [\"class\", \"mbsc-err-msg\", 4, \"ngIf\"], [1, \"mbsc-select-ic\", \"mbsc-ic\", \"mbsc-ic-arrow-down5\"], [1, \"mbsc-err-msg\"]],\n    template: function MbscInput_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"label\");\n        ɵngcc0.ɵɵprojection(1);\n        ɵngcc0.ɵɵelementStart(2, \"span\", 0)(3, \"input\", 1, 2);\n        ɵngcc0.ɵɵlistener(\"ngModelChange\", function MbscInput_Template_input_ngModelChange_3_listener($event) {\n          return ctx.innerValue = $event;\n        })(\"blur\", function MbscInput_Template_input_blur_3_listener($event) {\n          return ctx.onTouch($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(5, MbscInput_span_5_Template, 1, 0, \"span\", 3);\n        ɵngcc0.ɵɵtemplate(6, MbscInput_span_6_Template, 2, 1, \"span\", 4);\n        ɵngcc0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"mbsc-err\", ctx.error)(\"mbsc-select\", ctx.dropdown)(\"mbsc-input-box\", ctx.inputStyle == \"box\")(\"mbsc-input-outline\", ctx.inputStyle == \"outline\")(\"mbsc-label-stacked\", ctx.labelStyle == \"stacked\")(\"mbsc-label-inline\", ctx.labelStyle == \"inline\")(\"mbsc-label-floating\", ctx.labelStyle == \"floating\");\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"type\", ctx.type)(\"placeholder\", ctx.placeholder)(\"ngModel\", ctx.innerValue)(\"disabled\", ctx.disabled)(\"readonly\", ctx._readonly);\n        ɵngcc0.ɵɵattribute(\"name\", ctx.name)(\"data-icon\", ctx.icon ? ctx.icon : null)(\"data-icon-align\", ctx.iconAlign ? ctx.iconAlign : null)(\"data-password-toggle\", ctx.passwordToggle ? \"true\" : null)(\"data-icon-show\", ctx.iconShow ? ctx.iconShow : null)(\"data-icon-hide\", ctx.iconHide ? ctx.iconHide : null)(\"data-icon-upload\", ctx.iconUpload ? ctx.iconUpload : null)(\"min\", ctx.min)(\"max\", ctx.max)(\"minlength\", ctx.minlength)(\"maxlength\", ctx.maxlength)(\"autocomplete\", ctx.autocomplete)(\"autocapitalize\", ctx.autocapitalize)(\"autocorrect\", ctx.autocorrect)(\"spellcheck\", ctx.spellcheck)(\"autofocus\", ctx.autofocus)(\"step\", ctx.step)(\"pattern\", ctx.pattern)(\"required\", ctx.required)(\"accept\", ctx.accept)(\"multiple\", ctx.multiple);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.dropdown);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.error && ctx.errorMessage);\n      }\n    },\n    directives: [ɵngcc1.DefaultValueAccessor, ɵngcc1.NgControlStatus, ɵngcc1.NgModel, ɵngcc1.MinLengthValidator, ɵngcc1.MaxLengthValidator, ɵngcc1.PatternValidator, ɵngcc1.RequiredValidator, ɵngcc2.NgIf],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscInput;\n}(MbscInputBase);\n\nvar MbscInputModule = function () {\n  function MbscInputModule() {}\n\n  MbscInputModule.ɵfac = function MbscInputModule_Factory(t) {\n    return new (t || MbscInputModule)();\n  };\n\n  MbscInputModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscInputModule\n  });\n  MbscInputModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[FormsModule, CommonModule, MbscBaseModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscInputModule, {\n      declarations: function () {\n        return [MbscInput, MbscInputBase, MbscFormBase, MbscFormValueBase];\n      },\n      imports: function () {\n        return [FormsModule, CommonModule, MbscBaseModule];\n      },\n      exports: function () {\n        return [MbscInput];\n      }\n    });\n  })();\n\n  return MbscInputModule;\n}();\n\nfunction adjustedDate(y, m, d, h, i, s, u) {\n  var date = new Date(y, m, d, h || 0, i || 0, s || 0, u || 0);\n\n  if (date.getHours() == 23 && (h || 0) === 0) {\n    date.setHours(date.getHours() + 2);\n  }\n\n  return date;\n}\n/**\r\n * Format a date into a string value with a specified format.\r\n * @param {String} format Output format.\r\n * @param {Date} date Date to format.\r\n * @param {Object} [settings={}] Settings.\r\n * @return {String} Returns the formatted date string.\r\n */\n\n\nfunction formatDate(format, date, settings) {\n  if (!date) {\n    return null;\n  }\n\n  var s = extend$1({}, dateTimeDefaults, settings),\n      look = function look(m) {\n    // Check whether a format character is doubled\n    var n = 0;\n\n    while (i + 1 < format.length && format.charAt(i + 1) == m) {\n      n++;\n      i++;\n    }\n\n    return n;\n  },\n      f1 = function f1(m, val, len) {\n    // Format a number, with leading zero if necessary\n    var n = '' + val;\n\n    if (look(m)) {\n      while (n.length < len) {\n        n = '0' + n;\n      }\n    }\n\n    return n;\n  },\n      f2 = function f2(m, val, s, l) {\n    // Format a name, short or long as requested\n    return look(m) ? l[val] : s[val];\n  },\n      i,\n      year,\n      output = '',\n      literal = false;\n\n  for (i = 0; i < format.length; i++) {\n    if (literal) {\n      if (format.charAt(i) == \"'\" && !look(\"'\")) {\n        literal = false;\n      } else {\n        output += format.charAt(i);\n      }\n    } else {\n      switch (format.charAt(i)) {\n        case 'd':\n          output += f1('d', s.getDay(date), 2);\n          break;\n\n        case 'D':\n          output += f2('D', date.getDay(), s.dayNamesShort, s.dayNames);\n          break;\n\n        case 'o':\n          output += f1('o', (date.getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000, 3);\n          break;\n\n        case 'm':\n          output += f1('m', s.getMonth(date) + 1, 2);\n          break;\n\n        case 'M':\n          output += f2('M', s.getMonth(date), s.monthNamesShort, s.monthNames);\n          break;\n\n        case 'y':\n          year = s.getYear(date);\n          output += look('y') ? year : (year % 100 < 10 ? '0' : '') + year % 100; //output += (look('y') ? date.getFullYear() : (date.getYear() % 100 < 10 ? '0' : '') + date.getYear() % 100);\n\n          break;\n\n        case 'h':\n          var h = date.getHours();\n          output += f1('h', h > 12 ? h - 12 : h === 0 ? 12 : h, 2);\n          break;\n\n        case 'H':\n          output += f1('H', date.getHours(), 2);\n          break;\n\n        case 'i':\n          output += f1('i', date.getMinutes(), 2);\n          break;\n\n        case 's':\n          output += f1('s', date.getSeconds(), 2);\n          break;\n\n        case 'a':\n          output += date.getHours() > 11 ? s.pmText : s.amText;\n          break;\n\n        case 'A':\n          output += date.getHours() > 11 ? s.pmText.toUpperCase() : s.amText.toUpperCase();\n          break;\n\n        case \"'\":\n          if (look(\"'\")) {\n            output += \"'\";\n          } else {\n            literal = true;\n          }\n\n          break;\n\n        default:\n          output += format.charAt(i);\n      }\n    }\n  }\n\n  return output;\n} // --- TRIAL SERVER CODE END ---\n\n/**\r\n * Extract a date from a string value with a specified format.\r\n * @param {String} format Input format.\r\n * @param {String} value String to parse.\r\n * @param {Object} [settings={}] Settings.\r\n * @return {Date} Returns the extracted date.\r\n */\n\n\nfunction parseDate(format, value, settings) {\n  var s = extend$1({}, dateTimeDefaults, settings),\n      def = makeDate(s.defaultValue || new Date());\n\n  if (!format || !value) {\n    return def;\n  } // If already a date object\n\n\n  if (value.getTime) {\n    return value;\n  }\n\n  value = typeof value == 'object' ? value.toString() : value + '';\n\n  var shortYearCutoff = s.shortYearCutoff,\n      year = s.getYear(def),\n      month = s.getMonth(def) + 1,\n      day = s.getDay(def),\n      doy = -1,\n      hours = def.getHours(),\n      minutes = def.getMinutes(),\n      seconds = 0,\n      //def.getSeconds(),\n  ampm = -1,\n      literal = false,\n      // Check whether a format character is doubled\n  lookAhead = function lookAhead(match) {\n    var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) == match;\n\n    if (matches) {\n      iFormat++;\n    }\n\n    return matches;\n  },\n      getNumber = function getNumber(match) {\n    // Extract a number from the string value\n    lookAhead(match);\n    var size = match == '@' ? 14 : match == '!' ? 20 : match == 'y' ? 4 : match == 'o' ? 3 : 2,\n        digits = new RegExp('^\\\\d{1,' + size + '}'),\n        num = value.substr(iValue).match(digits);\n\n    if (!num) {\n      return 0;\n    }\n\n    iValue += num[0].length;\n    return parseInt(num[0], 10);\n  },\n      getName = function getName(match, s, l) {\n    // Extract a name from the string value and convert to an index\n    var names = lookAhead(match) ? l : s,\n        i;\n\n    for (i = 0; i < names.length; i++) {\n      if (value.substr(iValue, names[i].length).toLowerCase() == names[i].toLowerCase()) {\n        iValue += names[i].length;\n        return i + 1;\n      }\n    }\n\n    return 0;\n  },\n      checkLiteral = function checkLiteral() {\n    iValue++;\n  },\n      iValue = 0,\n      iFormat;\n\n  for (iFormat = 0; iFormat < format.length; iFormat++) {\n    if (literal) {\n      if (format.charAt(iFormat) == \"'\" && !lookAhead(\"'\")) {\n        literal = false;\n      } else {\n        checkLiteral();\n      }\n    } else {\n      switch (format.charAt(iFormat)) {\n        case 'd':\n          day = getNumber('d');\n          break;\n\n        case 'D':\n          getName('D', s.dayNamesShort, s.dayNames);\n          break;\n\n        case 'o':\n          doy = getNumber('o');\n          break;\n\n        case 'm':\n          month = getNumber('m');\n          break;\n\n        case 'M':\n          month = getName('M', s.monthNamesShort, s.monthNames);\n          break;\n\n        case 'y':\n          year = getNumber('y');\n          break;\n\n        case 'H':\n          hours = getNumber('H');\n          break;\n\n        case 'h':\n          hours = getNumber('h');\n          break;\n\n        case 'i':\n          minutes = getNumber('i');\n          break;\n\n        case 's':\n          seconds = getNumber('s');\n          break;\n\n        case 'a':\n          ampm = getName('a', [s.amText, s.pmText], [s.amText, s.pmText]) - 1;\n          break;\n\n        case 'A':\n          ampm = getName('A', [s.amText, s.pmText], [s.amText, s.pmText]) - 1;\n          break;\n\n        case \"'\":\n          if (lookAhead(\"'\")) {\n            checkLiteral();\n          } else {\n            literal = true;\n          }\n\n          break;\n\n        default:\n          checkLiteral();\n      }\n    }\n  }\n\n  if (year < 100) {\n    year += new Date().getFullYear() - new Date().getFullYear() % 100 + (year <= (typeof shortYearCutoff != 'string' ? shortYearCutoff : new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10)) ? 0 : -100);\n  }\n\n  if (doy > -1) {\n    month = 1;\n    day = doy;\n\n    do {\n      var dim = 32 - new Date(year, month - 1, 32, 12).getDate();\n\n      if (day > dim) {\n        month++;\n        day -= dim;\n      }\n    } while (day > dim);\n  }\n\n  hours = ampm == -1 ? hours : ampm && hours < 12 ? hours + 12 : !ampm && hours == 12 ? 0 : hours;\n  var date = s.getDate(year, month - 1, day, hours, minutes, seconds);\n\n  if (s.getYear(date) != year || s.getMonth(date) + 1 != month || s.getDay(date) != day) {\n    return def; // Invalid date\n  }\n\n  return date;\n}\n\nfunction getDayDiff(d1, d2) {\n  return Math.round((d2 - d1) / (24 * 60 * 60 * 1000));\n}\n\nfunction getDateOnly(d) {\n  return adjustedDate(d.getFullYear(), d.getMonth(), d.getDate());\n}\n\nfunction getDateStr(d) {\n  return d.getFullYear() + '-' + (d.getMonth() + 1) + '-' + d.getDate();\n}\n\nfunction getISOString(d, parts) {\n  var ret = '',\n      time = '';\n\n  if (d) {\n    if (parts.h) {\n      time += pad(d.getHours()) + ':' + pad(d.getMinutes());\n\n      if (parts.s) {\n        time += ':' + pad(d.getSeconds());\n      }\n\n      if (parts.u) {\n        time += '.' + pad(d.getMilliseconds(), 3);\n      }\n\n      if (parts.tz) {\n        time += parts.tz; // Just put what we got\n      }\n    }\n\n    if (parts.y) {\n      ret += d.getFullYear();\n\n      if (parts.m) {\n        ret += '-' + pad(d.getMonth() + 1);\n\n        if (parts.d) {\n          ret += '-' + pad(d.getDate());\n        }\n\n        if (parts.h) {\n          ret += 'T' + time;\n        }\n      }\n    } else if (parts.h) {\n      ret = time;\n    }\n  }\n\n  return ret;\n}\n\nfunction setISOParts(parsed, offset, parts) {\n  var part,\n      v,\n      p = {\n    y: 1,\n    m: 2,\n    d: 3,\n    h: 4,\n    i: 5,\n    s: 6,\n    u: 7,\n    tz: 8\n  };\n\n  if (parts) {\n    for (part in p) {\n      v = parsed[p[part] - offset];\n\n      if (v) {\n        parts[part] = part == 'tz' ? v : 1;\n      }\n    }\n  }\n}\n\nfunction returnDate(d, s, displayFormat) {\n  var moment = window.moment || s.moment,\n      format = s.returnFormat;\n\n  if (d) {\n    if (format == 'moment' && moment) {\n      return moment(d);\n    }\n\n    if (format == 'locale') {\n      return formatDate(displayFormat, d, s);\n    }\n\n    if (format == 'iso8601') {\n      return getISOString(d, s.isoParts);\n    }\n  }\n\n  return d;\n}\n\nfunction makeDate(d, format, s, parts) {\n  var parse;\n\n  if (!d) {\n    return null;\n  } // If already date object\n\n\n  if (d.getTime) {\n    return d;\n  } // Moment object\n\n\n  if (d.toDate) {\n    return d.toDate();\n  }\n\n  if (typeof d == 'string') {\n    d = d.trim();\n  }\n\n  parse = ISO_8601_TIME.exec(d); // If ISO 8601 time string\n\n  if (parse) {\n    setISOParts(parse, 2, parts);\n    return new Date(1970, 0, 1, parse[2] ? +parse[2] : 0, parse[3] ? +parse[3] : 0, parse[4] ? +parse[4] : 0, parse[5] ? +parse[5] : 0);\n  }\n\n  if (!parse) {\n    parse = ISO_8601_FULL.exec(d);\n  } // If ISO 8601 date string\n\n\n  if (parse) {\n    setISOParts(parse, 0, parts);\n    return new Date(parse[1] ? +parse[1] : 1970, parse[2] ? parse[2] - 1 : 0, parse[3] ? +parse[3] : 1, parse[4] ? +parse[4] : 0, parse[5] ? +parse[5] : 0, parse[6] ? +parse[6] : 0, parse[7] ? +parse[7] : 0);\n  } // Parse date based on format\n\n\n  return parseDate(format, d, s);\n}\n\nfunction isSameDay(d1, d2) {\n  return d1.getFullYear() == d2.getFullYear() && d1.getMonth() == d2.getMonth() && d1.getDate() == d2.getDate();\n}\n\nvar ISO_8601_FULL = /^(\\d{4}|[+-]\\d{6})(?:-(\\d{2})(?:-(\\d{2}))?)?(?:T(\\d{2}):(\\d{2})(?::(\\d{2})(?:\\.(\\d{3}))?)?((Z)|([+-])(\\d{2})(?::(\\d{2}))?)?)?$/;\nvar ISO_8601_TIME = /^((\\d{2}):(\\d{2})(?::(\\d{2})(?:\\.(\\d{3}))?)?(?:(Z)|([+-])(\\d{2})(?::(\\d{2}))?)?)?$/;\nvar DAY_OF_MONTH = /^\\d{1,2}(\\/\\d{1,2})?$/;\nvar DAY_OF_WEEK = /^w\\d$/i;\nvar dateTimeDefaults = {\n  shortYearCutoff: '+10',\n  monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n  monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n  dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n  dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n  dayNamesMin: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],\n  amText: 'am',\n  pmText: 'pm',\n  getYear: function getYear(d) {\n    return d.getFullYear();\n  },\n  getMonth: function getMonth(d) {\n    return d.getMonth();\n  },\n  getDay: function getDay(d) {\n    return d.getDate();\n  },\n  getDate: adjustedDate,\n  getMaxDayOfMonth: function getMaxDayOfMonth(y, m) {\n    return 32 - new Date(y, m, 32, 12).getDate();\n  },\n  getWeekNumber: function getWeekNumber(d) {\n    // Copy date so don't modify original\n    d = new Date(d);\n    d.setHours(0, 0, 0); // Set to nearest Thursday: current date + 4 - current day number\n    // Make Sunday's day number 7\n\n    d.setDate(d.getDate() + 4 - (d.getDay() || 7)); // Get first day of year\n\n    var yearStart = new Date(d.getFullYear(), 0, 1); // Calculate full weeks to nearest Thursday\n\n    return Math.ceil(((d - yearStart) / 86400000 + 1) / 7);\n  }\n};\nutil.datetime = {\n  formatDate: formatDate,\n  parseDate: parseDate\n};\n\nfunction createStepper($elm, action, delay, isReadOnly, stopProp, ripple) {\n  var $btn,\n      changed,\n      index,\n      running,\n      source,\n      startX,\n      startY,\n      step,\n      timer,\n      check = isReadOnly || noop;\n\n  function onBtnStart(ev) {\n    var proceed;\n    $btn = $$1(this);\n    step = +$btn.attr('data-step');\n    index = +$btn.attr('data-index');\n    changed = true;\n\n    if (stopProp) {\n      ev.stopPropagation();\n    }\n\n    if (ev.type == 'touchstart') {\n      $btn.closest('.mbsc-no-touch').removeClass('mbsc-no-touch');\n    }\n\n    if (ev.type == 'mousedown') {\n      // Prevent focus\n      ev.preventDefault();\n    }\n\n    if (ev.type != 'keydown') {\n      //e.preventDefault();\n      startX = getCoord(ev, 'X');\n      startY = getCoord(ev, 'Y');\n      proceed = testTouch(ev, this);\n    } else {\n      proceed = ev.keyCode === 32;\n    }\n\n    if (!running && proceed && !$btn.hasClass('mbsc-disabled')) {\n      if (start(index, step, ev)) {\n        $btn.addClass('mbsc-active');\n\n        if (ripple) {\n          ripple.addRipple($btn.find('.mbsc-segmented-content'), ev);\n        }\n      }\n\n      if (ev.type == 'mousedown') {\n        $$1(document).on('mousemove', onBtnMove).on('mouseup', onBtnEnd);\n      }\n    }\n  }\n\n  function onBtnMove(ev) {\n    if (Math.abs(startX - getCoord(ev, 'X')) > 7 || Math.abs(startY - getCoord(ev, 'Y')) > 7) {\n      changed = true;\n      stop();\n    }\n  }\n\n  function onBtnEnd(ev) {\n    if (ev.type == 'touchend') {\n      // Prevents iOS scroll on double tap\n      ev.preventDefault();\n    }\n\n    stop();\n\n    if (ev.type == 'mouseup') {\n      $$1(document).off('mousemove', onBtnMove).off('mouseup', onBtnEnd);\n    }\n  }\n\n  function stop() {\n    running = false;\n    clearInterval(timer);\n\n    if ($btn) {\n      $btn.removeClass('mbsc-active');\n\n      if (ripple) {\n        setTimeout(function () {\n          ripple.removeRipple();\n        }, 100);\n      }\n    }\n  }\n\n  function start(i, st, ev) {\n    if (!running && !check(i)) {\n      index = i;\n      step = st;\n      source = ev;\n      running = true;\n      changed = false;\n      setTimeout(tick, 100);\n    }\n\n    return running;\n  }\n\n  function tick() {\n    if ($btn && $btn.hasClass('mbsc-disabled')) {\n      stop();\n      return;\n    }\n\n    if (running || !changed) {\n      changed = true;\n      action(index, step, source, tick);\n    }\n\n    if (running && delay) {\n      clearInterval(timer);\n      timer = setInterval(function () {\n        action(index, step, source);\n      }, delay);\n    }\n  }\n\n  function destroy() {\n    $elm.each(function (i, el) {\n      unlisten(el, 'touchstart', onBtnStart, {\n        passive: true\n      });\n      unlisten(el, 'mousedown', onBtnStart);\n      unlisten(el, 'keydown', onBtnStart);\n      unlisten(el, 'touchmove', onBtnMove, {\n        passive: true\n      });\n      unlisten(el, 'touchend', onBtnEnd);\n      unlisten(el, 'touchcancel', onBtnEnd);\n      unlisten(el, 'keyup', onBtnEnd);\n    });\n  }\n\n  $elm.each(function (i, el) {\n    listen(el, 'touchstart', onBtnStart, {\n      passive: true\n    });\n    listen(el, 'mousedown', onBtnStart);\n    listen(el, 'keydown', onBtnStart);\n    listen(el, 'touchmove', onBtnMove, {\n      passive: true\n    });\n    listen(el, 'touchend', onBtnEnd);\n    listen(el, 'touchcancel', onBtnEnd);\n    listen(el, 'keyup', onBtnEnd);\n  });\n  return {\n    start: start,\n    stop: stop,\n    destroy: destroy\n  };\n}\n\nvar innerStyle = 'position:absolute;left:0;top:0;';\nvar style = innerStyle + 'right:0;bottom:0;overflow:hidden;z-index:-1;';\nvar markup = '<div style=\"' + style + '\"><div style=\"' + innerStyle + '\"></div></div>' + '<div style=\"' + style + '\"><div style=\"' + innerStyle + 'width:200%;height:200%;\"></div></div>';\nvar observer;\nvar count = 0;\n\nfunction resizeObserver(el, callback, zone) {\n  function reset() {\n    expandChild.style.width = '100000px';\n    expandChild.style.height = '100000px';\n    expand.scrollLeft = 100000;\n    expand.scrollTop = 100000;\n    shrink.scrollLeft = 100000;\n    shrink.scrollTop = 100000;\n  }\n\n  function checkHidden() {\n    var now = new Date();\n    hiddenRafId = 0;\n\n    if (!stopCheck) {\n      if (now - lastCheck > 200 && !expand.scrollTop && !expand.scrollLeft) {\n        lastCheck = now;\n        reset();\n      }\n\n      if (!hiddenRafId) {\n        hiddenRafId = raf(checkHidden);\n      }\n    }\n  }\n\n  function onScroll() {\n    if (!rafId) {\n      rafId = raf(onResize);\n    }\n  }\n\n  function onResize() {\n    rafId = 0;\n    reset();\n    callback();\n  }\n\n  var expand;\n  var expandChild;\n  var helper;\n  var hiddenRafId;\n  var rafId;\n  var shrink;\n  var stopCheck;\n  var lastCheck = 0; //let isHidden = true;\n\n  if (window.ResizeObserver) {\n    if (!observer) {\n      observer = new ResizeObserver(function (entries) {\n        for (var _iterator = entries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n          var _ref;\n\n          if (_isArray) {\n            if (_i >= _iterator.length) break;\n            _ref = _iterator[_i++];\n          } else {\n            _i = _iterator.next();\n            if (_i.done) break;\n            _ref = _i.value;\n          }\n\n          var entry = _ref;\n\n          entry.target.__mbscResize();\n        }\n      });\n    }\n\n    count++;\n    el.__mbscResize = callback;\n    observer.observe(el);\n  } else {\n    helper = document.createElement('div');\n    helper.innerHTML = markup;\n    helper.dir = 'ltr'; // Need this to work in rtl as well;\n\n    shrink = helper.childNodes[1];\n    expand = helper.childNodes[0];\n    expandChild = expand.childNodes[0];\n    el.appendChild(helper);\n    expand.addEventListener('scroll', onScroll);\n    shrink.addEventListener('scroll', onScroll);\n\n    if (zone) {\n      zone.runOutsideAngular(function () {\n        raf(checkHidden);\n      });\n    } else {\n      raf(checkHidden);\n    }\n  }\n\n  return {\n    detach: function detach() {\n      if (observer) {\n        count--;\n        observer.unobserve(el);\n\n        if (!count) {\n          observer = null;\n        }\n      } else {\n        el.removeChild(helper);\n        stopCheck = true;\n      }\n    }\n  };\n}\n\nvar $activeElm,\n    preventShow,\n    themes = mobiscroll.themes,\n    needsFixed = /(iphone|ipod)/i.test(userAgent) && majorVersion >= 7,\n    isAndroid = os == 'android',\n    isIOS = os == 'ios',\n    isIOS8 = isIOS && majorVersion == 8,\n    halfBorder = isIOS && majorVersion > 7,\n    prevdef = function prevdef(ev) {\n  ev.preventDefault();\n};\n\nvar EDITABLE = 'input,select,textarea,button';\nvar ALLOW_ENTER = 'textarea,button,input[type=\"button\"],input[type=\"submit\"]';\nvar FOCUSABLE = EDITABLE + ',[tabindex=\"0\"]';\n\nvar Frame = function Frame(el, settings, inherit) {\n  var //$ariaDiv,\n  $ctx,\n      $header,\n      $lock,\n      $markup,\n      $overlay,\n      $persp,\n      $popup,\n      $wnd,\n      $wrapper,\n      buttons,\n      btn,\n      ctx,\n      doAnim,\n      hasContext,\n      isModal,\n      isInserted,\n      isPointer,\n      markup,\n      modalWidth,\n      modalHeight,\n      needsDimensions,\n      needsLock,\n      observer,\n      overlay,\n      popup,\n      posDebounce,\n      prevInst,\n      s,\n      scrollLock,\n      touched,\n      trigger,\n      wndWidth,\n      wndHeight,\n      that = this,\n      $elm = $$1(el),\n      elmList = [],\n      lastFocus = new Date();\n\n  function onBtnStart(ev) {\n    // Need this to prevent opening of sidemenus or similar\n    if (s.stopProp) {\n      ev.stopPropagation();\n    }\n\n    var b = closest(this, ev.target, '.mbsc-fr-btn-e');\n\n    if (!b) {\n      return;\n    } // Can't call preventDefault here, it kills page scroll\n\n\n    if (btn) {\n      btn.removeClass('mbsc-active');\n    }\n\n    btn = $$1(b); // Active button\n\n    if (!btn.hasClass('mbsc-disabled') && !btn.hasClass('mbsc-fr-btn-nhl')) {\n      btn.addClass('mbsc-active');\n    }\n\n    if (ev.type === 'mousedown') {\n      $$1(document).on('mouseup', onBtnEnd);\n    }\n  }\n\n  function onBtnEnd(ev) {\n    if (btn) {\n      btn.removeClass('mbsc-active');\n      btn = null;\n    }\n\n    if (ev.type === 'mouseup') {\n      $$1(document).off('mouseup', onBtnEnd);\n    }\n  }\n\n  function onScroll(ev) {\n    if (scrollLock && markup.contains(ev.target)) {\n      ev.preventDefault();\n    }\n  }\n\n  function onWndKeyDown(ev) {\n    if (mobiscroll.activeInstance == that) {\n      if (ev.keyCode == 13 && (!$$1(ev.target).is(ALLOW_ENTER) || ev.shiftKey)) {\n        that.select();\n      } else if (ev.keyCode == 27) {\n        that.cancel();\n      }\n    }\n  }\n\n  function onShow(prevFocus) {\n    if (!prevFocus && !isAndroid && that._activeElm) {\n      //overlay.focus();\n      lastFocus = new Date();\n\n      that._activeElm.focus();\n    } //that.ariaMessage(s.ariaMessage);\n\n  }\n\n  function onHide(prevAnim) {\n    var $activeEl = $activeElm,\n        focus = s.focusOnClose;\n\n    that._markupRemove();\n\n    $markup.remove();\n\n    if (isModal) {\n      ctx.mbscModals--;\n\n      if (s.scrollLock) {\n        ctx.mbscLock--;\n      }\n\n      if (!ctx.mbscLock) {\n        $lock.removeClass('mbsc-fr-lock');\n      }\n\n      if (needsLock) {\n        ctx.mbscIOSLock--;\n\n        if (!ctx.mbscIOSLock) {\n          $lock.removeClass('mbsc-fr-lock-ios');\n          $ctx.css({\n            top: '',\n            left: ''\n          });\n          $wnd.scrollLeft(ctx.mbscScrollLeft);\n          $wnd.scrollTop(ctx.mbscScrollTop);\n        }\n      } // The follwing should be done only if no other\n      // instance was opened during the hide animation\n\n\n      if (!ctx.mbscModals) {\n        $lock.removeClass('mbsc-fr-lock-ctx');\n      }\n\n      if (!ctx.mbscModals || prevInst) {\n        // Put focus back to the last active element\n        if (!prevAnim) {\n          if (!$activeEl) {\n            $activeEl = $elm;\n          }\n\n          setTimeout(function () {\n            if (focus === undefined || focus === true) {\n              preventShow = true;\n              $activeEl[0].focus();\n            } else if (focus) {\n              $$1(focus)[0].focus();\n            }\n          }, 200);\n        }\n      }\n    }\n\n    prevInst = undefined;\n    isInserted = false;\n    trigger('onHide');\n  }\n\n  function onPosition() {\n    clearTimeout(posDebounce);\n    posDebounce = setTimeout(function () {\n      if (that.position(true)) {\n        // Trigger reflow, needed on iOS safari, when orientation is changed\n        popup.style.visibility = 'hidden';\n        popup.offsetHeight;\n        popup.style.visibility = '';\n      }\n    }, 200);\n  }\n\n  function onFocus(ev) {\n    if (mobiscroll.activeInstance == that && ev.target.nodeType && !overlay.contains(ev.target) && new Date() - lastFocus > 100) {\n      lastFocus = new Date();\n\n      that._activeElm.focus();\n    }\n  }\n\n  function insertMarkup(prevAnim, prevFocus) {\n    function onAnimEnd() {\n      $markup.off(animEnd, onAnimEnd).removeClass('mbsc-anim-in mbsc-anim-trans mbsc-anim-trans-' + doAnim).find('.mbsc-fr-popup').removeClass('mbsc-anim-' + doAnim);\n      onShow(prevFocus);\n    }\n\n    function onOverlayStart(ev) {\n      if (!target && ev.target == overlay) {\n        target = true;\n        moved = false;\n        startX = getCoord(ev, 'X');\n        startY = getCoord(ev, 'Y');\n      }\n    }\n\n    function onOverlayMove(ev) {\n      if (target && !moved && (Math.abs(getCoord(ev, 'X') - startX) > 9 || Math.abs(getCoord(ev, 'Y') - startY) > 9)) {\n        moved = true;\n      }\n    } // Might be not visible if immediately hidden\n\n\n    if (!that._isVisible) {\n      return;\n    } // Show\n\n\n    if (isModal) {\n      $markup.appendTo($ctx);\n    } else if ($elm.is('div') && !that._hasContent) {\n      // Insert inside the element on which was initialized\n      $elm.empty().append($markup);\n    } else {\n      // Insert after the element\n      if ($elm.hasClass('mbsc-control')) {\n        var $wrap = $elm.closest('.mbsc-control-w');\n        $markup.insertAfter($wrap);\n\n        if ($wrap.hasClass('mbsc-select')) {\n          $wrap.addClass('mbsc-select-inline');\n        }\n      } else {\n        $markup.insertAfter($elm);\n      }\n    }\n\n    isInserted = true;\n\n    that._markupInserted($markup);\n\n    trigger('onMarkupInserted', {\n      target: markup\n    });\n\n    if (isModal && s.closeOnOverlayTap) {\n      var moved, target, startX, startY;\n      listen(overlay, 'touchstart', onOverlayStart, {\n        passive: true\n      });\n      listen(overlay, 'touchmove', onOverlayMove, {\n        passive: true\n      });\n      $overlay.on('mousedown', onOverlayStart).on('mousemove', onOverlayMove).on('touchcancel', function () {\n        target = false;\n      }).on('touchend click', function (ev) {\n        if (target && !moved) {\n          that.cancel();\n\n          if (ev.type == 'touchend') {\n            preventClick();\n          }\n        }\n\n        target = false;\n      });\n    }\n\n    $markup.on('mousedown', '.mbsc-btn-e,.mbsc-fr-btn-e', prevdef).on('keydown', '.mbsc-fr-btn-e', function (ev) {\n      if (ev.keyCode == 32) {\n        // Space\n        ev.preventDefault();\n        ev.stopPropagation();\n        this.click();\n      }\n    }).on('keydown', function (ev) {\n      // Trap focus inside modal\n      if (ev.keyCode == 32 && !$$1(ev.target).is(EDITABLE)) {\n        // Prevent page scroll on space press\n        ev.preventDefault();\n      } else if (ev.keyCode == 9 && isModal && s.focusTrap) {\n        // Tab\n        var $focusable = $markup.find(FOCUSABLE).filter(function () {\n          return this.offsetWidth > 0 || this.offsetHeight > 0;\n        }),\n            index = $focusable.index($$1(':focus', $markup)),\n            i = $focusable.length - 1,\n            target = 0;\n\n        if (ev.shiftKey) {\n          i = 0;\n          target = -1;\n        }\n\n        if (index === i) {\n          $focusable.eq(target)[0].focus();\n          ev.preventDefault();\n        }\n      }\n    }).on('touchend', '.mbsc-fr-btn-e', onBtnEnd);\n    listen(markup, 'touchstart', onBtnStart, {\n      passive: true\n    });\n    listen(markup, 'mousedown', onBtnStart); // Need event capture for this\n\n    listen(markup, 'touchstart', function () {\n      if (!touched) {\n        touched = true;\n        $ctx.find('.mbsc-no-touch').removeClass('mbsc-no-touch');\n      }\n    }, {\n      passive: true,\n      capture: true\n    }); // Init buttons\n\n    $$1.each(buttons, function (i, b) {\n      that.tap($$1('.mbsc-fr-btn' + i, $markup), function (ev) {\n        b = isString(b) ? that.buttons[b] : b;\n        (isString(b.handler) ? that.handlers[b.handler] : b.handler).call(this, ev, that);\n      }, true);\n    });\n\n    that._attachEvents($markup); // Set position\n\n\n    if (that.position() === false) {\n      return;\n    }\n\n    if (isModal || that._checkSize) {\n      observer = resizeObserver(markup, onPosition, s.zone);\n    }\n\n    if (isModal) {\n      $markup.removeClass('mbsc-fr-pos');\n\n      if (doAnim && !prevAnim) {\n        $markup.addClass('mbsc-anim-in mbsc-anim-trans mbsc-anim-trans-' + doAnim).on(animEnd, onAnimEnd).find('.mbsc-fr-popup').addClass('mbsc-anim-' + doAnim);\n      } else {\n        onShow(prevFocus);\n      }\n    }\n\n    trigger('onShow', {\n      target: markup,\n      valueText: that._tempValue\n    });\n  }\n\n  function show(beforeShow, $elm) {\n    if (that._isVisible) {\n      return;\n    }\n\n    if (beforeShow) {\n      beforeShow();\n    }\n\n    if (that.show() !== false) {\n      $activeElm = $elm;\n    }\n  }\n\n  function set() {\n    that._fillValue();\n\n    trigger('onSet', {\n      valueText: that._value\n    });\n  }\n\n  function cancel() {\n    trigger('onCancel', {\n      valueText: that._value\n    });\n  }\n\n  function clear() {\n    that.setVal(null, true);\n  } // Call the parent constructor\n\n\n  Base.call(this, el, settings, true);\n  /**\r\n   * Positions the scroller on the screen.\r\n   */\n\n  that.position = function (check) {\n    var anchor,\n        anchorWidth,\n        anchorHeight,\n        anchorPos,\n        anchorTop,\n        anchorLeft,\n        arrow,\n        arrowWidth,\n        arrowHeight,\n        docHeight,\n        docWidth,\n        isWrapped,\n        newHeight,\n        newWidth,\n        oldHeight,\n        oldWidth,\n        width,\n        top,\n        left,\n        css = {},\n        scrollLeft = 0,\n        scrollTop = 0,\n        minWidth = 0,\n        totalWidth = 0;\n\n    if (!isInserted) {\n      return false;\n    }\n\n    oldWidth = wndWidth;\n    oldHeight = wndHeight;\n    newHeight = Math.min(markup.offsetHeight, hasContext ? Infinity : window.innerHeight);\n    newWidth = Math.min(markup.offsetWidth, hasContext ? Infinity : window.innerWidth);\n\n    if (!newWidth || !newHeight || wndWidth === newWidth && wndHeight === newHeight && check) {\n      return;\n    }\n\n    if (that._checkResp(newWidth)) {\n      return false;\n    }\n\n    wndWidth = newWidth;\n    wndHeight = newHeight;\n\n    if (that._isFullScreen || /top|bottom/.test(s.display)) {\n      // Set width, if document is larger than viewport, needs to be set before onPosition (for calendar)\n      $popup.width(newWidth);\n    } else if (isModal) {\n      // Reset width\n      $wrapper.width('');\n    }\n\n    that._position($markup); // Call position for nested mobiscroll components\n    // $('.mbsc-comp', $markup).each(function () {\n    //     var inst = instances[this.id];\n    //     if (inst && inst !== that && inst.position) {\n    //         inst.position();\n    //     }\n    // });\n\n\n    if (!that._isFullScreen && /center|bubble/.test(s.display)) {\n      $$1('.mbsc-w-p', $markup).each(function () {\n        // Need fractional values here, so offsetWidth is not ok\n        width = this.getBoundingClientRect().width;\n        totalWidth += width;\n        minWidth = width > minWidth ? width : minWidth;\n      });\n      isWrapped = totalWidth > newWidth - 16 || s.tabs === true;\n      $wrapper.css({\n        'width': that._isLiquid ? Math.min(s.maxPopupWidth, newWidth - 16) : Math.ceil(isWrapped ? minWidth : totalWidth),\n        'white-space': isWrapped ? '' : 'nowrap'\n      });\n    }\n\n    if (trigger('onPosition', {\n      target: markup,\n      popup: popup,\n      hasTabs: isWrapped,\n      oldWidth: oldWidth,\n      oldHeight: oldHeight,\n      windowWidth: newWidth,\n      windowHeight: newHeight\n    }) === false || !isModal) {\n      return;\n    }\n\n    if (needsDimensions) {\n      scrollLeft = $wnd.scrollLeft();\n      scrollTop = $wnd.scrollTop();\n\n      if (wndWidth) {\n        $persp.css({\n          width: '',\n          height: ''\n        });\n      }\n    }\n\n    modalWidth = popup.offsetWidth;\n    modalHeight = popup.offsetHeight;\n    scrollLock = modalHeight <= newHeight && modalWidth <= newWidth;\n\n    if (s.display == 'center') {\n      left = Math.max(0, scrollLeft + (newWidth - modalWidth) / 2);\n      top = Math.max(0, scrollTop + (newHeight - modalHeight) / 2);\n    } else if (s.display == 'bubble') {\n      anchor = s.anchor === undefined ? $elm : $$1(s.anchor);\n      arrow = $$1('.mbsc-fr-arr-i', $markup)[0];\n      anchorPos = anchor.offset();\n      anchorTop = anchorPos.top + (hasContext ? scrollTop - $ctx.offset().top : 0);\n      anchorLeft = anchorPos.left + (hasContext ? scrollLeft - $ctx.offset().left : 0);\n      anchorWidth = anchor[0].offsetWidth;\n      anchorHeight = anchor[0].offsetHeight;\n      arrowWidth = arrow.offsetWidth;\n      arrowHeight = arrow.offsetHeight; // Horizontal positioning\n\n      left = constrain(anchorLeft - (modalWidth - anchorWidth) / 2, scrollLeft + 3, scrollLeft + newWidth - modalWidth - 3); // Vertical positioning\n      // Below the input\n\n      top = anchorTop + anchorHeight + arrowHeight / 2;\n\n      if (top + modalHeight + 8 > scrollTop + newHeight && anchorTop - modalHeight - arrowHeight / 2 > scrollTop) {\n        $popup.removeClass('mbsc-fr-bubble-bottom').addClass('mbsc-fr-bubble-top'); // Above the input\n\n        top = anchorTop - modalHeight - arrowHeight / 2;\n      } else {\n        $popup.removeClass('mbsc-fr-bubble-top').addClass('mbsc-fr-bubble-bottom');\n      } // Set arrow position\n\n\n      $$1('.mbsc-fr-arr', $markup).css({\n        left: constrain(anchorLeft + anchorWidth / 2 - (left + (modalWidth - arrowWidth) / 2), 0, arrowWidth)\n      }); // Lock scroll only if popup is entirely in the viewport\n\n      scrollLock = top > scrollTop && left > scrollLeft && top + modalHeight <= scrollTop + newHeight && left + modalWidth <= scrollLeft + newWidth;\n    } else {\n      left = scrollLeft;\n      top = s.display == 'top' ? scrollTop : Math.max(0, scrollTop + newHeight - modalHeight);\n    }\n\n    if (needsDimensions) {\n      // If top + modal height > doc height, increase doc height\n      docHeight = Math.max(top + modalHeight, hasContext ? ctx.scrollHeight : $$1(document).height());\n      docWidth = Math.max(left + modalWidth, hasContext ? ctx.scrollWidth : $$1(document).width());\n      $persp.css({\n        width: docWidth,\n        height: docHeight\n      }); // Check if scroll needed\n\n      if (s.scroll && s.display == 'bubble' && (top + modalHeight + 8 > scrollTop + newHeight || anchorTop > scrollTop + newHeight || anchorTop + anchorHeight < scrollTop)) {\n        $wnd.scrollTop(Math.min(anchorTop, top + modalHeight - newHeight + 8, docHeight - newHeight));\n      }\n    }\n\n    css.top = Math.floor(top);\n    css.left = Math.floor(left);\n    $popup.css(css);\n    return true;\n  };\n  /**\r\n   * Show mobiscroll on focus and click event of the parameter.\r\n   * @param {HTMLElement} elm - Events will be attached to this element.\r\n   * @param {Function} [beforeShow=undefined] - Optional function to execute before showing mobiscroll.\r\n   */\n\n\n  that.attachShow = function (elm, beforeShow) {\n    var $label,\n        $elm = $$1(elm).off('.mbsc'),\n        readOnly = $elm.prop('readonly');\n    tapOff($elm);\n\n    if (s.display !== 'inline') {\n      if ((s.showOnFocus || s.showOnTap) && $elm.is('input,select')) {\n        $elm.prop('readonly', true).on('mousedown.mbsc', function (ev) {\n          // Prevent input to get focus on tap (virtual keyboard pops up on some devices)\n          ev.preventDefault();\n        }).on('focus.mbsc', function () {\n          if (that._isVisible) {\n            // Don't allow input focus if mobiscroll is being opened\n            this.blur();\n          }\n        });\n        $label = $$1('label[for=\"' + $elm.attr('id') + '\"]');\n\n        if (!$label.length) {\n          $label = $elm.closest('label');\n        }\n      }\n\n      if (!$elm.is('select')) {\n        if (s.showOnFocus) {\n          $elm.on('focus.mbsc', function () {\n            if (!preventShow) {\n              show(beforeShow, $elm);\n            } else {\n              preventShow = false;\n            }\n          });\n        }\n\n        if (s.showOnTap) {\n          $elm.on('keydown.mbsc', function (ev) {\n            if (ev.keyCode == 32 || ev.keyCode == 13) {\n              // Space or Enter\n              ev.preventDefault();\n              ev.stopPropagation();\n              show(beforeShow, $elm);\n            }\n          });\n          that.tap($elm, function (ev) {\n            if (ev.isMbscTap) {\n              touched = true;\n            }\n\n            show(beforeShow, $elm);\n          });\n\n          if ($label && $label.length) {\n            that.tap($label, function (ev) {\n              ev.preventDefault();\n\n              if (ev.target !== $elm[0]) {\n                show(beforeShow, $elm);\n              }\n            });\n          }\n        }\n      }\n\n      elmList.push({\n        readOnly: readOnly,\n        el: $elm,\n        lbl: $label\n      });\n    }\n  };\n  /**\r\n   * Set button handler.\r\n   */\n\n\n  that.select = function () {\n    if (isModal) {\n      that.hide(false, 'set', false, set);\n    } else {\n      set();\n    }\n  };\n  /**\r\n   * Cancel and hide the scroller instance.\r\n   */\n\n\n  that.cancel = function () {\n    if (isModal) {\n      that.hide(false, 'cancel', false, cancel);\n    } else {\n      cancel();\n    }\n  };\n  /**\r\n   * Clear button handler.\r\n   */\n\n\n  that.clear = function () {\n    that._clearValue();\n\n    trigger('onClear');\n\n    if (isModal && that._isVisible && !that.live) {\n      that.hide(false, 'clear', false, clear);\n    } else {\n      clear();\n    }\n  };\n  /**\r\n   * Enables the scroller and the associated input.\r\n   */\n\n\n  that.enable = function () {\n    s.disabled = false;\n    $$1.each(elmList, function (i, v) {\n      if (v.el.is('input,select')) {\n        v.el[0].disabled = false;\n      }\n    });\n  };\n  /**\r\n   * Disables the scroller and the associated input.\r\n   */\n\n\n  that.disable = function () {\n    s.disabled = true;\n    $$1.each(elmList, function (i, v) {\n      if (v.el.is('input,select')) {\n        v.el[0].disabled = true;\n      }\n    });\n  };\n  /**\r\n   * Shows the scroller instance.\r\n   * @param {Boolean} prevAnim - Prevent animation if true\r\n   * @param {Boolean} prevFocus - Prevent focusing if true\r\n   */\n\n\n  that.show = function (prevAnim, prevFocus) {\n    var hasButtons, html, scrollLeft, scrollTop;\n\n    if (s.disabled || that._isVisible) {\n      return;\n    } // Parse value from input\n\n\n    that._readValue();\n\n    if (trigger('onBeforeShow') === false) {\n      return false;\n    }\n\n    $activeElm = null;\n    doAnim = s.animate;\n    buttons = s.buttons || [];\n    needsDimensions = hasContext || s.display == 'bubble';\n    needsLock = needsFixed && !needsDimensions && s.scrollLock;\n    hasButtons = buttons.length > 0; //touched = false;\n\n    if (doAnim !== false) {\n      if (s.display == 'top') {\n        doAnim = doAnim || 'slidedown';\n      } else if (s.display == 'bottom') {\n        doAnim = doAnim || 'slideup';\n      } else if (s.display == 'center' || s.display == 'bubble') {\n        doAnim = doAnim || 'pop';\n      }\n    }\n\n    if (isModal) {\n      wndWidth = 0;\n      wndHeight = 0;\n\n      if (needsLock && !$lock.hasClass('mbsc-fr-lock-ios')) {\n        //$lock.scrollTop(0);\n        ctx.mbscScrollTop = scrollTop = Math.max(0, $wnd.scrollTop());\n        ctx.mbscScrollLeft = scrollLeft = Math.max(0, $wnd.scrollLeft());\n        $ctx.css({\n          top: -scrollTop + 'px',\n          left: -scrollLeft + 'px'\n        });\n      }\n\n      $lock.addClass((s.scrollLock ? 'mbsc-fr-lock' : '') + (needsLock ? ' mbsc-fr-lock-ios' : '') + (hasContext ? ' mbsc-fr-lock-ctx' : '')); // Hide virtual keyboard\n\n      if ($$1(document.activeElement).is('input,textarea')) {\n        document.activeElement.blur();\n      } // Save active instance to previous\n\n\n      prevInst = mobiscroll.activeInstance; // Set active instance\n\n      mobiscroll.activeInstance = that; // Keep track of modals opened per context\n\n      ctx.mbscModals = (ctx.mbscModals || 0) + 1;\n\n      if (needsLock) {\n        ctx.mbscIOSLock = (ctx.mbscIOSLock || 0) + 1;\n      }\n\n      if (s.scrollLock) {\n        ctx.mbscLock = (ctx.mbscLock || 0) + 1;\n      }\n    } // Create wheels containers\n\n\n    html = '<div lang=\"' + s.lang + '\" class=\"mbsc-fr mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + ' mbsc-fr-' + s.display + ' ' + (s.cssClass || '') + ' ' + (s.compClass || '') + (that._isLiquid ? ' mbsc-fr-liq' : '') + (isModal ? ' mbsc-fr-pos' + (s.showOverlay ? '' : ' mbsc-fr-no-overlay') : '') + (isPointer ? ' mbsc-fr-pointer' : '') + (halfBorder ? ' mbsc-fr-hb' : '') + (touched ? '' : ' mbsc-no-touch') + (needsLock ? ' mbsc-platform-ios' : '') + (hasButtons ? buttons.length >= 3 ? ' mbsc-fr-btn-block ' : '' : ' mbsc-fr-nobtn') + '\">' + (isModal ? '<div class=\"mbsc-fr-persp\">' + (s.showOverlay ? '<div class=\"mbsc-fr-overlay\"></div>' : '') + // Overlay\n    '<div role=\"dialog\" class=\"mbsc-fr-scroll\">' : '') + '<div class=\"mbsc-fr-popup' + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr') + (s.headerText ? ' mbsc-fr-has-hdr' : '') + '\">' + ( // Popup\n    s.display === 'bubble' ? '<div class=\"mbsc-fr-arr-w\"><div class=\"mbsc-fr-arr-i\"><div class=\"mbsc-fr-arr\"></div></div></div>' : '') + ( // Bubble arrow\n    isModal ? '<div class=\"mbsc-fr-focus\" tabindex=\"-1\"></div>' : '') + '<div class=\"mbsc-fr-w\">' + ( // Popup content\n    //'<div aria-live=\"assertive\" class=\"mbsc-fr-aria mbsc-fr-hdn\"></div>' +\n    s.headerText ? '<div class=\"mbsc-fr-hdr\">' + (isString(s.headerText) ? s.headerText : '') + '</div>' : '') + // Header\n    '<div class=\"mbsc-fr-c\">'; // Wheel group container\n\n    html += that._generateContent();\n    html += '</div>';\n\n    if (hasButtons) {\n      var b,\n          i,\n          j,\n          l = buttons.length;\n      html += '<div class=\"mbsc-fr-btn-cont\">';\n\n      for (i = 0; i < buttons.length; i++) {\n        j = s.btnReverse ? l - i - 1 : i;\n        b = buttons[j];\n        b = isString(b) ? that.buttons[b] : b;\n\n        if (b.handler === 'set') {\n          b.parentClass = 'mbsc-fr-btn-s';\n        }\n\n        if (b.handler === 'cancel') {\n          b.parentClass = 'mbsc-fr-btn-c';\n        }\n\n        html += '<div' + (s.btnWidth ? ' style=\"width:' + 100 / buttons.length + '%\"' : '') + ' class=\"mbsc-fr-btn-w ' + (b.parentClass || '') + '\">' + '<div tabindex=\"0\" role=\"button\" class=\"mbsc-fr-btn' + j + ' mbsc-fr-btn-e ' + (b.cssClass === undefined ? s.btnClass : b.cssClass) + (b.icon ? ' mbsc-ic mbsc-ic-' + b.icon : '') + '\">' + (b.text || '') + '</div></div>';\n      }\n\n      html += '</div>';\n    }\n\n    html += '</div></div></div></div>' + (isModal ? '</div></div>' : '');\n    $markup = $$1(html);\n    $persp = $$1('.mbsc-fr-persp', $markup);\n    $overlay = $$1('.mbsc-fr-scroll', $markup);\n    $wrapper = $$1('.mbsc-fr-w', $markup);\n    $popup = $$1('.mbsc-fr-popup', $markup);\n    $header = $$1('.mbsc-fr-hdr', $markup); //$ariaDiv = $('.mbsc-fr-aria', $markup);\n\n    markup = $markup[0];\n    overlay = $overlay[0];\n    popup = $popup[0];\n    that._activeElm = $$1('.mbsc-fr-focus', $markup)[0];\n    that._markup = $markup;\n    that._isVisible = true;\n    that.markup = markup;\n\n    that._markupReady($markup);\n\n    trigger('onMarkupReady', {\n      target: markup\n    }); // Attach events\n\n    if (isModal) {\n      // Enter / ESC\n      $$1(window).on('keydown', onWndKeyDown); // Prevent scroll if not specified otherwise\n\n      if (s.scrollLock) {\n        listen(document, 'touchmove', onScroll, {\n          passive: false\n        });\n        listen(document, 'mousewheel', onScroll, {\n          passive: false\n        });\n        listen(document, 'wheel', onScroll, {\n          passive: false\n        });\n      }\n\n      if (s.focusTrap) {\n        $wnd.on('focusin', onFocus);\n      }\n    }\n\n    if (isModal) {\n      // Wait for the toolbar and addressbar to appear on iOS\n      setTimeout(function () {\n        insertMarkup(prevAnim, prevFocus);\n      }, needsLock ? 100 : 0);\n    } else {\n      insertMarkup(prevAnim, prevFocus);\n    }\n  };\n  /**\r\n   * Hides the scroller instance.\r\n   */\n\n\n  that.hide = function (prevAnim, btn, force, callback) {\n    function onAnimEnd() {\n      $markup.off(animEnd, onAnimEnd);\n      onHide(prevAnim);\n    } // If onClose handler returns false, prevent hide\n\n\n    if (!that._isVisible || !force && !that._isValid && btn == 'set' || !force && trigger('onBeforeClose', {\n      valueText: that._tempValue,\n      button: btn\n    }) === false) {\n      return false;\n    }\n\n    that._isVisible = false;\n\n    if (observer) {\n      observer.detach();\n      observer = null;\n    }\n\n    if (isModal) {\n      if ($$1(document.activeElement).is('input,textarea') && popup.contains(document.activeElement)) {\n        document.activeElement.blur();\n      }\n\n      if (mobiscroll.activeInstance == that) {\n        mobiscroll.activeInstance = prevInst;\n      }\n\n      $$1(window).off('keydown', onWndKeyDown);\n      $wnd.off('focusin', onFocus);\n      unlisten(document, 'touchmove', onScroll, {\n        passive: false\n      });\n      unlisten(document, 'mousewheel', onScroll, {\n        passive: false\n      });\n      unlisten(document, 'wheel', onScroll, {\n        passive: false\n      });\n    } // Hide wheels and overlay\n\n\n    if ($markup) {\n      if (isModal && doAnim && !prevAnim) {\n        $markup.addClass('mbsc-anim-out mbsc-anim-trans mbsc-anim-trans-' + doAnim).on(animEnd, onAnimEnd).find('.mbsc-fr-popup').addClass('mbsc-anim-' + doAnim);\n      } else {\n        onHide(prevAnim);\n      }\n\n      that._detachEvents($markup);\n    }\n\n    if (callback) {\n      callback();\n    } // For validation\n\n\n    $elm.trigger('blur');\n    trigger('onClose', {\n      valueText: that._value\n    });\n  }; // that.ariaMessage = function (txt) {\n  //     $ariaDiv.html('');\n  //     setTimeout(function () {\n  //         $ariaDiv.html(txt);\n  //     }, 100);\n  // };\n\n  /**\r\n   * Return true if the scroller is currently visible.\r\n   */\n\n\n  that.isVisible = function () {\n    return that._isVisible;\n  }; // Protected functions to override\n\n\n  that.setVal = noop;\n  that.getVal = noop;\n  that._generateContent = noop;\n  that._attachEvents = noop;\n  that._detachEvents = noop;\n  that._readValue = noop;\n  that._clearValue = noop;\n  that._fillValue = noop;\n  that._markupReady = noop;\n  that._markupInserted = noop;\n  that._markupRemove = noop;\n  that._position = noop;\n  that.__processSettings = noop;\n  that.__init = noop;\n  that.__destroy = noop; // Generic frame functions\n\n  /**\r\n   * Destroys the mobiscroll instance.\r\n   */\n\n  that._destroy = function () {\n    // Force hide without animation\n    that.hide(true, false, true);\n    $elm.off('.mbsc');\n    tapOff($elm); // Remove all events from elements\n\n    $$1.each(elmList, function (i, v) {\n      v.el.off('.mbsc').prop('readonly', v.readOnly);\n      tapOff(v.el);\n\n      if (v.lbl) {\n        v.lbl.off('.mbsc');\n        tapOff(v.lbl);\n      }\n    });\n\n    that.__destroy();\n  };\n\n  that._updateHeader = function () {\n    var t = s.headerText,\n        txt = t ? typeof t === 'function' ? t.call(el, that._tempValue) : t.replace(/\\{value\\}/i, that._tempValue) : '';\n    $header.html(txt || '&nbsp;');\n  };\n\n  that._getRespCont = function () {\n    hasContext = s.context != 'body';\n    $wnd = $$1(hasContext ? s.context : window);\n    return s.display == 'inline' ? $elm.is('div') ? $elm : $elm.parent() : $wnd;\n  };\n\n  that._processSettings = function (resp) {\n    var b, i;\n\n    that.__processSettings(resp);\n\n    isPointer = !s.touchUi;\n\n    if (isPointer) {\n      s.display = resp.display || settings.display || 'bubble';\n      s.buttons = resp.buttons || settings.buttons || [];\n      s.showOverlay = resp.showOverlay || settings.showOverlay || false;\n    } // Add default buttons\n\n\n    s.buttons = s.buttons || (s.display !== 'inline' ? ['cancel', 'set'] : []); // Hide header text in inline mode by default\n\n    s.headerText = s.headerText === undefined ? s.display !== 'inline' ? '{value}' : false : s.headerText;\n    buttons = s.buttons || [];\n    isModal = s.display !== 'inline';\n    $ctx = $$1(s.context);\n    $lock = hasContext ? $ctx : $$1('body,html');\n    ctx = $ctx[0];\n    that.live = true; // If no set button is found, live mode is activated\n\n    for (i = 0; i < buttons.length; i++) {\n      b = buttons[i];\n\n      if (b == 'ok' || b == 'set' || b.handler == 'set') {\n        that.live = false;\n      }\n    }\n\n    that.buttons.set = {\n      text: s.setText,\n      icon: s.setIcon,\n      handler: 'set'\n    };\n    that.buttons.cancel = {\n      text: s.cancelText,\n      icon: s.cancelIcon,\n      handler: 'cancel'\n    };\n    that.buttons.close = {\n      text: s.closeText,\n      icon: s.closeIcon,\n      handler: 'cancel'\n    };\n    that.buttons.clear = {\n      text: s.clearText,\n      icon: s.clearIcon,\n      handler: 'clear'\n    };\n    that._isInput = $elm.is('input');\n  };\n  /**\r\n   * Scroller initialization.\r\n   */\n\n\n  that._init = function (newSettings) {\n    var wasVisible = that._isVisible,\n        wasReady = wasVisible && !$markup.hasClass('mbsc-fr-pos');\n\n    if (wasVisible) {\n      that.hide(true, false, true);\n    } // Unbind all events (if re-init)\n\n\n    $elm.off('.mbsc');\n    tapOff($elm);\n\n    that.__init(newSettings);\n\n    that._isLiquid = s.layout == 'liquid';\n\n    if (isModal) {\n      that._readValue();\n\n      if (!that._hasContent && !s.skipShow) {\n        that.attachShow($elm);\n      }\n\n      if (wasVisible) {\n        that.show(wasReady);\n      }\n    } else {\n      that.show();\n    }\n\n    $elm.removeClass('mbsc-cloak').filter('input, select, textarea').on('change.mbsc', function () {\n      if (!that._preventChange) {\n        that.setVal($elm.val(), true, false);\n      }\n\n      that._preventChange = false;\n    });\n  };\n\n  that.buttons = {};\n  that.handlers = {\n    set: that.select,\n    cancel: that.cancel,\n    clear: that.clear\n  };\n  that._value = null;\n  that._isValid = true;\n  that._isVisible = false; // Constructor\n\n  s = that.settings;\n  trigger = that.trigger;\n\n  if (!inherit) {\n    that.init();\n  }\n};\n\nFrame.prototype._defaults = {\n  // Localization\n  lang: 'en',\n  setText: 'Set',\n  selectedText: '{count} selected',\n  closeText: 'Close',\n  cancelText: 'Cancel',\n  clearText: 'Clear',\n  // Options\n  context: 'body',\n  maxPopupWidth: 600,\n  disabled: false,\n  closeOnOverlayTap: true,\n  showOnFocus: isAndroid || isIOS,\n  // Needed for ion-input\n  showOnTap: true,\n  display: 'center',\n  scroll: true,\n  scrollLock: true,\n  showOverlay: true,\n  tap: true,\n  touchUi: true,\n  btnClass: 'mbsc-fr-btn',\n  btnWidth: true,\n  focusTrap: true,\n  focusOnClose: !isIOS8 // Temporary for iOS8\n\n};\nclasses.Frame = Frame;\nthemes.frame.mobiscroll = {\n  headerText: false,\n  btnWidth: false\n};\nthemes.scroller.mobiscroll = extend$1({}, themes.frame.mobiscroll, {\n  rows: 5,\n  showLabel: false,\n  selectedLineBorder: 1,\n  weekDays: 'min',\n  checkIcon: 'ion-ios7-checkmark-empty',\n  btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5',\n  btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5',\n  btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5',\n  btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5'\n});\n\nif (isBrowser) {\n  // Prevent re-show on window focus\n  $$1(window).on('focus', function () {\n    if ($activeElm) {\n      preventShow = true;\n    }\n  });\n} // eslint-disable-next-line no-unused-vars\n\n\nvar isIOS$1 = os == 'ios';\n\nvar ScrollViewBase = function ScrollViewBase(el, settings, inherit) {\n  var $btn,\n      $scrollbar,\n      $scrollbarTrack,\n      btnTimer,\n      contSize,\n      diffX,\n      diffY,\n      diff,\n      dir,\n      easing,\n      elastic,\n      endX,\n      endY,\n      eventObj,\n      isBtn,\n      isInfinite,\n      maxScroll,\n      maxSnapScroll,\n      minScroll,\n      move,\n      moving,\n      nativeScroll,\n      rafID,\n      //rafMoveID,\n  rafRunning,\n      scrollbar,\n      scrollbarHeight,\n      scrollbarOffset,\n      scrollbarTrack,\n      scrolled,\n      scrollDebounce,\n      scrollSnap,\n      scrollTimer,\n      snap,\n      snapPoints,\n      startPos,\n      startTime,\n      startX,\n      startY,\n      style,\n      target,\n      transTimer,\n      threshold,\n      trigger,\n      vertical,\n      that = this,\n      currPos,\n      currSnap = 0,\n      currSnapDir = 1,\n      s = settings,\n      $elm = $$1(el);\n\n  function onStart(ev) {\n    trigger('onStart', {\n      domEvent: ev\n    }); // Better performance if there are tap events on document\n\n    if (s.stopProp) {\n      ev.stopPropagation();\n    } //if (s.prevDef || ev.type == 'mousedown') {\n\n\n    if (s.prevDef && ev.type == 'mousedown') {\n      // Prevent touch highlight and focus\n      ev.preventDefault();\n    }\n\n    if (s.readonly || s.lock && moving) {\n      return;\n    }\n\n    if (testTouch(ev, this) && !move) {\n      if ($btn) {\n        $btn.removeClass('mbsc-active');\n      } // Highlight button\n\n\n      isBtn = false;\n\n      if (!moving) {\n        $btn = $$1(ev.target).closest('.mbsc-btn-e', this);\n\n        if ($btn.length && !$btn.hasClass('mbsc-disabled')) {\n          isBtn = true;\n          btnTimer = setTimeout(function () {\n            $btn.addClass('mbsc-active');\n          }, 100);\n        }\n      }\n\n      move = true;\n      scrolled = false;\n      nativeScroll = false;\n      that.scrolled = moving;\n      startX = getCoord(ev, 'X');\n      startY = getCoord(ev, 'Y');\n      endX = startX;\n      diffX = 0;\n      diffY = 0;\n      diff = 0;\n      startTime = new Date();\n      startPos = +getPosition(target, vertical) || 0; // Stop scrolling animation, 1ms is needed for Android 4.0\n\n      if (moving) {\n        scroll(startPos, isIOS$1 ? 0 : 1);\n      }\n\n      if (ev.type === 'mousedown') {\n        $$1(document).on('mousemove', onMove).on('mouseup', onEnd);\n      }\n    }\n  }\n\n  function onMove(ev) {\n    if (move) {\n      if (s.stopProp) {\n        ev.stopPropagation();\n      }\n\n      endX = getCoord(ev, 'X');\n      endY = getCoord(ev, 'Y');\n      diffX = endX - startX;\n      diffY = endY - startY;\n      diff = vertical ? diffY : diffX;\n\n      if (isBtn && (Math.abs(diffY) > s.thresholdY || Math.abs(diffX) > s.thresholdX)) {\n        clearTimeout(btnTimer);\n        $btn.removeClass('mbsc-active');\n        isBtn = false;\n      }\n\n      if (that.scrolled || !nativeScroll && Math.abs(diff) > threshold) {\n        if (!scrolled) {\n          trigger('onGestureStart', eventObj);\n        }\n\n        that.scrolled = scrolled = true;\n\n        if (!rafRunning) {\n          rafRunning = true;\n          rafID = raf(onMoving);\n        }\n      }\n\n      if (vertical || s.scrollLock) {\n        // Always prevent native scroll, if vertical\n        ev.preventDefault();\n      } else {\n        if (that.scrolled) {\n          // Prevent native scroll\n          ev.preventDefault();\n        } else if (Math.abs(diffY) > 7) {\n          nativeScroll = true;\n          that.scrolled = true;\n          onEnd();\n        }\n      }\n    }\n  }\n\n  function onMoving() {\n    //var time = new Date();\n    if (maxSnapScroll) {\n      diff = constrain(diff, -snap * maxSnapScroll, snap * maxSnapScroll);\n    }\n\n    scroll(constrain(startPos + diff, minScroll - elastic, maxScroll + elastic)); //if (s.momentum) {\n    //    startTime = time;\n    //    lastX = endX;\n    //}\n\n    rafRunning = false;\n  }\n\n  function onEnd(ev) {\n    if (move) {\n      var speed,\n          time = new Date() - startTime; // Better performance if there are tap events on document\n\n      if (s.stopProp && ev) {\n        ev.stopPropagation();\n      }\n\n      rafc(rafID);\n      rafRunning = false;\n\n      if (!nativeScroll && that.scrolled) {\n        // Calculate momentum distance\n        if (s.momentum && time < 300) {\n          speed = diff / time; //speed = Math.abs(lastX - endX) / time;\n\n          diff = Math.max(Math.abs(diff), speed * speed / s.speedUnit) * (diff < 0 ? -1 : 1);\n        }\n\n        finalize(diff);\n      }\n\n      if (isBtn) {\n        clearTimeout(btnTimer);\n        $btn.addClass('mbsc-active');\n        setTimeout(function () {\n          $btn.removeClass('mbsc-active');\n        }, 100);\n\n        if (!nativeScroll && !that.scrolled) {\n          trigger('onBtnTap', {\n            target: $btn[0],\n            domEvent: ev\n          });\n        }\n      } // Detach document events\n\n\n      if (ev && ev.type == 'mouseup') {\n        $$1(document).off('mousemove', onMove).off('mouseup', onEnd);\n      }\n\n      move = false;\n    }\n  }\n\n  function onClick(ev) {\n    if (that.scrolled) {\n      that.scrolled = false;\n      ev.stopPropagation();\n      ev.preventDefault();\n    }\n  }\n\n  function onScroll(ev) {\n    if (!el.contains(ev.target)) {\n      return;\n    }\n\n    ev = ev.originalEvent || ev;\n    diff = vertical ? ev.deltaY == undefined ? ev.wheelDelta || ev.detail : ev.deltaY : ev.deltaX;\n    trigger('onStart', {\n      domEvent: ev\n    });\n\n    if (s.stopProp) {\n      ev.stopPropagation();\n    }\n\n    if (diff) {\n      ev.preventDefault(); //diff = diff < 0 ? 20 : -20;\n\n      if (ev.deltaMode && ev.deltaMode == 1) {\n        diff *= 15;\n      }\n\n      diff = constrain(-diff, -scrollSnap, scrollSnap);\n      startPos = currPos;\n\n      if (s.readonly) {\n        return;\n      }\n\n      if (!scrolled) {\n        gestureStart();\n      }\n\n      if (startPos + diff < minScroll) {\n        startPos = minScroll;\n        diff = 0;\n      }\n\n      if (startPos + diff > maxScroll) {\n        startPos = maxScroll;\n        diff = 0;\n      }\n\n      if (!rafRunning) {\n        rafRunning = true;\n        rafID = raf(onMoving);\n      }\n\n      if (!diff && scrolled) {\n        return;\n      }\n\n      scrolled = true;\n      clearTimeout(scrollDebounce);\n      scrollDebounce = setTimeout(function () {\n        rafc(rafID);\n        rafRunning = false;\n        scrolled = false;\n        finalize(diff);\n      }, 200);\n    }\n  }\n\n  function onScrollBarStart(ev) {\n    trigger('onStart', {\n      domEvent: ev\n    });\n\n    if (s.readonly) {\n      return;\n    }\n\n    ev.stopPropagation();\n    startPos = currPos;\n    scrolled = false;\n\n    if (ev.target == scrollbar) {\n      startY = getCoord(ev, 'Y', true);\n      $$1(document).on('mousemove', onScrollBarMove).on('mouseup', onScrollBarEnd);\n    } else {\n      startY = $scrollbar.offset().top;\n      onScrollBarMove(ev);\n      onScrollBarEnd();\n    }\n  }\n\n  function onScrollBarMove(ev) {\n    var percent = (getCoord(ev, 'Y', true) - startY) / contSize;\n\n    if (isInfinite) {\n      diff = -(maxSnapScroll * snap * 2 + contSize) * percent;\n      diff = constrain(diff, -snap * maxSnapScroll, snap * maxSnapScroll);\n    } else {\n      diff = (minScroll - maxScroll - contSize) * percent;\n    }\n\n    if (!scrolled) {\n      gestureStart();\n    }\n\n    scrolled = true;\n    scroll(constrain(startPos + diff, minScroll - elastic, maxScroll + elastic));\n  }\n\n  function onScrollBarEnd() {\n    startPos = currPos;\n    finalize(0);\n    $$1(document).off('mousemove', onScrollBarMove).off('mouseup', onScrollBarEnd);\n  }\n\n  function onScrollBarClick(ev) {\n    ev.stopPropagation();\n  }\n\n  function gestureStart() {\n    eventObj = {\n      posX: vertical ? 0 : currPos,\n      posY: vertical ? currPos : 0,\n      originX: vertical ? 0 : startPos,\n      originY: vertical ? startPos : 0,\n      direction: diff > 0 ? vertical ? 270 : 360 : vertical ? 90 : 180\n    };\n    trigger('onGestureStart', eventObj);\n  }\n\n  function finalize(diff) {\n    var i, time, newPos; // Limit scroll to snap size\n\n    if (maxSnapScroll) {\n      diff = constrain(diff, -snap * maxSnapScroll, snap * maxSnapScroll);\n    } // Calculate snap and limit between min and max\n\n\n    newPos = constrain(Math.round((startPos + diff) / snap) * snap, minScroll, maxScroll); // Snap to nearest element\n\n    if (snapPoints) {\n      if (diff < 0) {\n        for (i = snapPoints.length - 1; i >= 0; i--) {\n          if (Math.abs(newPos) + contSize >= snapPoints[i].breakpoint) {\n            currSnap = i;\n            currSnapDir = 2;\n            newPos = snapPoints[i].snap2;\n            break;\n          }\n        }\n      } else if (diff >= 0) {\n        for (i = 0; i < snapPoints.length; i++) {\n          if (Math.abs(newPos) <= snapPoints[i].breakpoint) {\n            currSnap = i;\n            currSnapDir = 1;\n            newPos = snapPoints[i].snap1;\n            break;\n          }\n        }\n      }\n\n      newPos = constrain(newPos, minScroll, maxScroll);\n    }\n\n    time = s.time || (currPos < minScroll || currPos > maxScroll ? 1000 : Math.max(1000, Math.abs(newPos - currPos) * s.timeUnit));\n    eventObj.destinationX = vertical ? 0 : newPos;\n    eventObj.destinationY = vertical ? newPos : 0;\n    eventObj.duration = time;\n    eventObj.transitionTiming = easing;\n    trigger('onGestureEnd', eventObj); // Scroll to the calculated position\n\n    that.scroll(newPos, time);\n  }\n\n  function scroll(pos, time, tap, callback) {\n    var percent,\n        changed = pos != currPos,\n        anim = time > 1,\n        timing = time ? cssPrefix + 'transform ' + Math.round(time) + 'ms ' + easing : '',\n        done = function done() {\n      clearInterval(scrollTimer);\n      clearTimeout(transTimer); //rafc(rafMoveID);\n\n      moving = false;\n      currPos = pos;\n      eventObj.posX = vertical ? 0 : pos;\n      eventObj.posY = vertical ? pos : 0;\n\n      if (changed) {\n        trigger('onMove', eventObj);\n      }\n\n      if (anim) {\n        //that.scrolled = false;\n        trigger('onAnimationEnd', eventObj);\n      }\n\n      if (callback) {\n        callback();\n      }\n    };\n\n    eventObj = {\n      posX: vertical ? 0 : currPos,\n      posY: vertical ? currPos : 0,\n      originX: vertical ? 0 : startPos,\n      originY: vertical ? startPos : 0,\n      direction: pos - currPos > 0 ? vertical ? 270 : 360 : vertical ? 90 : 180\n    };\n    currPos = pos;\n\n    if (anim) {\n      eventObj.destinationX = vertical ? 0 : pos;\n      eventObj.destinationY = vertical ? pos : 0;\n      eventObj.duration = time;\n      eventObj.transitionTiming = easing;\n      trigger('onAnimationStart', eventObj);\n    }\n\n    style[jsPrefix + 'Transition'] = timing;\n    style[jsPrefix + 'Transform'] = 'translate3d(' + (vertical ? '0,' + pos + 'px,' : pos + 'px,' + '0,') + '0)';\n\n    if (scrollbar && scrollbarHeight) {\n      percent = isInfinite ? (scrollbarOffset - pos) / (maxSnapScroll * snap * 2) : (pos - maxScroll) / (minScroll - maxScroll);\n      scrollbar.style[jsPrefix + 'Transition'] = timing;\n      scrollbar.style[jsPrefix + 'Transform'] = 'translate3d(0,' + Math.max(0, Math.min((contSize - scrollbarHeight) * percent, contSize - scrollbarHeight)) + 'px,0)';\n    }\n\n    if (!changed && !moving || !time || time <= 1) {\n      done();\n    } else if (time) {\n      moving = !tap;\n      clearInterval(scrollTimer);\n      scrollTimer = setInterval(function () {\n        //rafMoveID = raf(function () {\n        var p = +getPosition(target, vertical) || 0;\n        eventObj.posX = vertical ? 0 : p;\n        eventObj.posY = vertical ? p : 0;\n        trigger('onMove', eventObj); // Trigger done if close to the end\n\n        if (Math.abs(p - pos) < 2) {\n          done();\n        } //});\n\n      }, 100);\n      clearTimeout(transTimer);\n      transTimer = setTimeout(function () {\n        done(); //style[pr + 'Transition'] = '';\n      }, time); // target.off(transEnd).on(transEnd, function (e) {\n      //     if (e.target === target[0]) {\n      //         target.off(transEnd);\n      //         style[pr + 'Transition'] = '';\n      //         done();\n      //     }\n      // });\n    }\n\n    if (s.sync) {\n      s.sync(pos, time, easing);\n    }\n  } // Call the parent constructor\n\n\n  Base.call(this, el, settings, true);\n  that.scrolled = false;\n  /**\r\n   * Scroll to the given position or element\r\n   */\n\n  that.scroll = function (pos, time, tap, callback) {\n    // If position is not numeric, scroll to element\n    if (!isNumeric(pos)) {\n      pos = Math.ceil(($$1(pos, el).length ? Math.round(target.offset()[dir] - $$1(pos, el).offset()[dir]) : currPos) / snap) * snap;\n    } else {\n      pos = Math.round(pos / snap) * snap;\n    }\n\n    pos = constrain(pos, minScroll, maxScroll);\n    currSnap = Math.round(pos / snap);\n    startPos = currPos;\n    scrollbarOffset = maxSnapScroll * snap + pos;\n    scroll(pos, time, tap, callback);\n  };\n\n  that.refresh = function (noScroll) {\n    var tempScroll;\n    contSize = (s.contSize === undefined ? vertical ? $elm.height() : $elm.width() : s.contSize) || 0;\n    maxScroll = (s.maxScroll === undefined ? 0 : s.maxScroll) || 0;\n    minScroll = Math.min(maxScroll, s.minScroll === undefined ? Math.min(0, vertical ? contSize - target.height() : contSize - target.width()) : s.minScroll) || 0;\n    snapPoints = null;\n\n    if (!vertical && s.rtl) {\n      tempScroll = maxScroll;\n      maxScroll = -minScroll;\n      minScroll = -tempScroll;\n    }\n\n    if (isString(s.snap)) {\n      snapPoints = [];\n      target.find(s.snap).each(function () {\n        var offset = vertical ? this.offsetTop : this.offsetLeft,\n            size = vertical ? this.offsetHeight : this.offsetWidth;\n        snapPoints.push({\n          breakpoint: offset + size / 2,\n          snap1: -offset,\n          snap2: contSize - offset - size\n        });\n      });\n    }\n\n    snap = isNumeric(s.snap) ? s.snap : 1;\n    maxSnapScroll = s.snap ? s.maxSnapScroll : 0;\n    easing = s.easing;\n    elastic = s.elastic ? isNumeric(s.snap) ? snap : isNumeric(s.elastic) ? s.elastic : 0 : 0; // && s.snap ? snap : 0;\n\n    scrollSnap = snap;\n\n    while (scrollSnap > 44) {\n      scrollSnap /= 2;\n    }\n\n    scrollSnap = Math.round(44 / scrollSnap) * scrollSnap;\n\n    if (scrollbar) {\n      isInfinite = minScroll == -Infinity || maxScroll == Infinity;\n      scrollbarHeight = minScroll < maxScroll ? Math.max(20, contSize * contSize / (maxScroll - minScroll + contSize)) : 0;\n      scrollbar.style.height = scrollbarHeight + 'px';\n      scrollbarTrack.style.height = scrollbarHeight ? '' : 0;\n    }\n\n    if (currPos === undefined) {\n      currPos = s.initialPos;\n      currSnap = Math.round(currPos / snap);\n    }\n\n    if (!noScroll) {\n      that.scroll(s.snap ? snapPoints && snapPoints[currSnap] ? snapPoints[currSnap]['snap' + currSnapDir] : currSnap * snap : currPos);\n    }\n  };\n\n  that._processSettings = function () {\n    vertical = s.axis == 'Y';\n    dir = vertical ? 'top' : 'left';\n    target = s.moveElement || $elm.children().eq(0);\n    style = target[0].style;\n    threshold = vertical ? s.thresholdY : s.thresholdX;\n\n    if (s.scrollbar) {\n      $scrollbarTrack = s.scrollbar;\n      $scrollbar = $scrollbarTrack.find('.mbsc-sc-bar');\n      scrollbar = $scrollbar[0];\n      scrollbarTrack = $scrollbarTrack[0];\n    }\n  };\n\n  that._init = function () {\n    that.refresh();\n    listen(el, 'mousedown', onStart);\n    listen(el, 'touchstart', onStart, {\n      passive: true\n    });\n    listen(el, 'touchend', onEnd);\n    listen(el, 'touchcancel', onEnd);\n    listen(el, 'click', onClick, true);\n    listen(document, 'touchmove', onMove, {\n      passive: false\n    });\n\n    if (s.mousewheel) {\n      listen(document, 'wheel', onScroll, {\n        passive: false,\n        capture: true\n      });\n      listen(document, 'mousewheel', onScroll, {\n        passive: false,\n        capture: true\n      });\n    }\n\n    if (scrollbar) {\n      $scrollbarTrack.on('mousedown', onScrollBarStart).on('click', onScrollBarClick);\n    } //el.addEventListener('touchend', function (ev) {\n    //    if (scrolled) {\n    //        ev.stopPropagation();\n    //    }\n    //}, true);\n\n  };\n  /**\r\n   * Destroy\r\n   */\n\n\n  that._destroy = function () {\n    clearInterval(scrollTimer);\n    unlisten(el, 'mousedown', onStart);\n    unlisten(el, 'touchstart', onStart, {\n      passive: true\n    });\n    unlisten(el, 'touchend', onEnd);\n    unlisten(el, 'touchcancel', onEnd);\n    unlisten(el, 'click', onClick, true);\n    unlisten(document, 'touchmove', onMove, {\n      passive: false\n    });\n    unlisten(document, 'wheel', onScroll, {\n      passive: false,\n      capture: true\n    });\n    unlisten(document, 'mousewheel', onScroll, {\n      passive: false,\n      capture: true\n    });\n\n    if (scrollbar) {\n      $scrollbarTrack.off('mousedown', onScrollBarStart).off('click', onScrollBarClick);\n    }\n  }; // Constructor\n\n\n  s = that.settings;\n  trigger = that.trigger;\n\n  if (!inherit) {\n    that.init();\n  }\n};\n\nScrollViewBase.prototype = {\n  _defaults: {\n    speedUnit: 0.0022,\n    //timeUnit: 0.8,\n    timeUnit: 3,\n    initialPos: 0,\n    axis: 'Y',\n    thresholdX: 10,\n    thresholdY: 5,\n    //easing: 'ease-out',\n    easing: 'cubic-bezier(0.190, 1.000, 0.220, 1.000)',\n    stopProp: true,\n    momentum: true,\n    mousewheel: true,\n    elastic: true\n  }\n}; // eslint-disable-next-line no-unused-vars\n\nvar presets = {},\n    css = isBrowser ? window.CSS : null,\n    has3d = css && css.supports && css.supports(\"(transform-style: preserve-3d)\");\n\nfunction sanitize(str) {\n  return (str + '').replace('\"', '___');\n}\n\nvar Scroller = function Scroller(el, settings, inherit) {\n  var $markup,\n      batchSize3d,\n      batchSize = 40,\n      animTime = 1000,\n      scroll3dAngle,\n      scroll3d,\n      selectedClass,\n      showScrollArrows,\n      stepper,\n      tempWheelArray,\n      itemHeight,\n      itemHeight3d,\n      isPointer,\n      isValidating,\n      s,\n      trigger,\n      lines,\n      wheels,\n      wheelsMap,\n      that = this,\n      $elm = $$1(el); // Event handlers\n\n  function onKeyDown(ev) {\n    var i = +$$1(this).attr('data-index'),\n        handle,\n        direction;\n\n    if (ev.keyCode == 38) {\n      // Up\n      handle = true;\n      direction = -1;\n    } else if (ev.keyCode == 40) {\n      // Down\n      handle = true;\n      direction = 1;\n    } else if (ev.keyCode == 32) {\n      // Space\n      handle = true;\n      onItemTap(i, $$1(ev.target));\n    }\n\n    if (handle) {\n      ev.stopPropagation();\n      ev.preventDefault();\n\n      if (direction) {\n        stepper.start(i, direction, ev);\n      }\n    }\n  }\n\n  function onKeyUp() {\n    stepper.stop();\n  }\n\n  function onItemTap(i, $item) {\n    var wheel = wheels[i],\n        idx = +$item.attr('data-index'),\n        val = getValue(wheel, idx),\n        selected = that._tempSelected[i],\n        maxSelect = isNumeric(wheel.multiple) ? wheel.multiple : Infinity;\n\n    if (trigger('onItemTap', {\n      target: $item[0],\n      index: i,\n      value: val,\n      selected: $item.hasClass('mbsc-sc-itm-sel')\n    }) !== false && !that._prevItemTap) {\n      // Select item on tap\n      if (wheel.multiple && !wheel._disabled[val]) {\n        if (selected[val] !== undefined) {\n          $item.removeClass(selectedClass).removeAttr('aria-selected');\n          delete selected[val];\n        } else {\n          if (maxSelect == 1) {\n            that._tempSelected[i] = selected = {};\n\n            wheel._$markup.find('.mbsc-sc-itm-sel').removeClass(selectedClass).removeAttr('aria-selected');\n          }\n\n          if (objectToArray(selected).length < maxSelect) {\n            $item.addClass(selectedClass).attr('aria-selected', 'true');\n            selected[val] = val;\n          }\n        }\n      }\n\n      setWheelValue(wheel, i, idx, animTime, wheel._index < idx ? 1 : 2, true, wheel.multiple);\n\n      if (that.live && (!wheel.multiple || wheel.multiple === 1 && s.tapSelect) && (s.setOnTap === true || s.setOnTap[i])) {\n        setTimeout(function () {\n          that.select();\n        }, s.tapSelect ? 0 : 200);\n      }\n    }\n\n    that._prevItemTap = false;\n  } // Private functions\n\n\n  function shouldSet(i, noscroll) {\n    var wheel = wheels[i];\n    return wheel && (!wheel.multiple || wheel.multiple !== 1 && noscroll && (s.setOnTap === true || s.setOnTap[i]));\n  }\n\n  function getMin(wheel) {\n    return -(wheel.max - wheel._offset - (wheel.multiple && !scroll3d ? Math.floor(s.rows / 2) : 0)) * itemHeight;\n  }\n\n  function getMax(wheel) {\n    return -(wheel.min - wheel._offset + (wheel.multiple && !scroll3d ? Math.floor(s.rows / 2) : 0)) * itemHeight;\n  }\n\n  function getIndex(wheel, val) {\n    return (wheel._array ? wheel._map[val] : +wheel.getIndex(val, that)) || 0;\n  }\n\n  function getItem(wheel, i) {\n    var data = wheel.data;\n\n    if (i >= wheel.min && i <= wheel.max) {\n      return wheel._array ? wheel.circular ? $$1(data).get(i % wheel._length) : data[i] : $$1.isFunction(data) ? data(i, that) : '';\n    }\n  }\n\n  function getItemValue(item) {\n    return $$1.isPlainObject(item) ? item.value !== undefined ? item.value : item.display : item;\n  }\n\n  function getItemText(item) {\n    var text = $$1.isPlainObject(item) ? item.display : item;\n    return text === undefined ? '' : text;\n  }\n\n  function getValue(wheel, i) {\n    return getItemValue(getItem(wheel, i));\n  }\n\n  function step(index, direction, ev) {\n    var wheel = wheels[index];\n    setWheelValue(wheel, index, wheel._index + direction, s.delay + 100, direction == 1 ? 1 : 2, false, false, ev.type == 'keydown');\n  }\n\n  function isReadOnly(i) {\n    return $$1.isArray(s.readonly) ? s.readonly[i] : s.readonly;\n  }\n\n  function initWheel(ww, l, keep) {\n    // Create a copy of the wheel, in case if same option object is used for multiple scroller instances\n    var w = extend$1(wheels[l] || {}, ww);\n    var index = w._index - w._batch;\n    w.data = w.data || [];\n    w.key = w.key !== undefined ? w.key : l;\n    w.label = w.label !== undefined ? w.label : l;\n    w._map = {};\n    w._array = $$1.isArray(w.data); // Map keys to index\n\n    if (w._array) {\n      w._length = w.data.length;\n      $$1.each(w.data, function (i, v) {\n        w._map[getItemValue(v)] = i;\n      });\n    }\n\n    w.circular = s.circular === undefined ? w.circular === undefined ? w._array && w._length > s.rows : w.circular : $$1.isArray(s.circular) ? s.circular[l] : s.circular;\n    w.min = w._array ? w.circular ? -Infinity : 0 : w.min === undefined ? -Infinity : w.min;\n    w.max = w._array ? w.circular ? Infinity : w._length - 1 : w.max === undefined ? Infinity : w.max;\n    w._nr = l;\n    w._index = getIndex(w, tempWheelArray[l]);\n    w._disabled = {};\n    w._batch = 0;\n    w._current = w._index;\n    w._first = w._index - batchSize; //Math.max(w.min, w._current - batchSize);\n\n    w._last = w._index + batchSize; //Math.min(w.max, w._first + 2 * batchSize);\n\n    w._offset = w._first;\n\n    if (keep) {\n      w._offset -= w._margin / itemHeight + (w._index - index);\n      w._margin += (w._index - index) * itemHeight;\n    } else {\n      w._margin = 0; //w._first * itemHeight;\n    }\n\n    w._refresh = function (noScroll) {\n      extend$1(w._scroller.settings, {\n        minScroll: getMin(w),\n        maxScroll: getMax(w)\n      });\n\n      w._scroller.refresh(noScroll);\n    };\n\n    wheelsMap[w.key] = w;\n    return w;\n  }\n\n  function generateItems(wheel, index, start, end, is3d) {\n    var i,\n        css,\n        item,\n        value,\n        text,\n        lbl,\n        invalid,\n        selected,\n        html = '',\n        checked = that._tempSelected[index],\n        disabled = wheel._disabled || {};\n\n    for (i = start; i <= end; i++) {\n      item = getItem(wheel, i);\n      text = getItemText(item);\n      value = getItemValue(item);\n      css = item && item.cssClass !== undefined ? item.cssClass : '';\n      lbl = item && item.label !== undefined ? item.label : '';\n      invalid = item && item.invalid;\n      selected = value !== undefined && value == tempWheelArray[index] && !wheel.multiple; // TODO: don't generate items with no value (use margin or placeholder instead)\n\n      html += '<div role=\"option\" tabindex=\"-1\" aria-selected=\"' + (checked[value] ? true : false) + '\" class=\"mbsc-sc-itm ' + (is3d ? 'mbsc-sc-itm-3d ' : '') + css + ' ' + (selected ? 'mbsc-sc-itm-sel ' : '') + (checked[value] ? selectedClass : '') + (value === undefined ? ' mbsc-sc-itm-ph' : ' mbsc-btn-e') + (invalid ? ' mbsc-sc-itm-inv-h mbsc-disabled' : '') + (disabled[value] ? ' mbsc-sc-itm-inv mbsc-disabled' : '') + '\" data-index=\"' + i + '\" data-val=\"' + sanitize(value) + '\"' + (lbl ? ' aria-label=\"' + lbl + '\"' : '') + (selected ? ' aria-selected=\"true\"' : '') + ' style=\"height:' + itemHeight + 'px;line-height:' + itemHeight + 'px;' + (is3d ? cssPrefix + 'transform:rotateX(' + (wheel._offset - i) * scroll3dAngle % 360 + 'deg) translateZ(' + itemHeight * s.rows / 2 + 'px);' : '') + '\">' + (lines > 1 ? '<div class=\"mbsc-sc-itm-ml\" style=\"line-height:' + Math.round(itemHeight / lines) + 'px;font-size:' + Math.round(itemHeight / lines * 0.8) + 'px;\">' : '') + text + (lines > 1 ? '</div>' : '') + '</div>';\n    }\n\n    return html;\n  }\n\n  function infinite(wheel, i, pos) {\n    var index = Math.round(-pos / itemHeight) + wheel._offset,\n        diff = index - wheel._current,\n        first = wheel._first,\n        last = wheel._last,\n        first3d = first + batchSize - batchSize3d + 1,\n        last3d = last - batchSize + batchSize3d;\n\n    if (diff) {\n      wheel._first += diff;\n      wheel._last += diff;\n      wheel._current = index; // Generate items\n      //setTimeout(function () {\n\n      if (diff > 0) {\n        wheel._$scroller.append(generateItems(wheel, i, Math.max(last + 1, first + diff), last + diff));\n\n        $$1('.mbsc-sc-itm', wheel._$scroller).slice(0, Math.min(diff, last - first + 1)).remove(); // 3D\n\n        if (scroll3d) {\n          wheel._$3d.append(generateItems(wheel, i, Math.max(last3d + 1, first3d + diff), last3d + diff, true));\n\n          $$1('.mbsc-sc-itm', wheel._$3d).slice(0, Math.min(diff, last3d - first3d + 1)).attr('class', 'mbsc-sc-itm-del');\n        }\n      } else if (diff < 0) {\n        wheel._$scroller.prepend(generateItems(wheel, i, first + diff, Math.min(first - 1, last + diff)));\n\n        $$1('.mbsc-sc-itm', wheel._$scroller).slice(Math.max(diff, first - last - 1)).remove(); // 3D\n\n        if (scroll3d) {\n          wheel._$3d.prepend(generateItems(wheel, i, first3d + diff, Math.min(first3d - 1, last3d + diff), true));\n\n          $$1('.mbsc-sc-itm', wheel._$3d).slice(Math.max(diff, first3d - last3d - 1)).attr('class', 'mbsc-sc-itm-del');\n        }\n      }\n\n      wheel._margin += diff * itemHeight;\n\n      wheel._$scroller.css('margin-top', wheel._margin + 'px'); //}, 10);\n\n    }\n  }\n\n  function getValid(index, v, dir, dis) {\n    var counter,\n        wheel = wheels[index],\n        disabled = dis || wheel._disabled,\n        idx = getIndex(wheel, v),\n        val = getValue(wheel, idx),\n        v1 = val,\n        v2 = val,\n        dist1 = 0,\n        dist2 = 0; // TODO: what if all items are invalid\n\n    if (disabled[val] === true) {\n      counter = 0;\n\n      while (idx - dist1 >= wheel.min && disabled[v1] && counter < 100) {\n        counter++;\n        dist1++;\n        v1 = getValue(wheel, idx - dist1);\n      }\n\n      counter = 0;\n\n      while (idx + dist2 < wheel.max && disabled[v2] && counter < 100) {\n        counter++;\n        dist2++;\n        v2 = getValue(wheel, idx + dist2);\n      } // If we have direction (+/- or mouse wheel), the distance does not count\n\n\n      if ((dist2 < dist1 && dist2 && dir !== 2 || !dist1 || idx - dist1 < 0 || dir == 1) && !disabled[v2]) {\n        val = v2;\n      } else {\n        val = v1;\n      }\n    }\n\n    return val;\n  }\n\n  function scrollToPos(time, index, dir, manual, tap, noscroll, shouldFocus) {\n    var diff,\n        idx,\n        offset,\n        ret,\n        isVisible = that._isVisible;\n    isValidating = true;\n    ret = s.validate.call(el, {\n      values: tempWheelArray.slice(0),\n      index: index,\n      direction: dir\n    }, that) || {};\n    isValidating = false;\n\n    if (ret.valid) {\n      that._tempWheelArray = tempWheelArray = ret.valid.slice(0);\n    }\n\n    if (!noscroll) {\n      $$1.each(wheels, function (i, wheel) {\n        if (isVisible) {\n          // Enable all items\n          wheel._$markup.find('.mbsc-sc-itm-inv').removeClass('mbsc-sc-itm-inv mbsc-disabled');\n        }\n\n        wheel._disabled = {}; // Disable invalid items\n\n        if (ret.disabled && ret.disabled[i]) {\n          $$1.each(ret.disabled[i], function (j, v) {\n            wheel._disabled[v] = true;\n\n            if (isVisible) {\n              wheel._$markup.find('.mbsc-sc-itm[data-val=\"' + sanitize(v) + '\"]').addClass('mbsc-sc-itm-inv mbsc-disabled');\n            }\n          });\n        } // Get closest valid value\n\n\n        tempWheelArray[i] = wheel.multiple ? tempWheelArray[i] : getValid(i, tempWheelArray[i], dir);\n\n        if (isVisible) {\n          if (!wheel.multiple || index === undefined) {\n            wheel._$markup.find('.mbsc-sc-itm-sel').removeClass(selectedClass).removeAttr('aria-selected');\n          } // Get index of valid value\n\n\n          idx = getIndex(wheel, tempWheelArray[i]);\n          diff = idx - wheel._index + wheel._batch;\n\n          if (Math.abs(diff) > 2 * batchSize + 1) {\n            offset = diff + (2 * batchSize + 1) * (diff > 0 ? -1 : 1);\n            wheel._offset += offset;\n            wheel._margin -= offset * itemHeight;\n\n            wheel._refresh();\n          }\n\n          wheel._index = idx + wheel._batch;\n\n          if (wheel.multiple) {\n            // Add selected styling to selected elements in case of multiselect\n            if (index === undefined) {\n              for (var v in that._tempSelected[i]) {\n                wheel._$markup.find('.mbsc-sc-itm[data-val=\"' + sanitize(v) + '\"]').addClass(selectedClass).attr('aria-selected', 'true');\n              }\n            }\n          } else {\n            // Mark element as aria selected\n            wheel._$markup.find('.mbsc-sc-itm[data-val=\"' + sanitize(tempWheelArray[i]) + '\"]').addClass('mbsc-sc-itm-sel').attr('aria-selected', 'true');\n          }\n\n          if (wheel._$active) {\n            wheel._$active.attr('tabindex', -1);\n          }\n\n          wheel._$active = wheel._$markup.find('.mbsc-sc-itm[data-index=\"' + wheel._index + '\"]').eq(scroll3d && wheel.multiple ? 1 : 0).attr('tabindex', 0);\n\n          if (shouldFocus && index === i && wheel._$active.length) {\n            wheel._$active[0].focus();\n\n            wheel._$scroller.parent().scrollTop(0);\n          } // Scroll to valid value\n\n\n          wheel._scroller.scroll(-(idx - wheel._offset + wheel._batch) * itemHeight, index === i || index === undefined ? time : animTime, tap);\n        }\n      });\n    }\n\n    trigger('onValidated', {\n      index: index,\n      time: time\n    }); // Get formatted value\n\n    that._tempValue = s.formatValue.call(el, tempWheelArray, that);\n\n    if (isVisible) {\n      that._updateHeader();\n    } // If in live mode, set and fill value on every move\n\n\n    if (that.live && shouldSet(index, noscroll)) {\n      that._hasValue = manual || that._hasValue;\n      setValue(manual, manual, 0, true);\n\n      if (manual) {\n        trigger('onSet', {\n          valueText: that._value\n        });\n      }\n    }\n\n    if (manual) {\n      trigger('onChange', {\n        index: index,\n        valueText: that._tempValue\n      });\n    }\n  }\n\n  function setWheelValue(wheel, i, idx, time, dir, tap, noscroll, shouldFocus) {\n    // Get the value at the given index\n    var value = getValue(wheel, idx);\n\n    if (value !== undefined) {\n      tempWheelArray[i] = value; // In case of circular wheels calculate the offset of the current batch\n\n      wheel._batch = wheel._array ? Math.floor(idx / wheel._length) * wheel._length : 0;\n      wheel._index = idx;\n      setTimeout(function () {\n        scrollToPos(time, i, dir, true, tap, noscroll, shouldFocus);\n      }, 10);\n    }\n  }\n\n  function setValue(fill, change, time, noscroll, temp) {\n    if (!noscroll) {\n      scrollToPos(time);\n    } else {\n      that._tempValue = s.formatValue.call(el, that._tempWheelArray, that);\n    }\n\n    if (!temp) {\n      that._wheelArray = [];\n\n      for (var i = 0; i < tempWheelArray.length; i++) {\n        // In case of multiple select wheel take the first selected value,\n        that._wheelArray[i] = wheels[i] && wheels[i].multiple ? Object.keys(that._tempSelected[i] || {})[0] : tempWheelArray[i];\n      }\n\n      that._value = that._hasValue ? that._tempValue : null;\n      that._selected = extend$1(true, {}, that._tempSelected);\n    }\n\n    if (fill) {\n      if (that._isInput) {\n        $elm.val(that._hasValue ? that._tempValue : '');\n      }\n\n      trigger('onFill', {\n        valueText: that._hasValue ? that._tempValue : '',\n        change: change\n      });\n\n      if (change) {\n        that._preventChange = true;\n        $elm.trigger('change');\n      }\n    }\n  } // Call the parent constructor\n\n\n  Frame.call(this, el, settings, true); // Public functions\n\n  /**\r\n   * Sets the value of the scroller.\r\n   * @param {Array} val - New value.\r\n   * @param {Boolean} [fill=false] - Set the value of the associated input element.\r\n   * @param {Boolean} [change=false] - Trigger change on the input element.\r\n   * @param {Boolean} [temp=false] - If true, then only set the temporary value (only scroll there but not set the value).\r\n   * @param {Number} [time=0] - Animation time in milliseconds.\r\n   */\n\n  that.setVal = that._setVal = function (val, fill, change, temp, time) {\n    that._hasValue = val !== null && val !== undefined;\n    that._tempWheelArray = tempWheelArray = $$1.isArray(val) ? val.slice(0) : s.parseValue.call(el, val, that) || [];\n    setValue(fill, change === undefined ? fill : change, time, false, temp);\n  };\n  /**\r\n   * Returns the selected value.\r\n   */\n\n\n  that.getVal = that._getVal = function (temp) {\n    var val = that._hasValue || temp ? that[temp ? '_tempValue' : '_value'] : null;\n    return isNumeric(val) ? +val : val;\n  };\n  /*\r\n   * Sets the wheel values (passed as an array).\r\n   */\n\n\n  that.setArrayVal = that.setVal;\n  /*\r\n   * Returns the selected wheel values as an array.\r\n   */\n\n  that.getArrayVal = function (temp) {\n    return temp ? that._tempWheelArray : that._wheelArray;\n  };\n\n  that.changeWheel = function (whls, time, manual) {\n    var i, w, ww;\n    $$1.each(whls, function (key, wheel) {\n      ww = wheelsMap[key]; // Check if wheel exists\n\n      if (ww) {\n        i = ww._nr;\n        w = initWheel(wheel, i, true);\n\n        if (that._isVisible) {\n          if (scroll3d) {\n            w._$3d.html(generateItems(w, i, w._first + batchSize - batchSize3d + 1, w._last - batchSize + batchSize3d, true));\n          }\n\n          w._$scroller.html(generateItems(w, i, w._first, w._last)).css('margin-top', w._margin + 'px');\n\n          w._refresh(isValidating);\n        }\n      }\n    });\n\n    if (that._isVisible && !that._isLiquid && !isValidating) {\n      that.position();\n    }\n\n    if (!isValidating) {\n      scrollToPos(time, undefined, undefined, manual);\n    }\n  };\n  /**\r\n   * Returns the closest valid value.\r\n   */\n\n\n  that.getValidValue = getValid; // Protected overrides\n\n  that._generateContent = function () {\n    var lbl,\n        maxPopupWidth = 0,\n        html = '',\n        style = scroll3d ? cssPrefix + 'transform: translateZ(' + (itemHeight * s.rows / 2 + 3) + 'px);' : '',\n        highlight = '<div class=\"mbsc-sc-whl-l\" style=\"' + style + 'height:' + itemHeight + 'px;margin-top:-' + (itemHeight / 2 + (s.selectedLineBorder || 0)) + 'px;\"></div>',\n        l = 0;\n    $$1.each(s.wheels, function (i, wg) {\n      html += '<div class=\"mbsc-w-p mbsc-sc-whl-gr-c' + (scroll3d ? ' mbsc-sc-whl-gr-3d-c' : '') + (s.showLabel ? ' mbsc-sc-lbl-v' : '') + '\">' + highlight + '<div class=\"mbsc-sc-whl-gr' + (scroll3d ? ' mbsc-sc-whl-gr-3d' : '') + (showScrollArrows ? ' mbsc-sc-cp' : '') + (s.width || s.maxWidth ? '\"' : '\" style=\"max-width:' + s.maxPopupWidth + 'px;\"') + '>';\n      $$1.each(wg, function (j, ww) {\n        // Wheels\n        that._tempSelected[l] = extend$1({}, that._selected[l]); // TODO: this should be done on initialization, not on show\n\n        var w = initWheel(ww, l);\n        wheels[l] = w;\n        maxPopupWidth += s.maxWidth ? s.maxWidth[l] || s.maxWidth : s.width ? s.width[l] || s.width : 0;\n        lbl = w.label !== undefined ? w.label : j;\n        html += '<div class=\"mbsc-sc-whl-w ' + (w.cssClass || '') + (w.multiple ? ' mbsc-sc-whl-multi' : '') + '\" style=\"' + (s.width ? 'width:' + (s.width[l] || s.width) + 'px;' : (s.minWidth ? 'min-width:' + (s.minWidth[l] || s.minWidth) + 'px;' : '') + (s.maxWidth ? 'max-width:' + (s.maxWidth[l] || s.maxWidth) + 'px;' : '')) + '\">' + (isPointer ? '<div class=\"mbsc-sc-bar-c\"><div class=\"mbsc-sc-bar\"></div></div>' : '') + // Scrollbar\n        '<div class=\"mbsc-sc-whl-o\" style=\"' + style + '\"></div>' + highlight + '<div aria-live=\"off\" aria-label=\"' + lbl + '\"' + (w.multiple ? ' aria-multiselectable=\"true\"' : '') + ' role=\"listbox\" data-index=\"' + l + '\" class=\"mbsc-sc-whl\"' + ' style=\"' + 'height:' + s.rows * itemHeight * (scroll3d ? 1.1 : 1) + 'px;\">' + (showScrollArrows ? '<div data-index=\"' + l + '\" data-step=\"1\" class=\"mbsc-sc-btn mbsc-sc-btn-plus ' + (s.btnPlusClass || '') + '\"></div>' + // + button\n        '<div data-index=\"' + l + '\" data-step=\"-1\" class=\"mbsc-sc-btn mbsc-sc-btn-minus ' + (s.btnMinusClass || '') + '\"></div>' : '') + // - button\n        '<div class=\"mbsc-sc-lbl\">' + lbl + '</div>' + // Wheel label\n        '<div class=\"mbsc-sc-whl-c\"' + ' style=\"height:' + itemHeight3d + 'px;margin-top:-' + (itemHeight3d / 2 + 1) + 'px;' + style + '\">' + '<div class=\"mbsc-sc-whl-sc\" style=\"top:' + (itemHeight3d - itemHeight) / 2 + 'px;\">'; // Create wheel values\n\n        html += generateItems(w, l, w._first, w._last) + '</div></div>';\n\n        if (scroll3d) {\n          html += '<div class=\"mbsc-sc-whl-3d\" style=\"height:' + itemHeight + 'px;margin-top:-' + itemHeight / 2 + 'px;\">';\n          html += generateItems(w, l, w._first + batchSize - batchSize3d + 1, w._last - batchSize + batchSize3d, true);\n          html += '</div>';\n        }\n\n        html += '</div></div>';\n        l++;\n      });\n      html += '</div></div>';\n    });\n\n    if (maxPopupWidth) {\n      s.maxPopupWidth = maxPopupWidth;\n    }\n\n    return html;\n  };\n\n  that._attachEvents = function ($markup) {\n    stepper = createStepper($$1('.mbsc-sc-btn', $markup), step, s.delay, isReadOnly, true);\n    $$1('.mbsc-sc-whl', $markup).on('keydown', onKeyDown).on('keyup', onKeyUp);\n  };\n\n  that._detachEvents = function () {\n    stepper.stop();\n\n    for (var i = 0; i < wheels.length; i++) {\n      wheels[i]._scroller.destroy();\n    }\n  };\n\n  that._markupReady = function ($m) {\n    $markup = $m;\n    $$1('.mbsc-sc-whl-w', $markup).each(function (i) {\n      var idx,\n          $wh = $$1(this),\n          wheel = wheels[i];\n      wheel._$markup = $wh;\n      wheel._$scroller = $$1('.mbsc-sc-whl-sc', this);\n      wheel._$3d = $$1('.mbsc-sc-whl-3d', this);\n      wheel._scroller = new ScrollViewBase(this, {\n        mousewheel: s.mousewheel,\n        moveElement: wheel._$scroller,\n        scrollbar: $$1('.mbsc-sc-bar-c', this),\n        initialPos: (wheel._first - wheel._index) * itemHeight,\n        contSize: s.rows * itemHeight,\n        snap: itemHeight,\n        minScroll: getMin(wheel),\n        maxScroll: getMax(wheel),\n        maxSnapScroll: batchSize,\n        prevDef: true,\n        stopProp: true,\n        timeUnit: 3,\n        easing: 'cubic-bezier(0.190, 1.000, 0.220, 1.000)',\n        sync: function sync(pos, time, easing) {\n          var timing = time ? cssPrefix + 'transform ' + Math.round(time) + 'ms ' + easing : '';\n\n          if (scroll3d) {\n            wheel._$3d[0].style[jsPrefix + 'Transition'] = timing;\n            wheel._$3d[0].style[jsPrefix + 'Transform'] = 'rotateX(' + -pos / itemHeight * scroll3dAngle + 'deg)';\n          }\n        },\n        onStart: function onStart(ev, inst) {\n          inst.settings.readonly = isReadOnly(i);\n        },\n        onGestureStart: function onGestureStart() {\n          $wh.addClass('mbsc-sc-whl-a mbsc-sc-whl-anim');\n          trigger('onWheelGestureStart', {\n            index: i\n          });\n        },\n        onGestureEnd: function onGestureEnd(ev) {\n          var dir = ev.direction == 90 ? 1 : 2,\n              time = ev.duration,\n              pos = ev.destinationY;\n          idx = Math.round(-pos / itemHeight) + wheel._offset;\n          setWheelValue(wheel, i, idx, time, dir);\n        },\n        onAnimationStart: function onAnimationStart() {\n          $wh.addClass('mbsc-sc-whl-anim');\n        },\n        onAnimationEnd: function onAnimationEnd() {\n          $wh.removeClass('mbsc-sc-whl-a mbsc-sc-whl-anim');\n          trigger('onWheelAnimationEnd', {\n            index: i\n          });\n\n          wheel._$3d.find('.mbsc-sc-itm-del').remove();\n        },\n        onMove: function onMove(ev) {\n          infinite(wheel, i, ev.posY);\n        },\n        onBtnTap: function onBtnTap(ev) {\n          onItemTap(i, $$1(ev.target));\n        }\n      });\n    });\n    scrollToPos();\n  };\n\n  that._fillValue = function () {\n    that._hasValue = true;\n    setValue(true, true, 0, true);\n  };\n\n  that._clearValue = function () {\n    $$1('.mbsc-sc-whl-multi .mbsc-sc-itm-sel', $markup).removeClass(selectedClass).removeAttr('aria-selected');\n  };\n\n  that._readValue = function () {\n    var v = $elm.val() || '',\n        l = 0;\n\n    if (v !== '') {\n      that._hasValue = true;\n    }\n\n    that._tempWheelArray = tempWheelArray = that._hasValue && that._wheelArray ? that._wheelArray.slice(0) : s.parseValue.call(el, v, that) || [];\n    that._tempSelected = extend$1(true, {}, that._selected);\n    $$1.each(s.wheels, function (i, wg) {\n      $$1.each(wg, function (j, w) {\n        // Wheels\n        wheels[l] = initWheel(w, l);\n        l++;\n      });\n    });\n    setValue(false, false, 0, true);\n    trigger('onRead');\n  };\n\n  that.__processSettings = function (resp) {\n    s = that.settings;\n    trigger = that.trigger;\n    lines = s.multiline;\n    selectedClass = 'mbsc-sc-itm-sel mbsc-ic mbsc-ic-' + s.checkIcon;\n    isPointer = !s.touchUi;\n\n    if (isPointer) {\n      // Settings that might be needed by the scroller preset as well\n      s.tapSelect = true;\n      s.circular = false;\n      s.rows = resp.rows || settings.rows || 7;\n    }\n  };\n\n  that.__init = function (newSettings) {\n    if (newSettings) {\n      // Reset wheel array in case of setting change,\n      // since it might affect the number of wheels\n      that._wheelArray = null;\n    }\n\n    wheels = [];\n    wheelsMap = {};\n    showScrollArrows = s.showScrollArrows;\n    scroll3d = s.scroll3d && has3d && !showScrollArrows && !isPointer && (s.theme == 'ios' || s.baseTheme == 'ios');\n    itemHeight = s.height;\n    itemHeight3d = scroll3d ? Math.round((itemHeight - (itemHeight * s.rows / 2 + 3) * 0.03) / 2) * 2 : itemHeight;\n    batchSize3d = Math.round(s.rows * 1.8);\n    scroll3dAngle = 360 / (batchSize3d * 2); // Ensure a minimum number of 3 items if clickpick buttons present\n\n    if (showScrollArrows) {\n      s.rows = Math.max(3, s.rows);\n    }\n  };\n\n  that._getItemValue = getItemValue; // Properties\n\n  that._tempSelected = {};\n  that._selected = {}; // Constructor\n\n  if (!inherit) {\n    that.init();\n  }\n}; // Extend defaults\n\n\nScroller.prototype = {\n  _hasDef: true,\n  _hasTheme: true,\n  _hasLang: true,\n  _responsive: true,\n  _class: 'scroller',\n  _presets: presets,\n  _defaults: extend$1({}, Frame.prototype._defaults, {\n    // Options\n    minWidth: 80,\n    height: 40,\n    rows: 3,\n    multiline: 1,\n    delay: 200,\n    readonly: false,\n    showLabel: true,\n    setOnTap: false,\n    wheels: [],\n    preset: '',\n    speedUnit: 0.0012,\n    timeUnit: 0.08,\n    checkIcon: 'checkmark',\n    compClass: 'mbsc-sc',\n    validate: function validate() {},\n    formatValue: function formatValue(d) {\n      return d.join(' ');\n    },\n    parseValue: function parseValue(value, inst) {\n      var val = [],\n          ret = [],\n          i = 0,\n          found,\n          data;\n\n      if (value !== null && value !== undefined) {\n        val = (value + '').split(' ');\n      }\n\n      $$1.each(inst.settings.wheels, function (j, wg) {\n        $$1.each(wg, function (k, w) {\n          data = w.data; // Default to first wheel value if not found\n\n          found = inst._getItemValue(data[0]);\n          $$1.each(data, function (l, item) {\n            // Don't do strict comparison\n            if (val[i] == inst._getItemValue(item)) {\n              found = inst._getItemValue(item);\n              return false;\n            }\n          });\n          ret.push(found);\n          i++;\n        });\n      });\n      return ret;\n    }\n  })\n};\nclasses.Scroller = Scroller;\nvar defaults$1 = {\n  separator: ' ',\n  // Localization\n  dateFormat: 'mm/dd/yy',\n  dateDisplay: 'MMddyy',\n  timeFormat: 'h:ii A',\n  dayText: 'Day',\n  monthText: 'Month',\n  yearText: 'Year',\n  hourText: 'Hours',\n  minuteText: 'Minutes',\n  ampmText: '&nbsp;',\n  secText: 'Seconds',\n  nowText: 'Now',\n  todayText: 'Today'\n}; // --- TRIAL SERVER CODE END ---\n\nvar DateTime = function DateTime(inst) {\n  function convertRanges(arr) {\n    var i,\n        v,\n        start,\n        end,\n        ret = [];\n\n    if (arr) {\n      for (i = 0; i < arr.length; i++) {\n        v = arr[i]; // Check if it's a range, but skip time-only ranges\n\n        if (v.start && v.end && !ISO_8601_TIME.test(v.start)) {\n          start = new Date(makeDate(v.start, format, s));\n          end = new Date(makeDate(v.end, format, s));\n\n          while (start <= end) {\n            ret.push(adjustedDate(start.getFullYear(), start.getMonth(), start.getDate()));\n            start.setDate(start.getDate() + 1);\n          }\n        } else {\n          ret.push(v);\n        }\n      }\n\n      return ret;\n    }\n\n    return arr;\n  }\n\n  function step(v, st, min, max) {\n    return Math.min(max, Math.floor(v / st) * st + min);\n  }\n\n  function getMax(step, min, max) {\n    return Math.floor((max - min) / step) * step + min;\n  }\n\n  function getYear(d) {\n    return s.getYear(d);\n  }\n\n  function getMonth(d) {\n    return s.getMonth(d);\n  }\n\n  function getDay(d) {\n    return s.getDay(d);\n  }\n\n  function getHours(d) {\n    var hour = d.getHours();\n    hour = hasAmPm && hour >= 12 ? hour - 12 : hour;\n    return step(hour, stepHour, minHour, maxHour);\n  }\n\n  function getMinutes(d) {\n    return step(d.getMinutes(), stepMinute, minMinute, maxMinute);\n  }\n\n  function getSeconds(d) {\n    return step(d.getSeconds(), stepSecond, minSecond, maxSecond);\n  }\n\n  function getMilliseconds(d) {\n    return d.getMilliseconds();\n  }\n\n  function getAmPm(d) {\n    return d.getHours() > 11 ? 1 : 0;\n  } // --- TRIAL SERVER CODE START ---\n\n\n  function getFullDate(d) {\n    return d.getFullYear() + '-' + pad(d.getMonth() + 1) + '-' + pad(d.getDate());\n  } // --- TRIAL SERVER CODE END ---\n\n\n  function getFullTime(d) {\n    return step(Math.round((d.getTime() - new Date(d).setHours(0, 0, 0, 0)) / 1000), timeStep || 1, 0, 86400);\n  }\n\n  function getArrayPart(data, part, d, def) {\n    var ret;\n\n    if (wheelOrder[part] !== undefined) {\n      ret = +data[wheelOrder[part]];\n\n      if (!isNaN(ret)) {\n        return ret;\n      }\n    }\n\n    if (d) {\n      return getDatePart[part](d);\n    }\n\n    if (innerValues[part] !== undefined) {\n      return innerValues[part];\n    }\n\n    return getDatePart[part](def);\n  }\n\n  function getDate(data) {\n    var d,\n        def = new Date(new Date().setHours(0, 0, 0, 0));\n\n    if (data === null) {\n      return data;\n    }\n\n    if (wheelOrder.dd !== undefined) {\n      d = data[wheelOrder.dd].split('-');\n      d = new Date(d[0], d[1] - 1, d[2]);\n    }\n\n    if (wheelOrder.tt !== undefined) {\n      d = d || def;\n      d = new Date(d.getTime() + data[wheelOrder.tt] % 86400 * 1000);\n    }\n\n    var year = getArrayPart(data, 'y', d, def),\n        month = getArrayPart(data, 'm', d, def),\n        day = Math.min(getArrayPart(data, 'd', d, def), s.getMaxDayOfMonth(year, month)),\n        hour = getArrayPart(data, 'h', d, def);\n    return s.getDate(year, month, day, hasAmPm && getArrayPart(data, 'a', d, def) ? hour + 12 : hour, getArrayPart(data, 'i', d, def), getArrayPart(data, 's', d, def), getArrayPart(data, 'u', d, def));\n  }\n\n  function getArray(d, fillInner) {\n    var i,\n        part,\n        parts = ['y', 'm', 'd', 'a', 'h', 'i', 's', 'u', 'dd', 'tt'],\n        ret = [];\n\n    if (d === null || d === undefined) {\n      return d;\n    }\n\n    for (i = 0; i < parts.length; i++) {\n      part = parts[i];\n\n      if (wheelOrder[part] !== undefined) {\n        ret[wheelOrder[part]] = getDatePart[part](d);\n      }\n\n      if (fillInner) {\n        innerValues[part] = getDatePart[part](d);\n      }\n    }\n\n    return ret;\n  } // --- TRIAL SERVER CODE START ---\n\n\n  function getDateIndex(d, hasDay) {\n    return hasDay ? // Number of days since 1970-01-01\n    Math.floor(new Date(d) / 8.64e7) : // Number of month since 1970-01-01\n    d.getMonth() + 12 * (d.getFullYear() - 1970);\n  }\n\n  function getYearValue(i) {\n    return {\n      value: i,\n      display: (/yy/i.test(dateDisplay) ? i : (i + '').substr(2, 2)) + (s.yearSuffix || '')\n    };\n  }\n\n  function getYearIndex(v) {\n    return v;\n  }\n\n  function getDateWheel(template) {\n    var hasDay = /d/i.test(template);\n    return {\n      label: '',\n      cssClass: 'mbsc-dt-whl-date',\n      min: minDate ? getDateIndex(getFullDate(minDate), hasDay) : undefined,\n      max: maxDate ? getDateIndex(getFullDate(maxDate), hasDay) : undefined,\n      data: function data(i) {\n        var today = new Date(new Date().setHours(0, 0, 0, 0)),\n            d = hasDay ? new Date(i * 8.64e7) : new Date(1970, i, 1);\n\n        if (hasDay) {\n          d = new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());\n        }\n\n        return {\n          invalid: hasDay && !isValid(d, true),\n          value: getFullDate(d),\n          display: today.getTime() == d.getTime() ? s.todayText : formatDate(template, d, s)\n        };\n      },\n      getIndex: function getIndex(v) {\n        return getDateIndex(v, hasDay);\n      }\n    };\n  }\n\n  function getTimeWheel(template) {\n    var i,\n        step,\n        time,\n        values = [];\n\n    if (/s/i.test(template)) {\n      step = stepSecond;\n    } else if (/i/i.test(template)) {\n      step = stepMinute * 60;\n    } else if (/h/i.test(template)) {\n      step = stepHour * 3600;\n    }\n\n    timeStep = steps.tt = step;\n\n    for (i = 0; i < 86400; i += step) {\n      time = new Date(new Date().setHours(0, 0, 0, 0) + i * 1000);\n      values.push({\n        value: i,\n        display: formatDate(template, time, s)\n      });\n    }\n\n    return {\n      label: '',\n      cssClass: 'mbsc-dt-whl-time',\n      data: values\n    };\n  }\n\n  function getWheels() {\n    var dateParts,\n        timeParts,\n        template,\n        i,\n        j,\n        types,\n        values,\n        monthStr,\n        nr = 0,\n        wheels = [],\n        dateGroup = [],\n        timeGroup = [];\n\n    if (/date/i.test(preset)) {\n      dateParts = dateWheels.split(/\\|/.test(dateWheels) ? '|' : '');\n\n      for (i = 0; i < dateParts.length; i++) {\n        template = dateParts[i];\n        types = 0;\n\n        if (template.length) {\n          // If contains different characters\n          if (/y/i.test(template)) {\n            isoParts.y = 1;\n            types++;\n          }\n\n          if (/m/i.test(template)) {\n            isoParts.y = 1;\n            isoParts.m = 1;\n            types++;\n          }\n\n          if (/d/i.test(template)) {\n            isoParts.y = 1;\n            isoParts.m = 1;\n            isoParts.d = 1;\n            types++;\n          }\n\n          if (types > 1 && wheelOrder.dd === undefined) {\n            wheelOrder.dd = nr;\n            nr++;\n            dateGroup.push(getDateWheel(template));\n            timeGroup = dateGroup; // TODO ???\n\n            oneDateWheel = true;\n          } else if (/y/i.test(template) && wheelOrder.y === undefined) {\n            wheelOrder.y = nr;\n            nr++; // Year wheel\n\n            dateGroup.push({\n              cssClass: 'mbsc-dt-whl-y',\n              label: s.yearText,\n              min: minDate ? s.getYear(minDate) : undefined,\n              max: maxDate ? s.getYear(maxDate) : undefined,\n              data: getYearValue,\n              getIndex: getYearIndex\n            });\n          } else if (/m/i.test(template) && wheelOrder.m === undefined) {\n            // Month wheel\n            wheelOrder.m = nr;\n            values = [];\n            nr++;\n\n            for (j = 0; j < 12; j++) {\n              monthStr = dateDisplay.replace(/[dy|]/gi, '').replace(/mm/, pad(j + 1) + (s.monthSuffix || '')).replace(/m/, j + 1 + (s.monthSuffix || ''));\n              values.push({\n                value: j,\n                display: /MM/.test(monthStr) ? monthStr.replace(/MM/, '<span class=\"mbsc-dt-month\">' + s.monthNames[j] + '</span>') : monthStr.replace(/M/, '<span class=\"mbsc-dt-month\">' + s.monthNamesShort[j] + '</span>')\n              });\n            }\n\n            dateGroup.push({\n              cssClass: 'mbsc-dt-whl-m',\n              label: s.monthText,\n              data: values\n            });\n          } else if (/d/i.test(template) && wheelOrder.d === undefined) {\n            // Day wheel\n            wheelOrder.d = nr;\n            values = [];\n            nr++;\n\n            for (j = 1; j < 32; j++) {\n              values.push({\n                value: j,\n                display: (/dd/i.test(dateDisplay) ? pad(j) : j) + (s.daySuffix || '')\n              });\n            }\n\n            dateGroup.push({\n              cssClass: 'mbsc-dt-whl-d',\n              label: s.dayText,\n              data: values\n            });\n          }\n        }\n      }\n\n      wheels.push(dateGroup);\n    }\n\n    if (/time/i.test(preset)) {\n      timeParts = timeWheels.split(/\\|/.test(timeWheels) ? '|' : '');\n\n      for (i = 0; i < timeParts.length; i++) {\n        template = timeParts[i];\n        types = 0;\n\n        if (template.length) {\n          // If contains different characters\n          if (/h/i.test(template)) {\n            isoParts.h = 1;\n            types++;\n          }\n\n          if (/i/i.test(template)) {\n            isoParts.i = 1;\n            types++;\n          }\n\n          if (/s/i.test(template)) {\n            isoParts.s = 1;\n            types++;\n          }\n\n          if (/a/i.test(template)) {\n            types++;\n          }\n        }\n\n        if (types > 1 && wheelOrder.tt === undefined) {\n          wheelOrder.tt = nr;\n          nr++;\n          timeGroup.push(getTimeWheel(template));\n        } else if (/h/i.test(template) && wheelOrder.h === undefined) {\n          // Hours wheel\n          values = [];\n          wheelOrder.h = nr;\n          isoParts.h = 1;\n          nr++;\n\n          for (j = minHour; j < (hasAmPm ? 12 : 24); j += stepHour) {\n            values.push({\n              value: j,\n              display: hasAmPm && j === 0 ? 12 : /hh/i.test(timeDisplay) ? pad(j) : j\n            });\n          }\n\n          timeGroup.push({\n            cssClass: 'mbsc-dt-whl-h',\n            label: s.hourText,\n            data: values\n          });\n        } else if (/i/i.test(template) && wheelOrder.i === undefined) {\n          // Minutes wheel\n          values = [];\n          wheelOrder.i = nr;\n          isoParts.i = 1;\n          nr++;\n\n          for (j = minMinute; j < 60; j += stepMinute) {\n            values.push({\n              value: j,\n              display: /ii/i.test(timeDisplay) ? pad(j) : j\n            });\n          }\n\n          timeGroup.push({\n            cssClass: 'mbsc-dt-whl-i',\n            label: s.minuteText,\n            data: values\n          });\n        } else if (/s/i.test(template) && wheelOrder.s === undefined) {\n          // Seconds wheel\n          values = [];\n          wheelOrder.s = nr;\n          isoParts.s = 1;\n          nr++;\n\n          for (j = minSecond; j < 60; j += stepSecond) {\n            values.push({\n              value: j,\n              display: /ss/i.test(timeDisplay) ? pad(j) : j\n            });\n          }\n\n          timeGroup.push({\n            cssClass: 'mbsc-dt-whl-s',\n            label: s.secText,\n            data: values\n          });\n        } else if (/a/i.test(template) && wheelOrder.a === undefined) {\n          wheelOrder.a = nr;\n          nr++;\n          timeGroup.push({\n            cssClass: 'mbsc-dt-whl-a',\n            label: s.ampmText,\n            data: /A/.test(template) ? [{\n              value: 0,\n              display: s.amText.toUpperCase()\n            }, {\n              value: 1,\n              display: s.pmText.toUpperCase()\n            }] : [{\n              value: 0,\n              display: s.amText\n            }, {\n              value: 1,\n              display: s.pmText\n            }]\n          });\n        }\n      }\n\n      if (timeGroup != dateGroup) {\n        wheels.push(timeGroup);\n      }\n    }\n\n    return wheels;\n  } // --- TRIAL SERVER CODE END ---\n\n\n  function getHtml5Options($elm) {\n    var format,\n        min,\n        max,\n        ret = {}; // Force format for html5 date inputs (experimental)\n\n    if ($elm.is('input')) {\n      switch ($elm.attr('type')) {\n        case 'date':\n          format = 'yy-mm-dd';\n          break;\n\n        case 'datetime':\n          format = 'yy-mm-ddTHH:ii:ssZ';\n          break;\n\n        case 'datetime-local':\n          format = 'yy-mm-ddTHH:ii:ss';\n          break;\n\n        case 'month':\n          format = 'yy-mm';\n          ret.dateOrder = 'mmyy';\n          break;\n\n        case 'time':\n          format = 'HH:ii:ss';\n          break;\n      }\n\n      ret.format = format; // Check for min/max attributes\n\n      min = $elm.attr('min');\n      max = $elm.attr('max');\n\n      if (min && min != 'undefined') {\n        ret.min = parseDate(format, min);\n      }\n\n      if (max && max != 'undefined') {\n        ret.max = parseDate(format, max);\n      }\n    }\n\n    return ret;\n  }\n\n  function getClosestValidDate(d, dir) {\n    var next,\n        prev,\n        nextValid = false,\n        prevValid = false,\n        up = 0,\n        down = 0,\n        // Normalize min and max dates for comparing later (set default values where there are no values from wheels)\n    mind = minDate ? getDate(getArray(minDate)) : -Infinity,\n        maxd = maxDate ? getDate(getArray(maxDate)) : Infinity;\n\n    if (isValid(d)) {\n      return d;\n    }\n\n    if (d < mind) {\n      d = mind;\n    }\n\n    if (d > maxd) {\n      d = maxd;\n    }\n\n    next = d;\n    prev = d;\n\n    if (dir !== 2) {\n      nextValid = isValid(next, true);\n\n      while (!nextValid && next < maxd && up < 100) {\n        next = new Date(next.getTime() + 1000 * 60 * 60 * 24);\n        nextValid = isValid(next, true);\n        up++;\n      }\n    }\n\n    if (dir !== 1) {\n      prevValid = isValid(prev, true);\n\n      while (!prevValid && prev > mind && down < 100) {\n        prev = new Date(prev.getTime() - 1000 * 60 * 60 * 24);\n        prevValid = isValid(prev, true);\n        down++;\n      }\n    }\n\n    if (dir === 1 && nextValid) {\n      return next;\n    }\n\n    if (dir === 2 && prevValid) {\n      return prev;\n    }\n\n    if (isSameMonth(d, next)) {\n      return next;\n    }\n\n    if (isSameMonth(d, prev)) {\n      return prev;\n    }\n\n    return down <= up && prevValid ? prev : next;\n  }\n\n  function isSameMonth(d1, d2) {\n    return s.getYear(d1) === s.getYear(d2) && s.getMonth(d1) === s.getMonth(d2);\n  }\n\n  function isValid(d, skip) {\n    if (!skip && d < minDate) {\n      return false;\n    }\n\n    if (!skip && d > maxDate) {\n      return false;\n    }\n\n    if (isInObj(d, valid)) {\n      return true;\n    }\n\n    if (isInObj(d, invalid)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  function isInObj(d, obj) {\n    var curr, j, v, val;\n\n    if (obj) {\n      for (j = 0; j < obj.length; j++) {\n        curr = obj[j];\n        val = curr.d || curr;\n        v = val + '';\n\n        if (!curr.start) {\n          if (DAY_OF_WEEK.test(v)) {\n            // Day of week\n            v = +v.replace('w', '');\n\n            if (v == d.getDay()) {\n              return true;\n            }\n          } else if (DAY_OF_MONTH.test(v)) {\n            // Day of month: '2' or '12/24'\n            v = v.split('/');\n\n            if (v[1]) {\n              if (v[0] - 1 == d.getMonth() && v[1] == d.getDate()) {\n                return true;\n              }\n            } else if (v[0] == d.getDate()) {\n              return true;\n            }\n          } else {\n            // Exact date\n            curr = makeDate(val, format, s);\n\n            if (d.getFullYear() == curr.getFullYear() && d.getMonth() == curr.getMonth() && d.getDate() == curr.getDate()) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  function validateDates(obj, y, m, first, maxdays, invalids, val) {\n    var d, dd, j, k, v;\n\n    if (obj) {\n      for (j = 0; j < obj.length; j++) {\n        d = obj[j];\n        dd = d.d || d;\n        v = dd + '';\n\n        if (!d.start) {\n          if (DAY_OF_WEEK.test(v)) {\n            // Day of week\n            v = +v.replace('w', '');\n\n            for (k = v - first; k < maxdays; k += 7) {\n              if (k >= 0) {\n                invalids[k + 1] = val;\n              }\n            }\n          } else if (DAY_OF_MONTH.test(v)) {\n            // Day of month: '2' or '12/24'\n            v = v.split('/');\n\n            if (v[1]) {\n              if (v[0] - 1 == m) {\n                invalids[v[1]] = val;\n              }\n            } else {\n              invalids[v[0]] = val;\n            }\n          } else {\n            // Exact date\n            d = makeDate(dd, format, s);\n\n            if (s.getYear(d) == y && s.getMonth(d) == m) {\n              invalids[s.getDay(d)] = val;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  function validateTimes(vobj, index, v, y, m, d, invalids, valid) {\n    var add,\n        all,\n        dd,\n        hours1,\n        hours2,\n        hours3,\n        i,\n        i1,\n        i2,\n        j,\n        obj,\n        parts1,\n        parts2,\n        prop1,\n        prop2,\n        remove,\n        ss,\n        str,\n        v1,\n        v2,\n        spec = {},\n        day = s.getDate(y, m, d),\n        w = ['a', 'h', 'i', 's'];\n\n    if (vobj) {\n      // Check if rules apply to the selected date\n      for (i = 0; i < vobj.length; i++) {\n        obj = vobj[i];\n\n        if (obj.start) {\n          obj.apply = false;\n          dd = obj.d;\n          ss = dd + '';\n          str = ss.split('/');\n\n          if (dd && (dd.getTime && y == s.getYear(dd) && m == s.getMonth(dd) && d == s.getDay(dd) || // Exact date\n          !DAY_OF_WEEK.test(ss) && (str[1] && d == str[1] && m == str[0] - 1 || !str[1] && d == str[0]) || // Day of month\n          DAY_OF_WEEK.test(ss) && day.getDay() == +ss.replace('w', '') // Day of week\n          )) {\n            obj.apply = true;\n            spec[day] = true; // Prevent applying generic rule on day, if specific exists\n          }\n        }\n      } // Apply rules\n\n\n      for (i = 0; i < vobj.length; i++) {\n        obj = vobj[i];\n        add = 0;\n        remove = 0;\n        i1 = mins[v];\n        i2 = maxs[v];\n        prop1 = true;\n        prop2 = true;\n        all = false;\n\n        if (obj.start && (obj.apply || !obj.d && !spec[day])) {\n          // Define time parts\n          parts1 = obj.start.split(':');\n          parts2 = obj.end.split(':');\n\n          for (j = 0; j < 3; j++) {\n            if (parts1[j] === undefined) {\n              parts1[j] = 0;\n            }\n\n            if (parts2[j] === undefined) {\n              parts2[j] = 59;\n            }\n\n            parts1[j] = +parts1[j];\n            parts2[j] = +parts2[j];\n          }\n\n          if (v == 'tt') {\n            // Wheel containing full time\n            i1 = step(Math.round((new Date(day).setHours(parts1[0], parts1[1], parts1[2]) - new Date(day).setHours(0, 0, 0, 0)) / 1000), timeStep, 0, 86400);\n            i2 = step(Math.round((new Date(day).setHours(parts2[0], parts2[1], parts2[2]) - new Date(day).setHours(0, 0, 0, 0)) / 1000), timeStep, 0, 86400);\n          } else {\n            parts1.unshift(parts1[0] > 11 ? 1 : 0);\n            parts2.unshift(parts2[0] > 11 ? 1 : 0);\n\n            if (hasAmPm) {\n              if (parts1[1] >= 12) {\n                parts1[1] = parts1[1] - 12;\n              }\n\n              if (parts2[1] >= 12) {\n                parts2[1] = parts2[1] - 12;\n              }\n            } // Look behind\n\n\n            for (j = 0; j < index; j++) {\n              if (validValues[j] !== undefined) {\n                v1 = step(parts1[j], steps[w[j]], mins[w[j]], maxs[w[j]]);\n                v2 = step(parts2[j], steps[w[j]], mins[w[j]], maxs[w[j]]);\n                hours1 = 0;\n                hours2 = 0;\n                hours3 = 0;\n\n                if (hasAmPm && j == 1) {\n                  hours1 = parts1[0] ? 12 : 0;\n                  hours2 = parts2[0] ? 12 : 0;\n                  hours3 = validValues[0] ? 12 : 0;\n                }\n\n                if (!prop1) {\n                  v1 = 0;\n                }\n\n                if (!prop2) {\n                  v2 = maxs[w[j]];\n                }\n\n                if ((prop1 || prop2) && v1 + hours1 < validValues[j] + hours3 && validValues[j] + hours3 < v2 + hours2) {\n                  all = true;\n                }\n\n                if (validValues[j] != v1) {\n                  prop1 = false;\n                }\n\n                if (validValues[j] != v2) {\n                  prop2 = false;\n                }\n              }\n            } // Look ahead\n\n\n            if (!valid) {\n              for (j = index + 1; j < 4; j++) {\n                if (parts1[j] > 0) {\n                  add = steps[v];\n                }\n\n                if (parts2[j] < maxs[w[j]]) {\n                  remove = steps[v];\n                }\n              }\n            }\n\n            if (!all) {\n              // Calculate min and max values\n              v1 = step(parts1[index], steps[v], mins[v], maxs[v]) + add;\n              v2 = step(parts2[index], steps[v], mins[v], maxs[v]) - remove;\n\n              if (prop1) {\n                i1 = v1;\n              }\n\n              if (prop2) {\n                i2 = v2;\n              }\n            }\n          } // Disable values\n\n\n          if (prop1 || prop2 || all) {\n            for (j = i1; j <= i2; j += steps[v]) {\n              invalids[j] = !valid;\n            }\n          }\n        }\n      }\n    }\n  } // --- TRIAL SERVER CODE START ---\n\n\n  var timeStep,\n      oneDateWheel,\n      wheels,\n      wheelOrder = {},\n      innerValues = {},\n      isoParts = {},\n      validValues = [],\n      html5def = getHtml5Options($$1(this)),\n      orig = extend$1({}, inst.settings),\n      calendarSystem = calendars[orig.calendarSystem],\n      s = extend$1(inst.settings, dateTimeDefaults, calendarSystem, defaults$1, html5def, orig),\n      preset = s.preset,\n      displayFormat = preset == 'datetime' ? s.dateFormat + s.separator + s.timeFormat : preset == 'time' ? s.timeFormat : s.dateFormat,\n      format = html5def.format || displayFormat,\n      dateWheels = s.dateWheels || s.dateFormat,\n      timeWheels = s.timeWheels || s.timeFormat,\n      //dateWheels = '|D M d|', // TODO settings\n  //timeWheels = '|h|ii|A|',\n  dateDisplay = s.dateWheels || s.dateDisplay,\n      timeDisplay = timeWheels,\n      baseTheme = s.baseTheme || s.theme,\n      invalid = convertRanges(s.invalid),\n      valid = convertRanges(s.valid),\n      minDate = makeDate(s.min, format, s),\n      maxDate = makeDate(s.max, format, s),\n      hasTime = /time/i.test(preset),\n      hasAmPm = /h/.test(timeDisplay),\n      genDayNames = /D/.test(dateDisplay),\n      stepParts = s.steps || {},\n      stepHour = stepParts.hour || s.stepHour || 1,\n      stepMinute = stepParts.minute || s.stepMinute || 1,\n      stepSecond = stepParts.second || s.stepSecond || 1,\n      zeroBased = stepParts.zeroBased,\n      minHour = zeroBased || !minDate ? 0 : minDate.getHours() % stepHour,\n      minMinute = zeroBased || !minDate ? 0 : minDate.getMinutes() % stepMinute,\n      minSecond = zeroBased || !minDate ? 0 : minDate.getSeconds() % stepSecond,\n      maxHour = getMax(stepHour, minHour, hasAmPm ? 11 : 23),\n      maxMinute = getMax(stepMinute, minMinute, 59),\n      maxSecond = getMax(stepMinute, minMinute, 59),\n      mins = {\n    y: minDate ? minDate.getFullYear() : -Infinity,\n    m: 0,\n    d: 1,\n    h: minHour,\n    i: minMinute,\n    s: minSecond,\n    a: 0,\n    tt: 0\n  },\n      maxs = {\n    y: maxDate ? maxDate.getFullYear() : Infinity,\n    m: 11,\n    d: 31,\n    h: maxHour,\n    i: maxMinute,\n    s: maxSecond,\n    a: 1,\n    tt: 86400\n  },\n      steps = {\n    y: 1,\n    m: 1,\n    d: 1,\n    h: stepHour,\n    i: stepMinute,\n    s: stepSecond,\n    a: 1,\n    tt: 1\n  },\n      widths = {\n    bootstrap: 46,\n    ios: 50,\n    material: 46,\n    mobiscroll: 46,\n    windows: 50\n  },\n      getDatePart = {\n    y: getYear,\n    m: getMonth,\n    d: getDay,\n    h: getHours,\n    i: getMinutes,\n    s: getSeconds,\n    u: getMilliseconds,\n    a: getAmPm,\n    dd: getFullDate,\n    tt: getFullTime\n  }; // --- TRIAL SERVER CODE END ---\n  // Extended methods\n  // ---\n\n  inst.getVal = function (temp) {\n    return inst._hasValue || temp ? returnDate(getDate(inst.getArrayVal(temp)), s, format) : null;\n  };\n  /**\r\n   * Returns the selected date.\r\n   *\r\n   * @param {Boolean} [temp=false] If true, return the currently shown date on the picker, otherwise the last selected one.\r\n   * @return {Date}\r\n   */\n\n\n  inst.getDate = function (temp) {\n    return inst._hasValue || temp ? getDate(inst.getArrayVal(temp)) : null;\n  };\n  /**\r\n   * Sets the selected date\r\n   *\r\n   * @param {Date} d Date to select.\r\n   * @param {Boolean} [fill=false] Also set the value of the associated input element. Default is true.\r\n   * @param {Number} [time=0] Animation time to scroll to the selected date.\r\n   * @param {Boolean} [temp=false] Set temporary value only.\r\n   * @param {Boolean} [change=fill] Trigger change on input element.\r\n   */\n\n\n  inst.setDate = function (d, fill, time, temp, change) {\n    inst.setArrayVal(getArray(d, true), fill, change, temp, time);\n  }; // ---\n  // Initializations\n  // ---\n\n\n  wheels = getWheels();\n  s.isoParts = isoParts;\n  inst._format = displayFormat;\n  inst._order = wheelOrder;\n\n  inst.handlers.now = function () {\n    inst.setDate(new Date(), inst.live, 1000, true, true);\n  };\n\n  inst.buttons.now = {\n    text: s.nowText,\n    icon: s.nowIcon,\n    handler: 'now'\n  }; // ---\n\n  return {\n    minWidth: oneDateWheel && hasTime ? widths[baseTheme] : undefined,\n    compClass: 'mbsc-dt mbsc-sc',\n    wheels: wheels,\n    headerText: s.headerText ? function () {\n      return formatDate(displayFormat, getDate(inst.getArrayVal(true)), s);\n    } : false,\n    formatValue: function formatValue(d) {\n      return formatDate(format, getDate(d), s);\n    },\n    parseValue: function parseValue(val) {\n      if (!val) {\n        innerValues = {};\n        inst._hasValue = false;\n      }\n\n      return getArray(makeDate(val || s.defaultValue || new Date(), format, s, isoParts), !!val);\n    },\n    validate: function validate(data) {\n      var i,\n          j,\n          dayStr,\n          weekDay,\n          values = data.values,\n          index = data.index,\n          dir = data.direction,\n          dayWheel = s.wheels[0][wheelOrder.d],\n          validated = getClosestValidDate(getDate(values), dir),\n          temp = getArray(validated),\n          disabled = [],\n          wheels = {},\n          y = getDatePart.y(validated),\n          //get(temp, 'y'),\n      m = getDatePart.m(validated),\n          //get(temp, 'm'),\n      maxdays = s.getMaxDayOfMonth(y, m),\n          minprop = true,\n          maxprop = true;\n      $$1.each(['dd', 'y', 'm', 'd', 'tt', 'a', 'h', 'i', 's'], function (x, i) {\n        var min = mins[i],\n            max = maxs[i],\n            val = getDatePart[i](validated);\n        disabled[wheelOrder[i]] = [];\n\n        if (minprop && minDate) {\n          min = getDatePart[i](minDate);\n        }\n\n        if (maxprop && maxDate) {\n          max = getDatePart[i](maxDate);\n        }\n\n        if (val < min) {\n          val = min;\n        }\n\n        if (val > max) {\n          val = max;\n        }\n\n        if (i !== 'dd' && i !== 'tt') {\n          if (minprop) {\n            minprop = val == min;\n          }\n\n          if (maxprop) {\n            maxprop = val == max;\n          }\n        }\n\n        if (wheelOrder[i] !== undefined) {\n          if (i != 'y' && i != 'dd') {\n            for (j = mins[i]; j <= maxs[i]; j += steps[i]) {\n              if (j < min || j > max) {\n                disabled[wheelOrder[i]].push(j);\n              }\n            }\n          } // Disable some days\n\n\n          if (i == 'd') {\n            var first = s.getDate(y, m, 1).getDay(),\n                invalids = {}; // Set invalid indexes\n\n            validateDates(invalid, y, m, first, maxdays, invalids, 1); // Delete indexes which are valid\n\n            validateDates(valid, y, m, first, maxdays, invalids, 0);\n            $$1.each(invalids, function (j, v) {\n              if (v) {\n                disabled[wheelOrder[i]].push(j);\n              }\n            });\n          }\n        }\n      }); // Invalid times\n\n      if (hasTime) {\n        $$1.each(['a', 'h', 'i', 's', 'tt'], function (i, v) {\n          var val = getDatePart[v](validated),\n              d = getDatePart.d(validated),\n              invalids = {};\n\n          if (wheelOrder[v] !== undefined) {\n            validateTimes(invalid, i, v, y, m, d, invalids, 0);\n            validateTimes(valid, i, v, y, m, d, invalids, 1);\n            $$1.each(invalids, function (j, x) {\n              if (x) {\n                disabled[wheelOrder[v]].push(j);\n              }\n            }); // Get valid value\n\n            validValues[i] = inst.getValidValue(wheelOrder[v], val, dir, invalids);\n          }\n        });\n      } // Regenerate day wheel if number of days in month changes\n      // or if day names needs to be regenerated\n\n\n      if (dayWheel && (dayWheel.data.length !== maxdays || genDayNames && (index === undefined || index === wheelOrder.y || index === wheelOrder.m))) {\n        wheels[wheelOrder.d] = dayWheel;\n        dayWheel.data = [];\n\n        for (i = 1; i <= maxdays; i++) {\n          weekDay = s.getDate(y, m, i).getDay();\n          dayStr = dateDisplay.replace(/[my|]/gi, '').replace(/dd/, (i < 10 ? '0' + i : i) + (s.daySuffix || '')).replace(/d/, i + (s.daySuffix || ''));\n          dayWheel.data.push({\n            value: i,\n            display: /DD/.test(dayStr) ? dayStr.replace(/DD/, '<span class=\"mbsc-dt-day\">' + s.dayNames[weekDay] + '</span>') : dayStr.replace(/D/, '<span class=\"mbsc-dt-day\">' + s.dayNamesShort[weekDay] + '</span>')\n          });\n        } // Need to update day value, if out of month\n\n\n        inst._tempWheelArray[wheelOrder.d] = temp[wheelOrder.d];\n        inst.changeWheel(wheels);\n      }\n\n      return {\n        disabled: disabled,\n        valid: temp\n      };\n    }\n  };\n};\n\nvar id$1 = 0;\n\nfunction jsonp(url, callback) {\n  var script = document.createElement('script'),\n      unique = 'mbscjsonp' + ++id$1;\n\n  window[unique] = function (data) {\n    script.parentNode.removeChild(script);\n    delete window[unique];\n\n    if (!data) {\n      return;\n    }\n\n    callback(data);\n  };\n\n  script.src = url + (url.indexOf('?') >= 0 ? '&' : '?') + 'callback=' + unique;\n  document.body.appendChild(script);\n}\n\nfunction ajaxGet(url, callback) {\n  var request = new XMLHttpRequest();\n  request.open('GET', url, true);\n\n  request.onload = function () {\n    if (this.status >= 200 && this.status < 400) {\n      // Success!\n      callback(JSON.parse(this.response));\n    } //else {\n    // We reached our target server, but it returned an error\n    //}\n\n  };\n\n  request.onerror = function () {// There was a connection error of some sort\n  };\n\n  request.send();\n}\n\nfunction getJson(url, callback, type) {\n  if (type == 'jsonp') {\n    jsonp(url, callback);\n  } else {\n    ajaxGet(url, callback);\n  }\n}\n\nutil.getJson = getJson; // eslint-disable-next-line no-unused-vars\n\nvar defaults$2 = {\n  controls: ['calendar'],\n  firstDay: 0,\n  weekDays: 'short',\n  maxMonthWidth: 170,\n  breakPointMd: 768,\n  months: 1,\n  pageBuffer: 1,\n  weeks: 6,\n  highlight: true,\n  outerMonthChange: true,\n  quickNav: true,\n  yearChange: true,\n  tabs: 'auto',\n  // CSS classes\n  todayClass: 'mbsc-cal-today',\n  btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left6',\n  btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right6',\n  // Localization\n  dateText: 'Date',\n  timeText: 'Time',\n  todayText: 'Today',\n  fromText: 'Start',\n  toText: 'End',\n  moreEventsText: '{count} more',\n  prevMonthText: 'Previous Month',\n  nextMonthText: 'Next Month',\n  prevYearText: 'Previous Year',\n  nextYearText: 'Next Year'\n}; // --- TRIAL SERVER CODE END ---\n\nvar CalendarBase = function CalendarBase(inst) {\n  var $calendar,\n      $markup,\n      $monthHdr,\n      $monthPicker,\n      $tabPaneCont,\n      $tabPanes,\n      $yearHdr,\n      $yearPicker,\n      activeDate,\n      base,\n      calRows,\n      calSize,\n      calWidth,\n      context,\n      controls,\n      controlsArray,\n      cssDisabled,\n      cssSelected,\n      cssSelectedTab,\n      currFirstDay,\n      dayLabels,\n      dayProps,\n      dayScroll,\n      displayFormat,\n      firstWeekDay,\n      hasCal,\n      hasLabels,\n      hasMarks,\n      hasTabs,\n      // hasText,\n  hasQuickNav,\n      hoverTimer,\n      invalidObj,\n      isCellHover,\n      isDayClick,\n      isLiquid,\n      isMonthView,\n      isPageMove,\n      isRTL,\n      isVertical,\n      labelsObj,\n      markedObj,\n      colorsObj,\n      maxDate,\n      maxFirstYear,\n      maxLabels,\n      maxMonth,\n      maxYear,\n      minDate,\n      minFirstYear,\n      minMonth,\n      minYear,\n      monthIndex,\n      monthNames,\n      monthScroll,\n      needsSlide,\n      needsRefresh,\n      pageBuffer,\n      pageNr,\n      pageOffset,\n      pageTotal,\n      rtl,\n      s,\n      selectedDate,\n      showOuterDays,\n      trigger,\n      validObj,\n      visibleTab,\n      wasTouched,\n      weekCounter,\n      weekDays,\n      yearChange,\n      yearIndex,\n      yearScroll,\n      yearSuffix,\n      labelIdx = 1,\n      elm = this;\n\n  function showCont($cont) {\n    if ($cont.hasClass('mbsc-cal-h')) {\n      $cont.removeClass('mbsc-cal-h');\n    }\n  }\n\n  function hideCont($cont) {\n    if (!$cont.hasClass('mbsc-cal-h')) {\n      $cont.addClass('mbsc-cal-h');\n    }\n  }\n\n  function toggleCont($cont) {\n    if ($cont.hasClass('mbsc-cal-h')) {\n      showCont($cont);\n    } else {\n      hideCont($cont);\n    }\n  }\n\n  function preProcessSettings() {\n    var ctrls, layout, orig;\n    controls = {};\n    controlsArray = [];\n    dayLabels = {};\n    trigger = inst.trigger;\n    orig = extend$1({}, inst.settings);\n    s = extend$1(inst.settings, defaults$2, orig);\n    ctrls = s.controls.join(',');\n    firstWeekDay = s.firstDay;\n    isRTL = s.rtl;\n    pageBuffer = s.pageBuffer;\n    weekCounter = s.weekCounter;\n    calRows = s.weeks;\n    isMonthView = calRows == 6;\n    isVertical = s.calendarScroll == 'vertical';\n    context = inst._getRespCont();\n    weekDays = s.weekDays == 'full' ? '' : s.weekDays == 'min' ? 'Min' : 'Short';\n    layout = s.layout || (s.display == 'inline' || /top|bottom/.test(s.display) && s.touchUi ? 'liquid' : '');\n    isLiquid = layout == 'liquid'; // && s.display !== 'bubble';\n\n    calWidth = isLiquid ? null : s.calendarWidth;\n    rtl = isRTL && !isVertical ? -1 : 1;\n    cssDisabled = 'mbsc-disabled ' + (s.disabledClass || '');\n    cssSelectedTab = 'mbsc-selected ' + (s.selectedTabClass || '');\n    cssSelected = 'mbsc-selected ' + (s.selectedClass || '');\n    maxLabels = Math.max(1, Math.floor(((s.calendarHeight || 0) / calRows - 45) / 18));\n\n    if (ctrls.match(/calendar/)) {\n      controls.calendar = 1;\n      hasCal = true;\n    } // Allow date scroller only if calendar not present\n\n\n    if (ctrls.match(/date/) && !hasCal) {\n      controls.date = 1;\n    }\n\n    if (ctrls.match(/time/)) {\n      controls.time = 1;\n    }\n\n    s.controls.forEach(function (v) {\n      if (controls[v]) {\n        controlsArray.push(v);\n      }\n    }); // Disable quick nav for week view\n\n    hasQuickNav = s.quickNav && hasCal && isMonthView; // Disable year change for week view\n\n    yearChange = s.yearChange && isMonthView; // Fullscreen mode\n\n    if (isLiquid && hasCal && s.display == 'center') {\n      inst._isFullScreen = true;\n    }\n\n    s.layout = layout; // Pass back to core if set to liquid\n\n    s.preset = (controls.date || hasCal ? 'date' : '') + (controls.time ? 'time' : '');\n  }\n\n  function postProcessSettings() {\n    monthNames = yearChange ? s.monthNamesShort : s.monthNames;\n    yearSuffix = s.yearSuffix || '';\n    monthIndex = (s.dateWheels || s.dateFormat).search(/m/i);\n    yearIndex = (s.dateWheels || s.dateFormat).search(/y/i);\n    displayFormat = inst._format;\n\n    if (s.min) {\n      minDate = getDateOnly(makeDate(s.min, displayFormat, s));\n      minYear = s.getYear(minDate);\n      minMonth = s.getMonth(minDate);\n      minFirstYear = s.getDate(Math.floor(minYear / 12) * 12, 0, 1);\n    }\n\n    if (s.max) {\n      maxDate = getDateOnly(makeDate(s.max, displayFormat, s));\n      maxYear = s.getYear(maxDate);\n      maxMonth = s.getMonth(maxDate);\n      maxFirstYear = s.getDate(Math.floor(maxYear / 12) * 12, 0, 1);\n    }\n\n    inst._minDate = minDate;\n    inst._maxDate = maxDate;\n  }\n\n  function addToList(obj, d, ev) {\n    obj[d] = obj[d] || [];\n    obj[d].push(ev);\n  }\n\n  function prepareObj(list, start, end) {\n    var d,\n        v,\n        year,\n        month,\n        day,\n        maxDays,\n        endTime,\n        startTime,\n        getDate = s.getDate,\n        getYear = s.getYear,\n        getMonth = s.getMonth,\n        getDay = s.getDay,\n        getMaxDayOfMonth = s.getMaxDayOfMonth,\n        startYear = getYear(start),\n        startMonth = getMonth(start),\n        obj = {};\n\n    if (list) {\n      $$1.each(list, function (i, ev) {\n        d = ev.d || ev.start || ev;\n        v = d + '';\n\n        if (ev.start && ev.end) {\n          startTime = getDateOnly(makeDate(ev.start, displayFormat, s));\n          endTime = getDateOnly(makeDate(ev.end, displayFormat, s));\n\n          while (startTime <= endTime) {\n            addToList(obj, startTime, ev);\n            startTime = getDate(getYear(startTime), getMonth(startTime), getDay(startTime) + 1);\n          }\n        } else if (DAY_OF_WEEK.test(v)) {\n          // Day of week\n          startTime = getFirstDay(start, false, +v.replace('w', ''));\n\n          while (startTime <= end) {\n            addToList(obj, startTime, ev);\n            startTime = getDate(getYear(startTime), getMonth(startTime), getDay(startTime) + 7);\n          }\n        } else if (DAY_OF_MONTH.test(v)) {\n          // Day of month: '2' or '12/24'\n          v = v.split('/');\n          var hasMonth = !!v[1],\n              yearInc = hasMonth ? 1 : 0,\n              monthInc = hasMonth ? 0 : 1,\n              vMonth = hasMonth ? v[0] - 1 : startMonth,\n              vDay = hasMonth ? +v[1] : +v[0];\n          maxDays = getMaxDayOfMonth(startYear, vMonth);\n          startTime = getDate(startYear, vMonth, Math.min(vDay, maxDays));\n\n          while (startTime <= end) {\n            year = getYear(startTime);\n            month = getMonth(startTime);\n            day = getDay(startTime);\n\n            if (day === vDay) {\n              addToList(obj, startTime, ev);\n            }\n\n            maxDays = getMaxDayOfMonth(year + yearInc, month + monthInc);\n            startTime = getDate(year + yearInc, month + monthInc, Math.min(vDay, maxDays));\n          }\n        } else {\n          // Exact date\n          addToList(obj, getDateOnly(makeDate(d, displayFormat, s)), ev);\n        }\n      });\n    }\n\n    return obj;\n  }\n\n  function isValidDate(d) {\n    if (d < minDate) {\n      return false;\n    }\n\n    if (d > maxDate) {\n      return false;\n    }\n\n    return invalidObj[d] === undefined || validObj[d] !== undefined;\n  }\n\n  function getDayProps(d) {\n    var i,\n        mark,\n        markedMarkup,\n        props,\n        marked = markedObj[d] ? markedObj[d] : false,\n        colors = colorsObj[d] ? colorsObj[d] : false,\n        background = colors && colors[0].background ? colors[0].background : marked && marked[0].background,\n        cssClass = '';\n\n    if (colors) {\n      for (i = 0; i < colors.length; i++) {\n        cssClass += (colors[i].cssClass || '') + ' ';\n      }\n    }\n\n    if (marked) {\n      // Marks\n      markedMarkup = '<div class=\"mbsc-cal-marks\">';\n\n      for (i = 0; i < marked.length; i++) {\n        mark = marked[i];\n        cssClass += (mark.cssClass || '') + ' ';\n        markedMarkup += '<div class=\"mbsc-cal-mark\"' + (mark.color ? ' style=\"background:' + mark.color + ';\"' : '') + '></div>';\n      }\n\n      markedMarkup += '</div>';\n    }\n\n    props = {\n      marked: marked,\n      background: background,\n      cssClass: cssClass,\n      // ariaLabel: hasText ? txt : '',\n      markup: dayLabels[d] ? dayLabels[d].join('') : hasMarks ? markedMarkup : ''\n    };\n    return extend$1(props, inst._getDayProps(d, props));\n  }\n\n  function getOffsetStyle(offset) {\n    return ' style=\"' + (isVertical ? 'transform: translateY(' + offset * 100 + '%)' : 'left:' + offset * 100 * rtl + '%') + '\"';\n  }\n\n  function calcMonthNr() {\n    // Calculate pageNr\n    pageNr = s.months == 'auto' ? // Exact month number from setting\n    Math.max(1, // Min 1 month\n    Math.min(3, // Max 3 months\n    Math.floor((calWidth || getWidth(context)) / 280))) : +s.months;\n    pageTotal = pageNr + 2 * pageBuffer;\n    pageOffset = 0; //Math.round(pageNr / 2) - 1;\n    // Don't allow vertical scroll with multiple months\n\n    isVertical = isVertical && pageNr < 2; // Don't show outer days by default for multiple months or vertical scroll\n\n    showOuterDays = s.showOuterDays === undefined ? pageNr < 2 && !isVertical || !isMonthView : s.showOuterDays;\n  }\n\n  function constrain(d) {\n    if (getPageDay(d, pageNr - 1) > maxDate) {\n      d = getPageDay(maxDate, 1 - pageNr);\n    }\n\n    if (d < minDate) {\n      d = minDate;\n    }\n\n    return d;\n  }\n\n  function getLabelMarkup(event, i, showText) {\n    var noBg = event.background === 'none';\n    var color = noBg ? 'none' : event.color;\n    var txtColor = noBg ? event.color : getTextColor(color);\n    var txt = event.text;\n    return '<div data-id=\"' + event._id + '\" data-index=\"' + i + '\" class=\"mbsc-cal-txt' + (noBg ? ' mbsc-cal-txt-only' : '') + '\" title=\"' + $$1('<div>' + txt + '</div>').text() + '\"' + (color ? ' style=\"background:' + color + (showText && txtColor ? ';color:' + txtColor : '') + ';\"' : '') + '>' + (showText ? txt : '') + '</div>';\n  }\n\n  function onGenMonth(d) {\n    var start = getFirstDay(getPageDay(d, -pageOffset - pageBuffer), false);\n    var end = getFirstDay(getPageDay(d, -pageOffset + pageNr + pageBuffer - 1), false);\n    end = s.getDate(s.getYear(end), s.getMonth(end), s.getDay(end) + calRows * 7);\n\n    inst._onGenMonth(start, end);\n\n    invalidObj = prepareObj(s.invalid, start, end);\n    validObj = prepareObj(s.valid, start, end);\n    markedObj = prepareObj(s.labels || s.events || s.marked, start, end);\n    colorsObj = prepareObj(s.colors, start, end);\n    labelsObj = inst._labels || markedObj || colorsObj;\n    hasLabels = s.labels || inst._labels; // Multiple labels\n\n    if (hasLabels) {\n      (function () {\n        dayLabels = {};\n        var eventRows = {};\n        var day = start;\n\n        var _loop = function _loop() {\n          if (day.getDay() == firstWeekDay) {\n            eventRows = {};\n          }\n\n          var maxRows = maxLabels;\n          var events = labelsObj[day] || [];\n          var eventsNr = events.length;\n          var labels = [];\n          var prevEvent = void 0;\n          var prevIndex = void 0;\n          var row = 0;\n          var displayed = 0;\n          var i = 0;\n          var width = void 0;\n\n          while (row < maxRows) {\n            prevEvent = null; // Check  if there are any events already in this row\n\n            events.forEach(function (ev, j) {\n              if (eventRows[row] == ev) {\n                prevEvent = ev;\n                prevIndex = j;\n              }\n            });\n\n            if (row == maxRows - 1 && (displayed < eventsNr - 1 || eventsNr && i == eventsNr && !prevEvent)) {\n              var nr = eventsNr - displayed;\n              var txt = (nr > 1 ? s.moreEventsPluralText || s.moreEventsText : s.moreEventsText).replace(/{count}/, nr);\n\n              if (nr) {\n                labels.push('<div class=\"mbsc-cal-txt-more\">' + txt + '</div>');\n              } // Remove event from previous days and replace it with more label\n\n\n              if (prevEvent) {\n                eventRows[row] = null;\n\n                prevEvent._days.forEach(function (d) {\n                  dayLabels[d][row] = '<div class=\"mbsc-cal-txt-more\">' + s.moreEventsText.replace(/{count}/, 1) + '</div>';\n                });\n              }\n\n              displayed++;\n              row++;\n            } else if (prevEvent) {\n              if (prevIndex == i) {\n                i++;\n              }\n\n              if (isSameDay(day, makeDate(prevEvent.end))) {\n                eventRows[row] = null;\n              }\n\n              labels.push(getLabelMarkup(prevEvent, prevIndex));\n              row++;\n              displayed++;\n\n              prevEvent._days.push(day);\n            } else if (i < eventsNr) {\n              var event = events[i];\n              var startTime = event.start && makeDate(event.start);\n              var endTime = event.end && makeDate(event.end);\n              var weekDay = day.getDay();\n              var offset = firstWeekDay - weekDay > 0 ? 7 : 0;\n              var multiDay = endTime && !isSameDay(startTime, endTime);\n\n              if (!startTime || // all day event\n              isSameDay(day, startTime) || // event start day\n              weekDay == firstWeekDay // first day of week (if event continues from prev week))\n              ) {\n                if (event._id === undefined) {\n                  event._id = labelIdx++;\n                }\n\n                if (multiDay) {\n                  eventRows[row] = event;\n                }\n\n                event._days = [day];\n                width = multiDay ? Math.min(getDayDiff(day, getDateOnly(endTime)) + 1, 7 + firstWeekDay - weekDay - offset) * 100 : 100;\n                labels.push(multiDay ? '<div class=\"mbsc-cal-txt-w\" style=\"width:' + width + '%\">' + getLabelMarkup(event, i, true) + '</div>' + getLabelMarkup(event, i) : getLabelMarkup(event, i, true));\n                row++;\n                displayed++;\n              }\n\n              i++;\n            } else {\n              labels.push('<div class=\"mbsc-cal-txt-ph\"></div>');\n              row++;\n            }\n          }\n\n          dayLabels[day] = labels;\n          day = s.getDate(s.getYear(day), s.getMonth(day), s.getDay(day) + 1);\n        };\n\n        while (day < end) {\n          _loop();\n        }\n      })();\n    }\n  }\n\n  function onBeforeMonthChange(d) {\n    var y = s.getYear(d),\n        m = s.getMonth(d);\n    currFirstDay = d;\n    activeDate = d;\n    setTitle(d);\n    trigger('onMonthChange', {\n      year: y,\n      month: m\n    });\n    trigger('onMonthLoading', {\n      year: y,\n      month: m\n    });\n    trigger('onPageChange', {\n      firstDay: d\n    });\n    trigger('onPageLoading', {\n      firstDay: d\n    });\n    onGenMonth(d);\n  }\n\n  function onAfterMonthChange(d) {\n    var y = s.getYear(d),\n        m = s.getMonth(d);\n\n    if (needsRefresh === undefined) {\n      onPageLoaded(d, y, m);\n    } else {\n      genAllMonths(d, needsRefresh, true);\n    }\n\n    focusDate(activeDate, dayScroll.focus);\n    dayScroll.focus = false;\n  }\n\n  function onPageLoaded(d, y, m) {\n    var $scroller = dayScroll.$scroller;\n    $$1('.mbsc-cal-slide', $scroller).removeClass('mbsc-cal-slide-a');\n    $$1('.mbsc-cal-slide', $scroller).slice(pageBuffer, pageBuffer + pageNr).addClass('mbsc-cal-slide-a');\n    $$1('.mbsc-cal-slide-a .mbsc-cal-day', $scroller).on('mouseenter', function () {\n      var $cell = $$1(this);\n\n      if (!wasTouched && !isPageMove) {\n        hoverTimer = setTimeout(function () {\n          isCellHover = true;\n          trigger('onCellHoverIn', getDayInfo($cell));\n        }, 150);\n      }\n    }).on('mouseleave', function () {\n      clearTimeout(hoverTimer);\n\n      if (!wasTouched && isCellHover) {\n        isCellHover = false;\n        trigger('onCellHoverOut', getDayInfo($$1(this)));\n      }\n    });\n\n    if (hasLabels) {\n      $$1('.mbsc-cal-slide-a .mbsc-cal-txt', $scroller).on('mouseenter', function () {\n        var id = $$1(this).attr('data-id');\n        $$1('.mbsc-cal-txt[data-id=\"' + id + '\"]', $scroller).addClass('mbsc-hover');\n      }).on('mouseleave', function () {\n        $$1('.mbsc-cal-txt.mbsc-hover', $scroller).removeClass('mbsc-hover');\n      });\n    }\n\n    trigger('onMonthLoaded', {\n      year: y,\n      month: m\n    });\n    trigger('onPageLoaded', {\n      firstDay: d\n    });\n  }\n\n  function genTabMarkup() {\n    var html, tabText;\n    html = '<div class=\"mbsc-cal-tabs-c\"><div class=\"mbsc-cal-tabs\" role=\"tablist\">';\n    controlsArray.forEach(function (v, i) {\n      tabText = s[(v == 'calendar' ? 'date' : v) + 'Text'];\n      html += '<div role=\"tab\" aria-controls=\"' + (elm.id + '-mbsc-pnl-' + i) + '\" class=\"mbsc-cal-tab mbsc-fr-btn-e ' + (i ? '' : cssSelectedTab) + '\" data-control=\"' + v + '\"' + (s.tabLink ? '><a href=\"#\">' + tabText + '</a>' : ' tabindex=\"0\">' + tabText) + '</div>';\n    });\n    html += '</div></div>';\n    return html;\n  }\n\n  function genCalMarkup() {\n    var html,\n        i,\n        j,\n        k,\n        monthBtns,\n        monthsMarkup,\n        yearBtns = '',\n        btnPrevClass = isRTL ? s.btnCalNextClass : s.btnCalPrevClass,\n        btnNextClass = isRTL ? s.btnCalPrevClass : s.btnCalNextClass; // Generate month buttons\n\n    monthBtns = '<div class=\"mbsc-cal-btn-w\"><div data-step=\"-1\" role=\"button\" tabindex=\"0\" aria-label=\"' + s.prevMonthText + '\" class=\"' + btnPrevClass + ' mbsc-cal-prev mbsc-cal-prev-m mbsc-cal-btn mbsc-fr-btn mbsc-fr-btn-e\"></div>';\n\n    for (i = 0; i < (calRows ? pageNr : 1); i++) {\n      monthBtns += '<div role=\"button\" class=\"mbsc-cal-month\"></div>';\n    }\n\n    monthBtns += '<div data-step=\"1\" role=\"button\" tabindex=\"0\" aria-label=\"' + s.nextMonthText + '\" class=\"' + btnNextClass + ' mbsc-cal-next mbsc-cal-next-m mbsc-cal-btn mbsc-fr-btn mbsc-fr-btn-e\"></div></div>'; // Generate year buttons\n\n    if (yearChange) {\n      yearBtns = '<div class=\"mbsc-cal-btn-w\"><div data-step=\"-12\" role=\"button\" tabindex=\"0\" aria-label=\"' + s.prevYearText + '\" class=\"' + btnPrevClass + ' mbsc-cal-prev mbsc-cal-prev-y mbsc-cal-btn mbsc-fr-btn mbsc-fr-btn-e\"></div>' + '<div role=\"button\" class=\"mbsc-cal-year\"></div>' + '<div data-step=\"12\" role=\"button\" tabindex=\"0\" aria-label=\"' + s.nextYearText + '\" class=\"' + btnNextClass + ' mbsc-cal-next mbsc-cal-next-y mbsc-cal-btn mbsc-fr-btn mbsc-fr-btn-e\"></div></div>';\n    }\n\n    if (calRows) {\n      monthsMarkup = genAllMonths(currFirstDay);\n    }\n\n    html = '<div class=\"mbsc-w-p mbsc-cal-c\"><div class=\"mbsc-cal ' + (isMonthView ? '' : ' mbsc-cal-week-view') + (pageNr > 1 ? ' mbsc-cal-multi ' : '') + (weekCounter ? ' mbsc-cal-weeks ' : '') + (isVertical ? ' mbsc-cal-vertical' : '') + (hasMarks ? ' mbsc-cal-has-marks' : '') + (hasLabels ? ' mbsc-cal-has-labels' : '') + ( // (hasText ? ' mbsc-cal-has-txt' : '') +\n    showOuterDays ? '' : ' mbsc-cal-hide-diff ') + (s.calendarClass || '') + '\"' + (!isLiquid ? ' style=\"width:' + (calWidth || 280 * pageNr) + 'px;\"' : '') + '>' + '<div class=\"mbsc-cal-hdr\">' + (yearIndex < monthIndex || pageNr > 1 ? yearBtns + monthBtns : monthBtns + yearBtns) + '</div>';\n\n    if (calRows) {\n      html += '<div class=\"mbsc-cal-body\"><div class=\"mbsc-cal-day-picker\"><div class=\"mbsc-cal-days-c\">';\n\n      for (j = 0; j < pageNr; j++) {\n        // Generate week days\n        html += '<div class=\"mbsc-cal-days\">';\n\n        for (i = 0; i < 7; i++) {\n          k = (i + firstWeekDay) % 7;\n          html += '<div class=\"mbsc-cal-week-day' + k + '\" aria-label=\"' + s.dayNames[k] + '\">' + s['dayNames' + weekDays][k] + '</div>';\n        }\n\n        html += '</div>';\n      }\n\n      html += '</div>' + '<div class=\"mbsc-cal-scroll-c mbsc-cal-day-scroll-c ' + (s.calendarClass || '') + '\"' + (s.calendarHeight ? ' style=\"height:' + s.calendarHeight + 'px\"' : '') + '>' + '<div class=\"mbsc-cal-scroll\" style=\"width:' + 100 / pageNr + '%' + '\">' + monthsMarkup + '</div></div>';\n    }\n\n    html += '</div>';\n\n    if (hasQuickNav) {\n      // Generate month picker\n      html += '<div class=\"mbsc-cal-month-picker mbsc-cal-picker mbsc-cal-h\"><div class=\"mbsc-cal-scroll-c ' + (s.calendarClass || '') + '\">' + '<div class=\"mbsc-cal-scroll\">';\n\n      for (i = 0; i < 3; i++) {\n        html += '<div class=\"mbsc-cal-slide\"' + getOffsetStyle(i - 1) + '><div role=\"grid\" class=\"mbsc-cal-table\"><div role=\"row\" class=\"mbsc-cal-row\">';\n\n        for (j = 0; j < 12; j++) {\n          if (j && j % 3 === 0) {\n            html += '</div><div role=\"row\" class=\"mbsc-cal-row\">';\n          }\n\n          html += '<div role=\"gridcell\"' + (i == 1 ? ' tabindex=\"-1\" aria-label=\"' + s.monthNames[j] + '\" data-val=\"' + j + '\"' : '') + ' class=\"mbsc-cal-cell' + (i == 1 ? ' mbsc-btn-e' : '') + '\"><div class=\"mbsc-cal-cell-i mbsc-cal-cell-txt\">' + (i == 1 ? s.monthNamesShort[j] : '&nbsp;') + '</div></div>';\n        }\n\n        html += '</div></div></div>';\n      }\n\n      html += '</div></div></div>'; // Generate year picker\n\n      html += '<div class=\"mbsc-cal-year-picker mbsc-cal-picker mbsc-cal-h\"><div class=\"mbsc-cal-scroll-c ' + (s.calendarClass || '') + '\">' + '<div class=\"mbsc-cal-scroll\">';\n\n      for (i = -1; i < 2; i++) {\n        html += genYears(getPageYear(currFirstDay, i), i);\n      }\n\n      html += '</div></div></div>';\n    } // Closing\n\n\n    html += '</div></div></div>';\n    return html;\n  }\n\n  function genYears(d, off) {\n    var i,\n        year = s.getYear(d),\n        html = '<div class=\"mbsc-cal-slide\"' + getOffsetStyle(off) + '><div role=\"grid\" class=\"mbsc-cal-table\"><div role=\"row\" class=\"mbsc-cal-row\">';\n\n    for (i = 0; i < 12; i++) {\n      if (i && i % 3 === 0) {\n        html += '</div><div role=\"row\" class=\"mbsc-cal-row\">';\n      }\n\n      html += '<div role=\"gridcell\" tabindex=\"-1\" aria-label=\"' + year + '\" data-val=\"' + year + '\"' + ' class=\"mbsc-cal-cell mbsc-btn-e ' + (year < minYear || year > maxYear ? ' mbsc-disabled ' : '') + (year == s.getYear(currFirstDay) ? cssSelected : '') + '\"><div class=\"mbsc-cal-cell-i mbsc-cal-cell-txt\">' + year + yearSuffix + '</div></div>';\n      year++;\n    }\n\n    html += '</div></div></div>';\n    return html;\n  }\n\n  function genMonth(firstDay, off) {\n    var bg,\n        curr,\n        cssClass,\n        y,\n        m,\n        d,\n        displayMonth,\n        displayDate,\n        fullDate,\n        props,\n        isValid,\n        isSelected,\n        isToday,\n        isOuterDay,\n        maxDays,\n        i,\n        j,\n        k = 1,\n        year = s.getYear(firstDay),\n        month = s.getMonth(firstDay),\n        day = s.getDay(firstDay),\n        selected = s.defaultValue === null && !inst._hasValue ? null : inst.getDate(true),\n        weekDay = s.getDate(year, month, day).getDay(),\n        // Get the weekday of the month\n    offset = firstWeekDay - weekDay > 0 ? 7 : 0,\n        html = '<div class=\"mbsc-cal-slide\"' + getOffsetStyle(off) + '><div role=\"grid\" class=\"mbsc-cal-table\"><div role=\"row\" class=\"mbsc-cal-row\">';\n\n    for (j = 0; j < 7 * calRows; j++) {\n      i = j + firstWeekDay - offset;\n      curr = s.getDate(year, month, i - weekDay + day);\n      y = curr.getFullYear();\n      m = curr.getMonth();\n      d = curr.getDate();\n      displayMonth = s.getMonth(curr);\n      displayDate = s.getDay(curr);\n      maxDays = s.getMaxDayOfMonth(y, m);\n      fullDate = y + '-' + (m + 1) + '-' + d;\n      props = extend$1({\n        valid: isValidDate(curr),\n        selected: selected && isSameDay(selected, curr)\n      }, getDayProps(curr));\n      bg = props.background === 'none' ? false : props.background;\n      isValid = props.valid;\n      isSelected = props.selected;\n      cssClass = props.cssClass; // Compare dates at noon, in some timezones 0:00 doesn't exists on daylight saving day\n\n      isToday = new Date(curr).setHours(12, 0, 0, 0) === new Date().setHours(12, 0, 0, 0);\n      isOuterDay = displayMonth !== month; // Day is from another month\n\n      dayProps[fullDate] = props;\n\n      if (j && j % 7 === 0) {\n        html += '</div><div role=\"row\" class=\"mbsc-cal-row\">';\n      }\n\n      if (weekCounter && j % 7 === 0) {\n        // If displaying days from next month, reset month counter\n        if (weekCounter == 'month' && isOuterDay && k > 1) {\n          k = d == 1 ? 1 : 2;\n        } else if (weekCounter == 'year') {\n          k = s.getWeekNumber(s.getDate(y, m, d + (7 - firstWeekDay + 1) % 7));\n        }\n\n        html += '<div role=\"gridcell\" class=\"mbsc-cal-cell mbsc-cal-week-nr\">' + k + '</div>';\n        k++;\n      }\n\n      html += '<div role=\"gridcell\"' + // Aria attributes\n      ' aria-label=\"' + (isToday ? s.todayText + ', ' : '') + s.dayNames[curr.getDay()] + ', ' + s.monthNames[displayMonth] + ' ' + displayDate + ' ' + (props.ariaLabel ? ', ' + props.ariaLabel : '') + '\"' + (isOuterDay && !showOuterDays ? ' aria-hidden=\"true\"' : ' data-full=\"' + fullDate + '\"') + (isOuterDay || !isValid ? ' aria-disabled=\"true\"' : '') + (isSelected ? ' aria-selected=\"true\"' : '') + (isValid ? ' tabindex=\"-1\"' : '') + // Classes\n      ' class=\"mbsc-cal-cell mbsc-cal-day mbsc-cal-day' + i % 7 + ' ' + (s.dayClass || '') + ' ' + (isSelected ? cssSelected : '') + (isToday ? ' ' + s.todayClass : '') + (cssClass ? ' ' + cssClass : '') + (displayDate == 1 ? ' mbsc-cal-day-first' : '') + (displayDate == maxDays ? ' mbsc-cal-day-last' : '') + (isOuterDay ? ' mbsc-cal-day-diff' : '') + (isValid ? ' mbsc-btn-e' : ' mbsc-disabled') + (props.marked ? ' mbsc-cal-day-marked' : '') + (bg ? ' mbsc-cal-day-colored' : '') + '\"><div class=\"mbsc-cal-cell-i mbsc-cal-day-i\"><div class=\"mbsc-cal-day-date mbsc-cal-cell-txt\"' + (bg ? ' style=\"background:' + bg + ';color:' + getTextColor(bg) + '\"' : '') + '>' + displayDate + '</div>'\n      /* TRIAL */\n      + ( // Extra markup (extra div is needed in RTL mode for Chrome, otherwise labels and marks appear at the top of the cell)\n      props.markup ? '<div class=\"mbsc-cal-day-markup\">' + props.markup + '</div>' : '') + '</div></div>';\n    }\n\n    html += '</div></div></div>';\n    return html;\n  }\n\n  function genAllMonths(firstDay, render, insert) {\n    var i,\n        y = s.getYear(firstDay),\n        m = s.getMonth(firstDay),\n        pos = dayScroll ? dayScroll.pos : 0,\n        html = '';\n    dayProps = {};\n\n    if (calRows) {\n      if (!render) {\n        trigger('onMonthLoading', {\n          year: y,\n          month: m\n        });\n        trigger('onPageLoading', {\n          firstDay: firstDay\n        });\n      }\n\n      onGenMonth(firstDay);\n\n      for (i = 0; i < pageTotal; i++) {\n        html += genMonth(getPageDay(firstDay, i - pageOffset - pageBuffer), pos * rtl + i - pageBuffer);\n      }\n    } //activateMonth(); // TODO: ???\n\n\n    needsRefresh = undefined;\n\n    if (insert && dayScroll) {\n      dayScroll.$active = null;\n      dayScroll.$scroller.html(html);\n      onPageLoaded(firstDay, y, m);\n    }\n\n    return html;\n  }\n\n  function focusDate(d, focus) {\n    if (dayScroll) {\n      var $active = dayScroll.$active;\n\n      if ($active && $active.length) {\n        $active[0].blur();\n\n        if ($active.hasClass('mbsc-disabled')) {\n          $active.removeAttr('tabindex');\n        } else {\n          $active.attr('tabindex', '-1');\n        }\n      }\n\n      dayScroll.$active = $$1('.mbsc-cal-slide-a .mbsc-cal-day[data-full=\"' + getDateStr(d) + '\"]', dayScroll.$scroller).attr('tabindex', '0');\n\n      if (focus && dayScroll.$active.length) {\n        dayScroll.$active[0].focus();\n      }\n    }\n  }\n\n  function highlightDate(d) {\n    var $ctx = dayScroll && dayScroll.$scroller;\n\n    if (s.highlight && dayScroll) {\n      $$1('.mbsc-selected', $ctx).removeClass(cssSelected).removeAttr('aria-selected');\n\n      if (s.defaultValue !== null || inst._hasValue) {\n        $$1('.mbsc-cal-day[data-full=\"' + getDateStr(d) + '\"]', $ctx).addClass(cssSelected).attr('aria-selected', 'true');\n      }\n    }\n  }\n\n  function highlightSelected(v, $ctx) {\n    $$1('.mbsc-selected', $ctx).removeClass(cssSelected).removeAttr('aria-selected');\n    $$1('.mbsc-cal-cell[data-val=\"' + v + '\"]', $ctx).addClass(cssSelected).attr('aria-selected', 'true');\n  }\n\n  function setDate(d, nav, anim, focus) {\n    var diff, newFirstDay;\n\n    if (!visibleTab) {\n      return;\n    }\n\n    if (d < minDate) {\n      d = minDate;\n    }\n\n    if (d > maxDate) {\n      d = maxDate;\n    }\n\n    if (visibleTab === 'calendar' || !hasTabs || nav) {\n      inst._isSetDate = !nav;\n\n      if (hasCal && calRows) {\n        newFirstDay = getFirstDay(constrain(d), isMonthView);\n\n        if (needsSlide && (d < getPageDay(currFirstDay, -pageOffset) || d >= getPageDay(currFirstDay, pageNr - pageOffset))) {\n          diff = isMonthView ? s.getMonth(newFirstDay) - s.getMonth(currFirstDay) + (s.getYear(newFirstDay) - s.getYear(currFirstDay)) * 12 : Math.floor(getDayDiff(currFirstDay, newFirstDay) / (7 * calRows));\n\n          if (diff) {\n            // Clear queue to navigate immediately\n            dayScroll.queue = [];\n            dayScroll.focus = focus && anim;\n            changePageQueue(dayScroll, diff, anim);\n          }\n        }\n\n        if (!diff || !anim) {\n          focusDate(d, focus);\n        }\n\n        if (!nav) {\n          highlightDate(d);\n        }\n\n        if (!isMonthView && !diff) {\n          setTitle(currFirstDay, true);\n        }\n\n        activeDate = d;\n        needsSlide = true;\n      }\n\n      inst._onSetDate(d, diff);\n\n      inst._isSetDate = false;\n    }\n  }\n\n  function setTitle(d, skipButtons) {\n    var i,\n        year,\n        month,\n        dd,\n        y = s.getYear(d),\n        m = s.getMonth(d),\n        yy = y + yearSuffix;\n\n    if (hasQuickNav) {\n      // Highlight month\n      highlightSelected(m, monthScroll.$scroller); // Highlight year\n\n      highlightSelected(y, yearScroll.$scroller); // Scroll to selected year\n\n      changePageQueue(yearScroll, Math.floor(y / 12) - Math.floor(s.getYear(yearScroll.first) / 12), true); // Disable out of range months\n\n      $$1('.mbsc-cal-cell', monthScroll.$scroller).removeClass('mbsc-disabled');\n\n      if (y === minYear) {\n        for (i = 0; i < minMonth; i++) {\n          $$1('.mbsc-cal-cell[data-val=\"' + i + '\"]', monthScroll.$scroller).addClass('mbsc-disabled');\n        }\n      }\n\n      if (y === maxYear) {\n        for (i = maxMonth + 1; i <= 12; i++) {\n          $$1('.mbsc-cal-cell[data-val=\"' + i + '\"]', monthScroll.$scroller).addClass('mbsc-disabled');\n        }\n      }\n    }\n\n    if (!skipButtons) {\n      // Disable/enable prev/next buttons\n      checkBtn($$1('.mbsc-cal-prev-m', $markup), getPageDay(d, -pageOffset) <= minDate);\n      checkBtn($$1('.mbsc-cal-next-m', $markup), getPageDay(d, pageNr - pageOffset) > maxDate);\n      checkBtn($$1('.mbsc-cal-prev-y', $markup), s.getDate(y - 1, m + 1, 1) <= minDate);\n      checkBtn($$1('.mbsc-cal-next-y', $markup), s.getDate(y + 1, m, 1) > maxDate);\n    } // Update year in header\n\n\n    $yearHdr.attr('aria-label', y).html(yy); // Update month in header\n\n    for (i = 0; i < pageNr; i++) {\n      dd = getPageDay(d, i - pageOffset);\n\n      if (selectedDate >= dd && selectedDate < getPageDay(dd, 1)) {\n        dd = selectedDate;\n      }\n\n      year = s.getYear(dd);\n      month = s.getMonth(dd);\n      yy = year + yearSuffix;\n      $monthHdr.eq(i).attr('aria-label', s.monthNames[month] + (yearChange ? '' : ' ' + y)).html((!yearChange && yearIndex < monthIndex ? yy + ' ' : '') + monthNames[month] + (!yearChange && yearIndex > monthIndex ? ' ' + yy : ''));\n    }\n  }\n\n  function checkBtn($btn, disable) {\n    if (disable) {\n      $btn.addClass(cssDisabled).attr('aria-disabled', 'true');\n    } else {\n      $btn.removeClass(cssDisabled).removeAttr('aria-disabled');\n    }\n  }\n\n  function getDayInfo($day) {\n    var day = $day[0],\n        full = $day.attr('data-full'),\n        parts = full ? full.split('-') : [],\n        d = adjustedDate(parts[0], parts[1] - 1, parts[2]),\n        selected = $day.hasClass('mbsc-selected');\n    return extend$1(dayProps[full], {\n      date: d,\n      target: day,\n      selected: selected\n    });\n  }\n\n  function selectDay($day, ev) {\n    var curr = inst.getDate(true),\n        props = getDayInfo($day),\n        day = $day[0],\n        d = props.date,\n        dtime = adjustedDate(d.getFullYear(), d.getMonth(), d.getDate(), curr.getHours(), curr.getMinutes(), curr.getSeconds()),\n        $target = $$1(ev.target),\n        target = $target[0];\n\n    if (!showOuterDays && $day.hasClass('mbsc-cal-day-diff')) {\n      return;\n    }\n\n    props.date = dtime; // Check if a label was tapped\n\n    if (hasLabels && day.contains(target)) {\n      while (target != day) {\n        if ($target.hasClass('mbsc-cal-txt') || $target.hasClass('mbsc-cal-txt-more')) {\n          var index = $target.attr('data-index');\n          var labels = labelsObj[d];\n\n          if (trigger('onLabelTap', {\n            date: dtime,\n            domEvent: ev,\n            target: $target[0],\n            labels: labels,\n            label: labels[index]\n          }) === false) {\n            return;\n          }\n\n          break;\n        }\n\n        $target = $target.parent();\n        target = $target[0];\n      }\n    }\n\n    if (trigger('onDayChange', props) !== false && !s.readonly && !$day.hasClass('mbsc-disabled')) {\n      inst._selectDay($day, d, dtime, props.selected);\n    }\n  }\n\n  function selectMonth($month) {\n    hideCont($monthPicker);\n    setDate(s.getDate(s.getYear(dayScroll.first), $month.attr('data-val'), 1), true, true);\n  }\n\n  function selectYear($year) {\n    hideCont($yearPicker);\n    setDate(s.getDate($year.attr('data-val'), s.getMonth(dayScroll.first), 1), true, true);\n  }\n\n  function getFirstDay(d, isMonth, w) {\n    var y = s.getYear(d),\n        m = s.getMonth(d),\n        weekDay = d.getDay(),\n        offset = firstWeekDay - weekDay > 0 ? 7 : 0;\n    return isMonth ? s.getDate(y, m, 1) : s.getDate(y, m, (w === undefined ? firstWeekDay : w) - offset - weekDay + s.getDay(d));\n  }\n\n  function getPageDay(d, diff) {\n    var year = s.getYear(d),\n        month = s.getMonth(d),\n        day = s.getDay(d);\n    return isMonthView ? s.getDate(year, month + diff, 1) : s.getDate(year, month, day + diff * calRows * 7);\n  }\n\n  function getPageYear(d, diff) {\n    var year = Math.floor(s.getYear(d) / 12) * 12;\n    return s.getDate(year + diff * 12, 0, 1);\n  }\n\n  function changePageQueue(props, diff, anim, callback) {\n    if (!diff || !inst._isVisible) {\n      return;\n    }\n\n    props.queue.push(arguments);\n\n    if (props.queue.length == 1) {\n      changePage(props, diff, anim, callback);\n    }\n  }\n\n  function changePage(props, diff, anim, callback) {\n    var i,\n        inc,\n        html = '',\n        $scroller = props.$scroller,\n        pageBuffer = props.buffer,\n        pageOffset = props.offset,\n        pageNr = props.pages,\n        pageTotal = props.total,\n        firstDay = props.first,\n        genPage = props.genPage,\n        getFirst = props.getFirst,\n        move = diff > 0 ? Math.min(diff, pageBuffer) : Math.max(diff, -pageBuffer),\n        pos = props.pos * rtl + move - diff + pageOffset,\n        load = Math.abs(diff) > pageBuffer; // Call any pending callback\n\n    if (props.callback) {\n      props.load();\n      props.callback(true);\n    }\n\n    props.first = getFirst(firstDay, diff);\n    props.pos += move * rtl;\n    props.changing = true;\n\n    props.load = function () {\n      if (load) {\n        for (i = 0; i < pageNr; i++) {\n          inc = diff + i - pageOffset; // ???\n\n          html += genPage(getFirst(firstDay, inc), pos + inc);\n        }\n\n        if (diff > 0) {\n          $$1('.mbsc-cal-slide', $scroller).slice(-pageNr).remove();\n          $scroller.append(html);\n        } else if (diff < 0) {\n          $$1('.mbsc-cal-slide', $scroller).slice(0, pageNr).remove();\n          $scroller.prepend(html);\n        }\n      }\n    };\n\n    props.callback = function (forceStop) {\n      var nr = Math.abs(move),\n          html = '';\n\n      if (!inst._isVisible) {\n        return;\n      }\n\n      for (i = 0; i < nr; i++) {\n        inc = diff + i - pageOffset - pageBuffer + (diff > 0 ? pageTotal - nr : 0); // ???\n\n        html += genPage(getFirst(firstDay, inc), pos + inc);\n      }\n\n      if (diff > 0) {\n        $scroller.append(html);\n        $$1('.mbsc-cal-slide', $scroller).slice(0, move).remove();\n      } else if (diff < 0) {\n        $scroller.prepend(html);\n        $$1('.mbsc-cal-slide', $scroller).slice(move).remove();\n      }\n\n      if (load) {\n        html = '';\n\n        for (i = 0; i < nr; i++) {\n          inc = diff + i - pageOffset - pageBuffer + (diff > 0 ? 0 : pageTotal - nr); // ???\n\n          html += genPage(getFirst(firstDay, inc), pos + inc);\n        }\n\n        if (diff > 0) {\n          $$1('.mbsc-cal-slide', $scroller).slice(0, move).remove();\n          $scroller.prepend(html);\n        } else if (diff < 0) {\n          $$1('.mbsc-cal-slide', $scroller).slice(move).remove();\n          $scroller.append(html);\n        }\n      }\n\n      refreshScroller(props);\n\n      if (callback && !forceStop) {\n        callback();\n      }\n\n      props.callback = null;\n      props.load = null;\n      props.queue.shift();\n      load = false;\n\n      if (props.queue.length) {\n        changePage.apply(this, props.queue[0]);\n      } else {\n        props.changing = false;\n        props.onAfterChange(props.first);\n      }\n    };\n\n    props.onBeforeChange(props.first);\n\n    if (props.load) {\n      props.load();\n      props.scroller.scroll(-props.pos * props.size, anim ? 200 : 0, false, props.callback);\n    }\n  }\n\n  function createScroller(cont, min, max, buffer, offset, pages, total, first, onTap, onBeforeChange, onAfterChange, genPage, getFirst) {\n    var axis = isVertical ? 'Y' : 'X',\n        props = {\n      $scroller: $$1('.mbsc-cal-scroll', cont),\n      queue: [],\n      buffer: buffer,\n      offset: offset,\n      pages: pages,\n      first: first,\n      total: total,\n      pos: 0,\n      min: min,\n      max: max,\n      genPage: genPage,\n      getFirst: getFirst,\n      onBeforeChange: onBeforeChange,\n      onAfterChange: onAfterChange\n    };\n    props.scroller = new ScrollViewBase(cont, {\n      axis: axis,\n      easing: '',\n      contSize: 0,\n      maxSnapScroll: buffer,\n      mousewheel: s.mousewheel === undefined ? isVertical : s.mousewheel,\n      time: 200,\n      lock: true,\n      rtl: isRTL,\n      stopProp: false,\n      minScroll: 0,\n      maxScroll: 0,\n      onBtnTap: function onBtnTap(ev) {\n        if (ev.domEvent.type == 'touchend') {\n          preventClick();\n        }\n\n        onTap($$1(ev.target), ev.domEvent);\n      },\n      onStart: function onStart() {\n        clearTimeout(hoverTimer);\n      },\n      onGestureStart: function onGestureStart() {\n        isPageMove = true;\n      },\n      onAnimationStart: function onAnimationStart() {\n        props.changing = true;\n      },\n      onAnimationEnd: function onAnimationEnd(ev) {\n        isPageMove = false;\n\n        if (genPage) {\n          changePageQueue(props, Math.round((-props.pos * props.size - ev['pos' + axis]) / props.size) * rtl);\n        }\n      }\n    });\n\n    inst._scrollers.push(props.scroller);\n\n    return props;\n  }\n\n  function refreshScroller(props, check) {\n    var size,\n        plus = 0,\n        minus = 0,\n        firstDay = props.first;\n\n    if (props.changing && check) {\n      return;\n    }\n\n    if (props.getFirst) {\n      plus = props.buffer;\n      minus = props.buffer; //while (minus && s.getDate(y, m + minus + monthNr - moveMonth - 1, 1) > maxDate) { ???\n\n      while (minus && props.getFirst(firstDay, minus + props.pages - props.offset - 1) > props.max) {\n        minus--;\n      } //while (plus && s.getDate(y, m - plus - moveMonth, 1) < minDate) { ???\n\n\n      while (plus && props.getFirst(firstDay, 1 - plus - props.offset) <= props.min) {\n        plus--;\n      }\n    }\n\n    size = Math.round(calSize / props.pages); // Page size might be a fractional value in case of multiple months\n    // so we need to explicitly set the rounded value\n\n    if (isLiquid && size && props.size != size) {\n      props.$scroller[isVertical ? 'height' : 'width'](size);\n    }\n\n    extend$1(props.scroller.settings, {\n      snap: size,\n      minScroll: (-props.pos * rtl - minus) * size,\n      maxScroll: (-props.pos * rtl + plus) * size\n    });\n    props.size = size;\n    props.scroller.refresh();\n  }\n\n  function refresh(render) {\n    inst._onRefresh(render);\n\n    if (inst._isVisible && hasCal && calRows) {\n      if (dayScroll && dayScroll.changing) {\n        needsRefresh = render;\n      } else {\n        genAllMonths(currFirstDay, render, true);\n        focusDate(activeDate);\n      }\n    }\n  }\n\n  function onTouchStart(ev) {\n    wasTouched = ev.type === 'touchstart';\n  }\n\n  function attachEvents() {\n    if (hasCal && calRows) {\n      var $scrollers = $$1('.mbsc-cal-scroll-c', $markup); // Day selector\n\n      dayScroll = createScroller($scrollers[0], minDate, maxDate, pageBuffer, pageOffset, pageNr, pageTotal, currFirstDay, selectDay, onBeforeMonthChange, onAfterMonthChange, genMonth, getPageDay);\n\n      if (hasQuickNav) {\n        // Month selector\n        monthScroll = createScroller($scrollers[1], null, null, 1, 0, 1, 3, currFirstDay, selectMonth); // Year selector\n\n        yearScroll = createScroller($scrollers[2], minFirstYear, maxFirstYear, 1, 0, 1, 3, currFirstDay, selectYear, noop, noop, genYears, getPageYear); // Show / hide month picker\n\n        inst.tap($monthHdr, function () {\n          toggleCont($monthPicker);\n          hideCont($yearPicker);\n        }); // Show / hide year picker\n\n        inst.tap($yearHdr, function () {\n          toggleCont($yearPicker);\n          hideCont($monthPicker);\n        });\n      } // Init navigation arrows\n\n\n      createStepper($$1('.mbsc-cal-btn', $markup), function (i, diff, ev, next) {\n        changePageQueue(dayScroll, diff, true, next);\n      }); // Triggers onMonthLoaded on initial render\n\n      onAfterMonthChange(currFirstDay); // Focus on the selected date on show\n\n      if ((s.defaultValue !== null || inst._hasValue) && !inst._multiple) {\n        inst._activeElm = dayScroll.$active[0];\n      }\n\n      listen($calendar[0], 'touchstart', onTouchStart, {\n        passive: true\n      });\n      listen($calendar[0], 'mousedown', onTouchStart);\n      $calendar // Keyboard navigation\n      .on('keydown', function (ev) {\n        var year = s.getYear(activeDate),\n            month = s.getMonth(activeDate),\n            day = s.getDay(activeDate),\n            newDate;\n\n        switch (ev.keyCode) {\n          case 32:\n            //SPACE\n            selectDay(dayScroll.$active, ev);\n            break;\n\n          case 37:\n            //LEFT_ARROW:\n            newDate = s.getDate(year, month, day - 1 * rtl);\n            break;\n\n          case 39:\n            //RIGHT_ARROW:\n            newDate = s.getDate(year, month, day + 1 * rtl);\n            break;\n\n          case 38:\n            //UP_ARROW:\n            newDate = s.getDate(year, month, day - 7);\n            break;\n\n          case 40:\n            //DOWN_ARROW:\n            newDate = s.getDate(year, month, day + 7);\n            break;\n\n          case 36:\n            //HOME:\n            newDate = s.getDate(year, month, 1);\n            break;\n\n          case 35:\n            //END:\n            newDate = s.getDate(year, month + 1, 0);\n            break;\n\n          case 33:\n            //PAGE_UP:\n            newDate = ev.altKey ? s.getDate(year - 1, month, day) : isMonthView ? s.getDate(year, month - 1, day) : s.getDate(year, month, day - calRows * 7);\n            break;\n\n          case 34:\n            //PAGE_DOWN:\n            newDate = ev.altKey ? s.getDate(year + 1, month, day) : isMonthView ? s.getDate(year, month + 1, day) : s.getDate(year, month, day + calRows * 7);\n            break;\n        }\n\n        if (newDate) {\n          ev.preventDefault();\n          setDate(newDate, true, false, true);\n        }\n      });\n    } // Tabs\n\n\n    inst.tap($$1('.mbsc-cal-tab', $markup), function () {\n      inst.changeTab($$1(this).attr('data-control'));\n    });\n  }\n\n  preProcessSettings();\n  base = DateTime.call(this, inst);\n  postProcessSettings(); // Public functions\n  // ---\n\n  inst.refresh = function () {\n    refresh(false);\n  };\n\n  inst.redraw = function () {\n    refresh(true);\n  };\n\n  inst.navigate = function (d, anim) {\n    setDate(makeDate(d, displayFormat, s), true, anim);\n  };\n\n  inst.changeTab = function (tab) {\n    if (!inst._isVisible || !controls[tab] || visibleTab == tab) {\n      return;\n    }\n\n    visibleTab = tab;\n    $$1('.mbsc-cal-tab', $markup).removeClass(cssSelectedTab).removeAttr('aria-selected');\n    $$1('.mbsc-cal-tab[data-control=\"' + tab + '\"]', $markup).addClass(cssSelectedTab).attr('aria-selected', 'true');\n\n    if (hasTabs) {\n      $tabPanes.addClass('mbsc-cal-h');\n      controls[visibleTab].removeClass('mbsc-cal-h');\n    }\n\n    if (visibleTab == 'calendar') {\n      // Set the date of the calendar if date changed from the scroller\n      setDate(inst.getDate(true), false, true);\n    } // Hide\n\n\n    inst._showDayPicker();\n\n    inst.trigger('onTabChange', {\n      tab: visibleTab\n    });\n  }; // ---\n  // Protected functions\n  // ---\n\n\n  inst._checkSize = true;\n  inst._onGenMonth = noop;\n  inst._onSetDate = noop;\n  inst._onRefresh = noop;\n  inst._getDayProps = noop;\n  inst._prepareObj = prepareObj;\n\n  inst._showDayPicker = function () {\n    if (hasQuickNav) {\n      hideCont($yearPicker);\n      hideCont($monthPicker);\n    }\n  };\n\n  inst._selectDay = inst.__selectDay = function ($day, d, dtime) {\n    var fill = inst.live; // Prevents month slide in setDate\n\n    needsSlide = s.outerMonthChange;\n    isDayClick = true; // Set date on scroller\n\n    inst.setDate(dtime, fill, 1000, !fill, true);\n\n    if (fill) {\n      trigger('onSet', {\n        valueText: inst._value\n      });\n    }\n  };\n\n  inst._checkBtn = checkBtn; // ---\n\n  return extend$1(base, {\n    labels: null,\n    // Overrides labels coming from language files\n    compClass: 'mbsc-calendar mbsc-dt mbsc-sc',\n    onMarkupReady: function onMarkupReady(ev) {\n      var j = 0;\n      $markup = $$1(ev.target);\n      $tabPaneCont = $$1('.mbsc-fr-c', $markup);\n      activeDate = inst.getDate(true);\n      calSize = 0;\n\n      if (hasCal) {\n        hasMarks = !!(s.marked || s.data) && !s.labels && !s.multiLabel && !s.showEventCount; // hasText = s.showEventCount || !!(s.events || s.labels);\n\n        needsSlide = true;\n        visibleTab = 'calendar';\n        calcMonthNr();\n        currFirstDay = getFirstDay(constrain(activeDate), isMonthView);\n        $tabPaneCont.append(genCalMarkup());\n        $monthHdr = $$1('.mbsc-cal-month', $markup);\n        $yearHdr = $$1('.mbsc-cal-year', $markup);\n        $calendar = $$1('.mbsc-cal-day-scroll-c', $markup);\n      }\n\n      if (hasQuickNav) {\n        $yearPicker = $$1('.mbsc-cal-year-picker', $markup);\n        $monthPicker = $$1('.mbsc-cal-month-picker', $markup);\n      }\n\n      $tabPanes = $$1('.mbsc-w-p', $markup); // Insert tab markup\n\n      if (controlsArray.length > 1) {\n        $tabPaneCont.before(genTabMarkup());\n      } // Find markup for controls\n\n\n      ['date', 'time', 'calendar'].forEach(function (v) {\n        if (controls[v]) {\n          controls[v] = $tabPanes.eq(j);\n          j++;\n        } else if (v == 'date' && !controls.date && hasCal) {\n          $tabPanes.eq(j).remove();\n          j++;\n        }\n      }); // Insert controls in correct order\n\n      controlsArray.forEach(function (v) {\n        $tabPaneCont.append(controls[v]);\n      }); // TODO: this is an ugly solution\n\n      if (!hasCal && controls.date) {\n        controls.date.css('position', 'relative');\n      }\n\n      inst._scrollers = [];\n      attachEvents();\n    },\n    onShow: function onShow() {\n      if (hasCal && calRows) {\n        setTitle(currFirstDay);\n      }\n    },\n    onHide: function onHide() {\n      inst._scrollers.forEach(function (v) {\n        v.destroy();\n      });\n\n      dayProps = null;\n      dayScroll = null;\n      monthScroll = null;\n      yearScroll = null;\n      visibleTab = null;\n    },\n    onValidated: function onValidated(ev) {\n      var ctrl,\n          d,\n          i = ev.index,\n          order = inst._order;\n      d = inst.getDate(true);\n      selectedDate = d; // Find out on which control was the selection made\n\n      if (isDayClick) {\n        ctrl = 'calendar';\n      } else if (i !== undefined) {\n        ctrl = order.dd == i || order.d == i || order.m == i || order.y == i ? 'date' : 'time';\n      }\n\n      trigger('onSetDate', {\n        date: d,\n        control: ctrl\n      }); // Set date on calendar\n\n      if (ctrl !== 'time') {\n        setDate(d, false, !!ev.time, isDayClick && !inst._multiple);\n      }\n\n      isDayClick = false;\n    },\n    onPosition: function onPosition(ev) {\n      var i,\n          y,\n          m,\n          doRefresh,\n          modalHeight,\n          newCalSize,\n          availableHeight,\n          oldHeight = ev.oldHeight,\n          windowHeight = ev.windowHeight;\n      hasTabs = (ev.hasTabs || s.tabs === true || s.tabs !== false && isLiquid) && controlsArray.length > 1;\n\n      if (isLiquid) {\n        if (ev.windowWidth >= s.breakPointMd) {\n          $$1(ev.target).addClass('mbsc-fr-md');\n        } else {\n          $$1(ev.target).removeClass('mbsc-fr-md');\n        }\n      } // Show/hide tabs\n\n\n      if (hasTabs) {\n        $markup.addClass('mbsc-cal-tabbed');\n        visibleTab = $$1('.mbsc-cal-tab.mbsc-selected', $markup).attr('data-control');\n        $tabPanes.addClass('mbsc-cal-h');\n        controls[visibleTab].removeClass('mbsc-cal-h');\n      } else {\n        // visibleTab = 'calendar';\n        $markup.removeClass('mbsc-cal-tabbed');\n        $tabPanes.removeClass('mbsc-cal-h');\n      } // Full screen mode\n\n\n      if (inst._isFullScreen) {\n        // Reset height\n        $calendar.height('');\n        modalHeight = ev.popup.offsetHeight; // Get available height\n\n        availableHeight = windowHeight - modalHeight + $calendar[0].offsetHeight; // Only set fixed height if calendar height is bigger than viewport height\n\n        if (windowHeight >= modalHeight) {\n          $calendar.height(availableHeight);\n        }\n      }\n\n      if (hasLabels && calRows && windowHeight != oldHeight) {\n        // Check how many labels can we display on a day\n        var calHeight = availableHeight || $calendar[0].offsetHeight;\n        var ph = $calendar.find('.mbsc-cal-txt,.mbsc-cal-txt-ph')[0];\n        var numberHeight = ph.offsetTop;\n        var txtHeight = ph.offsetHeight;\n        var newMaxLabels = Math.max(1, Math.floor((calHeight / calRows - numberHeight) / (txtHeight + 2))); // Redraw the calendar, if max labels changed\n\n        if (maxLabels != newMaxLabels) {\n          maxLabels = newMaxLabels;\n          inst.redraw();\n        }\n      } // Refresh scrollviews\n\n\n      if (hasCal && calRows) {\n        // Need to calculate size\n        if (isLiquid || isVertical || hasTabs) {\n          newCalSize = $calendar[0][isVertical ? 'offsetHeight' : 'offsetWidth'];\n        } else {\n          newCalSize = calWidth || pageNr * 280;\n        }\n\n        doRefresh = newCalSize != calSize;\n        calSize = newCalSize; // Use long or short month names\n\n        if (isLiquid && doRefresh) {\n          if (yearChange) {\n            monthNames = s.maxMonthWidth > $monthHdr[0].offsetWidth ? s.monthNamesShort : s.monthNames;\n            y = s.getYear(currFirstDay);\n            m = s.getMonth(currFirstDay);\n\n            for (i = 0; i < pageNr; i++) {\n              $monthHdr.eq(i).text(monthNames[s.getMonth(s.getDate(y, m - pageOffset + i, 1))]);\n            }\n          }\n        }\n\n        if (doRefresh) {\n          refreshScroller(dayScroll, true);\n        }\n      }\n\n      if (hasQuickNav && doRefresh) {\n        refreshScroller(monthScroll, true);\n        refreshScroller(yearScroll, true);\n      }\n    }\n  });\n};\n\nvar Calendar = Scroller;\nvar defaults$3 = {};\n\npresets.calendar = function (inst) {\n  function getDateOnly(d) {\n    return adjustedDate(d.getFullYear(), d.getMonth(), d.getDate());\n  }\n\n  function setValues(values) {\n    var d,\n        i,\n        first = null;\n    selectedValues = {};\n\n    if (values && values.length) {\n      for (i = 0; i < values.length; i++) {\n        d = makeDate(values[i], displayFormat, s, s.isoParts);\n        first = first || d;\n        selectedValues[getDateOnly(d)] = d;\n      }\n    }\n\n    return first;\n  }\n\n  function redraw() {\n    inst.redraw();\n  } // ---\n\n\n  var base,\n      ctx,\n      displayFormat,\n      firstSelectDay,\n      origValues,\n      orig = extend$1({}, inst.settings),\n      s = extend$1(inst.settings, defaults$3, orig),\n      cssSelected = 'mbsc-selected ' + (s.selectedClass || ''),\n      defaultValue = s.defaultValue,\n      multi = s.select == 'multiple' || s.select > 1 || s.selectType == 'week',\n      maxSelect = isNumeric(s.select) ? s.select : Infinity,\n      selectedValues = {};\n  base = CalendarBase.call(this, inst);\n  firstSelectDay = s.firstSelectDay === undefined ? s.firstDay : s.firstSelectDay;\n  displayFormat = inst._format;\n\n  if (multi) {\n    setValues(defaultValue);\n  } // Extended methods\n  // ---\n\n\n  inst._multiple = multi;\n\n  inst._getDayProps = function (d) {\n    return {\n      selected: multi ? selectedValues[d] !== undefined : undefined\n    };\n  };\n\n  inst._selectDay = function ($day, d, dtime, selected) {\n    var isSingleSelect = s.select == 'single' || s.select == 1 || s.select === undefined; // Single select with instant close\n\n    if (s.setOnDayTap && isSingleSelect && s.display != 'inline') {\n      inst.setDate(dtime);\n      inst.select();\n      return;\n    }\n\n    if (multi) {\n      // Multiple day selection\n      if (s.selectType == 'week') {\n        // Select whole week\n        var i,\n            sel,\n            diff = d.getDay() - firstSelectDay;\n        diff = diff < 0 ? 7 + diff : diff;\n\n        if (isSingleSelect) {\n          // Only one week can be selected\n          selectedValues = {};\n        }\n\n        for (i = 0; i < 7; i++) {\n          sel = adjustedDate(d.getFullYear(), d.getMonth(), d.getDate() - diff + i);\n\n          if (selected) {\n            delete selectedValues[sel];\n          } else if (objectToArray(selectedValues).length / 7 < maxSelect) {\n            selectedValues[sel] = sel;\n          }\n        }\n\n        redraw();\n      } else {\n        // Select day only\n        var days = $$1('.mbsc-cal-day[data-full=\"' + $day.attr('data-full') + '\"]', ctx);\n\n        if (selected) {\n          days.removeClass(cssSelected).removeAttr('aria-selected');\n          delete selectedValues[d];\n        } else if (objectToArray(selectedValues).length < maxSelect) {\n          days.addClass(cssSelected).attr('aria-selected', 'true');\n          selectedValues[d] = d;\n        }\n      }\n    } // Standard selection\n\n\n    inst.__selectDay($day, d, dtime);\n  };\n\n  inst.setVal = function (val, fill, change, temp, time) {\n    if (multi) {\n      val = setValues(val);\n    }\n\n    inst._setVal(val, fill, change, temp, time);\n\n    if (multi) {\n      redraw();\n    }\n  };\n\n  inst.getVal = function (temp) {\n    var i,\n        ret = [];\n\n    if (multi) {\n      for (i in selectedValues) {\n        ret.push(returnDate(selectedValues[i], s, displayFormat));\n      }\n\n      return ret;\n    }\n\n    return returnDate(inst.getDate(temp), s, displayFormat);\n  }; // ---\n\n\n  return extend$1({}, base, {\n    highlight: !multi,\n    outerMonthChange: !multi,\n    parseValue: function parseValue(v) {\n      if (multi && v && typeof v === 'string') {\n        v = setValues(v.split(','));\n      }\n\n      if (multi && defaultValue && defaultValue.length) {\n        s.defaultValue = defaultValue[0];\n      }\n\n      return base.parseValue.call(this, v);\n    },\n    formatValue: function formatValue(d) {\n      var i,\n          ret = [];\n\n      if (multi) {\n        for (i in selectedValues) {\n          ret.push(formatDate(displayFormat, selectedValues[i], s));\n        }\n\n        return ret.join(', ');\n      }\n\n      return base.formatValue.call(this, d, inst);\n    },\n    onClear: function onClear() {\n      if (multi) {\n        selectedValues = {};\n        redraw();\n      }\n    },\n    onBeforeShow: function onBeforeShow() {\n      if (s.setOnDayTap === undefined && (!s.buttons || !s.buttons.length) && s.controls.length == 1) {\n        s.setOnDayTap = true;\n      }\n\n      if (s.setOnDayTap && s.display != 'inline') {\n        s.outerMonthChange = false;\n      }\n\n      if (s.counter && multi) {\n        s.headerText = function () {\n          var length = 0,\n              w = s.selectType == 'week' ? 7 : 1;\n          $$1.each(selectedValues, function () {\n            length++;\n          });\n          length = Math.round(length / w);\n          return (length > 1 ? s.selectedPluralText || s.selectedText : s.selectedText).replace(/{count}/, length);\n        };\n      }\n    },\n    onMarkupReady: function onMarkupReady(ev) {\n      base.onMarkupReady.call(this, ev);\n      ctx = $$1(ev.target);\n\n      if (multi) {\n        $$1('.mbsc-fr-hdr', ctx).attr('aria-live', 'off');\n        origValues = extend$1({}, selectedValues);\n      }\n    },\n    onCancel: function onCancel() {\n      if (!inst.live && multi) {\n        selectedValues = extend$1({}, origValues);\n      }\n    }\n  });\n};\n\nvar MbscDatetimeBase = function (_super) {\n  __extends(MbscDatetimeBase, _super);\n\n  function MbscDatetimeBase(initialElem, zone, control, inputService, view) {\n    return _super.call(this, initialElem, zone, control, inputService, view) || this;\n  }\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscDatetimeBase.prototype, \"defaultValue\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscDatetimeBase.prototype, \"invalid\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Date)], MbscDatetimeBase.prototype, \"max\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Date)], MbscDatetimeBase.prototype, \"min\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDatetimeBase.prototype, \"returnFormat\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscDatetimeBase.prototype, \"steps\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscDatetimeBase.prototype, \"valid\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDatetimeBase.prototype, \"calendarSystem\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDatetimeBase.prototype, \"ampmText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDatetimeBase.prototype, \"amText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDatetimeBase.prototype, \"dateFormat\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDatetimeBase.prototype, \"dateWheels\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscDatetimeBase.prototype, \"dayNames\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscDatetimeBase.prototype, \"dayNamesShort\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDatetimeBase.prototype, \"dayText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDatetimeBase.prototype, \"hourText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDatetimeBase.prototype, \"minuteText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscDatetimeBase.prototype, \"monthNames\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscDatetimeBase.prototype, \"monthNamesShort\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDatetimeBase.prototype, \"monthSuffix\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDatetimeBase.prototype, \"monthText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDatetimeBase.prototype, \"nowText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDatetimeBase.prototype, \"pmText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDatetimeBase.prototype, \"secText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDatetimeBase.prototype, \"timeFormat\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDatetimeBase.prototype, \"timeWheels\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDatetimeBase.prototype, \"yearSuffix\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDatetimeBase.prototype, \"yearText\", void 0);\n\n  MbscDatetimeBase = __decorate([__metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, ViewContainerRef])], MbscDatetimeBase);\n\n  MbscDatetimeBase.ɵfac = function MbscDatetimeBase_Factory(t) {\n    return new (t || MbscDatetimeBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl), ɵngcc0.ɵɵdirectiveInject(MbscInputService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscDatetimeBase.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscDatetimeBase,\n    selectors: [[\"mbsc-dt-b\"]],\n    inputs: {\n      defaultValue: \"defaultValue\",\n      invalid: \"invalid\",\n      max: \"max\",\n      min: \"min\",\n      returnFormat: \"returnFormat\",\n      steps: \"steps\",\n      valid: \"valid\",\n      calendarSystem: \"calendarSystem\",\n      ampmText: \"ampmText\",\n      amText: \"amText\",\n      dateFormat: \"dateFormat\",\n      dateWheels: \"dateWheels\",\n      dayNames: \"dayNames\",\n      dayNamesShort: \"dayNamesShort\",\n      dayText: \"dayText\",\n      hourText: \"hourText\",\n      minuteText: \"minuteText\",\n      monthNames: \"monthNames\",\n      monthNamesShort: \"monthNamesShort\",\n      monthSuffix: \"monthSuffix\",\n      monthText: \"monthText\",\n      nowText: \"nowText\",\n      pmText: \"pmText\",\n      secText: \"secText\",\n      timeFormat: \"timeFormat\",\n      timeWheels: \"timeWheels\",\n      yearSuffix: \"yearSuffix\",\n      yearText: \"yearText\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscDatetimeBase;\n}(MbscScrollerBase);\n\nvar MbscDatetimeBaseModule = function () {\n  function MbscDatetimeBaseModule() {}\n\n  MbscDatetimeBaseModule.ɵfac = function MbscDatetimeBaseModule_Factory(t) {\n    return new (t || MbscDatetimeBaseModule)();\n  };\n\n  MbscDatetimeBaseModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscDatetimeBaseModule\n  });\n  MbscDatetimeBaseModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, MbscScrollerBaseModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscDatetimeBaseModule, {\n      declarations: function () {\n        return [MbscDatetimeBase];\n      },\n      imports: function () {\n        return [CommonModule, MbscScrollerBaseModule];\n      }\n    });\n  })();\n\n  return MbscDatetimeBaseModule;\n}();\n\nvar MbscCalBase = function (_super) {\n  __extends(MbscCalBase, _super);\n\n  function MbscCalBase(initialElem, zone, control, inputService, view) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, view) || this;\n\n    _this.onTabChange = new EventEmitter();\n    _this.onLabelTap = new EventEmitter();\n    _this.onMonthChange = new EventEmitter();\n    _this.onMonthLoading = new EventEmitter();\n    _this.onMonthLoaded = new EventEmitter();\n    _this.onPageChange = new EventEmitter();\n    _this.onPageLoaded = new EventEmitter();\n    _this.onPageLoading = new EventEmitter();\n    return _this;\n  }\n\n  MbscCalBase.prototype.ngOnInit = function () {\n    this.cloneDictionary.colors = [];\n    this.cloneDictionary.labels = [];\n    this.cloneDictionary.marked = [];\n\n    _super.prototype.ngOnInit.call(this);\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscCalBase.prototype, \"calendarHeight\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscCalBase.prototype, \"calendarWidth\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscCalBase.prototype, \"calendarScroll\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscCalBase.prototype, \"colors\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscCalBase.prototype, \"counter\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscCalBase.prototype, \"defaultValue\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscCalBase.prototype, \"events\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscCalBase.prototype, \"labels\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscCalBase.prototype, \"marked\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscCalBase.prototype, \"months\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscCalBase.prototype, \"mousewheel\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscCalBase.prototype, \"outerMonthChange\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscCalBase.prototype, \"showOuterDays\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscCalBase.prototype, \"tabs\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscCalBase.prototype, \"weekCounter\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscCalBase.prototype, \"weekDays\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscCalBase.prototype, \"weeks\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscCalBase.prototype, \"yearChange\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscCalBase.prototype, \"dateText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscCalBase.prototype, \"dayNamesMin\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscCalBase.prototype, \"firstDay\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscCalBase.prototype, \"timeText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscCalBase.prototype, \"moreEventsPluralText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscCalBase.prototype, \"moreEventsText\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscCalBase.prototype, \"onTabChange\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscCalBase.prototype, \"onLabelTap\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscCalBase.prototype, \"onMonthChange\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscCalBase.prototype, \"onMonthLoading\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscCalBase.prototype, \"onMonthLoaded\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscCalBase.prototype, \"onPageChange\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscCalBase.prototype, \"onPageLoaded\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscCalBase.prototype, \"onPageLoading\", void 0);\n\n  MbscCalBase = __decorate([__metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, ViewContainerRef])], MbscCalBase);\n\n  MbscCalBase.ɵfac = function MbscCalBase_Factory(t) {\n    return new (t || MbscCalBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl), ɵngcc0.ɵɵdirectiveInject(MbscInputService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscCalBase.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscCalBase,\n    selectors: [[\"mbsc-cal-b\"]],\n    inputs: {\n      calendarHeight: \"calendarHeight\",\n      calendarWidth: \"calendarWidth\",\n      calendarScroll: \"calendarScroll\",\n      colors: \"colors\",\n      counter: \"counter\",\n      defaultValue: \"defaultValue\",\n      events: \"events\",\n      labels: \"labels\",\n      marked: \"marked\",\n      months: \"months\",\n      mousewheel: \"mousewheel\",\n      outerMonthChange: \"outerMonthChange\",\n      showOuterDays: \"showOuterDays\",\n      tabs: \"tabs\",\n      weekCounter: \"weekCounter\",\n      weekDays: \"weekDays\",\n      weeks: \"weeks\",\n      yearChange: \"yearChange\",\n      dateText: \"dateText\",\n      dayNamesMin: \"dayNamesMin\",\n      firstDay: \"firstDay\",\n      timeText: \"timeText\",\n      moreEventsPluralText: \"moreEventsPluralText\",\n      moreEventsText: \"moreEventsText\"\n    },\n    outputs: {\n      onTabChange: \"onTabChange\",\n      onLabelTap: \"onLabelTap\",\n      onMonthChange: \"onMonthChange\",\n      onMonthLoading: \"onMonthLoading\",\n      onMonthLoaded: \"onMonthLoaded\",\n      onPageChange: \"onPageChange\",\n      onPageLoaded: \"onPageLoaded\",\n      onPageLoading: \"onPageLoading\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscCalBase;\n}(MbscDatetimeBase);\n\nvar MbscCalBaseModule = function () {\n  function MbscCalBaseModule() {}\n\n  MbscCalBaseModule.ɵfac = function MbscCalBaseModule_Factory(t) {\n    return new (t || MbscCalBaseModule)();\n  };\n\n  MbscCalBaseModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscCalBaseModule\n  });\n  MbscCalBaseModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, MbscDatetimeBaseModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscCalBaseModule, {\n      declarations: function () {\n        return [MbscCalBase];\n      },\n      imports: function () {\n        return [CommonModule, MbscDatetimeBaseModule];\n      }\n    });\n  })();\n\n  return MbscCalBaseModule;\n}();\n\nvar MbscCalendar = function (_super) {\n  __extends(MbscCalendar, _super);\n\n  function MbscCalendar(initialElement, zone, control, inputService, optionService, view) {\n    var _this = _super.call(this, initialElement, zone, control, inputService, view) || this;\n\n    _this.optionService = optionService;\n    _this.onSetDate = new EventEmitter();\n    _this.onCellHoverIn = new EventEmitter();\n    _this.onCellHoverOut = new EventEmitter();\n    _this.onDayChange = new EventEmitter();\n    _this.options = {};\n    _this.isMulti = undefined;\n    _this.onChangeEmitter = new EventEmitter();\n    return _this;\n  }\n\n  Object.defineProperty(MbscCalendar.prototype, \"value\", {\n    set: function (v) {\n      if (!this.control) {\n        this.setNewValueProxy(v);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscCalendar.prototype.setNewValue = function (v) {\n    if (this.instance) {\n      var changed = void 0;\n\n      if (this.isMulti) {\n        changed = !deepEqualsArray(v, this.instance.getVal());\n      } else {\n        var innerValue = this.instance.getVal();\n        changed = !innerValue && v || innerValue && !v || innerValue && v && innerValue.toString() !== v.toString();\n      }\n\n      if (changed) {\n        this.instance.setVal(v, true, false);\n\n        if (this._inputService && this._inputService.input) {\n          this._inputService.input.innerValue = this.instance._value;\n        }\n      }\n    }\n  };\n\n  MbscCalendar.prototype.initControl = function () {\n    var options = extend$1({\n      preset: 'calendar'\n    }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);\n    this.instance = new Calendar(this.element, options);\n\n    if (this.initialValue !== undefined && this.initialValue !== \"\") {\n      this.instance.setVal(this.initialValue, true, false);\n    }\n  };\n\n  MbscCalendar.prototype.ngOnInit = function () {\n    this.isMulti = this.options && (this.options.select && this.options.select !== 'single' || this.options.selectType == 'week');\n    this.cloneDictionary.marked = [];\n    this.cloneDictionary.invalid = [];\n\n    _super.prototype.ngOnInit.call(this);\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscCalendar.prototype, \"controls\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscCalendar.prototype, \"firstSelectDay\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscCalendar.prototype, \"selectType\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscCalendar.prototype, \"select\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscCalendar.prototype, \"setOnDayTap\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscCalendar.prototype, \"onSetDate\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscCalendar.prototype, \"onCellHoverIn\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscCalendar.prototype, \"onCellHoverOut\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscCalendar.prototype, \"onDayChange\", void 0);\n\n  __decorate([Input$1('mbsc-options'), __metadata(\"design:type\", Object)], MbscCalendar.prototype, \"options\", void 0);\n\n  __decorate([Input$1('mbsc-calendar'), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], MbscCalendar.prototype, \"value\", null);\n\n  __decorate([Output('mbsc-calendarChange'), __metadata(\"design:type\", EventEmitter)], MbscCalendar.prototype, \"onChangeEmitter\", void 0);\n\n  MbscCalendar = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscCalendar);\n\n  MbscCalendar.ɵfac = function MbscCalendar_Factory(t) {\n    return new (t || MbscCalendar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscCalendar.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscCalendar,\n    selectors: [[\"\", \"mbsc-calendar\", \"\"]],\n    inputs: {\n      value: [\"mbsc-calendar\", \"value\"],\n      controls: \"controls\",\n      firstSelectDay: \"firstSelectDay\",\n      selectType: \"selectType\",\n      select: \"select\",\n      setOnDayTap: \"setOnDayTap\",\n      options: [\"mbsc-options\", \"options\"]\n    },\n    outputs: {\n      onSetDate: \"onSetDate\",\n      onCellHoverIn: \"onCellHoverIn\",\n      onCellHoverOut: \"onCellHoverOut\",\n      onDayChange: \"onDayChange\",\n      onChangeEmitter: \"mbsc-calendarChange\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscCalendar;\n}(MbscCalBase);\n\nvar MbscCalendarComponent = function (_super) {\n  __extends(MbscCalendarComponent, _super);\n\n  function MbscCalendarComponent(initialElem, zone, control, inputService, optionService) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;\n\n    _this.placeholder = '';\n    _this.errorMessage = '';\n    return _this;\n  }\n\n  MbscCalendarComponent.prototype.ngAfterViewInit = function () {\n    _super.prototype.ngAfterViewInit.call(this);\n\n    this.setThemeClasses();\n  };\n\n  __decorate([Input$1('icon'), __metadata(\"design:type\", String)], MbscCalendarComponent.prototype, \"inputIcon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscCalendarComponent.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscCalendarComponent.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscCalendarComponent.prototype, \"placeholder\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscCalendarComponent.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscCalendarComponent.prototype, \"errorMessage\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscCalendarComponent.prototype, \"options\", void 0);\n\n  MbscCalendarComponent = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])], MbscCalendarComponent);\n\n  MbscCalendarComponent.ɵfac = function MbscCalendarComponent_Factory(t) {\n    return new (t || MbscCalendarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscCalendarComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscCalendarComponent,\n    selectors: [[\"mbsc-calendar\"]],\n    inputs: {\n      inputIcon: [\"icon\", \"inputIcon\"],\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      name: \"name\",\n      placeholder: \"placeholder\",\n      error: \"error\",\n      errorMessage: \"errorMessage\",\n      options: \"options\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\", 4, \"ngIf\"], [3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\"]],\n    template: function MbscCalendarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MbscCalendarComponent_mbsc_input_0_Template, 2, 13, \"mbsc-input\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.inline || ctx.showInput);\n      }\n    },\n    directives: [ɵngcc2.NgIf, MbscInput],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscCalendarComponent;\n}(MbscCalendar);\n\nvar MbscCalendarModule = function () {\n  function MbscCalendarModule() {}\n\n  MbscCalendarModule.ɵfac = function MbscCalendarModule_Factory(t) {\n    return new (t || MbscCalendarModule)();\n  };\n\n  MbscCalendarModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscCalendarModule\n  });\n  MbscCalendarModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, MbscCalBaseModule, MbscInputModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscCalendarModule, {\n      declarations: function () {\n        return [MbscCalendar, MbscCalendarComponent];\n      },\n      imports: function () {\n        return [CommonModule, MbscCalBaseModule, MbscInputModule];\n      },\n      exports: function () {\n        return [MbscCalendar, MbscCalendarComponent];\n      }\n    });\n  })();\n\n  return MbscCalendarModule;\n}();\n\nvar Button = /*#__PURE__*/function (_FormControl) {\n  _inheritsLoose(Button, _FormControl);\n\n  function Button(elm, settings) {\n    var _this;\n\n    _this = _FormControl.call(this, elm, settings) || this;\n    var $elm = _this._$elm;\n    var hasIcon = $elm.attr('data-icon');\n    $elm.addClass('mbsc-btn mbsc-no-touch').find('.mbsc-btn-ic').remove();\n\n    if (hasIcon) {\n      $elm.prepend('<span class=\"mbsc-btn-ic mbsc-ic mbsc-ic-' + hasIcon + '\"></span>');\n\n      if ($elm.text() === \"\") {\n        $elm.addClass('mbsc-btn-icon-only');\n      }\n    }\n\n    _this._$rippleElm = $elm;\n    return _this;\n  }\n\n  var _proto = Button.prototype;\n\n  _proto.getClassElm = function getClassElm() {\n    return this._$elm;\n  };\n\n  return Button;\n}(FormControl); // Init mbsc-button elements on page load\n\n\nautoInit('[mbsc-button]', Button);\n\nvar CheckBox = /*#__PURE__*/function (_FormControl) {\n  _inheritsLoose(CheckBox, _FormControl);\n\n  function CheckBox(elm, settings) {\n    var _this;\n\n    _this = _FormControl.call(this, elm, settings) || this;\n\n    _this._$parent.prepend(_this._$elm).addClass('mbsc-checkbox mbsc-control-w').find('.mbsc-checkbox-box').remove();\n\n    _this._$elm.after('<span class=\"mbsc-checkbox-box\"></span>');\n\n    return _this;\n  }\n\n  return CheckBox;\n}(FormControl); // Init mbsc-checkbox elements on page load\n\n\nautoInit('[mbsc-checkbox]', CheckBox);\n\nvar Radio = /*#__PURE__*/function (_FormControl) {\n  _inheritsLoose(Radio, _FormControl);\n\n  function Radio(elm, settings) {\n    var _this;\n\n    _this = _FormControl.call(this, elm, settings) || this;\n\n    _this._$parent.addClass('mbsc-radio mbsc-control-w').find('.mbsc-radio-box').remove();\n\n    _this._$elm.after('<span class=\"mbsc-radio-box\"><span></span></span>');\n\n    return _this;\n  }\n\n  return Radio;\n}(FormControl); // Init mbsc-radio elements on page load\n\n\nautoInit('[mbsc-radio]', Radio);\n\nvar Select = /*#__PURE__*/function (_Input) {\n  _inheritsLoose(Select, _Input);\n\n  function Select(elm, settings) {\n    var _this;\n\n    _this = _Input.call(this, elm, settings) || this;\n    var $elm = _this._$elm;\n    var $parent = _this._$parent;\n    var $existing = $parent.find('.mbsc-select-input');\n    var $input = $existing.length ? $existing : $$1('<input tabindex=\"-1\" class=\"mbsc-select-input mbsc-control\" readonly>');\n    _this._$input = $input;\n    _this._delm = $input[0];\n    _this._setText = _this._setText.bind(_assertThisInitialized(_this));\n    $parent.addClass('mbsc-select' + (_this._$frame ? ' mbsc-select-inline' : ''));\n    $elm.after($input);\n    $input.after('<span class=\"mbsc-select-ic mbsc-ic mbsc-ic-arrow-down5\"></span>'); // Update dummy input text on change\n\n    $elm.on('change', _this._setText);\n\n    _this._setText();\n\n    return _this;\n  }\n\n  var _proto = Select.prototype;\n\n  _proto.destroy = function destroy() {\n    _Input.prototype.destroy.call(this);\n\n    this._$parent.find('.mbsc-select-ic').remove();\n\n    this._$elm.off('change', this._setText);\n  };\n\n  _proto._setText = function _setText() {\n    var elm = this._elm;\n    var $elm = $$1(elm); // Check if select and mobiscroll select was not initialized\n\n    if ($elm.is('select') && !$elm.hasClass('mbsc-comp')) {\n      this._$input.val(elm.selectedIndex != -1 ? elm.options[elm.selectedIndex].text : '');\n    } // Check floating label\n\n\n    this.refresh();\n  };\n\n  return Select;\n}(Input); // Init mbsc-select elements on page load\n\n\nautoInit('[mbsc-dropdown]', Select);\nvar events$2 = ['change', 'keydown', 'input', 'scroll'];\nvar sizeDebounce;\n\nfunction sizeTextAreas() {\n  clearTimeout(sizeDebounce);\n  sizeDebounce = setTimeout(function () {\n    $$1('textarea.mbsc-control').each(function () {\n      sizeTextArea(this);\n    });\n  }, 100);\n}\n\nfunction sizeTextArea(control) {\n  var height,\n      lineNr,\n      line,\n      rowNr = $$1(control).attr('rows') || 6;\n\n  if (control.offsetHeight) {\n    control.style.height = '';\n    line = control.scrollHeight - control.offsetHeight;\n    height = control.offsetHeight + (line > 0 ? line : 0);\n    lineNr = Math.round(height / 24);\n\n    if (lineNr > rowNr) {\n      //control.scrollTop = height;\n      height = 24 * rowNr + (height - lineNr * 24);\n      $$1(control).addClass('mbsc-textarea-scroll');\n    } else {\n      $$1(control).removeClass('mbsc-textarea-scroll');\n    }\n\n    if (height) {\n      control.style.height = height + 'px';\n    }\n  }\n}\n\nfunction scrollTextArea(elm) {\n  var $elm = $$1(elm);\n\n  if (!$elm.hasClass('mbsc-textarea-scroll')) {\n    var line = elm.scrollHeight - elm.offsetHeight,\n        height = elm.offsetHeight + line,\n        lineNr = Math.round(height / 24),\n        rowNr = $elm.attr('rows') || 6;\n\n    if (lineNr <= rowNr) {\n      elm.scrollTop = 0;\n      elm.style.height = height + 'px';\n    }\n  }\n}\n\nif (isBrowser) {\n  // Set height of textareas on viewport size changes\n  $$1(window).on('resize orientationchange', sizeTextAreas);\n}\n\nvar TextArea = /*#__PURE__*/function (_Input) {\n  _inheritsLoose(TextArea, _Input);\n\n  function TextArea(elm, settings) {\n    var _this;\n\n    _this = _Input.call(this, elm, settings) || this;\n\n    _this._$parent.addClass('mbsc-textarea');\n\n    events$2.forEach(function (ev) {\n      _this._$elm.on(ev, _this._handle);\n    });\n    sizeTextArea(elm);\n    return _this;\n  }\n\n  var _proto = TextArea.prototype;\n\n  _proto.destroy = function destroy() {\n    var _this2 = this;\n\n    _Input.prototype.destroy.call(this);\n\n    events$2.forEach(function (ev) {\n      _this2._$elm.off(ev, _this2._handle);\n    });\n  };\n\n  _proto.refresh = function refresh() {\n    _Input.prototype.refresh.call(this);\n\n    clearTimeout(this._debounce);\n    sizeTextArea(this._elm);\n  };\n\n  _proto._handle = function _handle(ev) {\n    _Input.prototype._handle.call(this, ev);\n\n    switch (ev.type) {\n      case 'change':\n        sizeTextArea(this._elm);\n        break;\n\n      case 'keydown':\n      case 'input':\n        this._onInput(ev);\n\n        break;\n\n      case 'scroll':\n        scrollTextArea(this._elm);\n    }\n  };\n\n  _proto._onInput = function _onInput() {\n    var _this3 = this;\n\n    clearTimeout(this._debounce);\n    this._debounce = setTimeout(function () {\n      sizeTextArea(_this3._elm);\n    }, 100);\n  };\n\n  return TextArea;\n}(Input);\n\nautoInit('[mbsc-textarea]', TextArea);\n\nvar SegmentedItem = /*#__PURE__*/function (_FormControl) {\n  _inheritsLoose(SegmentedItem, _FormControl);\n\n  function SegmentedItem(elm, settings) {\n    var _this;\n\n    _this = _FormControl.call(this, elm, settings) || this;\n    var $segmentCont;\n    var $segment;\n    var $elm = _this._$elm;\n    var $parent = _this._$parent;\n\n    if (!$parent.hasClass('mbsc-segmented-item-ready')) {\n      $segmentCont = $$1('<div class=\"mbsc-segmented mbsc-no-touch\"></div>');\n      $parent.after($segmentCont);\n      $parent.parent().find('input[name=\"' + $elm.attr('name') + '\"]').each(function () {\n        var $input = $$1(this);\n        $segment = $input.parent().addClass('mbsc-segmented-item mbsc-segmented-item-ready');\n        $$1('<span class=\"mbsc-segmented-content\">' + ($input.attr('data-icon') ? '<span class=\"mbsc-ic mbsc-ic-' + $input.attr('data-icon') + '\"></span>' : '') + '</span>').append($segment.contents()).appendTo($segment);\n        $segment.prepend($input);\n        $segmentCont.append($segment);\n      });\n    }\n\n    _this._$rippleElm = $elm.next();\n    return _this;\n  }\n\n  var _proto = SegmentedItem.prototype;\n\n  _proto.getClassElm = function getClassElm() {\n    return this._$elm.closest('.mbsc-segmented');\n  };\n\n  return SegmentedItem;\n}(FormControl); // Init mbsc-segmented elements on page load\n\n\nautoInit('[mbsc-segmented]', SegmentedItem);\n\nvar Stepper = function Stepper(control, settings) {\n  var $btnPlus,\n      $btnMinus,\n      $controls,\n      cssClass = '',\n      displayValue,\n      max,\n      min,\n      inputStyle,\n      ripple,\n      scale,\n      step,\n      stepper,\n      s,\n      theme,\n      val,\n      that = this,\n      $control = $$1(control),\n      ready,\n      $parent,\n      old = val;\n\n  function onChange() {\n    var v;\n\n    if (!control.disabled) {\n      v = parseFloat($$1(this).val());\n      setValue(isNaN(v) ? val : v);\n    }\n  }\n\n  function checkDisabled() {\n    return control.disabled;\n  }\n\n  function stepValue(index, dir) {\n    setValue(val + dir * step);\n  }\n\n  function setValue(v, fill, change) {\n    old = val;\n\n    if (fill === undefined) {\n      fill = true;\n    }\n\n    if (change === undefined) {\n      change = fill;\n    }\n\n    val = round(v);\n    $controls.removeClass('mbsc-disabled');\n\n    if (fill) {\n      $control.val(val);\n    }\n\n    if (val == min) {\n      $btnMinus.addClass('mbsc-disabled');\n    } else if (val == max) {\n      $btnPlus.addClass('mbsc-disabled');\n    }\n\n    if (val !== old && change) {\n      $control.trigger('change');\n    }\n  }\n\n  function getAttr(attr, def, str) {\n    var v = $control.attr(attr);\n    return v === undefined || v === '' ? def : str ? v : +v;\n  }\n\n  function round(v) {\n    return +Math.min(max, Math.max(Math.round(v / step) * step, min)).toFixed(scale);\n  } // Call the parent constructor\n\n\n  Base.call(this, control, settings, true);\n  /* TRIALFUNC */\n\n  that.getVal = function () {\n    var v = parseFloat($control.val());\n    v = isNaN(v) ? val : v;\n    return round(v);\n  };\n\n  that.setVal = function (v, fill, change) {\n    v = parseFloat(v);\n    setValue(isNaN(v) ? val : v, fill, change);\n  };\n\n  that._init = function () {\n    ready = $control.parent().hasClass('mbsc-stepper');\n    $parent = ready ? $control.closest('.mbsc-stepper-cont') : $control.parent();\n    s = that.settings;\n    min = settings.min === undefined ? getAttr('min', s.min) : settings.min;\n    max = settings.max === undefined ? getAttr('max', s.max) : settings.max;\n    step = settings.step === undefined ? getAttr('step', s.step) : settings.step;\n    scale = Math.abs(step) < 1 ? (step + '').split('.')[1].length : 0;\n    inputStyle = settings.inputStyle === undefined ? getAttr('data-input-style', s.inputStyle, true) : settings.inputStyle;\n    displayValue = $control.attr('data-val') || s.val;\n    val = round(+control.value || 0);\n    theme = mobiscroll.themes.form[s.theme];\n    ripple = theme && theme.addRipple ? theme : null;\n\n    if (!ready) {\n      $parent.addClass('mbsc-stepper-cont mbsc-no-touch mbsc-control-w').addClass(inputStyle == 'box' ? 'mbsc-input-box' : '').addClass(inputStyle == 'outline' ? 'mbsc-input-outline' : '').append('<span class=\"mbsc-segmented mbsc-stepper' + '\"></span>').find('.mbsc-stepper').append('<span class=\"mbsc-segmented-item mbsc-stepper-control mbsc-stepper-minus ' + (val == min ? 'mbsc-disabled' : '') + '\" data-step=\"-1\" tabindex=\"0\"><span class=\"mbsc-segmented-content\"><span class=\"mbsc-ic mbsc-ic-minus\"></span></span></span>').append('<span class=\"mbsc-segmented-item mbsc-stepper-control mbsc-stepper-plus ' + (val == max ? 'mbsc-disabled' : '') + '\"  data-step=\"1\" tabindex=\"0\"><span class=\"mbsc-segmented-content\"> <span class=\"mbsc-ic mbsc-ic-plus\"></span></span></span>').prepend($control);\n    }\n\n    if (cssClass) {\n      $parent.removeClass(cssClass).find('.mbsc-segmented').removeClass(cssClass);\n    }\n\n    cssClass = 'mbsc-' + s.theme + (theme.baseTheme ? ' mbsc-' + theme.baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr');\n    $parent.addClass(cssClass).find('.mbsc-segmented').addClass(cssClass);\n    $btnMinus = $$1('.mbsc-stepper-minus', $parent);\n    $btnPlus = $$1('.mbsc-stepper-plus', $parent);\n    $controls = $$1('.mbsc-stepper-control', $parent);\n\n    if (!ready) {\n      if (displayValue == 'left') {\n        $parent.addClass('mbsc-stepper-val-left');\n        $control.after('<span class=\"mbsc-segmented-item\"><span class=\"mbsc-segmented-content\"></span></span>');\n      } else if (displayValue == 'right') {\n        $parent.addClass('mbsc-stepper-val-right');\n        $btnPlus.after('<span class=\"mbsc-segmented-item\"><span class=\"mbsc-segmented-content\"></span></span>');\n      } else {\n        $btnMinus.after('<span class=\"mbsc-segmented-item\"><span class=\"mbsc-segmented-content mbsc-stepper-val\"></span></span>');\n      }\n    }\n\n    if (!stepper) {\n      $control.on('change', onChange);\n      stepper = createStepper($controls, stepValue, 150, checkDisabled, false, ripple);\n    }\n\n    $control.val(val).attr('data-role', 'stepper').attr('min', min).attr('max', max).attr('step', step).addClass('mbsc-control');\n    control.mbscInst = that;\n  };\n\n  that._destroy = function () {\n    $control.removeClass('mbsc-control').off('change', onChange);\n    stepper.destroy();\n    delete control.mbscInst;\n  };\n\n  that.init();\n};\n\nStepper.prototype = {\n  _class: 'stepper',\n  _hasDef: true,\n  _hasTheme: true,\n  _hasLang: true,\n  _defaults: {\n    min: 0,\n    max: 100,\n    step: 1\n  }\n};\nclasses.Stepper = Stepper; // Init mbsc-stepper elements on page load\n\nautoInit('[mbsc-stepper]', Stepper);\n\nvar ProgressBase = function ProgressBase(elm, settings, inherit) {\n  var $elm,\n      $parent,\n      cssClass,\n      s,\n      that = this; // Call the parent constructor\n\n  Base.call(this, elm, settings, true);\n  that.__init = noop;\n  that.__destroy = noop;\n\n  that._init = function () {\n    var wasInit;\n    s = that.settings;\n    $elm = $$1(elm); // Check if the element was already initialized\n\n    wasInit = !!$parent;\n    $parent = $elm.parent();\n    $parent = $parent.hasClass('mbsc-input-wrap') ? $parent.parent() : $parent;\n    that._$parent = $parent;\n\n    if (cssClass) {\n      $parent.removeClass(cssClass);\n    }\n\n    cssClass = that._css + ' mbsc-progress-w mbsc-control-w ' + getCssClass(s);\n    $parent.addClass(cssClass);\n    $elm.addClass('mbsc-control');\n\n    that.__init();\n\n    if (!wasInit) {\n      that._attachChange();\n    } // Show initial value\n\n\n    that.refresh();\n    elm.mbscInst = that;\n  };\n\n  that._destroy = function () {\n    that.__destroy();\n\n    $parent.removeClass(cssClass);\n    $elm.removeClass('mbsc-control');\n    delete elm.mbscInst;\n  };\n\n  if (!inherit) {\n    that.init();\n  }\n};\n\nvar SliderBase = function SliderBase(elm, settings, inherit) {\n  var $elm,\n      $handle,\n      $handleCont,\n      $handles,\n      $parent,\n      $track,\n      action,\n      base,\n      changed,\n      diffX,\n      diffY,\n      diff,\n      endX,\n      endY,\n      handleIndex,\n      isHover,\n      isPressed,\n      isRtl,\n      listener,\n      live,\n      max,\n      min,\n      moved,\n      multiple,\n      oldValue,\n      step,\n      s,\n      scale,\n      startX,\n      startY,\n      stepDecimal,\n      timer,\n      totalWidth,\n      value,\n      that = this,\n      lastUpdate = new Date();\n\n  function onStart(ev) {\n    if (ev.type === 'mousedown') {\n      ev.preventDefault();\n    }\n\n    if (testTouch(ev, this) && (!action || isHover) && !elm.disabled && !elm.readOnly\n    /* TRIALCOND */\n    ) {\n      if (s.stopProp) {\n        ev.stopPropagation();\n      }\n\n      action = true;\n      moved = false;\n      changed = false;\n      startX = getCoord(ev, 'X');\n      startY = getCoord(ev, 'Y');\n      endX = startX;\n      $track.removeClass('mbsc-progress-anim');\n      $handle = multiple ? $$1('.mbsc-slider-handle', this) : $handles;\n\n      if ($handleCont) {\n        $handleCont.removeClass('mbsc-handle-curr');\n      }\n\n      $handleCont = $handle.parent().addClass('mbsc-active mbsc-handle-curr');\n      $elm.addClass('mbsc-active');\n      handleIndex = +$handle.attr('data-index');\n      totalWidth = $track[0].offsetWidth;\n      diff = $track[0].getBoundingClientRect().left;\n\n      if (ev.type === 'mousedown') {\n        isPressed = true;\n        $$1(document).on('mousemove', onMove).on('mouseup', onEnd);\n      }\n\n      if (ev.type === 'mouseenter') {\n        isHover = true;\n        $$1(document).on('mousemove', onMove);\n      }\n    }\n  }\n\n  function onMove(ev) {\n    if (action) {\n      endX = getCoord(ev, 'X');\n      endY = getCoord(ev, 'Y');\n      diffX = endX - startX;\n      diffY = endY - startY;\n\n      if (Math.abs(diffX) > 5) {\n        moved = true;\n      }\n\n      if (moved || isPressed || isHover) {\n        if (Math.abs(lastUpdate - new Date()) > 50) {\n          lastUpdate = new Date();\n          updateSlider(endX, s.round, live && (!isHover || isPressed));\n        }\n      }\n\n      if (moved) {\n        ev.preventDefault();\n      } else if (Math.abs(diffY) > 7 && ev.type == 'touchmove') {\n        cleanUp();\n      }\n    }\n  }\n\n  function onEnd(ev) {\n    if (action) {\n      ev.preventDefault();\n\n      if (!multiple) {\n        $track.addClass('mbsc-progress-anim');\n      }\n\n      if (isHover && !isPressed) {\n        updateValue(value[handleIndex], handleIndex, false, false, true);\n      } else {\n        updateSlider(endX, true, true);\n      }\n\n      if (!moved && !changed) {\n        if (ev.type == 'touchend') {\n          // Prevent ghost click\n          preventClick();\n        }\n\n        that._onTap(value[handleIndex]);\n      }\n\n      if (ev.type == 'mouseup') {\n        isPressed = false;\n      }\n\n      if (ev.type == 'mouseleave') {\n        isHover = false;\n      }\n\n      if (!isHover) {\n        cleanUp();\n      }\n    }\n  }\n\n  function onCancel() {\n    if (action) {\n      cleanUp();\n    }\n  }\n\n  function onChange() {\n    var v = that._readValue($$1(this)),\n        i = +$$1(this).attr('data-index');\n\n    if (v !== value[i]) {\n      value[i] = v;\n      oldValue[i] = v;\n      updateValue(v, i);\n    }\n  }\n\n  function onClick(ev) {\n    // Prevent propagating click to label\n    ev.stopPropagation();\n  }\n\n  function onLabelClick(ev) {\n    // Prevent change on label click for swithes\n    ev.preventDefault();\n  }\n\n  function onKeyDown(ev) {\n    var dir;\n\n    if (!elm.disabled) {\n      switch (ev.keyCode) {\n        case 38:\n        case 39:\n          dir = 1;\n          break;\n\n        case 40:\n        case 37:\n          dir = -1;\n          break;\n      }\n\n      if (dir) {\n        ev.preventDefault();\n\n        if (!timer) {\n          handleIndex = +$$1(this).attr('data-index');\n          updateValue(value[handleIndex] + step * dir, handleIndex, true);\n          timer = setInterval(function () {\n            updateValue(value[handleIndex] + step * dir, handleIndex, true);\n          }, 200);\n        }\n      }\n    }\n  }\n\n  function onKeyUp(ev) {\n    ev.preventDefault();\n    clearInterval(timer);\n    timer = null;\n  }\n\n  function cleanUp() {\n    action = false;\n    $handleCont.removeClass('mbsc-active');\n    $elm.removeClass('mbsc-active'); // Detach document events\n\n    $$1(document).off('mousemove', onMove).off('mouseup', onEnd);\n  }\n\n  function updateSlider(pos, round, fill) {\n    var percent = round ? Math.min(Math[that._rounding || 'round'](Math.max((pos - diff) * 100 / totalWidth, 0) / scale / step) * step * 100 / (max - min + base), 100) : Math.max(0, Math.min((pos - diff) * 100 / totalWidth, 100));\n\n    if (isRtl) {\n      percent = 100 - percent;\n    }\n\n    updateValue(Math.round((min - base + percent / scale) * stepDecimal) / stepDecimal, handleIndex, fill, percent);\n  }\n\n  function updateValue(v, index, fill, percent, refresh, change) {\n    var $handle = $handles.eq(index),\n        $handleCont = $handle.parent();\n    v = Math.min(max, Math.max(v, min));\n\n    if (change === undefined) {\n      change = fill;\n    }\n\n    if (that._update) {\n      v = that._update(v, value, index, percent, multiple, refresh, $handleCont);\n    } else {\n      $handleCont.css({\n        left: isRtl ? 'auto' : (percent || getPercent(v, min, max)) + '%',\n        right: isRtl ? (percent || getPercent(v, min, max)) + '%' : 'auto'\n      });\n    }\n\n    if (v > min) {\n      $handleCont.removeClass('mbsc-slider-start');\n    } else if (value[index] > min || refresh) {\n      $handleCont.addClass('mbsc-slider-start');\n    } // Store new value\n\n\n    if (fill) {\n      value[index] = v;\n    } // Check if value changed\n\n\n    if (fill && oldValue[index] != v) {\n      changed = true;\n      oldValue[index] = v; // Set new value to the input\n\n      that._fillValue(v, index, change);\n    }\n\n    $handle.attr('aria-valuenow', v);\n  } // Call the parent constructor\n\n\n  ProgressBase.call(this, elm, settings, true);\n  that._onTap = noop;\n  that.___init = noop;\n  that.___destroy = noop;\n\n  that._attachChange = function () {\n    $elm.on(s.changeEvent, onChange);\n  };\n\n  that.__init = function () {\n    var wasInit;\n\n    if ($handles) {\n      wasInit = true;\n      $handles.parent().remove();\n    }\n\n    that.___init();\n\n    $parent = that._$parent;\n    $track = that._$track;\n    $elm = $parent.find('input');\n    s = that.settings;\n    min = that._min;\n    max = that._max;\n    base = that._base || 0;\n    step = that._step;\n    live = that._live;\n    stepDecimal = step % 1 !== 0 ? 100 / (+(step % 1).toFixed(2) * 100) : 1;\n    scale = 100 / (max - min + base) || 100;\n    multiple = $elm.length > 1;\n    isRtl = s.rtl;\n    value = [];\n    oldValue = []; // Read values\n\n    $elm.each(function (i) {\n      value[i] = that._readValue($$1(this));\n      $$1(this).attr('data-index', i);\n    });\n    $handles = $parent.find('.mbsc-slider-handle');\n    listener = $parent.find(multiple ? '.mbsc-slider-handle-cont' : '.mbsc-progress-cont')[0]; // Attach events\n\n    $handles.on('keydown', onKeyDown).on('keyup', onKeyUp).on('blur', onKeyUp);\n    listen(listener, 'touchstart', onStart, {\n      passive: true\n    });\n    listen(listener, 'mousedown', onStart);\n    listen(listener, 'touchend', onEnd);\n    listen(listener, 'touchcancel', onEnd);\n    listen(listener, 'pointercancel', onCancel);\n\n    if (s.hover) {\n      listen(listener, 'mouseenter', onStart);\n      listen(listener, 'mouseleave', onEnd);\n    }\n\n    if (!wasInit) {\n      $elm.on('click', onClick);\n      $parent.on('click', onLabelClick); // Attach to document to avoid non-passive listener warnings\n\n      listen(document, 'touchmove', onMove, {\n        passive: false\n      });\n    }\n  };\n\n  that.__destroy = function () {\n    $parent.off('click', onLabelClick);\n    $elm.off(s.changeEvent, onChange).off('click', onClick);\n    $handles.off('keydown', onKeyDown).off('keyup', onKeyUp).off('blur', onKeyUp);\n    unlisten(listener, 'touchstart', onStart, {\n      passive: true\n    });\n    unlisten(listener, 'mousedown', onStart);\n    unlisten(listener, 'touchend', onEnd);\n    unlisten(listener, 'touchcancel', onEnd);\n    unlisten(listener, 'pointercancel', onCancel);\n    unlisten(listener, 'mouseenter', onStart);\n    unlisten(listener, 'mouseleave', onEnd);\n    unlisten(document, 'touchmove', onMove, {\n      passive: false\n    });\n\n    that.___destroy();\n  };\n\n  that.refresh = function () {\n    $elm.each(function (i) {\n      updateValue(that._readValue($$1(this)), i, true, false, true, false);\n    });\n  };\n\n  that.getVal = function () {\n    return multiple ? value.slice(0) : value[0];\n  };\n\n  that.setVal = that._setVal = function (val, fill, change) {\n    if (!$$1.isArray(val)) {\n      val = [val];\n    }\n\n    $$1.each(val, function (i, v) {\n      value[i] = v;\n    });\n    $$1.each(val, function (i, v) {\n      updateValue(v, i, true, false, true, change);\n    });\n  };\n\n  if (!inherit) {\n    that.init();\n  }\n};\n\nvar Switch = function Switch(elm, settings) {\n  var $elm,\n      $parent,\n      s,\n      formControl,\n      that = this;\n  settings = settings || {};\n  extend$1(settings, {\n    changeEvent: 'click',\n    round: false\n  }); // Call the parent constructor\n\n  SliderBase.call(this, elm, settings, true);\n\n  that._readValue = function () {\n    return elm.checked ? 1 : 0;\n  };\n\n  that._fillValue = function (v, index, change) {\n    $elm.prop('checked', !!v);\n\n    if (change) {\n      $elm.trigger('change');\n    }\n  };\n\n  that._onTap = function (v) {\n    that._setVal(v ? 0 : 1);\n  };\n\n  that.___init = function () {\n    s = that.settings;\n    $elm = $$1(elm);\n    $parent = $elm.parent();\n    $parent.find('.mbsc-switch-track').remove();\n    $parent.prepend($elm);\n    $elm.attr('data-role', 'switch').after('<span class=\"mbsc-progress-cont mbsc-switch-track\">' + '<span class=\"mbsc-progress-track mbsc-progress-anim\">' + '<span class=\"mbsc-slider-handle-cont\">' + '<span class=\"mbsc-slider-handle mbsc-switch-handle\" data-index=\"0\">' + '<span class=\"mbsc-switch-txt-off\">' + s.offText + '</span>' + '<span class=\"mbsc-switch-txt-on\">' + s.onText + '</span>' + '</span></span></span></span>');\n\n    if (formControl) {\n      formControl.destroy();\n    }\n\n    formControl = new FormControl(elm, s);\n    that._$track = $parent.find('.mbsc-progress-track');\n    that._min = 0;\n    that._max = 1;\n    that._step = 1;\n  };\n\n  that.___destroy = function () {\n    formControl.destroy();\n  };\n\n  that.getVal = function () {\n    return elm.checked;\n  };\n\n  that.setVal = function (val, fill, change) {\n    that._setVal(val ? 1 : 0, fill, change);\n  };\n\n  that.init();\n};\n\nSwitch.prototype = {\n  _class: 'switch',\n  _css: 'mbsc-switch',\n  _hasTheme: true,\n  _hasLang: true,\n  _hasDef: true,\n  _defaults: {\n    stopProp: true,\n    offText: 'Off',\n    onText: 'On'\n  }\n};\nclasses.Switch = Switch; // Init mbsc-switch elements on page load\n\nautoInit('[mbsc-switch]', Switch); // eslint-disable-next-line no-unused-vars\n\nvar Progress = function Progress(elm, settings, inherit) {\n  var $display,\n      $elm,\n      $parent,\n      $progress,\n      $target,\n      $track,\n      min,\n      max,\n      inputStyle,\n      labelStyle,\n      s,\n      template,\n      value,\n      valueText,\n      that = this;\n\n  function onChange() {\n    var v = getAttr('value', min);\n\n    if (v !== value) {\n      updateValue(v);\n    }\n  }\n\n  function getAttr(attr, def, str) {\n    var v = $elm.attr(attr);\n    return v === undefined || v === '' ? def : str ? v : +v;\n  }\n\n  function updateValue(v, refresh, fill, change) {\n    v =\n    /* TRIALCONDREV */\n    Math.min(max, Math.max(v, min));\n    $progress.css('width', (v - min) * 100 / (max - min) + '%');\n\n    if (fill === undefined) {\n      fill = true;\n    }\n\n    if (change === undefined) {\n      change = fill;\n    }\n\n    if (v !== value || refresh) {\n      // Display value\n      that._display(v);\n    }\n\n    if (v !== value) {\n      // Set new value\n      value = v; // Put new value in the progress element\n\n      if (fill) {\n        $elm.attr('value', value);\n      } // Trigger change on the element\n\n\n      if (change) {\n        $elm.trigger('change');\n      }\n    }\n  } // Call the parent constructor\n\n\n  ProgressBase.call(this, elm, settings, true);\n\n  that._display = function (v) {\n    valueText = template && s.returnAffix ? template.replace(/\\{value\\}/, v).replace(/\\{max\\}/, max) : v;\n\n    if ($target) {\n      $target.html(valueText);\n    }\n\n    if ($display) {\n      $display.html(valueText);\n    }\n  };\n\n  that._attachChange = function () {\n    $elm.on('change', onChange);\n  };\n\n  that.__init = function () {\n    var displayValue, i, stepLabels, wasInit;\n    s = that.settings;\n    $elm = $$1(elm); // Check if the element was already initialized\n\n    wasInit = !!$parent;\n    $parent = that._$parent; // Read settings from data attributes or settings object\n\n    min = that._min = settings.min === undefined ? getAttr('min', s.min) : settings.min;\n    max = that._max = settings.max === undefined ? getAttr('max', s.max) : settings.max;\n    inputStyle = settings.inputStyle === undefined ? getAttr('data-input-style', s.inputStyle, true) : settings.inputStyle;\n    labelStyle = settings.labelStyle === undefined ? getAttr('data-label-style', s.labelStyle, true) : settings.labelStyle;\n    value = getAttr('value', min);\n    displayValue = $elm.attr('data-val') || s.val;\n    stepLabels = $elm.attr('data-step-labels');\n    stepLabels = stepLabels ? JSON.parse(stepLabels) : s.stepLabels;\n    template = $elm.attr('data-template') || (max == 100 && !s.template ? '{value}%' : s.template);\n\n    if (!wasInit) {\n      wrapLabel($parent, null, inputStyle, labelStyle, elm);\n      addIcon($elm); // Generate track and progress\n\n      $parent.find('.mbsc-input-wrap').append('<span class=\"mbsc-progress-cont\"><span class=\"mbsc-progress-track mbsc-progress-anim\"><span class=\"mbsc-progress-bar\"></span></span></span>');\n      $progress = that._$progress = $parent.find('.mbsc-progress-bar');\n      $track = that._$track = $parent.find('.mbsc-progress-track');\n    } else {\n      if (displayValue) {\n        $display.remove();\n        $parent.removeClass('mbsc-progress-value-' + (displayValue == 'right' ? 'right' : 'left'));\n      }\n\n      if (stepLabels) {\n        $$1('.mbsc-progress-step-label', $track).remove();\n      }\n    } // Set attributes\n\n\n    $elm.attr('min', min).attr('max', max); // Generate value container on left or right side\n\n    if (displayValue) {\n      $display = $$1('<span class=\"mbsc-progress-value\"></span>');\n      $parent.addClass('mbsc-progress-value-' + (displayValue == 'right' ? 'right' : 'left')).find('.mbsc-input-wrap').append($display);\n    } // Generate step labels\n\n\n    if (stepLabels) {\n      for (i = 0; i < stepLabels.length; ++i) {\n        $track.append('<span class=\"mbsc-progress-step-label\" style=\"' + (s.rtl ? 'right' : 'left') + ': ' + (stepLabels[i] - min) * 100 / (max - min) + '%\" >' + stepLabels[i] + '</span>');\n      }\n    }\n\n    $target = $$1($elm.attr('data-target') || s.target);\n  };\n\n  that.__destroy = function () {\n    $parent.removeClass('mbsc-ic-left mbsc-ic-right').find('.mbsc-progress-cont').remove();\n    $parent.find('.mbsc-input-ic').remove();\n    $elm.off('change', onChange);\n  };\n\n  that.refresh = function () {\n    updateValue(getAttr('value', min), true, false);\n  };\n\n  that.getVal = function () {\n    return value;\n  };\n\n  that.setVal = function (v, fill, change) {\n    updateValue(v, true, fill, change);\n  };\n\n  if (!inherit) {\n    that.init();\n  }\n};\n\nProgress.prototype = {\n  _class: 'progress',\n  _css: 'mbsc-progress',\n  _hasTheme: true,\n  _hasLang: true,\n  _hasDef: true,\n  _defaults: {\n    min: 0,\n    max: 100,\n    returnAffix: true\n  }\n};\nclasses.Progress = Progress; // Init mbsc-progress elements on page load\n\nautoInit('[mbsc-progress]', Progress);\n\nvar Slider = function Slider(elm, settings, inherit) {\n  var $elm,\n      $parent,\n      $progress,\n      $tooltips,\n      $track,\n      hasProgress,\n      hasTooltip,\n      isRange,\n      isRtl,\n      max,\n      min,\n      step,\n      s,\n      that = this; // Call the parent constructor\n\n  Progress.call(this, elm, settings, true);\n  var progressInit = that.__init,\n      progressDestroy = that.__destroy;\n  SliderBase.call(this, elm, settings, true);\n  var sliderInit = that.__init,\n      sliderDestroy = that.__destroy; // ---\n\n  that.__init = function () {\n    progressInit();\n    sliderInit();\n  };\n\n  that.__destroy = function () {\n    progressDestroy();\n    sliderDestroy();\n  };\n\n  that._update = function (v, value, index, percent, multiple, refresh, $handleCont) {\n    if (isRange) {\n      if (index === 0) {\n        v = Math.min(v, value[1]);\n        $progress.css({\n          width: getPercent(value[1], min, max) - getPercent(v, min, max) + '%',\n          left: isRtl ? 'auto' : getPercent(v, min, max) + '%',\n          right: isRtl ? getPercent(v, min, max) + '%' : 'auto'\n        });\n      } else {\n        v = Math.max(v, value[0]);\n        $progress.css({\n          width: getPercent(v, min, max) - getPercent(value[0], min, max) + '%'\n        });\n      }\n    } else if (multiple || !hasProgress) {\n      $handleCont.css({\n        left: isRtl ? 'auto' : (percent || getPercent(v, min, max)) + '%',\n        right: isRtl ? (percent || getPercent(v, min, max)) + '%' : 'auto'\n      });\n    } else {\n      $progress.css('width', (percent || getPercent(v, min, max)) + '%');\n    }\n\n    if (hasTooltip) {\n      $tooltips.eq(index).html(v);\n    } // Display value in the specified container(s)\n\n\n    if (!multiple && (value[index] != v || refresh)) {\n      that._display(v);\n    } // Return validated value\n\n\n    return v;\n  };\n\n  that._readValue = function ($elm) {\n    return +$elm.val();\n  };\n\n  that._fillValue = function (v, index, change) {\n    $elm.eq(index).val(v);\n\n    if (change) {\n      $elm.eq(index).trigger('change');\n    }\n  };\n\n  that._markupReady = function () {\n    var i, stepNr;\n\n    if (hasTooltip) {\n      $parent.addClass('mbsc-slider-has-tooltip');\n    } // Generate step marks\n\n\n    if (step != 1) {\n      stepNr = (max - min) / step;\n\n      for (i = 0; i <= stepNr; ++i) {\n        $track.append('<span class=\"mbsc-slider-step\" style=\"' + (isRtl ? 'right' : 'left') + ':' + 100 / stepNr * i + '%\"></span>');\n      }\n    } // Generate slider handles\n\n\n    $elm.each(function (i) {\n      if (this.type == 'range') {\n        // Set min / max / step properties for all inputs\n        $$1(this).attr('min', min).attr('max', max).attr('step', step);\n      }\n\n      (hasProgress ? $progress : $track).append('<span class=\"mbsc-slider-handle-cont' + (isRange && !i ? ' mbsc-slider-handle-left' : '') + '\">' + '<span tabindex=\"0\" class=\"mbsc-slider-handle\" aria-valuemin=\"' + min + '\" aria-valuemax=\"' + max + '\" data-index=\"' + i + '\"></span>' + (hasTooltip ? '<span class=\"mbsc-slider-tooltip\"></span>' : '') + '</span>');\n    });\n    $tooltips = $parent.find('.mbsc-slider-tooltip');\n  };\n\n  that.___init = function () {\n    if ($parent) {\n      $parent.removeClass('mbsc-slider-has-tooltip');\n\n      if (step != 1) {\n        $$1('.mbsc-slider-step', $track).remove();\n      }\n    }\n\n    $parent = that._$parent;\n    $track = that._$track;\n    $progress = that._$progress;\n    $elm = $parent.find('input');\n    s = that.settings;\n    min = that._min;\n    max = that._max;\n    that._step = step = settings.step === undefined ? +$elm.attr('step') || s.step : settings.step;\n    that._live = getBoolAttr('data-live', s.live, $elm);\n    hasTooltip = getBoolAttr('data-tooltip', s.tooltip, $elm);\n    hasProgress = getBoolAttr('data-highlight', s.highlight, $elm) && $elm.length < 3;\n    isRange = hasProgress && $elm.length == 2;\n    isRtl = s.rtl;\n\n    that._markupReady();\n  };\n\n  if (!inherit) {\n    that.init();\n  }\n};\n\nSlider.prototype = {\n  _class: 'progress',\n  _css: 'mbsc-progress mbsc-slider',\n  _hasTheme: true,\n  _hasLang: true,\n  _hasDef: true,\n  _defaults: {\n    changeEvent: 'change',\n    stopProp: true,\n    min: 0,\n    max: 100,\n    step: 1,\n    live: true,\n    highlight: true,\n    round: true,\n    returnAffix: true\n  }\n};\nclasses.Slider = Slider; // Init mbsc-slider elements on page load\n\nautoInit('[mbsc-slider]', Slider);\n\nvar Rating = function Rating(elm, settings, inherit) {\n  var $progress,\n      $track,\n      max,\n      min,\n      empty,\n      filled,\n      s,\n      that = this,\n      $elm = $$1(elm); // Call the parent constructor\n\n  Slider.call(this, elm, settings, true);\n\n  that._update = function (v, value, index, percent, multiple, refresh) {\n    $progress.css('width', getPercent(v, 0, max) + '%'); // Display value in the specified container(s)\n\n    if (!multiple && (value[index] != v || refresh)) {\n      that._display(v);\n    } // Return validated value\n\n\n    return v;\n  };\n\n  that._markupReady = function () {\n    var i,\n        emptyString = '',\n        filledString = '';\n    $track = that._$track;\n    $progress = that._$progress;\n    s = that.settings;\n    min = that._min;\n    max = that._max;\n    that._base = min;\n    that._rounding = s.rtl ? 'floor' : 'ceil';\n    empty = $elm.attr('data-empty') || s.empty;\n    filled = $elm.attr('data-filled') || s.filled;\n\n    for (i = 0; i < max; ++i) {\n      emptyString += '<span class=\"mbsc-ic mbsc-ic-' + empty + '\"></span>';\n      filledString += '<span class=\"mbsc-ic mbsc-ic-' + filled + '\"></span>';\n    }\n\n    $track.html(emptyString);\n    $track.append($progress);\n    $progress.html(filledString);\n    $track.append('<span class=\"mbsc-rating-handle-cont' + '\">' + '<span tabindex=\"0\" class=\"mbsc-slider-handle\" aria-valuemin=\"' + min + '\" aria-valuemax=\"' + max + '\" data-index=\"0\"></span>' + '</span>');\n  };\n\n  if (!inherit) {\n    that.init();\n  }\n};\n\nRating.prototype = {\n  _class: 'progress',\n  _css: 'mbsc-progress mbsc-rating',\n  _hasTheme: true,\n  _hasLang: true,\n  _hasDef: true,\n  _defaults: {\n    changeEvent: 'change',\n    stopProp: true,\n    min: 1,\n    max: 5,\n    step: 1,\n    live: true,\n    round: true,\n    hover: true,\n    highlight: true,\n    returnAffix: true,\n    empty: 'star',\n    filled: 'star3'\n  }\n};\nclasses.Rating = Rating; // Init mbsc-rating elements on page load\n\nautoInit('[mbsc-rating]', Rating);\nvar nr = 1;\n\nvar CollapsibleBase = /*#__PURE__*/function () {\n  function CollapsibleBase(elm, settings) {\n    var _this = this;\n\n    var content;\n    var $header;\n    var $content;\n    var $elm = $$1(elm);\n    this.settings = settings;\n    this._isOpen = settings.isOpen || false;\n    $elm.addClass('mbsc-collapsible ' + (this._isOpen ? 'mbsc-collapsible-open' : ''));\n\n    if ($elm.hasClass('mbsc-card')) {\n      // card enhance\n      $header = $elm.find('.mbsc-card-header').eq(0).addClass('mbsc-collapsible-header');\n      $content = $elm.find('.mbsc-card-content').eq(0).addClass('mbsc-collapsible-content');\n    } else if ($elm.hasClass('mbsc-form-group') || $elm.hasClass('mbsc-form-group-inset')) {\n      // form group enhance\n      $header = $elm.find('.mbsc-form-group-title').eq(0).addClass('mbsc-collapsible-header');\n      $content = $elm.find('.mbsc-form-group-content').eq(0).addClass('mbsc-collapsible-content');\n    } else {\n      // if it is used independently\n      $header = $elm.find('.mbsc-collapsible-header').eq(0);\n      $content = $elm.find('.mbsc-collapsible-content').eq(0);\n    }\n\n    content = $content[0];\n\n    if (content && !content.id) {\n      content.id = 'mbsc-collapsible-' + nr++;\n    }\n\n    if ($header.length && content) {\n      var $collapsibleIcon = $$1('<span class=\"mbsc-collapsible-icon mbsc-ic mbsc-ic-arrow-down5\"></span>');\n      tap(this, $header, function () {\n        _this.collapse();\n      });\n      $header.attr('role', 'button').attr('aria-expanded', this._isOpen).attr('aria-controls', content.id).attr('tabindex', '0').on('mousedown', function (ev) {\n        // prevent focus on mouse down\n        ev.preventDefault();\n      }).on('keydown', function (ev) {\n        if (ev.which === 32 || ev.keyCode == 13) {\n          //space or enter \n          ev.preventDefault();\n\n          _this.collapse();\n        }\n      }).append($collapsibleIcon);\n    }\n\n    elm.mbscInst = this;\n    this._$header = $header;\n    this._$content = $content;\n    this._$elm = $elm;\n    this._$accordionParent = $elm.parent('[mbsc-accordion], mbsc-accordion, .mbsc-accordion');\n    this.show = this.show.bind(this);\n    this.hide = this.hide.bind(this);\n    this.toggle = this.toggle.bind(this);\n  }\n\n  var _proto = CollapsibleBase.prototype;\n\n  _proto.collapse = function collapse(show) {\n    var $elm = this._$elm;\n    var $content = this._$content;\n\n    var removeHeight = function removeHeight() {\n      $content.off('transitionend', removeHeight).css('height', '');\n    };\n\n    if (show === undefined) {\n      show = !this._isOpen;\n    }\n\n    if (show && this._isOpen || !show && !this._isOpen || !$content.length) {\n      return;\n    }\n\n    if (show) {\n      if (hasTransition) {\n        $content.on('transitionend', removeHeight).css('height', $content[0].scrollHeight);\n      }\n\n      $elm.addClass('mbsc-collapsible-open');\n    } else {\n      if (hasTransition) {\n        $content.css('height', getComputedStyle($content[0]).height);\n      }\n\n      setTimeout(function () {\n        $content.css('height', 0);\n        $elm.removeClass('mbsc-collapsible-open');\n      }, 50);\n    }\n\n    if (show && this._$accordionParent) {\n      this._$accordionParent.find('.mbsc-collapsible-open').each(function () {\n        if (this !== $elm[0]) {\n          this.mbscInst.hide();\n        }\n      });\n    }\n\n    this._isOpen = show;\n\n    this._$header.attr('aria-expanded', this._isOpen);\n  };\n\n  _proto.show = function show() {\n    this.collapse(true);\n  };\n\n  _proto.hide = function hide() {\n    this.collapse(false);\n  };\n\n  _proto.toggle = function toggle() {\n    this.collapse();\n  };\n\n  _proto.destroy = function destroy() {\n    this._$elm.removeClass('mbsc-collapsible mbsc-collapsible-open');\n\n    this._$content.removeClass('mbsc-collapsible-content');\n\n    this._$header.removeClass('mbsc-collapsible-header').find('.mbsc-collapsible-icon').remove();\n  };\n\n  return CollapsibleBase;\n}();\n\nclasses.CollapsibleBase = CollapsibleBase;\nvar id$2 = 0;\n\nfunction initControls($ctx, controls, s, shallow) {\n  $$1('input,select,textarea,progress,button', $ctx).each(function () {\n    var control = this,\n        $control = $$1(control),\n        //$parent = $control.parent(),\n    type = getControlType($control); // Skip elements with data-enhance=\"false\"\n\n    if ($control.attr('data-enhance') != 'false'\n    /* TRIALCOND */\n    ) {\n      if ($control.hasClass('mbsc-control')) {\n        if (control.mbscInst) {\n          control.mbscInst.option({\n            theme: s.theme,\n            lang: s.lang,\n            rtl: s.rtl,\n            onText: s.onText,\n            offText: s.offText,\n            stopProp: s.stopProp\n          });\n        }\n      } else {\n        if (!control.id) {\n          control.id = 'mbsc-form-control-' + ++id$2;\n        }\n\n        switch (type) {\n          case 'button':\n          case 'submit':\n            controls[control.id] = new Button(control, {\n              theme: s.theme,\n              rtl: s.rtl,\n              tap: s.tap\n            });\n            break;\n\n          case 'switch':\n            controls[control.id] = new Switch(control, {\n              theme: s.theme,\n              lang: s.lang,\n              rtl: s.rtl,\n              tap: s.tap,\n              onText: s.onText,\n              offText: s.offText,\n              stopProp: s.stopProp\n            });\n            break;\n\n          case 'checkbox':\n            controls[control.id] = new CheckBox(control, {\n              tap: s.tap,\n              theme: s.theme,\n              rtl: s.rtl\n            });\n            break;\n\n          case 'range':\n            if (!$$1(control).parent().hasClass('mbsc-slider')) {\n              controls[control.id] = new Slider(control, {\n                theme: s.theme,\n                lang: s.lang,\n                rtl: s.rtl,\n                stopProp: s.stopProp,\n                labelStyle: s.labelStyle\n              });\n            }\n\n            break;\n\n          case 'rating':\n            controls[control.id] = new Rating(control, {\n              theme: s.theme,\n              lang: s.lang,\n              rtl: s.rtl,\n              stopProp: s.stopProp\n            });\n            break;\n\n          case 'progress':\n            controls[control.id] = new Progress(control, {\n              theme: s.theme,\n              lang: s.lang,\n              rtl: s.rtl,\n              labelStyle: s.labelStyle\n            });\n            break;\n\n          case 'radio':\n            controls[control.id] = new Radio(control, {\n              tap: s.tap,\n              theme: s.theme,\n              rtl: s.rtl\n            });\n            break;\n\n          case 'select':\n          case 'select-one':\n          case 'select-multiple':\n            controls[control.id] = new Select(control, {\n              tap: s.tap,\n              inputStyle: s.inputStyle,\n              labelStyle: s.labelStyle,\n              theme: s.theme,\n              rtl: s.rtl\n            });\n            break;\n\n          case 'textarea':\n            controls[control.id] = new TextArea(control, {\n              tap: s.tap,\n              inputStyle: s.inputStyle,\n              labelStyle: s.labelStyle,\n              theme: s.theme,\n              rtl: s.rtl\n            });\n            break;\n\n          case 'segmented':\n            controls[control.id] = new SegmentedItem(control, {\n              theme: s.theme,\n              rtl: s.rtl,\n              tap: s.tap,\n              inputStyle: s.inputStyle\n            });\n            break;\n\n          case 'stepper':\n            controls[control.id] = new Stepper(control, {\n              theme: s.theme,\n              rtl: s.rtl\n            });\n            break;\n\n          case 'hidden':\n            return;\n\n          default:\n            controls[control.id] = new Input(control, {\n              tap: s.tap,\n              inputStyle: s.inputStyle,\n              labelStyle: s.labelStyle,\n              theme: s.theme,\n              rtl: s.rtl\n            });\n            break;\n        }\n      }\n    }\n  });\n  $$1('[data-collapsible]:not(.mbsc-collapsible)', $ctx).each(function () {\n    var control = this,\n        $control = $$1(control),\n        isOpen = $control.attr('data-open');\n\n    if (!control.id) {\n      control.id = 'mbsc-form-control-' + ++id$2;\n    }\n\n    controls[control.id] = new CollapsibleBase(control, {\n      isOpen: isOpen !== undefined && isOpen != 'false'\n    });\n    instances[control.id] = controls[control.id];\n  }); // Set initial height for textareas\n\n  if (!shallow) {\n    sizeTextAreas();\n  }\n} // eslint-disable-next-line no-unused-vars\n\n\nvar halfBorder$1 = os == 'ios' && majorVersion > 7;\n\nvar Card = function Card(el, settings) {\n  var s,\n      collapsibleInst,\n      cssClass = '',\n      $elm = $$1(el),\n      controls = {},\n      that = this;\n\n  function touched() {\n    $elm.removeClass('mbsc-no-touch');\n  } // Call the parent constructor\n\n\n  Base.call(this, el, settings, true);\n\n  that.refresh = function (shallow) {\n    initControls($elm, controls, s, shallow);\n  };\n  /**\r\n   * Card initialization.\r\n   */\n\n\n  that._init = function () {\n    var isCollapsible = s.collapsible !== undefined || $elm.attr('data-collapsible') !== undefined;\n\n    if (!$elm.hasClass('mbsc-card')) {\n      $elm.show();\n      listen(el, 'touchstart', touched, {\n        passive: true\n      });\n    }\n\n    if (cssClass) {\n      $elm.removeClass(cssClass);\n    } // --- TRIAL SERVER CODE START ---\n\n\n    cssClass = 'mbsc-card mbsc-form mbsc-no-touch mbsc-' + s.theme + (halfBorder$1 ? ' mbsc-form-hb' : '') + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr'); // --- TRIAL SERVER CODE END ---\n\n    $elm.addClass(cssClass).removeClass('mbsc-cloak');\n\n    if (isCollapsible && !collapsibleInst) {\n      var isOpen = $elm.attr('data-open');\n      collapsibleInst = new CollapsibleBase(el, {\n        isOpen: isOpen !== undefined && isOpen != 'false' || s.collapsible === true\n      });\n    }\n    /* TRIAL */\n\n\n    that.refresh();\n  };\n  /**\r\n   * Destroys the mobiscroll instance.\r\n   */\n\n\n  that._destroy = function () {\n    $elm.removeClass(cssClass);\n    unlisten(el, 'touchstart', touched, {\n      passive: true\n    });\n\n    for (var id in controls) {\n      controls[id].destroy();\n    }\n\n    if (collapsibleInst) {\n      collapsibleInst.destroy();\n    }\n  };\n\n  that.toggle = function () {\n    if (collapsibleInst) {\n      collapsibleInst.toggle();\n    }\n  };\n\n  that.hide = function () {\n    if (collapsibleInst) {\n      collapsibleInst.hide();\n    }\n  };\n\n  that.show = function () {\n    if (collapsibleInst) {\n      collapsibleInst.show();\n    }\n  }; // Constructor\n\n\n  s = that.settings;\n  that.init();\n}; // Extend defaults\n\n\nCard.prototype = {\n  _hasDef: true,\n  _hasTheme: true,\n  _hasLang: true,\n  _class: 'card',\n  _defaults: {\n    tap: hasGhostClick,\n    stopProp: true,\n    rtl: false\n  }\n};\nclasses.Card = Card; // Init mbsc-card elements on page load or when mbsc-enhance event is triggeres\n\nautoInit('[mbsc-card]', Card, true);\nvar SELECTED_CLASS = 'mbsc-selected';\nvar ACTIVE_CLASS = 'mbsc-lv-item-active';\nvar confirms,\n    halfBorder$2 = os == 'ios' && majorVersion > 7,\n    guid = 1,\n    transp = 'transparent';\n\nvar ListView = function ListView(elem, settings) {\n  var action,\n      actionWidth,\n      activeTimer,\n      animPos,\n      cancel,\n      confirmItem,\n      confirmIndex,\n      cont,\n      cont0,\n      currIndex,\n      currList,\n      currPh,\n      currParent,\n      currSiblings,\n      currStage,\n      currStageIdx,\n      debounce,\n      demoMode,\n      disabled,\n      diffX,\n      diffY,\n      dropDown,\n      dropUp,\n      dragged,\n      dummyCont,\n      endTimer,\n      endX,\n      endY,\n      event,\n      fill,\n      found,\n      groupHeader,\n      hadEnhance,\n      handlePos,\n      hasContext,\n      handleDiv,\n      hoverDir,\n      hoverItem,\n      hoverItemOpened,\n      hoverTime,\n      hoverTimeout,\n      hoverTimer,\n      htmlLeft,\n      htmlRight,\n      icon,\n      iconc,\n      stagec,\n      isClick,\n      isLoading,\n      isTouch,\n      itemw,\n      item,\n      itemHeight,\n      itemIndex,\n      itemNode,\n      itemSelector,\n      itemTop,\n      listNode,\n      listSelector,\n      loading,\n      maxDrag,\n      minDrag,\n      multic,\n      multiple,\n      nextItem,\n      nextOffset,\n      nextStage,\n      nextItems,\n      onScrollThrottle,\n      onScrollDebounce,\n      prevClick,\n      preventHover,\n      preventTimer,\n      prevItems,\n      placeholder,\n      prevItem,\n      prevOffset,\n      prevStage,\n      quickSwipe,\n      rafID,\n      rafRunning,\n      s,\n      scroll,\n      selectable,\n      simulating,\n      slideCont,\n      stageNr,\n      stages,\n      startPos,\n      startTime,\n      startX,\n      startY,\n      style,\n      swipe,\n      swipeInterval,\n      swipeTimeout,\n      tapHighlight,\n      text,\n      timer,\n      type,\n      types,\n      undoRef,\n      undoAnim,\n      wnd,\n      wnd0,\n      wndHeight,\n      wndScroll,\n      wndTop,\n      that = this,\n      e = elem,\n      elm = $$1(e),\n      transition = 0,\n      slideLevel = 0,\n      startTop = 0,\n      stageObj = {},\n      actionQueue = {},\n      treeMap = {};\n\n  function onActionStart() {\n    quickSwipe = false;\n    prevClick = false;\n    animPos = 0;\n    startPos = 0;\n    startTime = new Date();\n    itemw = currList.width();\n    currSiblings = getChildren(currList);\n    itemIndex = currSiblings.index(item);\n    itemHeight = item[0].offsetHeight;\n    startTop = item[0].offsetTop;\n    type = types[item.attr('data-type') || 'defaults'];\n    stages = type.stages;\n  }\n\n  function onStart(ev) {\n    var itm;\n    var target = closest(cont0, ev.target, '.mbsc-lv-item');\n\n    if (!target || !cont0.contains(target)) {\n      return;\n    }\n\n    if (ev.type === 'touchstart') {\n      cont.removeClass('mbsc-no-touch');\n      preventHover = true;\n      clearTimeout(preventTimer);\n    }\n\n    if (testTouch(ev, target) && !action && !transition && !confirms && !undoing\n    /* TRIALCOND */\n    ) {\n      action = true;\n      cancel = true;\n      isClick = false;\n      isTouch = ev.type === 'touchstart';\n      startX = getCoord(ev, 'X');\n      startY = getCoord(ev, 'Y');\n      diffX = 0;\n      diffY = 0;\n      item = $$1(target);\n      itm = item; // Local reference\n\n      onActionStart();\n      tapHighlight = type.actionable || item.hasClass('mbsc-lv-parent') || item.hasClass('mbsc-lv-back');\n      itemTop = item.offset().top;\n\n      if (tapHighlight) {\n        activeTimer = setTimeout(function () {\n          itm.addClass(isTouch ? ACTIVE_CLASS : '');\n          event('onItemActivate', {\n            target: itm[0],\n            domEvent: ev\n          });\n        }, 120);\n      }\n\n      if (that.sortable && !item.hasClass('mbsc-lv-back')) {\n        if (!that.sortable.group) {\n          nextItems = item.nextUntil('.mbsc-lv-gr-title').filter('.mbsc-lv-item');\n          prevItems = item.prevUntil('.mbsc-lv-gr-title').filter('.mbsc-lv-item');\n        }\n\n        minDrag = (!that.sortable.group ? prevItems.length ? prevItems.eq(-1) : item : currList.children(itemSelector).eq(0))[0].offsetTop - startTop;\n        maxDrag = (!that.sortable.group ? nextItems.length ? nextItems.eq(-1) : item : currList.children(itemSelector).eq(-1))[0].offsetTop - startTop;\n\n        if (that.sortable.handle) {\n          if ($$1(ev.target).hasClass('mbsc-lv-handle')) {\n            clearTimeout(activeTimer);\n\n            if (jsPrefix === 'Moz') {\n              // On FF we need to prevent touchstart to disable scroll\n              ev.preventDefault();\n              onSortStart();\n            } else {\n              timer = setTimeout(function () {\n                onSortStart();\n              }, 100);\n            }\n          }\n        } else {\n          timer = setTimeout(function () {\n            fill.appendTo(item);\n            fill[0].style[jsPrefix + 'Animation'] = 'mbsc-lv-fill ' + (s.sortDelay - 100) + 'ms linear';\n            clearTimeout(endTimer);\n            clearTimeout(activeTimer);\n            cancel = false;\n            timer = setTimeout(function () {\n              fill[0].style[jsPrefix + 'Animation'] = '';\n              onSortStart();\n            }, s.sortDelay - 80);\n          }, 80);\n        }\n      }\n\n      if (ev.type == 'mousedown') {\n        $$1(document).on('mousemove', onMove).on('mouseup', onEnd);\n      }\n    }\n  }\n\n  function onMove(ev) {\n    var sortChange = false,\n        dropChange = true,\n        prevPos = animPos;\n\n    if (action) {\n      endX = getCoord(ev, 'X');\n      endY = getCoord(ev, 'Y');\n      diffX = endX - startX;\n      diffY = endY - startY;\n      clearTimeout(endTimer);\n\n      if (!dragged && !swipe && !scroll && !item.hasClass('mbsc-lv-back')) {\n        if (Math.abs(diffY) > 10) {\n          // It's a scroll\n          scroll = true;\n          onEnd(extend$1({}, ev, {\n            type: ev.type == 'mousemove' ? 'mouseup' : 'touchend'\n          }));\n          clearTimeout(activeTimer);\n        } else if (Math.abs(diffX) > 7) {\n          // It's a swipe\n          onSwipeStart();\n        }\n      }\n\n      if (swipe) {\n        ev.preventDefault();\n        animPos = diffX / itemw * 100;\n        onSwipeMove(prevPos);\n      } else if (dragged) {\n        ev.preventDefault();\n        var scrolled,\n            st = wnd.scrollTop(),\n            diff = Math.max(minDrag, Math.min(diffY + wndScroll, maxDrag)),\n            top = hasContext ? itemTop - wndTop + st - wndScroll : itemTop; // Check if scroll is needed\n\n        if (wndHeight + st < top + diff + itemHeight) {\n          wnd.scrollTop(top + diff - wndHeight + itemHeight);\n          scrolled = true;\n        } else if (top + diff < st) {\n          wnd.scrollTop(top + diff);\n          scrolled = true;\n        } // Update scroll values if window was scrolled\n\n\n        if (scrolled) {\n          wndScroll += wnd.scrollTop() - st;\n        } // Check overlap with next item\n\n\n        if (nextOffset) {\n          // If subtree exists, drop element on subtree at 1/4, change sort order at 3/4 overlap\n          if (that.sortable.multiLevel && nextItem.hasClass('mbsc-lv-parent')) {\n            if (startTop + itemHeight / 4 + diff > nextOffset) {\n              sortChange = true;\n            } else if (startTop + itemHeight - itemHeight / 4 + diff > nextOffset) {\n              dropDown = nextItem.addClass('mbsc-lv-item-hl');\n              dropChange = false;\n            } // Check 1/2 overlap\n\n          } else if (startTop + itemHeight / 2 + diff > nextOffset) {\n            // If over back button, highlight to drop to parent level\n            if (nextItem.hasClass('mbsc-lv-back')) {\n              if (that.sortable.multiLevel) {\n                dropUp = nextItem.addClass('mbsc-lv-item-hl');\n                dropChange = false;\n              }\n            } else {\n              sortChange = true;\n            }\n          }\n\n          if (sortChange) {\n            placeholder.insertAfter(nextItem);\n            prevItem = nextItem;\n            nextItem = getNextPrev(nextItem, 'next');\n            prevOffset = nextOffset;\n            nextOffset = nextItem.length && nextItem[0].offsetTop;\n            currIndex++;\n          }\n        } // Check overlap with prev item\n\n\n        if (!sortChange && prevOffset) {\n          // If subtree exists, drop element on subtree at 1/3, change sort order at 2/3 overlap\n          if (that.sortable.multiLevel && prevItem.hasClass('mbsc-lv-parent')) {\n            if (startTop + itemHeight - itemHeight / 4 + diff < prevOffset) {\n              sortChange = true;\n            } else if (startTop + itemHeight / 4 + diff < prevOffset) {\n              dropDown = prevItem.addClass('mbsc-lv-item-hl');\n              dropChange = false;\n            } // Check 1/2 overlap\n\n          } else if (startTop + itemHeight / 2 + diff < prevOffset) {\n            // If over back button, highlight to drop to parent level\n            if (prevItem.hasClass('mbsc-lv-back')) {\n              if (that.sortable.multiLevel) {\n                dropUp = prevItem.addClass('mbsc-lv-item-hl');\n                dropChange = false;\n              }\n            } else {\n              sortChange = true;\n            }\n          }\n\n          if (sortChange) {\n            placeholder.insertBefore(prevItem);\n            nextItem = prevItem;\n            prevItem = getNextPrev(prevItem, 'prev');\n            nextOffset = prevOffset;\n            prevOffset = prevItem.length && prevItem[0].offsetTop + prevItem[0].offsetHeight;\n            currIndex--;\n          }\n        }\n\n        if (dropChange) {\n          if (dropDown) {\n            dropDown.removeClass('mbsc-lv-item-hl');\n            dropDown = false;\n          }\n\n          if (dropUp) {\n            dropUp.removeClass('mbsc-lv-item-hl');\n            dropUp = false;\n          }\n        }\n\n        if (sortChange) {\n          event('onSortChange', {\n            target: item[0],\n            index: currIndex\n          });\n        }\n\n        drag(item, diff);\n        event('onSort', {\n          target: item[0],\n          index: currIndex\n        });\n      } else if (Math.abs(diffX) > 5 || Math.abs(diffY) > 5) {\n        // Cancel dragstart if movement is > 5px\n        stopTimer();\n      }\n    }\n  }\n\n  function onEnd(ev) {\n    var dist,\n        map,\n        parent,\n        itm = item;\n\n    if (action) {\n      action = false;\n      stopTimer();\n\n      if (ev.type == 'mouseup') {\n        $$1(document).off('mousemove', onMove).off('mouseup', onEnd);\n      }\n\n      if (!scroll) {\n        preventTimer = setTimeout(function () {\n          preventHover = false;\n        }, 300);\n      }\n\n      if (swipe || scroll || dragged) {\n        prevClick = true;\n      }\n\n      if (swipe) {\n        onSwipeEnd();\n      } else if (dragged) {\n        // Sort end\n        parent = currList;\n\n        if (dropDown) {\n          resetItem(item.detach());\n          map = treeMap[dropDown.attr('data-ref')];\n          currIndex = getChildren(map.child).length;\n          dropDown.removeClass('mbsc-lv-item-hl');\n\n          if (s.navigateOnDrop) {\n            navigate(dropDown, function () {\n              that.add(null, item, null, null, dropDown, true);\n              scrollToItem(item);\n              onSortEnd(item, itemIndex, parent, true);\n            });\n          } else {\n            that.add(null, item, null, null, dropDown, true);\n            onSortEnd(item, itemIndex, parent, true);\n          }\n        } else if (dropUp) {\n          resetItem(item.detach());\n          map = treeMap[dropUp.attr('data-back')];\n          currIndex = getChildren(map.parent).index(map.item) + 1;\n          dropUp.removeClass('mbsc-lv-item-hl');\n\n          if (s.navigateOnDrop) {\n            navigate(dropUp, function () {\n              that.add(null, item, currIndex, null, currList, true);\n              scrollToItem(item);\n              onSortEnd(item, itemIndex, parent, true);\n            });\n          } else {\n            that.add(null, item, currIndex, null, map.parent, true);\n            onSortEnd(item, itemIndex, parent, true);\n          }\n        } else {\n          dist = placeholder[0].offsetTop - startTop; // Animate item to its place\n\n          drag(item, dist, Math.abs(dist - Math.max(minDrag, Math.min(diffY + wndScroll, maxDrag))) * 6, function () {\n            resetItem(item);\n            item.insertBefore(placeholder);\n            onSortEnd(item, itemIndex, parent, currIndex !== itemIndex);\n          });\n        }\n\n        dragged = false;\n      } else if (!scroll && Math.abs(diffX) < 5 && Math.abs(diffY) < 5) {\n        // Tap\n        isClick = true; // Trigger click and activate target, if it's a form control\n\n        if (ev.type === 'touchend' && s.tap) {\n          activateControl(ev.target, getControlType($$1(ev.target)), ev);\n        }\n      }\n\n      clearTimeout(activeTimer);\n      setTimeout(function () {\n        itm.removeClass(ACTIVE_CLASS);\n        event('onItemDeactivate', {\n          target: itm[0]\n        });\n      }, 100);\n      scroll = false;\n      currStage = null;\n    }\n  }\n\n  function onClick(ev) {\n    var isSelected, ret;\n\n    if (isClick) {\n      isSelected = item.attr('data-selected') == 'true';\n\n      if (type.tap) {\n        ret = type.tap.call(e, {\n          target: item,\n          index: itemIndex,\n          domEvent: ev\n        }, that);\n      }\n\n      if (tapHighlight && !item.hasClass(ACTIVE_CLASS)) {\n        item.addClass(isTouch ? ACTIVE_CLASS : '');\n        event('onItemActivate', {\n          target: item[0],\n          domEvent: ev\n        });\n      } // select or deselect item on tap\n\n\n      if (selectable) {\n        if (multiple) {\n          if (isSelected) {\n            deselectItem(item);\n          } else {\n            selectItem(item);\n          }\n        } else {\n          deselectItem($$1(itemSelector, cont).filter('.' + SELECTED_CLASS));\n          selectItem(item);\n        }\n      }\n\n      ret = event('onItemTap', {\n        target: item[0],\n        index: itemIndex,\n        domEvent: ev,\n        selected: isSelected\n      });\n\n      if (ret !== false) {\n        navigate(item);\n      }\n    }\n  }\n\n  function onIconStart(ev) {\n    var target = closest(cont0, ev.target, '.mbsc-lv-ic-m');\n\n    if (!target) {\n      return;\n    }\n\n    if (!demoMode) {\n      ev.stopPropagation();\n      ev.preventDefault();\n    }\n\n    startX = getCoord(ev, 'X');\n    startY = getCoord(ev, 'Y');\n  }\n\n  function onSwipeStart() {\n    swipe = valueOrFunc(type.swipe, {\n      target: item[0],\n      index: itemIndex,\n      direction: diffX > 0 ? 'right' : 'left'\n    });\n\n    if (swipe) {\n      stopTimer();\n      clearTimeout(activeTimer);\n\n      if (type.actions) {\n        // Get the width of the action menu from settings\n        // Numeric values are converted to string, because 0 is also accepted, we convert back to number at the end\n        actionWidth = getActionWidth(type, diffX); // Show action icons and set width\n\n        multic.html(type.icons).show().children().css('width', actionWidth + '%'); // Hide stage icons\n\n        iconc.hide(); // Set disabled actions\n\n        $$1('.mbsc-lv-ic-m', stagec).removeClass('mbsc-lv-ic-disabled');\n        $$1(type.leftMenu).each(disableActions);\n        $$1(type.rightMenu).each(disableActions);\n      } else {\n        iconc.show();\n        multic.hide();\n        currStageIdx = type.start;\n        currStage = stages[currStageIdx];\n        prevStage = stages[currStageIdx - 1];\n        nextStage = stages[currStageIdx + 1];\n      }\n\n      item.addClass('mbsc-lv-item-swiping').removeClass(ACTIVE_CLASS);\n      text.css('line-height', itemHeight + 'px');\n      stagec.css({\n        top: startTop,\n        height: itemHeight,\n        backgroundColor: getFirstColor(diffX)\n      }).addClass('mbsc-lv-stage-c-v').appendTo(currList.parent());\n\n      if (s.iconSlide) {\n        item.append(iconc);\n      }\n\n      event('onSlideStart', {\n        target: item[0],\n        index: itemIndex\n      });\n    }\n  }\n\n  function onSwipeMove(prevPos) {\n    var stageChanged = false;\n\n    if (!rafRunning) {\n      if (type.actions) {\n        stagec.attr('class', 'mbsc-lv-stage-c-v mbsc-lv-stage-c mbsc-lv-' + (animPos < 0 ? 'right' : 'left'));\n      } else {\n        if (prevStage && (animPos < 0 ? animPos <= prevStage.percent : animPos < currStage.percent)) {\n          currStageIdx--;\n          nextStage = currStage;\n          currStage = prevStage;\n          prevStage = stages[currStageIdx - 1];\n          stageChanged = true;\n        } else if (nextStage && (animPos < 0 ? animPos > currStage.percent : animPos >= nextStage.percent)) {\n          currStageIdx++;\n          prevStage = currStage;\n          currStage = nextStage;\n          nextStage = stages[currStageIdx + 1];\n          stageChanged = true;\n        }\n\n        if (currStage) {\n          if (stageChanged || animPos > 0 == prevPos <= 0) {\n            // Also need to update stage background if swipe direction changed\n            setStageProps(currStage, s.iconSlide);\n          }\n\n          if (stageChanged) {\n            event('onStageChange', {\n              target: item[0],\n              index: itemIndex,\n              stage: currStage\n            });\n          }\n        }\n      }\n\n      if (!simulating) {\n        rafRunning = true;\n        rafID = raf(slideMove);\n      }\n    }\n  }\n\n  function onSwipeEnd(callback) {\n    function onCloseActions(ev) {\n      var target = closest(cont0, ev.target, '.mbsc-lv-ic-m');\n\n      if (!target) {\n        ev.preventDefault();\n        slideEnd(item, true, callback);\n      }\n    }\n\n    var quickSwipeLeft,\n        quickSwipeRight,\n        timeDiff,\n        itm = item[0],\n        pending = false,\n        revert = true;\n    rafc(rafID);\n    rafRunning = false; // We need an additional call to set the position in case when\n    // requestAnimationFrame did not call it at least once\n    // E.g. in a case of a quick swipe animation frame is\n    // cancelled before the first call\n\n    if (!simulating) {\n      slideMove();\n    }\n\n    if (type.actions) {\n      if (Math.abs(animPos) > 10 && actionWidth) {\n        slide(item, animPos < 0 ? -actionWidth : actionWidth, 200);\n        pending = true;\n        confirms = true;\n        confirmItem = item;\n        confirmIndex = itemIndex;\n\n        if (itm.__mbscOff) {\n          itm.__mbscOff();\n        }\n\n        listen(document, 'touchstart', onCloseActions, {\n          passive: false\n        });\n        listen(document, 'mousedown', onCloseActions);\n\n        itm.__mbscOff = function () {\n          unlisten(document, 'touchstart', onCloseActions, {\n            passive: false\n          });\n          unlisten(document, 'mousedown', onCloseActions);\n          delete itm.__mbscOff;\n        };\n      }\n    } else if (animPos) {\n      if (s.quickSwipe && !simulating) {\n        timeDiff = new Date() - startTime;\n        quickSwipeLeft = timeDiff < 300 && diffX < -50;\n        quickSwipeRight = timeDiff < 300 && diffX > 50;\n\n        if (quickSwipeLeft) {\n          quickSwipe = true;\n          currStage = type.left;\n          setStageProps(currStage, s.iconSlide);\n        } else if (quickSwipeRight) {\n          quickSwipe = true;\n          currStage = type.right;\n          setStageProps(currStage, s.iconSlide);\n        }\n      }\n\n      if (currStage && currStage.action) {\n        disabled = valueOrFunc(currStage.disabled, {\n          target: item[0],\n          index: itemIndex\n        });\n\n        if (!disabled) {\n          pending = true;\n          confirms = simulating || valueOrFunc(currStage.confirm, {\n            target: item[0],\n            index: itemIndex\n          });\n\n          if (confirms) {\n            // Slide to text + icon width\n            slide(item, (animPos < 0 ? -1 : 1) * iconc[0].offsetWidth * 100 / itemw, 200, true); // Tap to confirm\n\n            setConfirm(currStage, item, itemIndex, false, callback);\n          } else {\n            runAction(currStage, item, itemIndex, callback);\n          }\n        }\n      }\n    }\n\n    if (!pending) {\n      slideEnd(item, revert, callback);\n    }\n\n    swipe = false;\n  }\n\n  function onSortStart() {\n    dragged = true;\n    dropDown = false;\n    dropUp = false;\n    wndScroll = 0;\n    currIndex = itemIndex;\n\n    if (s.vibrate) {\n      vibrate();\n    }\n\n    nextItem = getNextPrev(item, 'next');\n    nextOffset = nextItem.length && nextItem[0].offsetTop;\n    prevItem = getNextPrev(item, 'prev');\n    prevOffset = prevItem.length && prevItem[0].offsetTop + prevItem[0].offsetHeight;\n    placeholder.height(itemHeight).insertAfter(item); // Item is removed from original list, otherwise messes up striped layout\n\n    item.css({\n      top: startTop\n    }).addClass('mbsc-lv-item-dragging').removeClass(ACTIVE_CLASS).appendTo(dummyCont);\n    event('onSortStart', {\n      target: item[0],\n      index: currIndex\n    });\n  }\n\n  function onSortEnd(item, itemIndex, parent, update) {\n    item.removeClass('mbsc-lv-item-dragging');\n    placeholder.remove();\n    event('onSortEnd', {\n      target: item[0],\n      index: currIndex\n    });\n\n    if (s.vibrate) {\n      vibrate();\n    }\n\n    if (update) {\n      that.addUndoAction(function (next) {\n        that.move(item, itemIndex, null, next, parent, true);\n      }, true);\n      event('onSortUpdate', {\n        target: item[0],\n        index: currIndex\n      });\n    }\n  }\n\n  function onMouseLeave() {\n    if (!preventHover) {\n      clearTimeout(hoverTimer);\n\n      if (confirms) {\n        trigger(document, 'touchstart');\n      }\n\n      if (hoverItemOpened) {\n        that.close(hoverItem, hoverTime);\n        hoverItemOpened = false;\n        hoverItem = null;\n      }\n    }\n  }\n\n  function onResize() {\n    clearTimeout(debounce);\n    debounce = setTimeout(function () {\n      wndHeight = wnd0.innerHeight || wnd.innerHeight();\n      wndTop = hasContext ? wnd.offset().top : 0;\n\n      if (action) {\n        // Reposition stage background, icon and text\n        startTop = item[0].offsetTop;\n        itemHeight = item[0].offsetHeight;\n        stagec.css({\n          top: startTop,\n          height: itemHeight\n        });\n      }\n    }, 200);\n  }\n\n  function onListClick(ev) {\n    if (prevClick) {\n      ev.stopPropagation();\n      ev.preventDefault();\n      prevClick = false;\n    }\n  }\n\n  function onScrollBottom() {\n    if (!isLoading) {\n      clearTimeout(onScrollDebounce);\n      onScrollDebounce = setTimeout(function () {\n        var height = hasContext ? wnd0.getBoundingClientRect().top + wnd.innerHeight() : window.innerHeight,\n            reachedBottom = loading[0].getBoundingClientRect().top - 3 < height;\n\n        if (!isLoading && reachedBottom) {\n          event('onListEnd');\n        }\n      }, 250);\n    }\n  }\n\n  function onScroll() {\n    if (dragged || !action) {\n      var group,\n          st = wnd.scrollTop(),\n          elmTop = elm.offset().top,\n          elmHeight = elm[0].offsetHeight,\n          wndTop = hasContext ? wnd.offset().top : st;\n      $$1('.mbsc-lv-gr-title', elm).each(function (i, v) {\n        if ($$1(v).offset().top < wndTop) {\n          group = v;\n        }\n      });\n\n      if (elmTop < wndTop && elmTop + elmHeight > wndTop) {\n        groupHeader.show().empty().append($$1(group).clone());\n      } else {\n        groupHeader.hide();\n      }\n    }\n  }\n\n  function disableActions(i, v) {\n    if (valueOrFunc(v.disabled, {\n      target: item[0],\n      index: itemIndex\n    })) {\n      $$1('.mbsc-ic-' + v.icon, stagec).addClass('mbsc-lv-ic-disabled');\n    }\n  }\n\n  function runAction(stage, item, index, callback) {\n    var revert,\n        undoStage = {\n      icon: 'undo2',\n      text: s.undoText,\n      action: function action() {\n        that.undo();\n      }\n    };\n\n    if (stage.undo) {\n      that.startActionTrack(); // Add user defined undo\n\n      if ($$1.isFunction(stage.undo)) {\n        that.addUndoAction(function () {\n          stage.undo.call(e, {\n            target: item[0],\n            index: index\n          }, that);\n        });\n      } // Remember the item where the undo is displayed\n\n\n      undoRef = item.attr('data-ref');\n    }\n\n    revert = stage.action.call(e, {\n      target: item[0],\n      index: index\n    }, that);\n\n    if (stage.undo) {\n      that.endActionTrack();\n\n      if (revert !== false) {\n        slide(item, +item.attr('data-pos') < 0 ? -100 : 100, 200);\n      }\n\n      placeholder.height(itemHeight).insertAfter(item);\n      item.css('top', startTop).addClass('mbsc-lv-item-undo');\n      multic.hide();\n      iconc.show();\n      stagec.append(iconc);\n      setStageProps(undoStage);\n      setConfirm(undoStage, item, index, true, callback);\n    } else {\n      slideEnd(item, revert, callback);\n    }\n  }\n\n  function setConfirm(stage, item, index, ph, callback) {\n    function onActionCancel(ev) {\n      ev.preventDefault();\n\n      if (ph) {\n        cleanUndo(item);\n      }\n\n      slideEnd(item, true, callback);\n    }\n\n    function onActionConfirmStart(ev) {\n      ev.stopPropagation();\n      startX = getCoord(ev, 'X');\n      startY = getCoord(ev, 'Y');\n    }\n\n    function onActionConfirmEnd(ev) {\n      ev.preventDefault();\n\n      if (ev.type === 'touchend') {\n        preventClick();\n      } // If movement is less than 10px, it's a tap\n\n\n      if (Math.abs(getCoord(ev, 'X') - startX) < 10 && Math.abs(getCoord(ev, 'Y') - startY) < 10) {\n        runAction(stage, item, index, callback);\n\n        if (ph) {\n          undoAnim = null;\n          cleanUndo(item);\n        }\n      }\n    }\n\n    var startX,\n        startY,\n        itm = item[0];\n    confirms = true;\n\n    if (itm.__mbscOff) {\n      itm.__mbscOff();\n    }\n\n    listen(document, 'touchstart', onActionCancel, {\n      passive: false\n    });\n    listen(document, 'mousedown', onActionCancel);\n\n    if (!demoMode) {\n      listen(iconc[0], 'touchstart', onActionConfirmStart, {\n        passive: true\n      });\n      listen(iconc[0], 'mousedown', onActionConfirmStart);\n      listen(iconc[0], 'touchend', onActionConfirmEnd);\n      listen(iconc[0], 'mouseup', onActionConfirmEnd);\n    }\n\n    itm.__mbscOff = function () {\n      unlisten(document, 'touchstart', onActionCancel, {\n        passive: false\n      });\n      unlisten(document, 'mousedown', onActionCancel);\n      unlisten(iconc[0], 'touchstart', onActionConfirmStart, {\n        passive: true\n      });\n      unlisten(iconc[0], 'mousedown', onActionConfirmStart);\n      unlisten(iconc[0], 'touchend', onActionConfirmEnd);\n      unlisten(iconc[0], 'mouseup', onActionConfirmEnd);\n      delete itm.__mbscOff;\n    };\n  }\n\n  function slideMove() {\n    slide(item, startPos + diffX * 100 / itemw);\n    rafRunning = false;\n  }\n\n  function slideEnd(item, revert, callback) {\n    if (item[0].__mbscOff) {\n      item[0].__mbscOff();\n    }\n\n    if (revert !== false) {\n      slide(item, 0, item.attr('data-pos') !== '0' ? 200 : 0, false, function () {\n        cleanStage(item, callback);\n        resetItem(item);\n      });\n    } else {\n      cleanStage(item, callback);\n    }\n\n    confirms = false;\n  }\n\n  function slide(item, pos, time, px, callback) {\n    pos = Math.max(swipe == 'right' ? 0 : -100, Math.min(pos, swipe == 'left' ? 0 : 100));\n    style = item[0].style;\n    item.attr('data-pos', pos);\n    style[jsPrefix + 'Transform'] = 'translate3d(' + (px ? itemw * pos / 100 + 'px' : pos + '%') + ',0,0)';\n    style[jsPrefix + 'Transition'] = cssPrefix + 'transform ' + (time || 0) + 'ms';\n\n    if (callback) {\n      transition++;\n      setTimeout(function () {\n        callback();\n        transition--;\n      }, time);\n    }\n\n    animPos = pos;\n  }\n\n  function drag(item, top, time, callback) {\n    top = Math.max(minDrag, Math.min(top, maxDrag));\n    style = item[0].style;\n    style[jsPrefix + 'Transform'] = 'translate3d(0,' + top + 'px,0)';\n    style[jsPrefix + 'Transition'] = cssPrefix + 'transform ' + (time || 0) + 'ms ease-out';\n\n    if (callback) {\n      transition++;\n      setTimeout(function () {\n        callback();\n        transition--;\n      }, time);\n    }\n  }\n\n  function stopTimer() {\n    clearTimeout(timer);\n\n    if (!cancel && that.sortable) {\n      cancel = true;\n      fill.remove();\n    }\n  }\n\n  function setStageProps(stage, iconSlide) {\n    var txt = valueOrFunc(stage.text, {\n      target: item[0],\n      index: itemIndex\n    }) || '';\n\n    if (valueOrFunc(stage.disabled, {\n      target: item[0],\n      index: itemIndex\n    })) {\n      stagec.addClass('mbsc-lv-ic-disabled');\n    } else {\n      stagec.removeClass('mbsc-lv-ic-disabled');\n    }\n\n    stagec.css('background-color', stage.color || (stage.percent === 0 ? getFirstColor(animPos) : transp));\n    iconc.attr('class', 'mbsc-lv-ic-c mbsc-lv-ic-' + (iconSlide ? 'move-' : '') + (animPos < 0 ? 'right' : 'left'));\n    icon.attr('class', ' mbsc-lv-ic-s mbsc-lv-ic mbsc-ic mbsc-ic-' + (stage.icon || 'none'));\n    text.attr('class', 'mbsc-lv-ic-text' + (stage.icon ? '' : ' mbsc-lv-ic-text-only') + (txt ? '' : ' mbsc-lv-ic-only')).html(txt || '&nbsp;');\n\n    if (s.animateIcons) {\n      if (quickSwipe) {\n        icon.addClass('mbsc-lv-ic-v');\n      } else {\n        setTimeout(function () {\n          icon.addClass('mbsc-lv-ic-a');\n        }, 10);\n      }\n    }\n  }\n\n  function cleanStage(item, callback) {\n    if (!action) {\n      // Don't clean stages if another action started\n      icon.attr('class', 'mbsc-lv-ic-s mbsc-lv-ic mbsc-ic mbsc-ic-none');\n      stagec.attr('style', '').removeClass('mbsc-lv-stage-c-v');\n      text.html('');\n    }\n\n    stagec.removeClass('mbsc-lv-left mbsc-lv-right');\n\n    if (item) {\n      event('onSlideEnd', {\n        target: item[0],\n        index: itemIndex\n      });\n\n      if (callback) {\n        callback();\n      }\n    }\n  }\n\n  function cleanUndo(item) {\n    item.css('top', '').removeClass('mbsc-lv-item-undo'); // Remove placeholder\n\n    if (undoAnim) {\n      that.animate(placeholder, 'collapse', function () {\n        placeholder.remove();\n      });\n    } else {\n      placeholder.remove();\n    }\n\n    cleanStage();\n    undoRef = null;\n    undoAnim = null;\n  }\n\n  function resetItem(item) {\n    style = item[0].style;\n    style[jsPrefix + 'Transform'] = '';\n    style[jsPrefix + 'Transition'] = '';\n    style.top = '';\n    item.removeClass('mbsc-lv-item-swiping');\n  }\n\n  function valueOrFunc(val, args) {\n    return $$1.isFunction(val) ? val.call(this, args, that) : val;\n  }\n\n  function isSelectable(item) {\n    return selectable && !item.hasClass('mbsc-lv-parent') && !item.hasClass('mbsc-lv-back');\n  }\n\n  function initItem(item) {\n    var id = item.attr('data-ref'),\n        role = item.attr('data-role'),\n        type = types[item.attr('data-type') || 'defaults'],\n        selected = isSelectable(item) && item.attr('data-selected') == 'true';\n\n    if (!id) {\n      id = guid++;\n      item.attr('data-ref', id);\n    }\n\n    treeMap[id] = {\n      item: item,\n      child: item.children(listSelector),\n      parent: item.parent(),\n      ref: item.parent()[0] === e ? null : item.parent().parent().attr('data-ref')\n    };\n    item.addClass(role == 'list-divider' ? 'mbsc-lv-gr-title' : 'mbsc-lv-item' + (type.actionable ? ' mbsc-lv-item-actionable' : '') + (selected ? ' ' + SELECTED_CLASS : ''));\n    item.attr('aria-selected', selected ? 'true' : 'false'); // Add sort handle\n\n    if (that.sortable.handle && role != 'list-divider' && !item.children('.mbsc-lv-handle-c').length) {\n      item.append(handleDiv);\n    }\n\n    if (s.enhance && !item.hasClass('mbsc-lv-item-enhanced')) {\n      var itemIcon = item.attr('data-icon'),\n          itemImg = item.find('img').eq(0).addClass('mbsc-lv-img');\n\n      if (itemImg.is(':first-child')) {\n        item.addClass('mbsc-lv-img-' + (s.rtl ? 'right' : 'left'));\n      } else if (itemImg.length) {\n        item.addClass('mbsc-lv-img-' + (s.rtl ? 'left' : 'right'));\n      }\n\n      item.addClass('mbsc-lv-item-enhanced').children().each(function (i, v) {\n        v = $$1(v);\n\n        if (v.is('p, h1, h2, h3, h4, h5, h6')) {\n          v.addClass('mbsc-lv-txt');\n        }\n      });\n\n      if (itemIcon) {\n        item.addClass('mbsc-lv-item-ic-' + (item.attr('data-icon-align') || (s.rtl ? 'right' : 'left'))).append('<div class=\"mbsc-lv-item-ic mbsc-ic mbsc-ic-' + itemIcon + '\"></div>');\n      }\n    }\n    /* TRIAL */\n\n  }\n\n  function initBranch(elm) {\n    // Create map object\n    $$1(itemSelector, elm).not('.mbsc-lv-back').each(function () {\n      initItem($$1(this));\n    }); // Add extra classes and markup (arrows and back items)\n\n    $$1(listSelector, elm).not('.mbsc-lv').addClass('mbsc-lv').prepend(htmlLeft).parent().addClass('mbsc-lv-parent mbsc-lv-item-actionable').prepend(htmlRight); // Add parent reference for back buttons\n\n    $$1('.mbsc-lv-back', elm).each(function () {\n      $$1(this).attr('data-back', $$1(this).parent().parent().attr('data-ref'));\n    });\n  }\n\n  function getChildren(list) {\n    return list.children(itemSelector).not('.mbsc-lv-back').not('.mbsc-lv-removed').not('.mbsc-lv-ph');\n  }\n\n  function getItemByID(item) {\n    if (typeof item !== 'object') {\n      item = $$1(itemSelector, cont).filter('[data-id=\"' + item + '\"]');\n    }\n\n    return $$1(item);\n  }\n\n  function getItemLevel(item) {\n    var level = 0,\n        map = treeMap[item.attr('data-ref')];\n\n    while (map && map.ref) {\n      level++;\n      map = treeMap[map.ref];\n    }\n\n    return level;\n  }\n\n  function getNextPrev(item, dir) {\n    item = item[dir](); // Returns next or previous item filtering out placeholder or currently dragged element\n\n    while (item.length && (!item.hasClass('mbsc-lv-item') || item.hasClass('mbsc-lv-ph') || item.hasClass('mbsc-lv-item-dragging'))) {\n      if (!that.sortable.group && item.hasClass('mbsc-lv-gr-title')) {\n        return false;\n      }\n\n      item = item[dir]();\n    }\n\n    return item;\n  }\n\n  function getFirstColor(pos) {\n    return (pos > 0 ? type.right : type.left).color || transp;\n  }\n\n  function getNumStr(s) {\n    return isNumeric(s) ? s + '' : 0;\n  }\n\n  function getActionWidth(type, diffX) {\n    return +(diffX < 0 ? getNumStr((type.actionsWidth || 0).right) || getNumStr(type.actionsWidth) || getNumStr(s.actionsWidth.right) || getNumStr(s.actionsWidth) : getNumStr((type.actionsWidth || 0).left) || getNumStr(type.actionsWidth) || getNumStr(s.actionsWidth.left) || getNumStr(s.actionsWidth));\n  }\n\n  function scrollToItem(item, scrollToTop) {\n    if (item) {\n      var scrollTop = wnd.scrollTop(),\n          itemHeight = item.is('.mbsc-lv-item') ? item[0].offsetHeight : 0,\n          itemTop = item.offset().top + (hasContext ? scrollTop - wndTop : 0);\n\n      if (scrollToTop) {\n        if (itemTop < scrollTop || itemTop + itemHeight > scrollTop + wndHeight) {\n          wnd.scrollTop(itemTop);\n        }\n      } else {\n        if (itemTop < scrollTop) {\n          wnd.scrollTop(itemTop);\n        } else if (itemTop + itemHeight > scrollTop + wndHeight) {\n          wnd.scrollTop(Math.min(itemTop, itemTop + itemHeight - wndHeight / 2));\n        }\n      }\n    }\n  }\n\n  function drill(dir, list, item, callback, scrollToTop) {\n    var parent = list.parent(),\n        ph = list.prev();\n    callback = callback || noop;\n\n    if (ph[0] === iconc[0]) {\n      ph = iconc.prev();\n    }\n\n    if (s.rtl) {\n      dir = dir === 'l' ? 'r' : 'l';\n    }\n\n    if (currList[0] !== list[0]) {\n      event('onNavStart', {\n        level: slideLevel,\n        direction: dir,\n        list: list[0]\n      });\n      slideCont.prepend(list.addClass('mbsc-lv-v mbsc-lv-sl-new')); // If top of the list is not visible, scroll to top\n\n      scrollToItem(cont);\n      animate(slideCont, 'mbsc-lv-sl-' + dir, function () {\n        currList.removeClass('mbsc-lv-sl-curr');\n        list.removeClass('mbsc-lv-sl-new').addClass('mbsc-lv-sl-curr');\n\n        if (currPh && currPh.length) {\n          currList.removeClass('mbsc-lv-v').insertAfter(currPh);\n        } else {\n          currParent.append(currList.removeClass('mbsc-lv-v'));\n        } // Remember the previous element where we need to put back the list later\n        // We need this because some frameworks like ember js put additional elements (script tags)\n        // and appending to parent element is not ok\n\n\n        currPh = ph;\n        currParent = parent;\n        currList = list;\n        scrollToItem(item, scrollToTop);\n        callback.call(e, item);\n        event('onNavEnd', {\n          level: slideLevel,\n          direction: dir,\n          list: list[0]\n        });\n      });\n    } else {\n      scrollToItem(item, scrollToTop);\n      callback.call(e, item);\n    }\n  }\n\n  function navigate(item, callback) {\n    if (!transition) {\n      if (item.hasClass('mbsc-lv-parent')) {\n        slideLevel++;\n        drill('r', treeMap[item.attr('data-ref')].child, null, callback);\n      } else if (item.hasClass('mbsc-lv-back')) {\n        slideLevel--;\n        drill('l', treeMap[item.attr('data-back')].parent, treeMap[item.attr('data-back')].item, callback);\n      }\n    }\n  }\n\n  function animate(el, anim, callback) {\n    var timer;\n\n    function onAnimEnd() {\n      clearTimeout(timer);\n      transition--;\n      el.off(animEnd, onAnimEnd).removeClass(anim);\n      callback.call(e, el);\n    }\n\n    callback = callback || noop;\n\n    if (s.animation && anim !== 'mbsc-lv-item-none') {\n      transition++;\n      el.on(animEnd, onAnimEnd).addClass(anim); // animEnd event will not execute with some integration plugins, this is a workaround to make sure it's executed\n\n      timer = setTimeout(onAnimEnd, 250);\n    } else {\n      callback.call(e, el);\n    }\n  }\n\n  function doAction(el, action) {\n    var queue,\n        id = el.attr('data-ref');\n    queue = actionQueue[id] = actionQueue[id] || [];\n\n    if (action) {\n      queue.push(action);\n    }\n\n    if (el.attr('data-action')) {\n      return;\n    }\n\n    action = queue.shift(); // Check this for safety\n    // There was a case in angular were the data-ref attribute was lost,\n    // so the queue was empty\n\n    if (action) {\n      el.attr('data-action', 1);\n      action(function () {\n        el.removeAttr('data-action');\n\n        if (queue.length) {\n          doAction(el);\n        } else {\n          delete actionQueue[id];\n        }\n      });\n    }\n  }\n\n  function processStages(stages, dir, duplicate) {\n    var count, temp;\n\n    if (stages && stages.length) {\n      count = 100 / (stages.length + 2);\n      $$1.each(stages, function (i, stage) {\n        if (stage.key === undefined) {\n          stage.key = stageNr++;\n        }\n\n        if (stage.percent === undefined) {\n          // if no percent passed then generate to both sides\n          stage.percent = dir * count * (i + 1);\n\n          if (duplicate) {\n            temp = extend$1({}, stage);\n            temp.key = stageNr++;\n            temp.percent = -count * (i + 1);\n            stages.push(temp);\n            stageObj[temp.key] = temp;\n          }\n        }\n\n        stageObj[stage.key] = stage;\n      });\n    }\n  }\n\n  function selectItem($item) {\n    if (isSelectable($item)) {\n      $item.addClass(SELECTED_CLASS).attr('data-selected', 'true').attr('aria-selected', 'true');\n    }\n  }\n\n  function deselectItem($item) {\n    $item.removeClass(SELECTED_CLASS).removeAttr('data-selected').removeAttr('aria-selected');\n  } // Call the parent constructor\n\n\n  Base.call(this, elem, settings, true);\n  /* TRIALFUNC */\n\n  /**\r\n   * Animate a list item\r\n   */\n\n  that.animate = function (li, anim, callback) {\n    animate(li, 'mbsc-lv-item-' + anim, callback);\n  };\n  /**\r\n   * Add a new list item\r\n   */\n\n\n  that.add = function (id, markup, index, callback, p, isUndo) {\n    var backBtn,\n        length,\n        siblings,\n        sublevel,\n        map,\n        pref,\n        cssClass = '',\n        $parent = p === undefined ? elm : getItemByID(p),\n        $list = $parent,\n        $item = typeof markup !== 'object' ? $$1('<' + itemNode + ' data-ref=\"' + guid++ + '\" data-id=\"' + id + '\">' + markup + '</' + itemNode + '>') : $$1(markup),\n        item = $item[0],\n        style = item.style,\n        dir = $item.attr('data-pos') < 0 ? 'left' : 'right',\n        ref = $item.attr('data-ref');\n    callback = callback || noop;\n\n    if (!ref) {\n      ref = guid++;\n      $item.attr('data-ref', ref);\n    }\n\n    initItem($item); // Put action in undo stack\n\n    if (!isUndo) {\n      that.addUndoAction(function (next) {\n        if (sublevel) {\n          that.navigate($parent, function () {\n            $list.remove();\n            $parent.removeClass('mbsc-lv-parent').children('.mbsc-lv-arr').remove();\n            map.child = $parent.children(listSelector);\n            that.remove($item, null, next, true);\n          });\n        } else {\n          that.remove($item, null, next, true);\n        }\n      }, true);\n    }\n\n    doAction($item, function (next) {\n      resetItem($item.css('top', '').removeClass('mbsc-lv-item-undo')); // If parent is a list item, insert new element in the sublist\n\n      if ($parent.is(itemSelector)) {\n        pref = $parent.attr('data-ref'); // If there is no sublist yet, create it\n\n        if (!$parent.children(listSelector).length) {\n          sublevel = true;\n          $parent.append('<' + listNode + '></' + listNode + '>');\n        }\n      } else {\n        pref = $parent.children('.mbsc-lv-back').attr('data-back');\n      }\n\n      map = treeMap[pref];\n\n      if (map) {\n        if (!map.child.length) {\n          $parent.addClass('mbsc-lv-parent').prepend(htmlRight); // Set parent to be the sublist\n\n          $list = $parent.children(listSelector).prepend(htmlLeft).addClass('mbsc-lv');\n          map.child = $list;\n          $$1('.mbsc-lv-back', $parent).attr('data-back', pref);\n        } else {\n          $list = map.child;\n        }\n      }\n\n      treeMap[ref] = {\n        item: $item,\n        child: $item.children(listSelector),\n        parent: $list,\n        ref: pref\n      };\n      siblings = getChildren($list);\n      length = siblings.length;\n\n      if (index === undefined || index === null) {\n        index = length;\n      }\n\n      if (isUndo) {\n        cssClass = 'mbsc-lv-item-new-' + (isUndo ? dir : '');\n      }\n\n      initBranch($item.addClass(cssClass));\n\n      if (index !== false) {\n        if (!length) {\n          backBtn = $$1('.mbsc-lv-back', $list);\n\n          if (backBtn.length) {\n            $item.insertAfter(backBtn);\n          } else {\n            $list.append($item);\n          }\n        } else if (index < length) {\n          $item.insertBefore(siblings.eq(index));\n        } else {\n          $item.insertAfter(siblings.eq(length - 1));\n        }\n      }\n\n      cont.trigger('mbsc-refresh'); // If current level is visible\n\n      if (s.animateAddRemove && $list.hasClass('mbsc-lv-v')) {\n        // Don't run expand animation if add is running on the \"undo\" element\n        style.height = item.offsetHeight + 'px';\n        that.animate($item, isUndo && undoRef === ref ? 'none' : 'expand', function ($item) {\n          that.animate($item, isUndo ? 'add-' + dir : 'pop-in', function ($item) {\n            style.height = '';\n            callback.call(e, $item.removeClass(cssClass));\n            next();\n          });\n        });\n      } else {\n        callback.call(e, $item.removeClass(cssClass));\n        next();\n      }\n\n      event('onItemAdd', {\n        target: item\n      });\n    });\n  };\n  /**\r\n   * Swipe a list item programatically\r\n   */\n\n\n  that.swipe = function (li, percent, time, demo, callback) {\n    var prevPos;\n    li = getItemByID(li);\n    item = li;\n    demoMode = demo;\n    simulating = true;\n    action = true;\n    time = time === undefined ? 300 : time;\n    diffX = percent > 0 ? 1 : -1;\n    onActionStart();\n    onSwipeStart();\n    slide(li, percent, time);\n    clearTimeout(swipeTimeout);\n    clearInterval(swipeInterval);\n    swipeInterval = setInterval(function () {\n      prevPos = animPos;\n      animPos = getPosition(li) / itemw * 100;\n      onSwipeMove(prevPos);\n    }, 10);\n    swipeTimeout = setTimeout(function () {\n      clearInterval(swipeInterval);\n      prevPos = animPos;\n      animPos = percent; // We need one additional move with the final percent to get the correct stage\n\n      onSwipeMove(prevPos);\n      onSwipeEnd(callback);\n      demoMode = false;\n      simulating = false;\n      action = false;\n    }, time);\n  };\n\n  that.openStage = function (li, stage, time, demo) {\n    if (stageObj[stage]) {\n      that.swipe(li, stageObj[stage].percent, time, demo);\n    }\n  };\n\n  that.openActions = function (li, dir, time, demo) {\n    li = getItemByID(li);\n    var percent = getActionWidth(types[li.attr('data-type') || 'defaults'], dir == 'left' ? -1 : 1);\n    that.swipe(li, dir == 'left' ? -percent : percent, time, demo);\n  };\n\n  that.close = function (li, time) {\n    that.swipe(li, 0, time);\n  };\n  /**\r\n   * Remove a list item\r\n   */\n\n\n  that.remove = function (id, dir, callback, isUndo) {\n    var $item, $parent, anim, index, ref, shouldNavigate, style;\n\n    function deleteSubTree($child) {\n      if ($child) {\n        shouldNavigate = shouldNavigate || $child.hasClass('mbsc-lv-v');\n        $child.children('[data-ref]').each(function () {\n          var ref = $$1(this).attr('data-ref');\n\n          if (treeMap[ref]) {\n            deleteSubTree(treeMap[ref].child);\n            delete treeMap[ref];\n          }\n        });\n      }\n    }\n\n    callback = callback || noop;\n    $item = getItemByID(id);\n    ref = $item.attr('data-ref');\n\n    if ($item.length && treeMap[ref]) {\n      $parent = $item.parent();\n      index = getChildren($parent).index($item);\n      style = $item[0].style;\n      deleteSubTree(treeMap[ref].child);\n\n      if (shouldNavigate) {\n        anim = s.animation;\n        s.animation = false;\n        that.navigate($item);\n        s.animation = anim;\n      }\n\n      delete treeMap[ref]; // Put action in undo stack\n\n      if (!isUndo) {\n        // If undo element is removed, undo placeholder should be removed with animation\n        if ($item.attr('data-ref') === undoRef) {\n          undoAnim = true;\n        }\n\n        that.addUndoAction(function (next) {\n          that.add(null, $item, index, next, $parent, true);\n        }, true);\n      }\n\n      doAction($item, function (next) {\n        dir = dir || ($item.attr('data-pos') < 0 ? 'left' : 'right');\n\n        if (s.animateAddRemove && $parent.hasClass('mbsc-lv-v')) {\n          that.animate($item.addClass('mbsc-lv-removed'), isUndo ? 'pop-out' : 'remove-' + dir, function ($item) {\n            style.height = $item[0].offsetHeight + 'px';\n            that.animate($item, 'collapse', function ($item) {\n              style.height = '';\n              resetItem($item.removeClass('mbsc-lv-removed'));\n\n              if (callback.call(e, $item) !== false) {\n                $item.remove();\n              }\n\n              next();\n            });\n          });\n        } else {\n          if (callback.call(e, $item) !== false) {\n            $item.remove();\n          }\n\n          next();\n        }\n\n        event('onItemRemove', {\n          target: $item[0]\n        });\n      });\n    }\n  };\n  /**\r\n   * Moves an item in the list\r\n   */\n\n\n  that.move = function (li, index, dir, callback, p, isUndo) {\n    li = getItemByID(li); //if (getChildren(li.parent()).index(li) !== index) {\n\n    if (!isUndo) {\n      that.startActionTrack();\n    }\n\n    stagec.append(iconc);\n    that.remove(li, dir, null, isUndo);\n    that.add(null, li, index, callback, p, isUndo);\n\n    if (!isUndo) {\n      that.endActionTrack();\n    } //}\n\n  };\n  /**\r\n   * Navigate and scroll to the given element\r\n   */\n\n\n  that.navigate = function (item, callback) {\n    var map, level;\n    item = getItemByID(item);\n    map = treeMap[item.attr('data-ref')];\n    level = getItemLevel(item);\n\n    if (map) {\n      drill(level >= slideLevel ? 'r' : 'l', map.parent, item, callback, true);\n      slideLevel = level;\n    }\n  };\n\n  that.showLoading = function () {\n    isLoading = true;\n    loading.addClass('mbsc-show-lv-loading');\n    wnd.scrollTop(hasContext ? wnd0.scrollHeight : $$1(s.context)[0].scrollHeight);\n  };\n\n  that.hideLoading = function () {\n    loading.removeClass('mbsc-show-lv-loading'); // Needs timeout to prevent triggering \n    // the onListEnd event from the scroll listener\n\n    setTimeout(function () {\n      isLoading = false;\n    }, 100);\n  };\n\n  that.select = function (item) {\n    if (!multiple) {\n      deselectItem($$1(itemSelector, cont).filter('.' + SELECTED_CLASS));\n    }\n\n    selectItem(getItemByID(item));\n  };\n\n  that.deselect = function (item) {\n    deselectItem(getItemByID(item));\n  };\n\n  that._processSettings = function () {\n    if (elm.is('[mbsc-enhance]')) {\n      hadEnhance = true;\n      elm.removeAttr('mbsc-enhance');\n    }\n  };\n  /**\r\n   * Listview initialization.\r\n   */\n\n\n  that._init = function () {\n    var contClass,\n        headerClass,\n        sortable,\n        defSortHandle = elm.find(listSelector).length ? 'left' : 'right',\n        i = 0,\n        icons = '',\n        iconsLeft = '',\n        iconsRight = '';\n    listNode = s.listNode;\n    listSelector = s.listSelector;\n    itemNode = s.itemNode;\n    itemSelector = s.itemSelector;\n    multiple = s.select == 'multiple';\n    selectable = s.select != 'off'; // --- TRIAL SERVER CODE START ---\n\n    sortable = s.sort || s.sortable || false; // Backward compatiblity for 'group' and sortHandle settings\n    // ---\n\n    if (sortable === 'group') {\n      sortable = {\n        group: false,\n        multiLevel: true\n      };\n    }\n\n    if (sortable === true) {\n      sortable = {\n        group: true,\n        multiLevel: true,\n        handle: s.sortHandle\n      };\n    }\n\n    if (sortable && sortable.handle === undefined) {\n      sortable.handle = s.sortHandle;\n    } // ---\n\n\n    if (sortable.handle) {\n      handlePos = sortable.handle === true ? defSortHandle : sortable.handle;\n      handleDiv = '<div class=\"mbsc-lv-handle-c mbsc-lv-item-h-' + handlePos + ' mbsc-lv-handle\"><div class=\"' + s.handleClass + ' mbsc-lv-handle-bar-c mbsc-lv-handle\">' + s.handleMarkup + '</div></div>';\n    }\n\n    htmlLeft = '<' + itemNode + ' class=\"mbsc-lv-item mbsc-lv-back mbsc-lv-item-actionable\">' + s.backText + '<div class=\"mbsc-lv-arr mbsc-lv-ic mbsc-ic ' + s.leftArrowClass + '\"></div></' + itemNode + '>';\n    htmlRight = '<div class=\"mbsc-lv-arr mbsc-lv-ic mbsc-ic ' + s.rightArrowClass + '\"></div>';\n    contClass = 'mbsc-no-touch mbsc-lv-cont mbsc-lv-' + s.theme + ' mbsc-' + s.theme + (halfBorder$2 ? ' mbsc-lv-hb' : '') + (s.rtl ? ' mbsc-lv-rtl mbsc-rtl' : ' mbsc-ltr') + (s.baseTheme ? ' mbsc-lv-' + s.baseTheme + ' mbsc-' + s.baseTheme : '') + (s.animateIcons ? ' mbsc-lv-ic-anim' : '') + (s.striped ? ' mbsc-lv-alt-row' : '') + (s.fixedHeader ? ' mbsc-lv-has-fixed-header' : '') + (sortable.handle ? ' mbsc-lv-handle-' + handlePos : ''); // --- TRIAL SERVER CODE END ---\n\n    that.sortable = sortable || false;\n\n    if (!cont) {\n      // Icon menu container\n      icons += '<div class=\"mbsc-lv-multi-c\"></div>'; // Stage icons container\n\n      icons += '<div class=\"mbsc-lv-ic-c\"><div class=\"mbsc-lv-ic-s mbsc-lv-ic mbsc-ic mbsc-ic-none\"></div><div class=\"mbsc-lv-ic-text\"></div></div>'; // Add classes\n\n      elm.addClass('mbsc-lv mbsc-lv-v mbsc-lv-root').removeClass('mbsc-cloak').show();\n      stagec = $$1('<div class=\"mbsc-lv-stage-c\">' + icons + '</div>');\n      iconc = $$1('.mbsc-lv-ic-c', stagec);\n      multic = $$1('.mbsc-lv-multi-c', stagec);\n      icon = $$1('.mbsc-lv-ic-s', stagec);\n      text = $$1('.mbsc-lv-ic-text', stagec);\n      placeholder = $$1('<' + itemNode + ' class=\"mbsc-lv-item mbsc-lv-ph\"></' + itemNode + '>');\n      fill = $$1('<div class=\"mbsc-lv-fill-item\"></div>');\n      cont = $$1('<div class=\"' + contClass + '\"><' + listNode + ' class=\"mbsc-lv mbsc-lv-dummy\"></' + listNode + '><div class=\"mbsc-lv-sl-c\"></div>' + '<div class=\"mbsc-lv-loading\"><span class=\"mbsc-ic mbsc-ic-' + (s.loadingIcon || 'loop2') + '\"></span></div></div>');\n      cont0 = cont[0];\n      dummyCont = $$1('.mbsc-lv-dummy', cont);\n      loading = $$1('.mbsc-lv-loading', cont);\n      cont.insertAfter(elm);\n      onResize(); // Slide events\n\n      listen(cont0, 'mousedown', onStart);\n      listen(document, 'touchstart', onStart, {\n        passive: false\n      });\n      listen(document, 'touchmove', onMove, {\n        passive: false\n      });\n      cont.on('touchend touchcancel', '.mbsc-lv-item', onEnd).on('click', '.mbsc-lv-item', onClick); // Prevent click on swipe\n\n      listen(e, 'click', onListClick, true); // Init action icons\n      // ---\n\n      listen(cont0, 'mousedown', onIconStart);\n      listen(document, 'touchstart', onIconStart, {\n        passive: false\n      });\n      cont.on('touchend mouseup', '.mbsc-lv-ic-m', function (ev) {\n        if (!demoMode) {\n          if (ev.type === 'touchend') {\n            preventClick();\n          } // If movement is less than 10px, fire the click event handler\n\n\n          if (confirms && !$$1(this).hasClass('mbsc-lv-ic-disabled') && Math.abs(getCoord(ev, 'X') - startX) < 10 && Math.abs(getCoord(ev, 'Y') - startY) < 10) {\n            runAction((animPos < 0 ? type.rightMenu : type.leftMenu)[$$1(this).index()], confirmItem, confirmIndex);\n          }\n        }\n      }); // ---\n      // Init hierarchical navigation\n      // ---\n\n      slideCont = $$1('.mbsc-lv-sl-c', cont).append(elm.addClass('mbsc-lv-sl-curr')).attr('data-ref', guid++);\n      currList = elm;\n      currParent = cont; // ---\n    } else {\n      cont.attr('class', contClass); // reinit sort handles\n\n      $$1('.mbsc-lv-handle-c', cont).remove(); // remove to reinit list items\n\n      $$1(itemSelector, cont).not('.mbsc-lv-back').removeClass('mbsc-lv-item');\n      unlisten(wnd0, 'orientationchange', onResize);\n      unlisten(wnd0, 'resize', onResize);\n      unlisten(wnd0, 'scroll', onScrollBottom);\n      unlisten(wnd0, 'touchmove', onScrollBottom, {\n        passive: true\n      });\n\n      if (onScrollThrottle) {\n        unlisten(wnd0, 'scroll', onScrollThrottle);\n        unlisten(wnd0, 'touchmove', onScrollThrottle, {\n          passive: true\n        });\n      }\n    }\n\n    hasContext = s.context !== 'body';\n    wnd = $$1(hasContext ? s.context : window);\n    wnd0 = wnd[0]; // Recalculate sizes on resize / orientationchange\n\n    listen(wnd0, 'orientationchange', onResize);\n    listen(wnd0, 'resize', onResize);\n    listen(wnd0, 'scroll', onScrollBottom);\n    listen(wnd0, 'touchmove', onScrollBottom, {\n      passive: true\n    }); // Init stages and actions\n    // ---\n\n    stageNr = 0;\n    types = s.itemGroups || {};\n    types.defaults = {\n      swipeleft: s.swipeleft,\n      swiperight: s.swiperight,\n      stages: s.stages,\n      actions: s.actions,\n      actionsWidth: s.actionsWidth,\n      actionable: s.actionable\n    };\n    initBranch(elm);\n    $$1.each(types, function (n, v) {\n      v.swipe = v.swipe !== undefined ? v.swipe : s.swipe;\n      v.actionable = v.actionable !== undefined ? v.actionable : s.actionable;\n      v.stages = v.stages || []; // Init stages\n\n      processStages(v.stages, 1, true);\n      processStages(v.stages.left, 1);\n      processStages(v.stages.right, -1);\n\n      if (v.stages.left || v.stages.right) {\n        v.stages = [].concat(v.stages.left || [], v.stages.right || []);\n      }\n\n      found = false;\n\n      if (!v.stages.length) {\n        if (v.swipeleft) {\n          v.stages.push({\n            percent: -30,\n            action: v.swipeleft\n          });\n        }\n\n        if (v.swiperight) {\n          v.stages.push({\n            percent: 30,\n            action: v.swiperight\n          });\n        }\n      }\n\n      $$1.each(v.stages, function (i, v) {\n        // find the 0\n        if (v.percent === 0) {\n          found = true;\n          return false;\n        }\n      });\n\n      if (!found) {\n        v.stages.push({\n          percent: 0\n        });\n      }\n\n      v.stages.sort(function (a, b) {\n        return a.percent - b.percent;\n      });\n      $$1.each(v.stages, function (i, s) {\n        // find the 0\n        if (s.percent === 0) {\n          v.start = i;\n          return false;\n        }\n      });\n\n      if (found) {\n        v.left = v.right = v.stages[v.start];\n      } else {\n        v.left = v.stages[v.start - 1] || {};\n        v.right = v.stages[v.start + 1] || {};\n      } // Init actions\n\n\n      if (v.actions) {\n        v.leftMenu = v.actions.left || v.actions;\n        v.rightMenu = v.actions.right || v.leftMenu;\n        iconsLeft = '';\n        iconsRight = '';\n\n        for (i = 0; i < v.leftMenu.length; i++) {\n          iconsLeft += '<div ' + (v.leftMenu[i].color ? 'style=\"background-color: ' + v.leftMenu[i].color + '\"' : '') + ' class=\"mbsc-lv-ic-m mbsc-lv-ic mbsc-ic mbsc-ic-' + v.leftMenu[i].icon + '\">' + (v.leftMenu[i].text || '') + '</div>';\n        }\n\n        for (i = 0; i < v.rightMenu.length; ++i) {\n          iconsRight += '<div ' + (v.rightMenu[i].color ? 'style=\"background-color: ' + v.rightMenu[i].color + '\"' : '') + ' class=\"mbsc-lv-ic-m mbsc-lv-ic mbsc-ic mbsc-ic-' + v.rightMenu[i].icon + '\">' + (v.rightMenu[i].text || '') + '</div>';\n        }\n\n        if (v.actions.left) {\n          v.swipe = v.actions.right ? v.swipe : 'right';\n        }\n\n        if (v.actions.right) {\n          v.swipe = v.actions.left ? v.swipe : 'left';\n        }\n\n        v.icons = '<div class=\"mbsc-lv-multi mbsc-lv-multi-ic-left\">' + iconsLeft + '</div><div class=\"mbsc-lv-multi mbsc-lv-multi-ic-right\">' + iconsRight + '</div>';\n      }\n    }); // ---\n    // Init fixed header\n    // ---\n\n    if (s.fixedHeader) {\n      headerClass = 'mbsc-lv-fixed-header' + (hasContext ? ' mbsc-lv-fixed-header-ctx mbsc-lv-' + s.theme + ' mbsc-' + s.theme + (s.baseTheme ? ' mbsc-lv-' + s.baseTheme + ' mbsc-' + s.baseTheme : '') : '');\n\n      if (!groupHeader) {\n        groupHeader = $$1('<div class=\"' + headerClass + '\"></div>');\n      } else {\n        groupHeader.attr('class', headerClass);\n        onScroll();\n      }\n\n      if (hasContext) {\n        wnd.before(groupHeader);\n      } else {\n        cont.prepend(groupHeader);\n      }\n\n      onScrollThrottle = throttle(onScroll, 200);\n      listen(wnd0, 'scroll', onScrollThrottle);\n      listen(wnd0, 'touchmove', onScrollThrottle, {\n        passive: true\n      });\n    } // ---\n\n\n    if (s.hover) {\n      if (!hoverTime) {\n        cont.on('mouseover.mbsc-lv', '.mbsc-lv-item', function () {\n          if (!hoverItem || hoverItem[0] != this) {\n            onMouseLeave();\n            hoverItem = $$1(this);\n\n            if (types[hoverItem.attr('data-type') || 'defaults'].actions) {\n              hoverTimer = setTimeout(function () {\n                if (!preventHover) {\n                  hoverItemOpened = true;\n                  that.openActions(hoverItem, hoverDir, hoverTime, false);\n                } else {\n                  hoverItem = null;\n                }\n              }, hoverTimeout);\n            }\n          }\n        }).on('mouseleave.mbsc-lv', onMouseLeave);\n      }\n\n      hoverTime = s.hover.time || 200;\n      hoverTimeout = s.hover.timeout || 200;\n      hoverDir = s.hover.direction || s.hover || 'right';\n    }\n\n    if (hadEnhance) {\n      cont.attr('mbsc-enhance', '');\n    }\n\n    cont.trigger('mbsc-enhance', [{\n      theme: s.theme,\n      lang: s.lang\n    }]);\n  };\n  /**\r\n   * Listview destroy: removes event handlers, classes and additional markup.\r\n   */\n\n\n  that._destroy = function () {\n    var form;\n    currParent.append(currList);\n\n    if (hasContext && groupHeader) {\n      groupHeader.remove();\n    }\n\n    if (hadEnhance) {\n      elm.attr('mbsc-enhance', ''); // Destroy form instance if any\n\n      form = instances[cont0.id];\n\n      if (form) {\n        form.destroy();\n      }\n    }\n\n    unlisten(document, 'touchstart', onStart, {\n      passive: false\n    });\n    unlisten(document, 'touchstart', onIconStart, {\n      passive: false\n    });\n    unlisten(document, 'touchmove', onMove, {\n      passive: false\n    });\n    unlisten(e, 'click', onListClick, true);\n    cont.find('.mbsc-lv-txt,.mbsc-lv-img').removeClass('mbsc-lv-txt mbsc-lv-img');\n    cont.find(listSelector).removeClass('mbsc-lv mbsc-lv-v mbsc-lv-root mbsc-lv-sl-curr').find(itemSelector).removeClass('mbsc-lv-gr-title mbsc-lv-item mbsc-lv-item-enhanced mbsc-lv-parent mbsc-lv-img-left mbsc-lv-img-right mbsc-lv-item-ic-left mbsc-lv-item-ic-right').removeAttr('data-ref');\n    $$1('.mbsc-lv-back,.mbsc-lv-handle-c,.mbsc-lv-arr,.mbsc-lv-item-ic', cont).remove();\n    elm.insertAfter(cont);\n    cont.remove();\n    stagec.remove();\n    unlisten(wnd0, 'orientationchange', onResize);\n    unlisten(wnd0, 'resize', onResize);\n    unlisten(wnd0, 'scroll', onScrollBottom);\n    unlisten(wnd0, 'touchmove', onScrollBottom, {\n      passive: true\n    });\n\n    if (onScrollThrottle) {\n      unlisten(wnd0, 'scroll', onScrollThrottle);\n      unlisten(wnd0, 'touchmove', onScrollThrottle, {\n        passive: true\n      });\n    }\n  }; // Undo manager, may be removed later in separate class\n  // ---\n\n\n  var undoing,\n      undoQueue = [],\n      undoStack = [],\n      undoGroup = [],\n      undoListener = 0;\n\n  that.startActionTrack = function () {\n    // Start a new undo group if not running\n    if (!undoListener) {\n      undoGroup = [];\n    }\n\n    undoListener++;\n  };\n\n  that.endActionTrack = function () {\n    // End undo group, if this the outermost listener (undoListener counter is 0);\n    undoListener--;\n\n    if (!undoListener) {\n      undoStack.push(undoGroup);\n    }\n  };\n\n  that.addUndoAction = function (action, async) {\n    var obj = {\n      action: action,\n      async: async\n    }; //if (!undoing) {\n\n    if (undoListener) {\n      // Add undo action in current group, if a listener is running\n      undoGroup.push(obj);\n    } else {\n      // Add undo action within a new group\n      undoStack.push([obj]);\n\n      if (undoStack.length > s.undoLimit) {\n        undoStack.shift();\n      }\n    } //}\n\n  };\n\n  that.undo = function () {\n    var action, i, group;\n\n    function run() {\n      if (i < 0) {\n        undoing = false; // If there is data in the queue, keep calling the undo\n\n        undo();\n      } else {\n        action = group[i];\n        i--;\n\n        if (action.async) {\n          // Run action, next action must be called inside the action\n          action.action(run);\n        } else {\n          // Run action\n          action.action(); // Run next action\n\n          run();\n        }\n      }\n    }\n\n    function undo() {\n      group = undoQueue.shift();\n\n      if (group) {\n        undoing = true;\n        i = group.length - 1; // Call actions from the group recoursively\n\n        run();\n      }\n    }\n\n    if (undoStack.length) {\n      undoQueue.push(undoStack.pop());\n    } // If undo is currently running, don't do anything (it will be called later from queue)\n\n\n    if (!undoing) {\n      undo();\n    }\n  }; // ---\n  // Constructor\n\n\n  s = that.settings;\n  event = that.trigger;\n  that.init();\n}; // Defaults\n\n\nListView.prototype = {\n  _class: 'listview',\n  _hasDef: true,\n  _hasTheme: true,\n  _hasLang: true,\n  _defaults: {\n    context: 'body',\n    actionsWidth: 90,\n    sortDelay: 250,\n    undoLimit: 10,\n    tap: hasGhostClick,\n    swipe: true,\n    quickSwipe: true,\n    animateAddRemove: true,\n    animateIcons: true,\n    animation: true,\n    revert: true,\n    vibrate: true,\n    actionable: true,\n    handleClass: '',\n    handleMarkup: '<div class=\"mbsc-lv-handle-bar mbsc-lv-handle\"></div><div class=\"mbsc-lv-handle-bar mbsc-lv-handle\"></div><div class=\"mbsc-lv-handle-bar mbsc-lv-handle\"></div>',\n    listNode: 'ul',\n    listSelector: 'ul,ol',\n    itemNode: 'li',\n    itemSelector: 'li',\n    leftArrowClass: 'mbsc-ic-arrow-left4',\n    rightArrowClass: 'mbsc-ic-arrow-right4',\n    backText: 'Back',\n    undoText: 'Undo',\n    stages: [],\n    select: 'off'\n  }\n};\nclasses.ListView = ListView;\nmobiscroll.themes.listview.mobiscroll = {\n  leftArrowClass: 'mbsc-ic-arrow-left5',\n  rightArrowClass: 'mbsc-ic-arrow-right5'\n};\n\nvar MbscListviewService = function () {\n  function MbscListviewService() {\n    this.addObservable = new Observable();\n    this.removeObservable = new Observable();\n    this.cardObservable = new Observable();\n    this.instanceObservable = new Observable();\n    this.inst = null;\n  }\n\n  MbscListviewService.prototype.notifyInstanceReady = function (instance) {\n    this.inst = instance;\n    this.instanceObservable.next(instance);\n  };\n\n  MbscListviewService.prototype.onInstanceReady = function () {\n    return this.instanceObservable;\n  };\n\n  MbscListviewService.prototype.notifyAdded = function (item, parent) {\n    this.addObservable.next({\n      item: item,\n      parent: parent\n    });\n  };\n\n  MbscListviewService.prototype.notifyRemoved = function (item) {\n    this.removeObservable.next(item);\n  };\n\n  MbscListviewService.prototype.notifyCardPresence = function (isCard) {\n    this.cardObservable.next(isCard);\n  };\n\n  MbscListviewService.prototype.onCardContent = function () {\n    return this.cardObservable;\n  };\n\n  MbscListviewService.prototype.onItemAdded = function () {\n    return this.addObservable;\n  };\n\n  MbscListviewService.prototype.onItemRemoved = function () {\n    return this.removeObservable;\n  };\n\n  MbscListviewService.ɵfac = function MbscListviewService_Factory(t) {\n    return new (t || MbscListviewService)();\n  };\n\n  MbscListviewService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: MbscListviewService,\n    factory: function (t) {\n      return MbscListviewService.ɵfac(t);\n    }\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscListviewService;\n}();\n\nvar MbscSublistService = function () {\n  function MbscSublistService() {\n    this.addObservable = new Observable();\n    this.removeObserable = new Observable();\n  }\n\n  MbscSublistService.prototype.notifyAdded = function (item) {\n    this.addObservable.next(item);\n  };\n\n  MbscSublistService.prototype.notifyRemoved = function (item) {\n    this.removeObserable.next(item);\n  };\n\n  MbscSublistService.prototype.onItemAdded = function () {\n    return this.addObservable;\n  };\n\n  MbscSublistService.prototype.onItemRemoved = function () {\n    return this.removeObserable;\n  };\n\n  MbscSublistService.ɵfac = function MbscSublistService_Factory(t) {\n    return new (t || MbscSublistService)();\n  };\n\n  MbscSublistService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: MbscSublistService,\n    factory: function (t) {\n      return MbscSublistService.ɵfac(t);\n    }\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscSublistService;\n}();\n\nvar MbscListitemService = function () {\n  function MbscListitemService() {\n    this.sublistSubject = new Observable();\n    this.inst = null;\n  }\n\n  MbscListitemService.prototype.notifySublistCreated = function (item) {\n    this.sublistSubject.next(item);\n  };\n\n  MbscListitemService.prototype.onSublistCreated = function () {\n    return this.sublistSubject;\n  };\n\n  MbscListitemService.ɵfac = function MbscListitemService_Factory(t) {\n    return new (t || MbscListitemService)();\n  };\n\n  MbscListitemService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: MbscListitemService,\n    factory: function (t) {\n      return MbscListitemService.ɵfac(t);\n    }\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscListitemService;\n}();\n\nvar MbscListviewSublist = function () {\n  function MbscListviewSublist(parentServ, subServ, itemService) {\n    this.parentServ = parentServ;\n    this.subServ = subServ;\n    this.itemService = itemService;\n  }\n\n  MbscListviewSublist.prototype.ngOnInit = function () {\n    this.itemService.notifySublistCreated(this);\n  };\n\n  MbscListviewSublist = __decorate([__metadata(\"design:paramtypes\", [MbscListviewService, MbscSublistService, MbscListitemService])], MbscListviewSublist);\n\n  MbscListviewSublist.ɵfac = function MbscListviewSublist_Factory(t) {\n    return new (t || MbscListviewSublist)(ɵngcc0.ɵɵdirectiveInject(MbscListviewService), ɵngcc0.ɵɵdirectiveInject(MbscSublistService), ɵngcc0.ɵɵdirectiveInject(MbscListitemService));\n  };\n\n  MbscListviewSublist.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscListviewSublist,\n    selectors: [[\"mbsc-listview-sublist\"]],\n    features: [ɵngcc0.ɵɵProvidersFeature([MbscSublistService])],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscListviewSublist_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscListviewSublist;\n}();\n\nvar MbscListviewItem = function () {\n  function MbscListviewItem(elem, lvService, lvItemService, subService) {\n    var _this = this;\n\n    this.elem = elem;\n    this.lvService = lvService;\n    this.lvItemService = lvItemService;\n    this.subService = subService;\n    this.clone = null;\n    this.mounted = false;\n    this.isParent = false;\n    this._instance = undefined;\n    this.subitemObserver = null;\n    this.selectedChange = new EventEmitter();\n    this.sublistObserver = lvItemService.onSublistCreated().subscribe(function (sublist) {\n      _this.isParent = true;\n      _this.sublist = sublist;\n      _this.subitemObserver = sublist.subServ.onItemAdded().subscribe(function (subItem) {\n        if (_this.mounted) {\n          _this.lvService.notifyAdded(subItem, _this);\n        }\n      });\n    });\n    this.instanceObserver = this.lvService.onInstanceReady().subscribe(function (instance) {\n      _this._instance = instance;\n    });\n\n    if (lvService.inst) {\n      this._instance = lvService.inst;\n    }\n  }\n\n  Object.defineProperty(MbscListviewItem.prototype, \"Index\", {\n    get: function () {\n      var thisElem = $$1(this.elem.nativeElement);\n      var index = thisElem.parent().children('mbsc-listview-item, mbsc-listview-header').not('.mbsc-lv-back').index(thisElem);\n      return index;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MbscListviewItem.prototype, \"Element\", {\n    get: function () {\n      return this.clone || $$1(this.elem.nativeElement);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscListviewItem.prototype.ngAfterViewInit = function () {\n    if (this.subService) {\n      this.subService.notifyAdded(this);\n    } else {\n      this.lvService.notifyAdded(this);\n    }\n\n    this.mounted = true;\n  };\n\n  MbscListviewItem.prototype.ngOnDestroy = function () {\n    this.lvItemService.onSublistCreated().unsubscribe(this.sublistObserver);\n    this.lvService.onInstanceReady().unsubscribe(this.instanceObserver);\n\n    if (this.subitemObserver !== null) {\n      this.sublist.subServ.onItemAdded().unsubscribe(this.subitemObserver);\n      this.sublist = null;\n    }\n\n    var $elm = this.Element,\n        $clone = $elm.clone();\n\n    if ($elm.parent().length) {\n      $clone.insertBefore($elm);\n      this.clone = $clone;\n    }\n\n    if (this.subService) {\n      this.subService.notifyRemoved(this);\n    } else {\n      this.lvService.notifyRemoved(this);\n    }\n  };\n\n  Object.defineProperty(MbscListviewItem.prototype, \"selected\", {\n    get: function () {\n      return this._selected;\n    },\n    set: function (v) {\n      this._selected = v;\n\n      if (this._instance) {\n        if (this._selected) {\n          this._instance.select(this.elem.nativeElement);\n        } else {\n          this._instance.deselect(this.elem.nativeElement);\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscListviewItem.prototype.toggle = function () {\n    this._selected = !this._selected;\n    this.selectedChange.emit(this._selected);\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscListviewItem.prototype, \"id\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscListviewItem.prototype, \"icon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscListviewItem.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscListviewItem.prototype, \"type\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [Boolean])], MbscListviewItem.prototype, \"selected\", null);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscListviewItem.prototype, \"selectedChange\", void 0);\n\n  MbscListviewItem = __decorate([__param(3, Optional()), __metadata(\"design:paramtypes\", [ElementRef, MbscListviewService, MbscListitemService, MbscSublistService])], MbscListviewItem);\n\n  MbscListviewItem.ɵfac = function MbscListviewItem_Factory(t) {\n    return new (t || MbscListviewItem)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscListviewService), ɵngcc0.ɵɵdirectiveInject(MbscListitemService), ɵngcc0.ɵɵdirectiveInject(MbscSublistService, 8));\n  };\n\n  MbscListviewItem.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscListviewItem,\n    selectors: [[\"mbsc-listview-item\"]],\n    hostVars: 5,\n    hostBindings: function MbscListviewItem_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"data-id\", ctx.id)(\"data-icon\", ctx.icon)(\"data-icon-align\", ctx.iconAlign)(\"data-selected\", ctx.selected)(\"data-type\", ctx.type);\n      }\n    },\n    inputs: {\n      selected: \"selected\",\n      id: \"id\",\n      icon: \"icon\",\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      type: \"type\"\n    },\n    outputs: {\n      selectedChange: \"selectedChange\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([MbscListitemService])],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscListviewItem_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscListviewItem;\n}();\n\nvar MbscListviewHeader = function (_super) {\n  __extends(MbscListviewHeader, _super);\n\n  function MbscListviewHeader(elem, lvService, itemService, subService) {\n    return _super.call(this, elem, lvService, itemService, subService) || this;\n  }\n\n  MbscListviewHeader = __decorate([__param(3, Optional()), __metadata(\"design:paramtypes\", [ElementRef, MbscListviewService, MbscListitemService, MbscSublistService])], MbscListviewHeader);\n\n  MbscListviewHeader.ɵfac = function MbscListviewHeader_Factory(t) {\n    return new (t || MbscListviewHeader)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscListviewService), ɵngcc0.ɵɵdirectiveInject(MbscListitemService), ɵngcc0.ɵɵdirectiveInject(MbscSublistService, 8));\n  };\n\n  MbscListviewHeader.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscListviewHeader,\n    selectors: [[\"mbsc-listview-header\"]],\n    hostAttrs: [\"data-role\", \"list-divider\"],\n    hostVars: 1,\n    hostBindings: function MbscListviewHeader_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"data-id\", ctx.id);\n      }\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([MbscListitemService]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscListviewHeader_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscListviewHeader;\n}(MbscListviewItem);\n\nvar MbscListview = function (_super) {\n  __extends(MbscListview, _super);\n\n  function MbscListview(elem, zone, lvService, optionService) {\n    var _this = _super.call(this, elem, zone) || this;\n\n    _this.elem = elem;\n    _this.lvService = lvService;\n    _this.optionService = optionService;\n    _this.onItemTap = new EventEmitter();\n    _this.onItemAdd = new EventEmitter();\n    _this.onItemRemove = new EventEmitter();\n    _this.onListEnd = new EventEmitter();\n    _this.onNavEnd = new EventEmitter();\n    _this.onNavStart = new EventEmitter();\n    _this.onSlideEnd = new EventEmitter();\n    _this.onSlideStart = new EventEmitter();\n    _this.onSort = new EventEmitter();\n    _this.onSortChange = new EventEmitter();\n    _this.onSortStart = new EventEmitter();\n    _this.onSortEnd = new EventEmitter();\n    _this.onSortUpdate = new EventEmitter();\n    _this.onStageChange = new EventEmitter();\n    _this.cardContent = false;\n    _this.addObserver = lvService.onItemAdded().subscribe(function (t) {\n      var item = t.item,\n          parent = t.parent;\n\n      if (_this.instance) {\n        _this.instance.add(null, item.Element, item.Index, undefined, parent && parent.Element);\n      }\n    });\n    _this.removeObserver = lvService.onItemRemoved().subscribe(function (item) {\n      if (_this.instance) {\n        _this.instance.remove(item.Element, undefined);\n      }\n    });\n    _this.cardObserver = lvService.onCardContent().subscribe(function (isCard) {\n      _this.cardContent = isCard;\n    });\n    return _this;\n  }\n\n  MbscListview.prototype.tapHandler = function (event, inst) {\n    var selection = this.select || inst && inst.settings.select;\n\n    switch (selection) {\n      case 'multiple':\n        {\n          var item = this._getItem(event.target);\n\n          if (item && !item.isParent) {\n            item.toggle();\n          }\n\n          break;\n        }\n\n      case 'single':\n        {\n          var item = this._getItem(event.target);\n\n          if (item && !item.selected) {\n            this.items.forEach(function (item) {\n              if (item.selected) {\n                item.toggle();\n              }\n            });\n            item.toggle();\n          }\n        }\n    }\n\n    event.inst = inst;\n    this.onItemTap.emit(event);\n  };\n\n  MbscListview.prototype._getItem = function (nativeEl) {\n    return this.items.find(function (item) {\n      return item.elem.nativeElement === nativeEl;\n    });\n  };\n\n  MbscListview.prototype.initControl = function () {\n    var _this = this;\n\n    var onItemTap = this.tapHandler.bind(this);\n    var onItemTapUser = this.options && this.options.onItemTap;\n\n    if (onItemTapUser) {\n      onItemTap = function (event, inst) {\n        _this.tapHandler(event, inst);\n\n        return onItemTapUser(event, inst);\n      };\n    }\n\n    var options = extend$1({\n      listNode: 'mbsc-listview',\n      listSelector: 'mbsc-listview, mbsc-listview-sublist',\n      itemNode: 'mbsc-listview-item',\n      itemSelector: 'mbsc-listview-item, mbsc-listview-header'\n    }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, {\n      onItemTap: onItemTap\n    });\n    this.instance = new ListView(this.elem.nativeElement, options);\n    this.lvService.notifyInstanceReady(this.instance);\n  };\n\n  MbscListview.prototype.ngOnDestroy = function () {\n    this.lvService.onCardContent().unsubscribe(this.cardObserver);\n    this.lvService.onItemAdded().unsubscribe(this.addObserver);\n    this.lvService.onItemRemoved().unsubscribe(this.removeObserver);\n\n    _super.prototype.ngOnDestroy.call(this);\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscListview.prototype, \"actions\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscListview.prototype, \"actionsWidth\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscListview.prototype, \"context\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscListview.prototype, \"striped\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscListview.prototype, \"animateAddRemove\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscListview.prototype, \"actionable\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscListview.prototype, \"animateIcons\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscListview.prototype, \"enhance\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscListview.prototype, \"fillAnimation\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscListview.prototype, \"fixedHeader\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscListview.prototype, \"hover\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscListview.prototype, \"iconSlide\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscListview.prototype, \"itemGroups\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscListview.prototype, \"loadingIcon\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscListview.prototype, \"navigateOnDrop\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscListview.prototype, \"quickSwipe\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscListview.prototype, \"select\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscListview.prototype, \"sortable\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscListview.prototype, \"sortDelay\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscListview.prototype, \"stages\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscListview.prototype, \"swipe\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Function)], MbscListview.prototype, \"swipeleft\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Function)], MbscListview.prototype, \"swiperight\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscListview.prototype, \"vibrate\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscListview.prototype, \"undoText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscListview.prototype, \"backText\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscListview.prototype, \"onItemTap\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscListview.prototype, \"onItemAdd\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscListview.prototype, \"onItemRemove\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscListview.prototype, \"onListEnd\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscListview.prototype, \"onNavEnd\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscListview.prototype, \"onNavStart\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscListview.prototype, \"onSlideEnd\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscListview.prototype, \"onSlideStart\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscListview.prototype, \"onSort\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscListview.prototype, \"onSortChange\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscListview.prototype, \"onSortStart\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscListview.prototype, \"onSortEnd\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscListview.prototype, \"onSortUpdate\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscListview.prototype, \"onStageChange\", void 0);\n\n  __decorate([Input$1('options'), __metadata(\"design:type\", Object)], MbscListview.prototype, \"options\", void 0);\n\n  __decorate([ContentChildren(MbscListviewItem, {\n    descendants: true\n  }), __metadata(\"design:type\", QueryList)], MbscListview.prototype, \"items\", void 0);\n\n  MbscListview = __decorate([__param(3, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, MbscListviewService, MbscOptionsService])], MbscListview);\n\n  MbscListview.ɵfac = function MbscListview_Factory(t) {\n    return new (t || MbscListview)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscListviewService), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscListview.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscListview,\n    selectors: [[\"mbsc-listview\"]],\n    contentQueries: function MbscListview_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MbscListviewItem, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.items = _t);\n      }\n    },\n    hostAttrs: [1, \"mbsc-cloak\"],\n    hostVars: 2,\n    hostBindings: function MbscListview_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"mbsc-card-list\", ctx.cardContent);\n      }\n    },\n    inputs: {\n      actions: \"actions\",\n      actionsWidth: \"actionsWidth\",\n      context: \"context\",\n      striped: \"striped\",\n      animateAddRemove: \"animateAddRemove\",\n      actionable: \"actionable\",\n      animateIcons: \"animateIcons\",\n      enhance: \"enhance\",\n      fillAnimation: \"fillAnimation\",\n      fixedHeader: \"fixedHeader\",\n      hover: \"hover\",\n      iconSlide: \"iconSlide\",\n      itemGroups: \"itemGroups\",\n      loadingIcon: \"loadingIcon\",\n      navigateOnDrop: \"navigateOnDrop\",\n      quickSwipe: \"quickSwipe\",\n      select: \"select\",\n      sortable: \"sortable\",\n      sortDelay: \"sortDelay\",\n      stages: \"stages\",\n      swipe: \"swipe\",\n      swipeleft: \"swipeleft\",\n      swiperight: \"swiperight\",\n      vibrate: \"vibrate\",\n      undoText: \"undoText\",\n      backText: \"backText\",\n      options: \"options\"\n    },\n    outputs: {\n      onItemTap: \"onItemTap\",\n      onItemAdd: \"onItemAdd\",\n      onItemRemove: \"onItemRemove\",\n      onListEnd: \"onListEnd\",\n      onNavEnd: \"onNavEnd\",\n      onNavStart: \"onNavStart\",\n      onSlideEnd: \"onSlideEnd\",\n      onSlideStart: \"onSlideStart\",\n      onSort: \"onSort\",\n      onSortChange: \"onSortChange\",\n      onSortStart: \"onSortStart\",\n      onSortEnd: \"onSortEnd\",\n      onSortUpdate: \"onSortUpdate\",\n      onStageChange: \"onStageChange\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([MbscListviewService]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscListview_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscListview;\n}(MbscBase);\n\nvar comp = [MbscListview, MbscListviewItem, MbscListviewHeader, MbscListviewSublist];\n\nvar MbscListviewModule = function () {\n  function MbscListviewModule() {}\n\n  MbscListviewModule.ɵfac = function MbscListviewModule_Factory(t) {\n    return new (t || MbscListviewModule)();\n  };\n\n  MbscListviewModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscListviewModule\n  });\n  MbscListviewModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[MbscBaseModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscListviewModule, {\n      declarations: [MbscListview, MbscListviewItem, MbscListviewHeader, MbscListviewSublist],\n      imports: [MbscBaseModule],\n      exports: [MbscListview, MbscListviewItem, MbscListviewHeader, MbscListviewSublist]\n    });\n  })();\n\n  return MbscListviewModule;\n}();\n\nvar MbscCard = function (_super) {\n  __extends(MbscCard, _super);\n\n  function MbscCard(host, optionsService, lvService, zone) {\n    var _this = _super.call(this, host, zone) || this;\n\n    _this.optionsService = optionsService;\n    _this.lvService = lvService;\n    _this._collapsibleInput = null;\n    _this._open = false;\n\n    if (_this.lvService) {\n      _this.lvService.notifyCardPresence(true);\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(MbscCard.prototype, \"collapsibleInput\", {\n    set: function (v) {\n      this._collapsibleInput = v;\n      this.inlineOptionsObj.collapsible = this._open;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MbscCard.prototype, \"open\", {\n    set: function (v) {\n      if (this._open != v && this.instance) {\n        if (v) {\n          this.instance.show();\n        } else {\n          this.instance.hide();\n        }\n      }\n\n      this._open = !!v;\n\n      if (this._collapsibleInput !== null) {\n        this.inlineOptionsObj.collapsible = this._open;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscCard.prototype.initControl = function () {\n    var options = extend$1({}, this.optionsService ? this.optionsService.options : {}, this.options, this.inlineOptionsObj);\n    this.instance = new Card(this.initialElem.nativeElement, options);\n  };\n\n  __decorate([Input$1('collapsible'), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], MbscCard.prototype, \"collapsibleInput\", null);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [Boolean])], MbscCard.prototype, \"open\", null);\n\n  MbscCard = __decorate([__param(1, Optional()), __param(2, Optional()), __metadata(\"design:paramtypes\", [ElementRef, MbscOptionsService, MbscListviewService, NgZone])], MbscCard);\n\n  MbscCard.ɵfac = function MbscCard_Factory(t) {\n    return new (t || MbscCard)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(MbscListviewService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  MbscCard.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscCard,\n    selectors: [[\"\", \"mbsc-card\", \"\"]],\n    hostAttrs: [1, \"mbsc-cloak\"],\n    inputs: {\n      collapsibleInput: [\"collapsible\", \"collapsibleInput\"],\n      open: \"open\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscCard;\n}(MbscBase);\n\nvar MbscCardComponent = function (_super) {\n  __extends(MbscCardComponent, _super);\n\n  function MbscCardComponent(host, optionsService, lvService, zone) {\n    var _this = _super.call(this, host, optionsService, lvService, zone) || this;\n\n    _this.optionsService = optionsService;\n    return _this;\n  }\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscCardComponent.prototype, \"options\", void 0);\n\n  MbscCardComponent = __decorate([__param(1, Optional()), __param(2, Optional()), __metadata(\"design:paramtypes\", [ElementRef, MbscOptionsService, MbscListviewService, NgZone])], MbscCardComponent);\n\n  MbscCardComponent.ɵfac = function MbscCardComponent_Factory(t) {\n    return new (t || MbscCardComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(MbscListviewService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  MbscCardComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscCardComponent,\n    selectors: [[\"mbsc-card\"]],\n    inputs: {\n      options: \"options\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscCardComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%] { display: block }\"]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscCardComponent;\n}(MbscCard);\n\nvar MbscCardHeader = function () {\n  function MbscCardHeader() {}\n\n  MbscCardHeader.ɵfac = function MbscCardHeader_Factory(t) {\n    return new (t || MbscCardHeader)();\n  };\n\n  MbscCardHeader.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscCardHeader,\n    selectors: [[\"mbsc-card-header\"]],\n    hostAttrs: [1, \"mbsc-card-header\"],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscCardHeader_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%] { display: block; }\"]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscCardHeader;\n}();\n\nvar MbscCardContent = function () {\n  function MbscCardContent() {}\n\n  MbscCardContent.ɵfac = function MbscCardContent_Factory(t) {\n    return new (t || MbscCardContent)();\n  };\n\n  MbscCardContent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscCardContent,\n    selectors: [[\"mbsc-card-content\"]],\n    hostAttrs: [1, \"mbsc-card-content\"],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscCardContent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%] { display: block; }\"]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscCardContent;\n}();\n\nvar MbscCardFooter = function () {\n  function MbscCardFooter() {}\n\n  MbscCardFooter.ɵfac = function MbscCardFooter_Factory(t) {\n    return new (t || MbscCardFooter)();\n  };\n\n  MbscCardFooter.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscCardFooter,\n    selectors: [[\"mbsc-card-footer\"]],\n    hostAttrs: [1, \"mbsc-card-footer\"],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscCardFooter_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%] { display: block; }\"]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscCardFooter;\n}();\n\nvar MbscCardTitle = function () {\n  function MbscCardTitle() {}\n\n  MbscCardTitle.ɵfac = function MbscCardTitle_Factory(t) {\n    return new (t || MbscCardTitle)();\n  };\n\n  MbscCardTitle.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscCardTitle,\n    selectors: [[\"mbsc-card-title\"]],\n    hostAttrs: [1, \"mbsc-card-title\"],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscCardTitle_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%] { display: block; }\"]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscCardTitle;\n}();\n\nvar MbscCardSubtitle = function () {\n  function MbscCardSubtitle() {}\n\n  MbscCardSubtitle.ɵfac = function MbscCardSubtitle_Factory(t) {\n    return new (t || MbscCardSubtitle)();\n  };\n\n  MbscCardSubtitle.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscCardSubtitle,\n    selectors: [[\"mbsc-card-subtitle\"]],\n    hostAttrs: [1, \"mbsc-card-subtitle\"],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscCardSubtitle_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%] { display: block; }\"]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscCardSubtitle;\n}();\n\nvar comp$1 = [MbscCard, MbscCardComponent, MbscCardHeader, MbscCardContent, MbscCardFooter, MbscCardTitle, MbscCardSubtitle];\n\nvar MbscCardModule = function () {\n  function MbscCardModule() {}\n\n  MbscCardModule.ɵfac = function MbscCardModule_Factory(t) {\n    return new (t || MbscCardModule)();\n  };\n\n  MbscCardModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscCardModule\n  });\n  MbscCardModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[MbscBaseModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscCardModule, {\n      declarations: [MbscCard, MbscCardComponent, MbscCardHeader, MbscCardContent, MbscCardFooter, MbscCardTitle, MbscCardSubtitle],\n      imports: [MbscBaseModule],\n      exports: [MbscCard, MbscCardComponent, MbscCardHeader, MbscCardContent, MbscCardFooter, MbscCardTitle, MbscCardSubtitle]\n    });\n  })();\n\n  return MbscCardModule;\n}();\n/**\r\n * Convert rgb color to hex\r\n */\n\n\nfunction rgb2hex(rgb) {\n  var hex = [Math.round(rgb.r).toString(16), Math.round(rgb.g).toString(16), Math.round(rgb.b).toString(16)];\n  $$1.each(hex, function (nr, val) {\n    if (val.length == 1) {\n      hex[nr] = '0' + val;\n    }\n  });\n  return '#' + hex.join('');\n}\n/**\r\n * Convert hex color to rgb\r\n */\n\n\nfunction hex2rgb(hex) {\n  hex = parseInt(hex.indexOf('#') > -1 ? hex.substring(1) : hex, 16);\n  return {\n    r: hex >> 16,\n    g: (hex & 0x00FF00) >> 8,\n    b: hex & 0x0000FF,\n    toString: function toString() {\n      return 'rgb(' + this.r + ',' + this.g + ',' + this.b + ')';\n    }\n  };\n}\n/**\r\n * Convert hsv color to rgb\r\n */\n\n\nfunction hsv2rgb(hsv) {\n  var r,\n      g,\n      b,\n      h = hsv.h,\n      s = hsv.s * 255 / 100,\n      v = hsv.v * 255 / 100;\n\n  if (s === 0) {\n    r = g = b = v;\n  } else {\n    var t1 = v,\n        t2 = (255 - s) * v / 255,\n        t3 = (t1 - t2) * (h % 60) / 60;\n\n    if (h == 360) {\n      h = 0;\n    }\n\n    if (h < 60) {\n      r = t1;\n      b = t2;\n      g = t2 + t3;\n    } else if (h < 120) {\n      g = t1;\n      b = t2;\n      r = t1 - t3;\n    } else if (h < 180) {\n      g = t1;\n      r = t2;\n      b = t2 + t3;\n    } else if (h < 240) {\n      b = t1;\n      r = t2;\n      g = t1 - t3;\n    } else if (h < 300) {\n      b = t1;\n      g = t2;\n      r = t2 + t3;\n    } else if (h < 360) {\n      r = t1;\n      g = t2;\n      b = t1 - t3;\n    } else {\n      r = g = b = 0;\n    }\n  }\n\n  return {\n    r: r,\n    g: g,\n    b: b,\n    toString: function toString() {\n      return 'rgb(' + this.r + ',' + this.g + ',' + this.b + ')';\n    }\n  };\n}\n/**\r\n * Convert rgb color to hsv\r\n */\n\n\nfunction rgb2hsv(rgb) {\n  var h = 0,\n      s,\n      v,\n      min = Math.min(rgb.r, rgb.g, rgb.b),\n      max = Math.max(rgb.r, rgb.g, rgb.b),\n      delta = max - min;\n  v = max;\n  s = max ? 255 * delta / max : 0;\n\n  if (s) {\n    if (rgb.r == max) {\n      h = (rgb.g - rgb.b) / delta;\n    } else if (rgb.g == max) {\n      h = 2 + (rgb.b - rgb.r) / delta;\n    } else {\n      h = 4 + (rgb.r - rgb.g) / delta;\n    }\n  } else {\n    h = -1;\n  }\n\n  h *= 60;\n\n  if (h < 0) {\n    h += 360;\n  }\n\n  s *= 100 / 255;\n  v *= 100 / 255;\n  return {\n    h: h,\n    s: s,\n    v: v,\n    toString: function toString() {\n      return 'hsv(' + Math.round(this.h) + ',' + Math.round(this.s) + '%,' + Math.round(this.v) + '%)';\n    }\n  };\n}\n/**\r\n * Convert rgb color to hsl\r\n */\n\n\nfunction rgb2hsl(rgb) {\n  var r = rgb.r / 255,\n      g = rgb.g / 255,\n      b = rgb.b / 255,\n      max = Math.max(r, g, b),\n      min = Math.min(r, g, b),\n      l = (max + min) / 2,\n      h,\n      s;\n\n  if (max == min) {\n    h = s = 0; // achromatic\n  } else {\n    var d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\n    switch (max) {\n      case r:\n        h = (g - b) / d + (g < b ? 6 : 0);\n        break;\n\n      case g:\n        h = (b - r) / d + 2;\n        break;\n\n      case b:\n        h = (r - g) / d + 4;\n        break;\n    }\n\n    h /= 6;\n  }\n\n  return {\n    h: Math.round(h * 360),\n    s: Math.round(s * 100),\n    l: Math.round(l * 100),\n    toString: function toString() {\n      return 'hsl(' + this.h + ',' + this.s + '%,' + this.l + '%)';\n    }\n  };\n}\n/**\r\n * Convert hsl color to rgb\r\n */\n\n\nfunction hsl2rgb(hsl) {\n  var r,\n      g,\n      b,\n      m,\n      c,\n      x,\n      h = hsl.h,\n      s = hsl.s,\n      l = hsl.l;\n\n  if (!isFinite(h)) {\n    h = 0;\n  }\n\n  if (!isFinite(s)) {\n    s = 0;\n  }\n\n  if (!isFinite(l)) {\n    l = 0;\n  }\n\n  h /= 60;\n\n  if (h < 0) {\n    h = 6 - -h % 6;\n  }\n\n  h %= 6;\n  s = Math.max(0, Math.min(1, s / 100));\n  l = Math.max(0, Math.min(1, l / 100));\n  c = (1 - Math.abs(2 * l - 1)) * s;\n  x = c * (1 - Math.abs(h % 2 - 1));\n\n  if (h < 1) {\n    r = c;\n    g = x;\n    b = 0;\n  } else if (h < 2) {\n    r = x;\n    g = c;\n    b = 0;\n  } else if (h < 3) {\n    r = 0;\n    g = c;\n    b = x;\n  } else if (h < 4) {\n    r = 0;\n    g = x;\n    b = c;\n  } else if (h < 5) {\n    r = x;\n    g = 0;\n    b = c;\n  } else {\n    r = c;\n    g = 0;\n    b = x;\n  }\n\n  m = l - c / 2;\n  return {\n    r: Math.round((r + m) * 255),\n    g: Math.round((g + m) * 255),\n    b: Math.round((b + m) * 255),\n    toString: function toString() {\n      return 'rgb(' + this.r + ',' + this.g + ',' + this.b + ')';\n    }\n  };\n}\n/**\r\n * Convert hex color to hsl\r\n */\n\n\nfunction hex2hsl(hex) {\n  return rgb2hsl(hex2rgb(hex));\n}\n/**\r\n * Convert hsl color to hex\r\n */\n\n\nfunction hsl2hex(hsl) {\n  return rgb2hex(hsl2rgb(hsl));\n}\n/**\r\n * Convert hsv color to hex\r\n */\n\n\nfunction hsv2hex(hsv) {\n  return rgb2hex(hsv2rgb(hsv));\n}\n/**\r\n * Convert hex color to hsv\r\n */\n\n\nfunction hex2hsv(hex) {\n  return rgb2hsv(hex2rgb(hex));\n}\n\nvar Color = function Color(el, settings, inherit) {\n  var s,\n      def,\n      tempColors,\n      trigger,\n      scrollView,\n      previewScrollView,\n      hasClear,\n      currValue,\n      currHslValue,\n      isHorizontalScroll,\n      hasPreview,\n      sliderTrack,\n      refineMode,\n      rowItems,\n      slider,\n      colorIndex,\n      enhanceInput,\n      singleSelect,\n      maxSelect,\n      returnObj,\n      $input,\n      $colorItems,\n      $colorPreviewItems,\n      $currItem,\n      $sliderElm,\n      that = this,\n      $elm = $$1(el),\n      colorPreviewInd = 0,\n      previewValues = {},\n      tempPreviewValues = {};\n\n  function setValue(fill, change, temp) {\n    if (!temp) {\n      that._value = that._hasValue ? that._tempValue.slice(0) : null;\n\n      for (var i = 0; i < tempColors.length; ++i) {\n        if (tempColors[i].tempChangedColor && that._value && that._value.indexOf(tempColors[i].tempChangedColor) != -1) {\n          // set changed color if was set\n          tempColors[i].changedColor = tempColors[i].tempChangedColor;\n        } // else if (tempColors[i].changedColor && that._value.indexOf(tempColors[i].changedColor) == -1) { // delete changed color if was unset\n        //    delete tempColors[i].changedColor;\n        //}\n\n\n        delete tempColors[i].tempChangedColor;\n      }\n    }\n\n    if (fill) {\n      if (that._isInput) {\n        $elm.val(that._hasValue ? that._tempValue : '');\n      }\n\n      trigger('onFill', {\n        valueText: that._hasValue ? that._tempValue : '',\n        change: change\n      });\n\n      if (change) {\n        previewValues = extend$1(true, {}, tempPreviewValues);\n        that._preventChange = true;\n        $elm.trigger('change');\n      }\n\n      refreshSelectedValues(that._value, true);\n    }\n  }\n\n  function getInputColorItem(value, index) {\n    index = index !== undefined ? index : getColorIndex(value);\n    return '<div class=\"mbsc-color-input-item\" data-color=\"' + (index !== undefined ? index : value) + '\" style=\"background: ' + value + ';\">' + (singleSelect ? '' : '<div class=\"mbsc-color-input-item-close mbsc-ic mbsc-ic-material-close\"></div>') + '</div>';\n  }\n\n  function changeSliderStepsColor(color) {\n    sliderTrack[0].style.background = color ? cssPrefix + 'linear-gradient(left, ' + (s.rtl ? '#000000' : '#FFFFFF') + ' 0%, ' + color + ' 50%, ' + (s.rtl ? '#FFFFFF' : '#000000') + ' 100%)' : '';\n  }\n\n  function getColorIndex(color) {\n    if (Object.keys(tempPreviewValues).length && !isNaN(color)) {\n      return color;\n    }\n\n    for (var c in tempColors) {\n      if (color == tempColors[c].color || color == tempColors[c].changedColor) {\n        return c;\n      }\n    }\n  }\n\n  function generateInputItems() {\n    if (enhanceInput) {\n      var i,\n          inputColorItems = '';\n      $input.empty();\n\n      if (that._hasValue) {\n        if (singleSelect) {\n          inputColorItems += getInputColorItem(that._value, colorIndex);\n        } else {\n          for (i = 0; i < that._value.length; ++i) {\n            inputColorItems += getInputColorItem(that._value[i], Object.keys(tempPreviewValues).length && tempPreviewValues[i].colorIndex ? tempPreviewValues[i].colorIndex : getColorIndex(that._value[i]));\n          }\n        }\n\n        $input.append(inputColorItems);\n        that.tap($$1('.mbsc-color-input-item', $input), function (ev) {\n          if ($$1(ev.target).hasClass('mbsc-color-input-item-close')) {\n            var indx = $$1(this).index();\n            ev.stopPropagation();\n            ev.preventDefault();\n\n            if (colorIndex === undefined) {\n              colorIndex = $$1(ev.target).parent().attr('data-color');\n            }\n\n            if (hasPreview && tempColors[colorIndex]) {\n              colorPreviewInd = tempColors[colorIndex].previewInd;\n              $colorPreviewItems.eq(colorPreviewInd).parent().removeClass('mbsc-color-active');\n              previewValues[indx] = {};\n              tempPreviewValues[indx] = {};\n            }\n\n            that._value.splice(indx, 1);\n\n            that.setVal(that._value, true, true);\n          } else if (refineMode && s.display !== 'inline') {\n            colorIndex = $$1(ev.target).attr('data-color');\n\n            if (isNaN(colorIndex)) {\n              colorIndex = getColorIndex(colorIndex);\n            }\n\n            if (colorIndex && tempColors[colorIndex]) {\n              tempColors[colorIndex].selected = true;\n              colorPreviewInd = tempColors[colorIndex].previewInd; // scroll to view, if the selected color is not resent in the view\n\n              setTimeout(function () {\n                scrollView.scroll($colorItems.eq(colorIndex), 400);\n\n                if (hasPreview) {\n                  previewScrollView.scroll($colorPreviewItems.eq(colorPreviewInd), 400);\n                }\n              }, 200);\n            }\n          }\n        });\n      }\n    }\n  }\n\n  function convertToFormat(color, type) {\n    var colorHex,\n        colorValues = color.match(/\\d+/gmi);\n\n    switch (true) {\n      case color.indexOf('rgb') > -1:\n        colorHex = rgb2hex({\n          r: colorValues[0],\n          g: colorValues[1],\n          b: colorValues[2]\n        });\n        break;\n\n      case color.indexOf('hsl') > -1:\n        colorHex = hsl2hex({\n          h: colorValues[0],\n          s: colorValues[1],\n          l: colorValues[2]\n        });\n        break;\n\n      case color.indexOf('hsv') > -1:\n        colorHex = hsv2hex({\n          h: colorValues[0],\n          s: colorValues[1],\n          v: colorValues[2]\n        });\n        break;\n\n      case color.indexOf('#') > -1:\n        colorHex = color;\n        break;\n    }\n\n    return convertFromHex(colorHex, type || s.format);\n  }\n\n  function convertFromHex(color, type) {\n    switch (type) {\n      case 'rgb':\n        return hex2rgb(color);\n\n      case 'hsl':\n        return hex2hsl(color);\n\n      case 'hsv':\n        return hex2hsv(color);\n\n      default:\n        return color;\n    }\n  }\n\n  function getFirstEmptyPreviewIndex() {\n    var i;\n\n    for (i = 0; i < s.select; ++i) {\n      if (tempPreviewValues[i].colorIndex === undefined) {\n        return i;\n      }\n    }\n  }\n\n  function highlightActiveColor($color, ctx) {\n    $$1('.mbsc-color-active', ctx).removeClass('mbsc-color-active');\n\n    if (refineMode) {\n      $color.parent().addClass('mbsc-color-active');\n\n      if (hasPreview && $color) {\n        if (colorPreviewInd !== undefined) {\n          $colorPreviewItems.eq(colorPreviewInd).parent().addClass('mbsc-color-active');\n        }\n      }\n    }\n  }\n\n  function refreshSelectedValues(newtempColors, updateInput) {\n    var i,\n        temp,\n        indexes = [],\n        prevInd = 0,\n        colorValues = $$1.map(tempColors, function (v) {\n      return v.changedColor || v.color;\n    }); // check the indexes in the tempColors\n\n    if (singleSelect) {\n      newtempColors = $$1.isArray(newtempColors) ? newtempColors[0] : newtempColors;\n      temp = colorValues.indexOf(newtempColors);\n\n      if (temp > -1) {\n        indexes.push(temp);\n      }\n\n      if (newtempColors && !indexes.length && refineMode) {\n        var inputIndex = +$$1('.mbsc-color-input-item', $input).attr('data-color');\n\n        if (isNaN(inputIndex)) {\n          inputIndex = undefined;\n        } else {\n          indexes.push(inputIndex);\n        }\n\n        colorIndex = inputIndex;\n      }\n    } else if (newtempColors) {\n      if (hasPreview && refineMode) {\n        for (var c in previewValues) {\n          if (previewValues[c].colorIndex !== undefined) {\n            indexes.push(+previewValues[c].colorIndex);\n          }\n        }\n      } else {\n        for (i = 0; i < newtempColors.length; ++i) {\n          temp = colorValues.indexOf(newtempColors[i]);\n\n          if (temp > -1) {\n            indexes.push(temp);\n            colorValues[temp] = 'temp' + i;\n          }\n        }\n      }\n    } // loop trough new color indexes and check the colors\n\n\n    for (i = 0; i < indexes.length; ++i) {\n      if (tempColors[indexes[i]]) {\n        toggleColor(true, indexes[i], prevInd++, tempColors[indexes[i]].changedColor || tempColors[indexes[i]].color, true);\n      }\n    } // loop trough other color indexes and uncheck the colors\n\n\n    for (i = 0; i < tempColors.length; ++i) {\n      if (indexes.indexOf(i) == -1) {\n        toggleColor(false, i, undefined, tempColors[i].changedColor || tempColors[i].color, false);\n      }\n    } // generate new preview object\n\n\n    if (hasPreview) {\n      for (i = prevInd; i < s.select; ++i) {\n        tempPreviewValues[i] = {};\n\n        if ($colorPreviewItems) {\n          $colorPreviewItems.eq(i).addClass('mbsc-color-preview-item-empty').css({\n            background: 'transparent'\n          });\n        }\n      }\n    }\n\n    previewValues = extend$1(true, {}, tempPreviewValues);\n\n    if (updateInput !== false) {\n      generateInputItems();\n    }\n  }\n\n  function toggleColor(add, colorIndex, colorPreviewInd, currValue, updatePreview, updateValue) {\n    if (hasPreview && updatePreview) {\n      tempPreviewValues[colorPreviewInd].colorIndex = add ? colorIndex : undefined;\n      tempPreviewValues[colorPreviewInd].color = add ? currValue : undefined;\n\n      if ($colorPreviewItems) {\n        var colorPrevItem = $colorPreviewItems.eq(colorPreviewInd);\n        colorPrevItem.removeClass('mbsc-color-preview-item-empty').css({\n          background: add ? currValue : 'transparent'\n        });\n\n        if (!add) {\n          colorPrevItem.addClass('mbsc-color-preview-item-empty').parent().removeClass('mbsc-color-active');\n        }\n      }\n    }\n\n    if (updateValue) {\n      if (add) {\n        that._tempValue.splice(colorPreviewInd, 0, currValue);\n      } else {\n        that._tempValue.splice(that._tempValue.indexOf(currValue), 1);\n      }\n    }\n\n    if ($colorItems) {\n      if (add) {\n        $colorItems.eq(colorIndex).addClass('mbsc-color-selected');\n      } else {\n        $colorItems.eq(colorIndex).removeClass('mbsc-color-selected').parent().removeClass('mbsc-color-active');\n      }\n    }\n\n    tempColors[colorIndex].previewInd = add ? colorPreviewInd : undefined;\n    tempColors[colorIndex].selected = add;\n  }\n\n  function setDefaultValues(colorInd, ctx) {\n    if (colorInd !== undefined && (singleSelect || tempColors[colorInd] && tempColors[colorInd].selected)) {\n      colorIndex = colorInd;\n\n      if (tempColors[colorInd]) {\n        currValue = tempColors[colorInd].changedColor || tempColors[colorInd].color;\n        $currItem = $colorItems.eq(colorInd); // refresh slider tempColors\n\n        if (refineMode) {\n          highlightActiveColor($colorItems.eq(colorInd), ctx || '');\n          currHslValue = convertToFormat(tempColors[colorInd].color, 'hsl');\n          currHslValue.l = convertToFormat(currValue, 'hsl').l;\n          changeSliderStepsColor(tempColors[colorInd].color);\n          slider.setVal(100 - currHslValue.l, false, false);\n        }\n      }\n    } else if (refineMode) {\n      changeSliderStepsColor();\n    }\n  }\n\n  function getColorObjects() {\n    var i,\n        arr = [];\n\n    for (i = 0; i < tempColors.length; ++i) {\n      if (tempColors[i].selected) {\n        arr.push(tempColors[i]);\n      }\n    }\n\n    return arr;\n  }\n\n  function colorPreviewTap(ev, $m) {\n    var index = $$1(ev.target).index();\n    colorIndex = tempPreviewValues[index].colorIndex;\n    $currItem = $colorItems.eq(colorIndex); // refresh values\n\n    colorPreviewInd = index;\n    setDefaultValues(colorIndex, $m);\n    scrollView.scroll($currItem, 250);\n    trigger('onPreviewItemTap', {\n      target: ev.target,\n      value: tempPreviewValues[index].color,\n      index: index\n    });\n  }\n\n  function colorTap(ev, $m) {\n    var hasSelect = false,\n        $selectedtempColors = $$1('.mbsc-color-selected', $m);\n    $currItem = $$1(ev.target);\n\n    if ($currItem.hasClass('mbsc-color-clear-item')) {\n      currValue = '';\n      that.clear();\n      return;\n    }\n\n    if (singleSelect || maxSelect > +$selectedtempColors.length || $currItem.hasClass('mbsc-color-selected'))\n      /* TRIALCOND */\n      {\n        colorIndex = $currItem.attr('data-index');\n\n        if (hasPreview) {\n          colorPreviewInd = tempColors[colorIndex].previewInd !== undefined ? tempColors[colorIndex].previewInd : getFirstEmptyPreviewIndex();\n          hasSelect = refineMode && $currItem.hasClass('mbsc-color-selected') && !$currItem.parent().hasClass('mbsc-color-active'); // scroll to the preview color\n\n          if ($colorPreviewItems.length > 6) {\n            previewScrollView.scroll($colorPreviewItems.eq(colorPreviewInd));\n          }\n        }\n\n        currValue = tempColors[colorIndex].changedColor || tempColors[colorIndex].color;\n\n        if (singleSelect) {\n          $selectedtempColors.removeClass('mbsc-color-selected');\n          that._tempValue = currValue;\n\n          if (currValue) {\n            $currItem.toggleClass('mbsc-color-selected');\n          }\n\n          highlightActiveColor($currItem, $m);\n        } else {\n          highlightActiveColor($currItem, $m);\n\n          if (!hasSelect) {\n            toggleColor(!tempColors[colorIndex].selected, colorIndex, colorPreviewInd, currValue, true, true);\n          }\n        }\n\n        setDefaultValues(colorIndex, $m);\n\n        if (that.live) {\n          that._fillValue();\n\n          trigger('onSet', {\n            value: that._value\n          });\n        }\n\n        trigger('onItemTap', {\n          target: ev.target,\n          value: currValue,\n          selected: tempColors[colorIndex].selected,\n          index: colorIndex\n        });\n\n        that._updateHeader();\n      }\n  } // Call the parent constructor\n\n\n  Frame.call(this, el, settings, true); // Public functions\n\n  /* TRIALFUNC */\n\n  /**\r\n   * Sets the value\r\n   */\n\n  that.setVal = that._setVal = function (val, fill, change, temp) {\n    that._hasValue = val !== null && val !== undefined;\n    that._tempValue = singleSelect ? $$1.isArray(val) ? val[0] : val : $$1.isArray(val) ? val : val ? [val] : [];\n    setValue(fill, change === undefined ? fill : change, temp);\n  };\n  /**\r\n   * Returns the selected value\r\n   */\n\n\n  that.getVal = that._getVal = function (temp) {\n    return that._hasValue || temp ? returnObj ? getColorObjects() : that[temp ? '_tempValue' : '_value'] : null;\n  };\n\n  that._readValue = function () {\n    var v = $elm.val() || '';\n    that._hasValue = false;\n\n    if (v.length !== 0 && v !== '') {\n      that._hasValue = true;\n    }\n\n    if (that._hasValue) {\n      that._tempValue = singleSelect ? v : s.format == 'hex' ? v.split(',') : v.match(/[a-z]{3}\\((\\d+\\.?\\d{0,}?),\\s*([\\d.]+)%{0,},\\s*([\\d.]+)%{0,}\\)/gmi);\n      setValue(true);\n    } else {\n      that._tempValue = [];\n    }\n\n    refreshSelectedValues(that._tempValue, that._hasValue);\n  };\n\n  that._fillValue = function () {\n    that._hasValue = true;\n    setValue(true, true);\n  };\n\n  that._generateContent = function () {\n    var i,\n        html,\n        currColor,\n        colorOffset = hasClear ? 1 : 0;\n    rowItems = isHorizontalScroll ? Math.ceil((tempColors.length + colorOffset) / s.rows) : s.rows; // generate color content\n\n    html = '<div class=\"mbsc-color-scroll-cont mbsc-w-p ' + (isHorizontalScroll ? '' : 'mbsc-color-vertical') + '\"><div class=\"mbsc-color-cont\">' + (isHorizontalScroll ? '<div class=\"mbsc-color-row\">' : '');\n\n    for (i = 0; i < tempColors.length; ++i) {\n      currColor = tempColors[i].changedColor || tempColors[i].color;\n\n      if (hasClear && i === 0) {\n        html += '<div class=\"mbsc-color-item-c\"><div tabindex=\"0\" class=\"mbsc-color-clear-item mbsc-btn-e mbsc-color-selected\"><div class=\"mbsc-color-clear-cross\"></div></div></div>';\n      }\n\n      if (i !== 0 && (i + colorOffset) % rowItems === 0) {\n        html += isHorizontalScroll ? '</div><div class=\"mbsc-color-row\">' : '';\n      }\n\n      html += '<div class=\"mbsc-color-item-c\"><div tabindex=\"0\" data-index=\"' + i + '\" class=\"mbsc-color-item mbsc-btn-e mbsc-ic mbsc-ic-material-check mbsc-color-btn-e ' + (tempColors[i].selected ? 'mbsc-color-selected' : '') + '\"  style=\"background:' + currColor + '\"></div>'\n      /* TRIAL */\n      + '</div>';\n    }\n\n    html += '</div></div>' + (isHorizontalScroll ? '</div>' : '');\n\n    if (refineMode) {\n      // add refine slider \n      html += '<div class=\"mbsc-color-slider-cont\"><input class=\"mbsc-color-slider\" type=\"range\" data-highlight=\"false\" value=\"50\" min=\"0\" max=\"100\"/></div>';\n    } // add preview container \n\n\n    if (hasPreview) {\n      html += '<div class=\"mbsc-color-preview-cont\"><div class=\"mbsc-color-refine-preview\">';\n\n      for (var c in previewValues) {\n        html += '<div class=\"mbsc-color-preview-item-c mbsc-btn-e mbsc-color-btn-e\" tabindex=\"0\"><div class=\"mbsc-color-preview-item ' + (previewValues[c].color ? '' : 'mbsc-color-preview-item-empty') + '\" style=\"background: ' + (previewValues[c].color || 'initial') + ';\"></div></div>';\n      }\n\n      html += '</div></div>';\n    }\n\n    return html;\n  };\n\n  that._position = function ($m) {\n    var colorCont, colorItemWidth;\n\n    if (!isHorizontalScroll) {\n      colorCont = $m.find('.mbsc-color-cont');\n      colorItemWidth = Math.ceil(colorCont.find('.mbsc-color-item-c')[0].offsetWidth);\n      colorCont.width(Math.min(Math.floor($m.find('.mbsc-fr-c').width() / colorItemWidth), Math.round(tempColors.length / s.rows)) * colorItemWidth + 1);\n    }\n\n    if (scrollView) {\n      scrollView.refresh();\n    }\n\n    if (previewScrollView) {\n      previewScrollView.refresh();\n    }\n  };\n\n  that._markupInserted = function ($markup) {\n    if (!isHorizontalScroll) {\n      $markup.find('.mbsc-color-scroll-cont').css('max-height', $markup.find('.mbsc-color-item-c')[0].offsetHeight * s.rows);\n    } // init color scrollView\n\n\n    scrollView = new ScrollViewBase($markup.find('.mbsc-color-scroll-cont')[0], {\n      axis: isHorizontalScroll ? 'X' : 'Y',\n      rtl: s.rtl,\n      elastic: 60,\n      stopProp: false,\n      mousewheel: s.mousewheel,\n      onBtnTap: function onBtnTap(ev) {\n        colorTap(ev, $markup);\n      }\n    });\n  };\n\n  that._attachEvents = function ($markup) {\n    var modifiedColor;\n    $colorItems = $$1('.mbsc-color-item', $markup); // handle color selection with space\n\n    $markup.on('keydown', '.mbsc-color-btn-e', function (ev) {\n      ev.stopPropagation();\n\n      if (ev.keyCode == 32) {\n        // Space \n        if (ev.target.classList.contains('mbsc-color-item')) {\n          colorTap(ev, $markup);\n        } else {\n          colorPreviewTap(ev, $markup);\n        }\n      }\n    });\n\n    if (hasPreview) {\n      $colorPreviewItems = $$1('.mbsc-color-preview-item', $markup);\n    } // refine mode \n\n\n    if (refineMode) {\n      $markup.addClass('mbsc-color-refine');\n      $sliderElm = $$1('.mbsc-color-slider', $markup);\n      slider = new Slider($sliderElm[0], {\n        theme: s.theme,\n        rtl: s.rtl\n      });\n      sliderTrack = $markup.find('.mbsc-progress-track'); // change slider track step color\n\n      if (colorIndex && that._value) {\n        setDefaultValues(colorIndex, $markup);\n      }\n\n      $sliderElm.on('change', function () {\n        if (colorIndex !== undefined && (singleSelect || tempColors[colorIndex] && tempColors[colorIndex].selected)) {\n          currHslValue.l = 100 - this.value;\n          modifiedColor = convertToFormat(currHslValue.toString()).toString();\n\n          if (singleSelect) {\n            that._tempValue = modifiedColor;\n          } else {\n            that._tempValue[colorPreviewInd !== undefined ? colorPreviewInd : that._tempValue.length] = modifiedColor;\n          }\n\n          tempColors[colorIndex].tempChangedColor = modifiedColor;\n          $colorItems.eq(colorIndex).css('background', modifiedColor);\n\n          if (hasPreview) {\n            tempPreviewValues[colorPreviewInd].color = modifiedColor;\n            $colorPreviewItems.eq(colorPreviewInd).removeClass('mbsc-color-preview-item-empty').css({\n              'background': modifiedColor\n            });\n          }\n\n          if (that.live) {\n            throttle(that._fillValue());\n          }\n        }\n      });\n    }\n\n    if (hasPreview) {\n      // init colorprevirew scrollview\n      previewScrollView = new ScrollViewBase($markup.find('.mbsc-color-preview-cont')[0], {\n        axis: 'X',\n        rtl: s.rtl,\n        stopProp: false,\n        mousewheel: s.mousewheel,\n        onBtnTap: function onBtnTap(ev) {\n          colorPreviewTap(ev, $markup);\n        }\n      });\n    }\n\n    that._updateHeader();\n  };\n\n  that._markupRemove = function () {\n    if (scrollView) {\n      scrollView.destroy();\n    }\n\n    if (slider) {\n      slider.destroy();\n    }\n\n    if (previewScrollView) {\n      previewScrollView.destroy();\n    }\n  };\n\n  that.__processSettings = function () {\n    var i, data;\n    s = that.settings;\n    trigger = that.trigger;\n    isHorizontalScroll = s.navigation == 'horizontal';\n    that._value = [];\n    that._tempValue = [];\n    singleSelect = s.select == 'single';\n    hasClear = s.clear !== undefined ? s.clear : singleSelect;\n    data = s.data || [];\n\n    if (!data.length) {\n      switch (s.format) {\n        case 'rgb':\n          data = [\"rgb(255,235,60)\", \"rgb(255,153,0)\", \"rgb(244,68,55)\", \"rgb(234,30,99)\", \"rgb(156,38,176)\", \"rgb(104,58,183)\", \"rgb(63,81,181)\", \"rgb(33,150,243)\", \"rgb(0,151,136)\", \"rgb(75,175,79)\", \"rgb(126,93,78)\", \"rgb(158,158,158)\"];\n\n          if (hasClear) {\n            data.splice(10, 0, 'rgb(83, 71, 65)');\n          }\n\n          break;\n\n        case 'hsl':\n          data = [\"hsl(54,100%,62%)\", \"hsl(36,100%,50%)\", \"hsl(4,90%,59%)\", \"hsl(340,83%,52%)\", \"hsl(291,64%,42%)\", \"hsl(262,52%,47%)\", \"hsl(231,48%,48%)\", \"hsl(207,90%,54%)\", \"hsl(174,100%,30%)\", \"hsl(122,40%,49%)\", \"hsl(19,24%,40%)\", \"hsl(0,0%,62%)\"];\n\n          if (hasClear) {\n            data.splice(10, 0, 'hsl(20, 12%, 29%)');\n          }\n\n          break;\n\n        default:\n          data = ['#ffeb3c', '#ff9900', '#f44437', '#ea1e63', '#9c26b0', '#683ab7', '#3f51b5', '#2196f3', '#009788', '#4baf4f', '#7e5d4e', '#9e9e9e'];\n\n          if (hasClear) {\n            data.splice(10, 0, '#534741');\n          }\n\n      }\n    }\n\n    refineMode = s.mode == 'refine';\n    hasPreview = !isNaN(s.select);\n    maxSelect = isNaN(s.select) ? singleSelect ? 2 : data.length : s.select;\n    returnObj = $$1.isPlainObject(data[0]); // generate preview object\n\n    if (hasPreview && !Object.keys(previewValues).length) {\n      for (i = 0; i < s.select; ++i) {\n        previewValues[i] = {};\n        tempPreviewValues[i] = {};\n      }\n    }\n\n    tempColors = data.slice(0); // convert tempColors into objects\n\n    for (i = 0; i < tempColors.length; ++i) {\n      if (!$$1.isPlainObject(data[i])) {\n        data[i] = data[i].toLowerCase();\n        tempColors[i] = {\n          key: i,\n          name: data[i],\n          color: data[i]\n        };\n      } else {\n        tempColors[i].color = data[i].color;\n      }\n    }\n\n    def = s.defaultValue || tempColors[0].color;\n    currValue = def;\n    currHslValue = convertToFormat(currValue, 'hsl');\n    enhanceInput = s.enhance && $elm.is('input'); // Create dummy input\n\n    if (enhanceInput) {\n      if ($elm.hasClass('mbsc-color-input-hdn')) {\n        $input = $elm.prev();\n      } else {\n        $input = $$1('<div ' + (el.placeholder ? 'data-placeholder=\"' + el.placeholder + '\"' : '') + ' class=\"mbsc-control mbsc-color-input ' + (s.inputClass || '') + '\" readonly ></div>');\n        $input.insertBefore($elm);\n        $elm.addClass('mbsc-color-input-hdn').attr('tabindex', -1);\n      }\n\n      s.anchor = $input;\n      that.attachShow($input);\n    }\n  };\n\n  that.__destroy = function () {\n    if (enhanceInput) {\n      $elm.removeClass('mbsc-color-input-hdn');\n      $input.remove();\n    }\n  };\n\n  that._checkSize = true; // Constructor\n\n  if (!inherit) {\n    that.init();\n  }\n}; // Extend defaults\n\n\nColor.prototype = {\n  _hasDef: true,\n  _hasTheme: true,\n  _hasLang: true,\n  _class: 'color',\n  _defaults: extend$1({}, Frame.prototype._defaults, {\n    headerText: false,\n    validate: noop,\n    parseValue: noop,\n    enhance: true,\n    rows: 2,\n    select: 'single',\n    format: 'hex',\n    navigation: 'horizontal',\n    compClass: 'mbsc-color'\n  })\n};\nclasses.Color = Color;\nmobiscroll.themes.color = mobiscroll.themes.frame; // Expose utility functions\n\nutil.color = {\n  hsv2hex: hsv2hex,\n  hsv2rgb: hsv2rgb,\n  rgb2hsv: rgb2hsv,\n  rgb2hex: rgb2hex,\n  rgb2hsl: rgb2hsl,\n  hex2rgb: hex2rgb,\n  hex2hsv: hex2hsv,\n  hex2hsl: hex2hsl\n};\n\nvar MbscColor = function (_super) {\n  __extends(MbscColor, _super);\n\n  function MbscColor(initialElem, zone, control, inputService, optionService, view) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, view) || this;\n\n    _this.optionService = optionService;\n    _this.enhance = false;\n    _this.onSet = new EventEmitter();\n    _this.onClear = new EventEmitter();\n    _this.onItemTap = new EventEmitter();\n    _this.onPreviewItemTap = new EventEmitter();\n    _this.options = {};\n    _this.onChangeEmitter = new EventEmitter();\n    return _this;\n  }\n\n  Object.defineProperty(MbscColor.prototype, \"value\", {\n    set: function (v) {\n      this.setNewValueProxy(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscColor.prototype.refreshData = function (newData) {\n    this.instance.option('data', newData);\n  };\n\n  MbscColor.prototype.initControl = function () {\n    var options = extend$1({}, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);\n    this.instance = new Color(this.element, options);\n\n    if (this.initialValue !== undefined) {\n      this.instance.setVal(this.initialValue, true, false);\n    }\n  };\n\n  MbscColor.prototype.setNewValue = function (v) {\n    if (this.instance) {\n      var changed = void 0;\n\n      if (this.isMulti) {\n        changed = !deepEqualsArray(v, this.instance.getVal());\n      } else {\n        var innerValue = this.instance.getVal();\n        changed = innerValue !== v;\n      }\n\n      if (changed) {\n        this.instance.setVal(v, true, false);\n\n        if (this._inputService && this._inputService.input) {\n          this._inputService.input.innerValue = this.instance._value;\n        }\n      }\n    }\n  };\n\n  MbscColor.prototype.ngOnInit = function () {\n    this.isMulti = this.options && this.options.select && this.options.select !== 'single';\n    this.cloneDictionary.data = [];\n\n    _super.prototype.ngOnInit.call(this);\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscColor.prototype, \"clear\", void 0);\n\n  __decorate([Input$1('mbsc-data'), __metadata(\"design:type\", Array)], MbscColor.prototype, \"data\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscColor.prototype, \"defaultValue\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscColor.prototype, \"enhance\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscColor.prototype, \"format\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscColor.prototype, \"inputClass\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscColor.prototype, \"mode\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscColor.prototype, \"navigation\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscColor.prototype, \"preview\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscColor.prototype, \"previewText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscColor.prototype, \"rows\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscColor.prototype, \"valueText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscColor.prototype, \"select\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscColor.prototype, \"onSet\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscColor.prototype, \"onClear\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscColor.prototype, \"onItemTap\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscColor.prototype, \"onPreviewItemTap\", void 0);\n\n  __decorate([Input$1('mbsc-options'), __metadata(\"design:type\", Object)], MbscColor.prototype, \"options\", void 0);\n\n  __decorate([Input$1('mbsc-color'), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], MbscColor.prototype, \"value\", null);\n\n  __decorate([Output('mbsc-colorChange'), __metadata(\"design:type\", EventEmitter)], MbscColor.prototype, \"onChangeEmitter\", void 0);\n\n  MbscColor = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscColor);\n\n  MbscColor.ɵfac = function MbscColor_Factory(t) {\n    return new (t || MbscColor)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscColor.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscColor,\n    selectors: [[\"\", \"mbsc-color\", \"\"]],\n    inputs: {\n      value: [\"mbsc-color\", \"value\"],\n      clear: \"clear\",\n      data: [\"mbsc-data\", \"data\"],\n      defaultValue: \"defaultValue\",\n      enhance: \"enhance\",\n      format: \"format\",\n      inputClass: \"inputClass\",\n      mode: \"mode\",\n      navigation: \"navigation\",\n      preview: \"preview\",\n      previewText: \"previewText\",\n      rows: \"rows\",\n      valueText: \"valueText\",\n      select: \"select\",\n      options: [\"mbsc-options\", \"options\"]\n    },\n    outputs: {\n      onSet: \"onSet\",\n      onClear: \"onClear\",\n      onItemTap: \"onItemTap\",\n      onPreviewItemTap: \"onPreviewItemTap\",\n      onChangeEmitter: \"mbsc-colorChange\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscColor;\n}(MbscFrameBase);\n\nvar MbscColorComponent = function (_super) {\n  __extends(MbscColorComponent, _super);\n\n  function MbscColorComponent(initialElem, zone, control, inputService, optionService) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;\n\n    _this.errorMessage = '';\n    _this.placeholder = '';\n    _this.enhance = true;\n    return _this;\n  }\n\n  MbscColorComponent.prototype.ngAfterViewInit = function () {\n    _super.prototype.ngAfterViewInit.call(this);\n\n    this.setThemeClasses();\n  };\n\n  __decorate([Input$1('icon'), __metadata(\"design:type\", String)], MbscColorComponent.prototype, \"inputIcon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscColorComponent.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscColorComponent.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscColorComponent.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscColorComponent.prototype, \"errorMessage\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscColorComponent.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscColorComponent.prototype, \"placeholder\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscColorComponent.prototype, \"data\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscColorComponent.prototype, \"enhance\", void 0);\n\n  MbscColorComponent = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])], MbscColorComponent);\n\n  MbscColorComponent.ɵfac = function MbscColorComponent_Factory(t) {\n    return new (t || MbscColorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscColorComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscColorComponent,\n    selectors: [[\"mbsc-color\"]],\n    inputs: {\n      inputIcon: [\"icon\", \"inputIcon\"],\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      name: \"name\",\n      error: \"error\",\n      errorMessage: \"errorMessage\",\n      options: \"options\",\n      placeholder: \"placeholder\",\n      data: \"data\",\n      enhance: \"enhance\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\", 4, \"ngIf\"], [3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\"]],\n    template: function MbscColorComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MbscColorComponent_mbsc_input_0_Template, 2, 13, \"mbsc-input\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.inline || ctx.showInput);\n      }\n    },\n    directives: [ɵngcc2.NgIf, MbscInput],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscColorComponent;\n}(MbscColor);\n\nvar MbscColorModule = function () {\n  function MbscColorModule() {}\n\n  MbscColorModule.ɵfac = function MbscColorModule_Factory(t) {\n    return new (t || MbscColorModule)();\n  };\n\n  MbscColorModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscColorModule\n  });\n  MbscColorModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, MbscFrameBaseModule, MbscInputModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscColorModule, {\n      declarations: function () {\n        return [MbscColor, MbscColorComponent];\n      },\n      imports: function () {\n        return [CommonModule, MbscFrameBaseModule, MbscInputModule];\n      },\n      exports: function () {\n        return [MbscColor, MbscColorComponent];\n      }\n    });\n  })();\n\n  return MbscColorModule;\n}();\n\nvar DateTime$1 = Scroller;\npresets.date = DateTime;\npresets.time = DateTime;\npresets.datetime = DateTime;\n\nvar MbscDateBase = function (_super) {\n  __extends(MbscDateBase, _super);\n\n  function MbscDateBase(initialElem, zone, control, inputService, optionService, view) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, view) || this;\n\n    _this.optionService = optionService;\n    _this.options = {};\n    _this.preset = 'date';\n    _this.onChangeEmitter = new EventEmitter();\n    return _this;\n  }\n\n  Object.defineProperty(MbscDateBase.prototype, \"value\", {\n    set: function (v) {\n      this.setNewValueProxy(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscDateBase.prototype.setNewValue = function (v) {\n    if (this.instance) {\n      var innerValue = this.instance.getVal();\n\n      if (!innerValue && v || innerValue && !v || innerValue && v && innerValue.toString() !== v.toString()) {\n        this.instance.setVal(v, true, false);\n\n        if (this._inputService && this._inputService.input) {\n          this._inputService.input.innerValue = this.instance._value;\n        }\n      }\n    }\n  };\n\n  MbscDateBase.prototype.initControl = function () {\n    var options = extend$1({\n      preset: this.preset\n    }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);\n    this.instance = new DateTime$1(this.element, options);\n\n    if (this.initialValue !== undefined && this.initialValue !== \"\") {\n      this.instance.setVal(this.initialValue, true, false);\n    }\n  };\n\n  __decorate([Input$1('mbsc-options'), __metadata(\"design:type\", Object)], MbscDateBase.prototype, \"options\", void 0);\n\n  __decorate([Input$1('mbsc-date'), __metadata(\"design:type\", Date), __metadata(\"design:paramtypes\", [Date])], MbscDateBase.prototype, \"value\", null);\n\n  __decorate([Output('mbsc-dateChange'), __metadata(\"design:type\", EventEmitter)], MbscDateBase.prototype, \"onChangeEmitter\", void 0);\n\n  MbscDateBase = __decorate([__metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscDateBase);\n\n  MbscDateBase.ɵfac = function MbscDateBase_Factory(t) {\n    return new (t || MbscDateBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl), ɵngcc0.ɵɵdirectiveInject(MbscInputService), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscDateBase.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscDateBase,\n    selectors: [[\"\", \"mbsc-dt-b\", \"\"]],\n    inputs: {\n      value: [\"mbsc-date\", \"value\"],\n      options: [\"mbsc-options\", \"options\"]\n    },\n    outputs: {\n      onChangeEmitter: \"mbsc-dateChange\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscDateBase;\n}(MbscDatetimeBase);\n\nvar MbscDate = function (_super) {\n  __extends(MbscDate, _super);\n\n  function MbscDate(initialElem, zone, control, inputService, optionService, view) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;\n\n    _this.preset = 'date';\n    return _this;\n  }\n\n  MbscDate = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscDate);\n\n  MbscDate.ɵfac = function MbscDate_Factory(t) {\n    return new (t || MbscDate)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscDate.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscDate,\n    selectors: [[\"\", \"mbsc-date\", \"\"]],\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscDate;\n}(MbscDateBase);\n\nvar MbscDateComponent = function (_super) {\n  __extends(MbscDateComponent, _super);\n\n  function MbscDateComponent(initialElem, zone, control, inputService, optionService) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;\n\n    _this.errorMessage = '';\n    _this.placeholder = '';\n    return _this;\n  }\n\n  MbscDateComponent.prototype.ngAfterViewInit = function () {\n    _super.prototype.ngAfterViewInit.call(this);\n\n    this.setThemeClasses();\n  };\n\n  __decorate([Input$1('icon'), __metadata(\"design:type\", String)], MbscDateComponent.prototype, \"inputIcon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscDateComponent.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDateComponent.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscDateComponent.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDateComponent.prototype, \"errorMessage\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscDateComponent.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDateComponent.prototype, \"placeholder\", void 0);\n\n  MbscDateComponent = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])], MbscDateComponent);\n\n  MbscDateComponent.ɵfac = function MbscDateComponent_Factory(t) {\n    return new (t || MbscDateComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscDateComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscDateComponent,\n    selectors: [[\"mbsc-date\"]],\n    inputs: {\n      inputIcon: [\"icon\", \"inputIcon\"],\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      name: \"name\",\n      error: \"error\",\n      errorMessage: \"errorMessage\",\n      options: \"options\",\n      placeholder: \"placeholder\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\", 4, \"ngIf\"], [3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\"]],\n    template: function MbscDateComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MbscDateComponent_mbsc_input_0_Template, 2, 13, \"mbsc-input\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.inline || ctx.showInput);\n      }\n    },\n    directives: [ɵngcc2.NgIf, MbscInput],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscDateComponent;\n}(MbscDate);\n\nvar MbscTime = function (_super) {\n  __extends(MbscTime, _super);\n\n  function MbscTime(initialElem, zone, control, inputService, optionService, view) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;\n\n    _this.onChangeEmitter = new EventEmitter();\n    _this.preset = 'time';\n    return _this;\n  }\n\n  Object.defineProperty(MbscTime.prototype, \"value\", {\n    set: function (v) {\n      this.setNewValueProxy(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  __decorate([Input$1('mbsc-time'), __metadata(\"design:type\", Date), __metadata(\"design:paramtypes\", [Date])], MbscTime.prototype, \"value\", null);\n\n  __decorate([Output('mbsc-timeChange'), __metadata(\"design:type\", EventEmitter)], MbscTime.prototype, \"onChangeEmitter\", void 0);\n\n  MbscTime = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscTime);\n\n  MbscTime.ɵfac = function MbscTime_Factory(t) {\n    return new (t || MbscTime)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscTime.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscTime,\n    selectors: [[\"\", \"mbsc-time\", \"\"]],\n    inputs: {\n      value: [\"mbsc-time\", \"value\"]\n    },\n    outputs: {\n      onChangeEmitter: \"mbsc-timeChange\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscTime;\n}(MbscDateBase);\n\nvar MbscTimeComponent = function (_super) {\n  __extends(MbscTimeComponent, _super);\n\n  function MbscTimeComponent(initialElem, zone, control, inputService, optionService) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;\n\n    _this.errorMessage = '';\n    _this.placeholder = '';\n    return _this;\n  }\n\n  MbscTimeComponent.prototype.ngAfterViewInit = function () {\n    _super.prototype.ngAfterViewInit.call(this);\n\n    this.setThemeClasses();\n  };\n\n  __decorate([Input$1('icon'), __metadata(\"design:type\", String)], MbscTimeComponent.prototype, \"inputIcon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscTimeComponent.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscTimeComponent.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscTimeComponent.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscTimeComponent.prototype, \"errorMessage\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscTimeComponent.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscTimeComponent.prototype, \"placeholder\", void 0);\n\n  MbscTimeComponent = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])], MbscTimeComponent);\n\n  MbscTimeComponent.ɵfac = function MbscTimeComponent_Factory(t) {\n    return new (t || MbscTimeComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscTimeComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscTimeComponent,\n    selectors: [[\"mbsc-time\"]],\n    inputs: {\n      inputIcon: [\"icon\", \"inputIcon\"],\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      name: \"name\",\n      error: \"error\",\n      errorMessage: \"errorMessage\",\n      options: \"options\",\n      placeholder: \"placeholder\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\", 4, \"ngIf\"], [3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\"]],\n    template: function MbscTimeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MbscTimeComponent_mbsc_input_0_Template, 2, 13, \"mbsc-input\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.inline || ctx.showInput);\n      }\n    },\n    directives: [ɵngcc2.NgIf, MbscInput],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscTimeComponent;\n}(MbscTime);\n\nvar MbscDatetime = function (_super) {\n  __extends(MbscDatetime, _super);\n\n  function MbscDatetime(initialElem, zone, control, inputService, optionService, view) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;\n\n    _this.onChangeEmitter = new EventEmitter();\n    _this.preset = 'datetime';\n    return _this;\n  }\n\n  Object.defineProperty(MbscDatetime.prototype, \"value\", {\n    set: function (v) {\n      this.setNewValueProxy(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  __decorate([Input$1('mbsc-datetime'), __metadata(\"design:type\", Date), __metadata(\"design:paramtypes\", [Date])], MbscDatetime.prototype, \"value\", null);\n\n  __decorate([Output('mbsc-datetimeChange'), __metadata(\"design:type\", EventEmitter)], MbscDatetime.prototype, \"onChangeEmitter\", void 0);\n\n  MbscDatetime = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscDatetime);\n\n  MbscDatetime.ɵfac = function MbscDatetime_Factory(t) {\n    return new (t || MbscDatetime)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscDatetime.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscDatetime,\n    selectors: [[\"\", \"mbsc-datetime\", \"\"]],\n    inputs: {\n      value: [\"mbsc-datetime\", \"value\"]\n    },\n    outputs: {\n      onChangeEmitter: \"mbsc-datetimeChange\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscDatetime;\n}(MbscDateBase);\n\nvar MbscDatetimeComponent = function (_super) {\n  __extends(MbscDatetimeComponent, _super);\n\n  function MbscDatetimeComponent(initialElem, zone, control, inputService, optionService) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;\n\n    _this.errorMessage = '';\n    _this.placeholder = '';\n    return _this;\n  }\n\n  MbscDatetimeComponent.prototype.ngAfterViewInit = function () {\n    _super.prototype.ngAfterViewInit.call(this);\n\n    this.setThemeClasses();\n  };\n\n  __decorate([Input$1('icon'), __metadata(\"design:type\", String)], MbscDatetimeComponent.prototype, \"inputIcon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscDatetimeComponent.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDatetimeComponent.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscDatetimeComponent.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDatetimeComponent.prototype, \"errorMessage\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscDatetimeComponent.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDatetimeComponent.prototype, \"placeholder\", void 0);\n\n  MbscDatetimeComponent = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])], MbscDatetimeComponent);\n\n  MbscDatetimeComponent.ɵfac = function MbscDatetimeComponent_Factory(t) {\n    return new (t || MbscDatetimeComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscDatetimeComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscDatetimeComponent,\n    selectors: [[\"mbsc-datetime\"]],\n    inputs: {\n      inputIcon: [\"icon\", \"inputIcon\"],\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      name: \"name\",\n      error: \"error\",\n      errorMessage: \"errorMessage\",\n      options: \"options\",\n      placeholder: \"placeholder\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\", 4, \"ngIf\"], [3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\"]],\n    template: function MbscDatetimeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MbscDatetimeComponent_mbsc_input_0_Template, 2, 13, \"mbsc-input\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.inline || ctx.showInput);\n      }\n    },\n    directives: [ɵngcc2.NgIf, MbscInput],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscDatetimeComponent;\n}(MbscDatetime);\n\nvar comp$2 = [MbscDateBase, MbscDate, MbscDateComponent, MbscTime, MbscTimeComponent, MbscDatetime, MbscDatetimeComponent];\n\nvar MbscDatetimeModule = function () {\n  function MbscDatetimeModule() {}\n\n  MbscDatetimeModule.ɵfac = function MbscDatetimeModule_Factory(t) {\n    return new (t || MbscDatetimeModule)();\n  };\n\n  MbscDatetimeModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscDatetimeModule\n  });\n  MbscDatetimeModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, MbscDatetimeBaseModule, MbscInputModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscDatetimeModule, {\n      declarations: function () {\n        return [MbscDateBase, MbscDate, MbscDateComponent, MbscTime, MbscTimeComponent, MbscDatetime, MbscDatetimeComponent];\n      },\n      imports: function () {\n        return [CommonModule, MbscDatetimeBaseModule, MbscInputModule];\n      },\n      exports: function () {\n        return [MbscDateBase, MbscDate, MbscDateComponent, MbscTime, MbscTimeComponent, MbscDatetime, MbscDatetimeComponent];\n      }\n    });\n  })();\n\n  return MbscDatetimeModule;\n}();\n\nvar Popup = function Popup(el, settings, inherit) {\n  function addContent($m) {\n    /* TRIAL */\n    if (!$$1('.mbsc-fr-c', $m).hasClass('mbsc-wdg-c')\n    /* TRIALCOND */\n    ) {\n      $$1('.mbsc-fr-c', $m).addClass('mbsc-wdg-c').append($elm.show());\n\n      if (!$$1('.mbsc-w-p', $m).length) {\n        $$1('.mbsc-fr-c', $m).addClass('mbsc-w-p');\n      }\n    }\n  }\n\n  var s,\n      $prev,\n      $elm = $$1(el),\n      that = this; // Call the parent constructor\n\n  Frame.call(this, el, settings, true);\n  /* TRIALFUNC */\n\n  that._generateContent = function () {\n    return '';\n  };\n\n  that._markupReady = function ($m) {\n    if (s.display != 'inline') {\n      addContent($m);\n    }\n  };\n\n  that._markupInserted = function ($m) {\n    if (s.display == 'inline') {\n      addContent($m);\n    }\n\n    $m.trigger('mbsc-enhance', [{\n      theme: s.theme,\n      lang: s.lang\n    }]);\n  };\n\n  that._markupRemove = function () {\n    $elm.hide();\n\n    if ($prev && $prev.parent().length) {\n      $prev.after($elm);\n    }\n  };\n\n  that.__processSettings = function () {\n    s = that.settings;\n    that.buttons.ok = {\n      text: s.okText,\n      icon: s.okIcon,\n      handler: 'set'\n    };\n    s.buttons = s.buttons || (s.display == 'inline' ? [] : ['ok']);\n\n    if (!$prev && $elm.parent().length) {\n      $prev = $$1(document.createComment('popup'));\n      $elm.before($prev);\n    }\n\n    $elm.hide();\n  }; // Constructor\n\n\n  if (!inherit) {\n    that.init();\n  }\n};\n\nPopup.prototype = {\n  _hasDef: true,\n  _hasTheme: true,\n  _hasContent: true,\n  _hasLang: true,\n  _responsive: true,\n  _class: 'popup',\n  _defaults: extend$1({}, Frame.prototype._defaults, {\n    compClass: 'mbsc-wdg',\n    okText: 'OK',\n    headerText: false\n  })\n};\nclasses.Popup = Popup;\nclasses.Widget = Popup;\nmobiscroll.themes.popup = mobiscroll.themes.frame; // eslint-disable-next-line no-unused-vars\n\nvar Eventcalendar = Scroller;\n\nfunction getHeight(el) {\n  var style = getComputedStyle(el);\n  return el.innerHeight || el.clientHeight - parseFloat(style.paddingTop) - parseFloat(style.paddingBottom);\n}\n\nvar defaults$4 = {\n  view: {\n    calendar: {\n      type: 'month',\n      popover: true\n    }\n  },\n  // Localization\n  allDayText: 'All-day',\n  labelsShort: ['Yrs', 'Mths', 'Days', 'Hrs', 'Mins', 'Secs'],\n  eventText: 'event',\n  eventsText: 'events',\n  noEventsText: 'No events'\n},\n    overrides = {\n  yearChange: false,\n  weekDays: 'short'\n};\n\npresets.eventcalendar = function (inst, settings) {\n  // Private functions\n  // ---\n  function processSettings() {\n    var view = s.view,\n        calendar = view.calendar,\n        list = view.eventList,\n        months = s.months,\n        weeks = s.weeks;\n\n    if (calendar) {\n      if (calendar.type == 'week') {\n        weeks = calendar.size || 1;\n      } else if (calendar.size) {\n        months = calendar.size;\n      }\n\n      isListOnly = false;\n    } else {\n      weeks = 0;\n      isListOnly = true;\n    }\n\n    if (list) {\n      listType = list.type;\n      listSize = list.size || 1;\n    }\n\n    multiLabel = calendar && calendar.labels;\n    scrollEventList = list && list.scrollable;\n    showEventList = view.eventList;\n    showEventBubble = s.eventBubble === undefined ? calendar && calendar.popover : s.eventBubble;\n    s.weeks = weeks;\n    s.months = months;\n  }\n\n  function updateTitle(firstDay, lastDay) {\n    var title,\n        monthIndex = (s.dateWheels || s.dateFormat).search(/m/i),\n        yearIndex = (s.dateWheels || s.dateFormat).search(/y/i),\n        firstYear = s.getYear(firstDay),\n        firstMonth = s.getMonth(firstDay),\n        lastYear = s.getYear(lastDay),\n        lastMonth = s.getMonth(lastDay);\n\n    inst._checkBtn($$1('.mbsc-cal-prev-m', $ctx), getDateOnly(firstDay) <= inst._minDate);\n\n    inst._checkBtn($$1('.mbsc-cal-next-m', $ctx), getDateOnly(lastDay) >= inst._maxDate);\n\n    if (listType == 'day') {\n      title = formatDate(s.dateFormat, firstDay, s) + (listSize > 1 ? ' - ' + formatDate(s.dateFormat, lastDay, s) : '');\n    } else if (listType == 'week') {\n      title = formatDate(s.dateFormat, firstDay, s) + ' - ' + formatDate(s.dateFormat, lastDay, s);\n    } else if (listType == 'month') {\n      if (listSize == 1) {\n        title = yearIndex < monthIndex ? firstYear + ' ' + s.monthNames[firstMonth] : s.monthNames[firstMonth] + ' ' + firstYear;\n      } else {\n        title = yearIndex < monthIndex ? firstYear + ' ' + s.monthNamesShort[firstMonth] + ' - ' + lastYear + ' ' + s.monthNamesShort[lastMonth] : s.monthNamesShort[firstMonth] + ' ' + firstYear + ' - ' + s.monthNamesShort[lastMonth] + ' ' + lastYear;\n      }\n    } else if (listType == 'year') {\n      title = firstYear + (listSize > 1 ? \" - \" + lastYear : '');\n    }\n\n    $viewTitle.html(title);\n  }\n\n  function createEventList(firstDay, lastDay, eventObj) {\n    var d,\n        i,\n        j,\n        ev,\n        $items,\n        count = 0,\n        allEvents = [],\n        eventHtml = '',\n        events = [];\n\n    if (!eventObj) {\n      eventObj = inst._prepareObj(eventList, firstDay, lastDay);\n    }\n\n    for (d = getDateOnly(firstDay); d <= lastDay; d.setDate(d.getDate() + 1)) {\n      ev = eventObj[getDateOnly(d)];\n\n      if (ev && ev.length) {\n        events.push({\n          d: new Date(d),\n          list: sortEvents(ev)\n        });\n      }\n    }\n\n    if (events.length > 0) {\n      for (i = 0; i < events.length; i++) {\n        ev = events[i];\n        eventHtml += '<div><div class=\"mbsc-lv-gr-title mbsc-event-day\" data-full=\"' + getDateStr(ev.d) + '\">' + formatDate(s.dateFormat, ev.d, s) + '</div>';\n\n        for (j = 0; j < ev.list.length; j++) {\n          var event = ev.list[j],\n              start = event.start ? makeDate(event.start) : null,\n              end = event.end ? makeDate(event.end) : null,\n              color = event.color,\n              isRepeating = DAY_OF_WEEK.test(event.d) || DAY_OF_MONTH.test(event.d),\n              isMultiDay = start && end && !isSameDay(start, end),\n              isFirstDay = isMultiDay ? isSameDay(start, ev.d) : true,\n              isLastDay = isMultiDay ? isSameDay(end, ev.d) : true,\n              dt = event.d ? isRepeating ? event.d : makeDate(event.d) : start,\n              allDay = event.allDay || isRepeating || isMultiDay && !isFirstDay && !isLastDay;\n          allEvents.push({\n            d: ev.d,\n            e: event\n          });\n          eventHtml += '<div tabindex=\"0\" role=\"button\" class=\"mbsc-lv-item mbsc-lv-item-actionable\" data-index=\"' + count + '\"><div class=\"mbsc-event-time\">' + (allDay ? s.allDayText : isFirstDay && dt && dt.getTime ? formatDate(s.timeFormat, dt) : isMultiDay && isLastDay ? s.toText : '') + (!allDay && isLastDay && end && end.getTime ? '<br/>' + formatDate(s.timeFormat, end) : '') + '</div>' + '<div class=\"mbsc-event-color\"' + (color ? ' style=\"background:' + color + ';\"' : '') + '></div>' + '<div class=\"mbsc-event-txt\">' + event.text + '</div>'\n          /* TRIAL */\n          + '</div>';\n          count++;\n        }\n\n        eventHtml += '</div>';\n      }\n    } else {\n      eventHtml += '<div class=\"mbsc-lv-gr-title mbsc-event-empty\"><div class=\"mbsc-empty\"><h3>' + s.noEventsText + '</h3></div></div>';\n    }\n\n    preventScrollWatch++;\n    $eventListCont.html('<div class=\"mbsc-lv mbsc-lv-v\">' + eventHtml + '</div>').scrollTop(0);\n    setTimeout(function () {\n      // Need setTimeout since scroll listener is throtteled\n      preventScrollWatch--;\n    }, 150);\n    $items = $$1('.mbsc-lv-item', $eventListCont); // Assign event click\n\n    inst.tap($items, function (e) {\n      var data = allEvents[$$1(this).attr('data-index')];\n      trigger('onEventSelect', {\n        domEvent: e,\n        event: data.e,\n        date: data.d\n      });\n    });\n    handleFocus($items);\n  }\n\n  function handleFocus($items) {\n    $items.on('keydown', function (ev) {\n      if (ev.keyCode === 13 || ev.keyCode === 32) {\n        this.click();\n      }\n    }).on('focus', function () {\n      if (window.__mbscFocusVisible) {\n        $$1(this).addClass('mbsc-focus');\n      }\n    }).on('blur', function () {\n      $$1(this).removeClass('mbsc-focus');\n    });\n  }\n\n  function createEventPopover() {\n    if (popoverData) {\n      var d = getDateOnly(popoverData.d),\n          events = popoverData.events || eventObj[d],\n          cell = popoverData.cell || $$1('.mbsc-cal-slide-a .mbsc-cal-day[data-full=\"' + getDateStr(d) + '\"]', inst._markup)[0];\n      showEvents(events, d, cell);\n      popoverData = null;\n    }\n  }\n\n  function formatDuration(start, end) {\n    var lbl = s.labelsShort,\n        time = end - start,\n        seconds = Math.abs(time) / 1000,\n        minutes = seconds / 60,\n        hours = minutes / 60,\n        days = hours / 24,\n        years = days / 365;\n    return seconds < 45 && Math.round(seconds) + ' ' + lbl[5].toLowerCase() || //seconds < 90 && '1 minute' ||\n    minutes < 45 && Math.round(minutes) + ' ' + lbl[4].toLowerCase() || //minutes < 90 && '1 hour' ||\n    hours < 24 && Math.round(hours) + ' ' + lbl[3].toLowerCase() || //hours < 42 && '1 day' ||\n    days < 30 && Math.round(days) + ' ' + lbl[2].toLowerCase() || //days < 45 && '1 month' ||\n    days < 365 && Math.round(days / 30) + ' ' + lbl[1].toLowerCase() || //years < 1.5 && '1 year' ||\n    Math.round(years) + ' ' + lbl[0].toLowerCase();\n  }\n\n  function sortEvents(events) {\n    return events.slice(0).sort(function (a, b) {\n      var start1 = a.start ? makeDate(a.start) : null,\n          start2 = b.start ? makeDate(b.start) : null,\n          end1 = a.end ? makeDate(a.end) : null,\n          end2 = b.end ? makeDate(b.end) : null,\n          isRepeating1 = DAY_OF_WEEK.test(a.d) || DAY_OF_MONTH.test(a.d),\n          isRepeating2 = DAY_OF_WEEK.test(b.d) || DAY_OF_MONTH.test(b.d),\n          dt1 = a.d ? isRepeating1 ? a.d : makeDate(a.d) : start1,\n          dt2 = b.d ? isRepeating2 ? b.d : makeDate(b.d) : start2,\n          weight1 = !dt1.getTime ? 0 : start1 && end1 && start1.toDateString() !== end1.toDateString() ? 1 : a.allDay ? 2 : dt1.getTime(),\n          weight2 = !dt2.getTime ? 0 : start2 && end2 && start2.toDateString() !== end2.toDateString() ? 1 : b.allDay ? 2 : dt2.getTime();\n\n      if (weight1 == weight2) {\n        return a.text > b.text ? 1 : -1;\n      }\n\n      return weight1 - weight2;\n    });\n  }\n\n  function showEvents(events, d, cell) {\n    if (events) {\n      var $eventCont,\n          $eventContInner,\n          $eventScroller,\n          eventScroller,\n          $items,\n          html = '<div class=\"mbsc-cal-event-list\">';\n      $eventCont = $$1('<div class=\"mbsc-cal-events ' + (s.eventBubbleClass || '') + '\">' + '<div class=\"mbsc-cal-events-i\"><div class=\"mbsc-cal-events-sc\">' + '</div><div class=\"mbsc-sc-bar-c\"><div class=\"mbsc-sc-bar\"></div></div></div></div>');\n      $eventContInner = $$1('.mbsc-cal-events-i', $eventCont);\n      $eventScroller = $$1('.mbsc-cal-events-sc', $eventCont);\n      inst.tap($eventContInner, function () {\n        if (!eventScroller.scrolled) {\n          hideEvents();\n        }\n      });\n      popup = new Popup($eventCont[0], {\n        display: 'bubble',\n        theme: s.theme,\n        lang: s.lang,\n        context: s.context,\n        buttons: [],\n        anchor: cell,\n        showOverlay: false,\n        cssClass: 'mbsc-no-padding mbsc-cal-events-popup',\n        onShow: function onShow() {\n          eventScroller = new ScrollViewBase($eventContInner[0], {\n            scrollbar: $$1('.mbsc-sc-bar-c', $eventCont),\n            stopProp: false\n          });\n          $$1(document).on('click', hideEventsOnClick);\n        },\n        onClose: function onClose(event, inst) {\n          inst.destroy();\n\n          if (eventScroller) {\n            eventScroller.destroy();\n          }\n\n          $$1(document).off('click', hideEventsOnClick);\n        }\n      }); // Store the popup on the instance, we need to destroy it in case of an option call or re-init\n\n      inst._popup = popup;\n      eventDay = cell;\n      events = sortEvents(events);\n      $$1.each(events, function (i, e) {\n        var start = e.start ? makeDate(e.start) : null,\n            end = e.end ? makeDate(e.end) : null,\n            isRepeating = DAY_OF_WEEK.test(e.d) || DAY_OF_MONTH.test(e.d),\n            dt = e.d ? isRepeating ? e.d : makeDate(e.d) : start,\n            isMultiDay = start && end && !isSameDay(start, end),\n            isFirstDay = isMultiDay ? isSameDay(start, d) : true,\n            isLastDay = isMultiDay ? isSameDay(end, d) : true,\n            allDay = e.allDay || isRepeating || isMultiDay && !isFirstDay && !isLastDay,\n            bg = e.color,\n            ariaFrom = '',\n            ariaTo = '',\n            ariaLabel = $$1('<div>' + e.text + '</div>').text();\n\n        if (dt.getTime) {\n          ariaFrom = formatDate((isMultiDay ? 'MM d yy ' : '') + s.timeFormat, dt);\n        }\n\n        if (end) {\n          ariaTo = formatDate((isMultiDay ? 'MM d yy ' : '') + s.timeFormat, end);\n        }\n\n        html += '<div tabindex=\"0\" role=\"button\" title=\"' + ariaLabel + '\" aria-label=\"' + ariaLabel + (ariaFrom ? ', ' + s.fromText + ': ' + ariaFrom : '') + (ariaTo ? ', ' + s.toText + ': ' + ariaTo : '') + '\" class=\"mbsc-cal-event mbsc-lv-item mbsc-lv-item-actionable\">' + '<div class=\"mbsc-cal-event-color\" style=\"' + (bg ? 'background:' + bg + ';' : '') + '\"></div>' + '<div class=\"mbsc-cal-event-text\">' + '<div class=\"mbsc-cal-event-time\">' + (allDay ? s.allDayText : isFirstDay && dt.getTime ? formatDate(s.timeFormat, dt) : '') + '</div>' + e.text + '</div>' + (start && end && !e.allDay ? '<div class=\"mbsc-cal-event-dur\">' + s.formatDuration(start, end, e) + '</div>' : '') + '</div>';\n      });\n      html += '</div>';\n      $eventScroller.html(html);\n      popup.show();\n      trigger('onEventBubbleShow', {\n        target: eventDay,\n        eventList: $eventCont[0]\n      });\n      $items = $$1('.mbsc-cal-event', $eventScroller); // Assign event click\n\n      inst.tap($items, function (e) {\n        if (!eventScroller.scrolled) {\n          trigger('onEventSelect', {\n            domEvent: e,\n            event: events[$$1(this).index()],\n            date: d\n          });\n        }\n      });\n      handleFocus($items);\n      hasEventBubble = true;\n    }\n  }\n\n  function onScroll() {\n    var d, top, parts;\n\n    if (!preventScrollWatch) {\n      $$1('.mbsc-event-day', this).each(function () {\n        top = this.offsetTop - eventListCont.scrollTop;\n\n        if (top >= 0 && top < 35) {\n          parts = $$1(this).attr('data-full').split('-');\n          d = adjustedDate(parts[0], parts[1] - 1, parts[2]);\n\n          if (!isSameDay(d, currDay)) {\n            preventEventScroll = true;\n            inst.setVal(d);\n          }\n\n          return false;\n        }\n      });\n    }\n  }\n\n  function hideEvents() {\n    if (popup && hasEventBubble) {\n      popup.hide();\n    }\n\n    eventDay = null;\n    hasEventBubble = false;\n  }\n\n  function hideEventsOnClick(e) {\n    if ($$1(e.target).closest('.mbsc-cal-day').length == 0) {\n      hideEvents();\n    }\n  }\n\n  function refresh() {\n    hideEvents();\n    inst.redraw();\n  }\n\n  function getFirstLast(day) {\n    var y = s.getYear(day),\n        m = s.getMonth(day),\n        d = s.getDay(day);\n    currFirstDay = day;\n\n    if (listType == 'day') {\n      currLastDay = s.getDate(y, m, d + listSize - 1);\n    } else if (listType == 'week') {\n      // get first day of week\n      var diff,\n          weekDay = currFirstDay.getDay();\n      diff = d + s.firstDay - (s.firstDay - weekDay > 0 ? 7 : 0) - weekDay;\n      currFirstDay = s.getDate(y, m, diff);\n      currLastDay = s.getDate(y, m, diff + listSize * 7 - 1);\n    } else if (listType == 'month') {\n      currFirstDay = s.getDate(y, m, 1);\n      currLastDay = s.getDate(y, m + listSize, 0);\n    } else if (listType == 'year') {\n      currFirstDay = s.getDate(y, 0, 1);\n      currLastDay = s.getDate(y + listSize, 0, 0);\n    }\n  }\n\n  function scrollToDay(d, prevAnim) {\n    // Scroll to the day in the list, if any\n    if (showEventList && !preventEventScroll) {\n      var $day = $$1('.mbsc-event-day[data-full=\"' + getDateStr(d) + '\"]', $eventListCont);\n\n      if ($day.length) {\n        preventScrollWatch++;\n        smoothScroll(eventListCont, $day.parent()[0].offsetTop, prevAnim, function () {\n          // Need setTimeout since scroll listener is throtteled\n          setTimeout(function () {\n            preventScrollWatch--;\n          }, 150);\n        });\n      }\n    }\n  }\n\n  function triggerLoading(change, render) {\n    if (change) {\n      trigger('onPageChange', {\n        firstDay: currFirstDay,\n        lastDay: currLastDay\n      });\n    }\n\n    if (!render) {\n      trigger('onPageLoading', {\n        firstDay: currFirstDay,\n        lastDay: currLastDay\n      });\n    }\n\n    trigger('onPageLoaded', {\n      firstDay: currFirstDay,\n      lastDay: currLastDay\n    });\n  } // ---\n\n\n  var base,\n      $ctx,\n      $eventListCont,\n      $viewTitle,\n      currDay,\n      currFirstDay,\n      currLastDay,\n      eventDay,\n      eventListCont,\n      eventObj,\n      hasEventBubble,\n      isChanging,\n      isLabelTap,\n      isListOnly,\n      listType,\n      listSize,\n      multiLabel,\n      popoverData,\n      popup,\n      preventEventScroll,\n      preventScrollAnim,\n      prevFirstDay,\n      prevLastDay,\n      scrollEventList,\n      showEventList,\n      showEventBubble,\n      showMore,\n      elm = this,\n      orig = extend$1({}, inst.settings),\n      s = extend$1(inst.settings, defaults$4, orig, overrides, settings),\n      preventScrollWatch = 0,\n      eventID = 0,\n      eventList = extend$1(true, [], s.data),\n      firstLoad = true,\n      trigger = inst.trigger; // Keep tracking events in settings,\n  // otherwise changes will be lost on an eventual option call\n\n  s.data = eventList;\n  $$1.each(eventList, function (i, e) {\n    if (e._id === undefined) {\n      e._id = eventID++;\n    }\n  });\n  processSettings();\n  base = CalendarBase.call(this, inst); // Extended methods\n  // ---\n\n  inst._onGenMonth = function (start, end) {\n    eventObj = inst._prepareObj(eventList, start, end);\n    inst._labels = multiLabel ? eventObj : null;\n  };\n\n  inst._onRefresh = function (render) {\n    preventScrollAnim = true; // Will re-create the list\n\n    prevFirstDay = null;\n    prevLastDay = null;\n\n    if (isListOnly) {\n      triggerLoading(false, render);\n    }\n  };\n\n  inst._onSetDate = function (d, diff) {\n    currDay = d;\n\n    if (isListOnly) {\n      if (!preventEventScroll && !isChanging) {\n        getFirstLast(d);\n\n        if (!prevFirstDay || !prevLastDay || !isSameDay(prevFirstDay, currFirstDay) || !isSameDay(prevLastDay, currLastDay)) {\n          triggerLoading(true);\n        }\n      }\n    } else if (!diff && !isChanging) {\n      hideEvents();\n\n      if (showEventList && listType == 'day') {\n        // List events for the day\n        createEventList(d, d, eventObj);\n      }\n\n      if ((showEventBubble || showMore) && !isLabelTap) {\n        // Show event popover\n        createEventPopover();\n      }\n\n      scrollToDay(d);\n    }\n\n    preventEventScroll = false;\n    showMore = false;\n    isLabelTap = false;\n  };\n\n  inst._getDayProps = function (d) {\n    var events = eventObj[d],\n        ret = {\n      events: events\n    };\n\n    if (!s.marked && !s.labels && !multiLabel) {\n      if (events) {\n        ret.background = events[0] && events[0].background;\n        ret.marked = events; // For backward compatibility\n\n        ret.markup = s.showEventCount ? '<div class=\"mbsc-cal-txt\">' + events.length + ' ' + (events.length > 1 ? s.eventsText : s.eventText) + '</div>' : '<div class=\"mbsc-cal-marks\"><div class=\"mbsc-cal-mark\"></div></div>';\n      } else {\n        ret.markup = s.showEventCount ? '<div class=\"mbsc-cal-txt-ph\"></div>' : '';\n      }\n    }\n\n    return ret;\n  };\n\n  inst.addEvent = function (events) {\n    var ret = [];\n    events = extend$1(true, [], $$1.isArray(events) ? events : [events]);\n    $$1.each(events, function (i, e) {\n      if (e._id === undefined) {\n        e._id = eventID++;\n      }\n\n      eventList.push(e);\n      ret.push(e._id);\n    });\n    refresh();\n    return ret;\n  };\n\n  inst.updateEvent = function (event) {\n    $$1.each(eventList, function (j, e) {\n      if (e._id === event._id) {\n        eventList.splice(j, 1, event);\n        return false;\n      }\n    });\n    refresh();\n  };\n\n  inst.removeEvent = function (eids) {\n    eids = $$1.isArray(eids) ? eids : [eids];\n    $$1.each(eids, function (i, eid) {\n      $$1.each(eventList, function (j, e) {\n        if (e._id === eid) {\n          eventList.splice(j, 1);\n          return false;\n        }\n      });\n    });\n    refresh();\n  };\n\n  inst.getEvents = function (d) {\n    var obj;\n\n    if (d) {\n      d.setHours(0, 0, 0, 0);\n      obj = inst._prepareObj(eventList, d, d);\n      return obj[d] ? sortEvents(obj[d]) : [];\n    }\n\n    return extend$1(true, [], eventList);\n  };\n\n  inst.setEvents = function (events) {\n    var ret = [];\n    s.data = eventList = extend$1(true, [], events);\n    $$1.each(eventList, function (i, e) {\n      if (e._id === undefined) {\n        e._id = eventID++;\n      }\n\n      ret.push(e._id);\n    });\n    refresh();\n    return ret;\n  };\n\n  inst.navigate = function (d, anim, pop) {\n    d = makeDate(d, inst._format, s);\n    popoverData = pop ? {\n      d: d\n    } : null;\n    inst.setVal(d, true, true, false, anim ? 200 : 0);\n  }; // ---\n\n\n  return extend$1({}, base, {\n    multiLabel: multiLabel,\n    headerText: false,\n    buttons: s.display !== 'inline' ? ['close'] : s.buttons,\n    compClass: 'mbsc-ev-cal mbsc-calendar mbsc-dt mbsc-sc',\n    formatDuration: formatDuration,\n    onMarkupReady: function onMarkupReady(ev, inst) {\n      $ctx = $$1(ev.target);\n      currDay = inst.getDate(true);\n\n      if (showEventList) {\n        $eventListCont = $$1('<div class=\"mbsc-lv-cont mbsc-lv-' + s.theme + (s.baseTheme ? ' mbsc-lv-' + s.baseTheme : '') + (scrollEventList ? ' mbsc-event-list-h' : '') + ' mbsc-event-list\"></div>').appendTo($$1('.mbsc-fr-w', $ctx));\n        $eventListCont.on('scroll', throttle(onScroll));\n        eventListCont = $eventListCont[0];\n      }\n\n      base.onMarkupReady.call(this, ev);\n      $viewTitle = $$1('.mbsc-cal-month', $ctx);\n      hasEventBubble = false;\n      getFirstLast(currDay);\n\n      if (showEventList && isListOnly) {\n        triggerLoading(); // Init navigation arrows\n\n        createStepper($$1('.mbsc-cal-btn', $ctx), function (i, diff) {\n          var y = s.getYear(currFirstDay),\n              m = s.getMonth(currFirstDay),\n              d = s.getDay(currFirstDay);\n\n          if (listType == 'day') {\n            currFirstDay = s.getDate(y, m, d + diff * listSize);\n            currLastDay = s.getDate(y, m, d + (diff + 1) * listSize - 1);\n          } else if (listType == 'week') {\n            currFirstDay = s.getDate(y, m, d + diff * listSize * 7);\n            currLastDay = s.getDate(y, m, d + (diff + 1) * listSize * 7 - 1);\n          } else if (listType == 'month') {\n            currFirstDay = s.getDate(y, m + diff * listSize, 1);\n            currLastDay = s.getDate(y, m + (diff + 1) * listSize, 0);\n          } else if (listType == 'year') {\n            currFirstDay = s.getDate(y + diff * listSize, 0, 1);\n            currLastDay = s.getDate(y + (diff + 1) * listSize, 0, 0);\n          }\n\n          triggerLoading(true);\n        }, 200);\n      }\n\n      addWindowFocus();\n    },\n    onDayChange: function onDayChange(day) {\n      var cell = day.target,\n          show = cell !== eventDay;\n\n      if (show) {\n        showMore = showEventBubble !== false && $$1('.mbsc-cal-txt-more', cell).length;\n        popoverData = {\n          d: day.date,\n          cell: s.outerMonthChange && $$1(cell).hasClass('mbsc-cal-day-diff') ? null : cell,\n          events: day.events\n        };\n      }\n    },\n    onLabelTap: function onLabelTap(ev) {\n      if (ev.label) {\n        trigger('onEventSelect', {\n          domEvent: ev.domEvent,\n          event: ev.label,\n          date: ev.date\n        });\n        isLabelTap = true;\n      }\n    },\n    onPageChange: function onPageChange(ev) {\n      hideEvents();\n      isChanging = true;\n\n      if (!inst._isSetDate) {\n        inst.setVal(ev.firstDay);\n      }\n    },\n    onPageLoaded: function onPageLoaded(ev) {\n      var firstDay = ev.firstDay,\n          lastDay = ev.lastDay;\n\n      if (showEventList) {\n        if (isListOnly) {\n          if (!prevFirstDay || !prevLastDay || !isSameDay(prevFirstDay, firstDay) || !isSameDay(prevLastDay, lastDay)) {\n            prevFirstDay = firstDay;\n            prevLastDay = lastDay;\n            createEventList(firstDay, lastDay);\n            updateTitle(firstDay, lastDay);\n          }\n        } else {\n          if (listType == 'month') {\n            // month view\n            lastDay = s.getDate(s.getYear(firstDay), s.getMonth(firstDay) + listSize, 0);\n          } else if (listType == 'week') {\n            // week view\n            lastDay = s.getDate(s.getYear(firstDay), s.getMonth(firstDay), s.getDay(firstDay) + listSize * 7 - 1);\n          } else {\n            firstDay = inst.getVal(true);\n            lastDay = firstDay;\n          }\n\n          createEventList(firstDay, lastDay, eventObj);\n        }\n\n        if (!firstLoad && !isSameDay(currDay, firstDay)) {\n          scrollToDay(currDay, preventScrollAnim);\n          preventScrollAnim = false;\n        }\n      }\n\n      if (showEventBubble) {\n        createEventPopover();\n      }\n\n      isChanging = false;\n    },\n    onPosition: function onPosition(ev) {\n      base.onPosition.call(this, ev);\n\n      if (popup) {\n        popup.position();\n      }\n\n      if (showEventList && scrollEventList) {\n        $eventListCont.addClass('mbsc-event-list-h');\n        var context = s.display == 'inline' ? elm.parentNode : window,\n            availableHeight = getHeight(context),\n            listHeight = availableHeight - ev.popup.offsetHeight;\n        eventListCont.style.height = listHeight > 200 ? listHeight + 'px' : '';\n        $eventListCont.removeClass('mbsc-event-list-h');\n\n        if (firstLoad && listHeight) {\n          scrollToDay(currDay, true);\n          firstLoad = false;\n        }\n      }\n    },\n    onHide: function onHide() {\n      base.onHide.call(this); // Destroy the popup stored on the instance,\n      // the local variable is lost in case of option call or re-init\n\n      if (inst._popup) {\n        inst._popup.destroy();\n      }\n\n      removeWindowFocus();\n    }\n  });\n};\n\nvar MbscEventcalendar = function (_super) {\n  __extends(MbscEventcalendar, _super);\n\n  function MbscEventcalendar(initialElem, zone, optionService) {\n    var _this = _super.call(this, initialElem, zone, null, null, null) || this;\n\n    _this.optionService = optionService;\n    _this.onEventSelect = new EventEmitter();\n    _this.onCellHoverIn = new EventEmitter();\n    _this.onCellHoverOut = new EventEmitter();\n    _this.onDayChange = new EventEmitter();\n    _this.onSetDate = new EventEmitter();\n    _this.options = {};\n    return _this;\n  }\n\n  MbscEventcalendar.prototype.refreshData = function (newData) {\n    this.instance.setEvents(newData);\n  };\n\n  MbscEventcalendar.prototype.initControl = function () {\n    var options = extend$1({\n      preset: 'eventcalendar'\n    }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);\n    this.instance = new Eventcalendar(this.element, options);\n  };\n\n  MbscEventcalendar.prototype.ngOnInit = function () {\n    this.cloneDictionary.data = [];\n\n    _super.prototype.ngOnInit.call(this);\n  };\n\n  MbscEventcalendar.prototype.setNewValue = function () {};\n\n  __decorate([Input$1('mbsc-data'), __metadata(\"design:type\", Array)], MbscEventcalendar.prototype, \"data\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscEventcalendar.prototype, \"layout\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscEventcalendar.prototype, \"showEventCount\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscEventcalendar.prototype, \"eventBubble\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Function)], MbscEventcalendar.prototype, \"formatDuration\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscEventcalendar.prototype, \"view\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscEventcalendar.prototype, \"allDayText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscEventcalendar.prototype, \"eventText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscEventcalendar.prototype, \"eventsText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscEventcalendar.prototype, \"labelsShort\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscEventcalendar.prototype, \"noEventsText\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscEventcalendar.prototype, \"onEventSelect\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscEventcalendar.prototype, \"onCellHoverIn\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscEventcalendar.prototype, \"onCellHoverOut\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscEventcalendar.prototype, \"onDayChange\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscEventcalendar.prototype, \"onSetDate\", void 0);\n\n  __decorate([Input$1('mbsc-options'), __metadata(\"design:type\", Object)], MbscEventcalendar.prototype, \"options\", void 0);\n\n  MbscEventcalendar = __decorate([__param(2, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, MbscOptionsService])], MbscEventcalendar);\n\n  MbscEventcalendar.ɵfac = function MbscEventcalendar_Factory(t) {\n    return new (t || MbscEventcalendar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscEventcalendar.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscEventcalendar,\n    selectors: [[\"\", \"mbsc-eventcalendar\", \"\"]],\n    inputs: {\n      data: [\"mbsc-data\", \"data\"],\n      layout: \"layout\",\n      showEventCount: \"showEventCount\",\n      eventBubble: \"eventBubble\",\n      formatDuration: \"formatDuration\",\n      view: \"view\",\n      allDayText: \"allDayText\",\n      eventText: \"eventText\",\n      eventsText: \"eventsText\",\n      labelsShort: \"labelsShort\",\n      noEventsText: \"noEventsText\",\n      options: [\"mbsc-options\", \"options\"]\n    },\n    outputs: {\n      onEventSelect: \"onEventSelect\",\n      onCellHoverIn: \"onCellHoverIn\",\n      onCellHoverOut: \"onCellHoverOut\",\n      onDayChange: \"onDayChange\",\n      onSetDate: \"onSetDate\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscEventcalendar;\n}(MbscCalBase);\n\nvar MbscEventcalendarComponent = function (_super) {\n  __extends(MbscEventcalendarComponent, _super);\n\n  function MbscEventcalendarComponent(initialElem, zone, optionService) {\n    var _this = _super.call(this, initialElem, zone, optionService) || this;\n\n    _this.options = {};\n    return _this;\n  }\n\n  MbscEventcalendarComponent.prototype.ngOnInit = function () {\n    var display = this.options && this.options.display || this.display;\n\n    if (!display) {\n      this.display = 'inline';\n      this.inlineOptionsObj.display = 'inline';\n    }\n\n    _super.prototype.ngOnInit.call(this);\n  };\n\n  MbscEventcalendarComponent.prototype.ngAfterViewInit = function () {\n    _super.prototype.ngAfterViewInit.call(this);\n\n    this.setThemeClasses();\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscEventcalendarComponent.prototype, \"data\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscEventcalendarComponent.prototype, \"options\", void 0);\n\n  MbscEventcalendarComponent = __decorate([__param(2, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, MbscOptionsService])], MbscEventcalendarComponent);\n\n  MbscEventcalendarComponent.ɵfac = function MbscEventcalendarComponent_Factory(t) {\n    return new (t || MbscEventcalendarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscEventcalendarComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscEventcalendarComponent,\n    selectors: [[\"mbsc-eventcalendar\"]],\n    inputs: {\n      data: \"data\",\n      options: \"options\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    decls: 1,\n    vars: 0,\n    template: function MbscEventcalendarComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelement(0, \"div\");\n      }\n    },\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscEventcalendarComponent;\n}(MbscEventcalendar);\n\nvar MbscEventcalendarModule = function () {\n  function MbscEventcalendarModule() {}\n\n  MbscEventcalendarModule.ɵfac = function MbscEventcalendarModule_Factory(t) {\n    return new (t || MbscEventcalendarModule)();\n  };\n\n  MbscEventcalendarModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscEventcalendarModule\n  });\n  MbscEventcalendarModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[MbscCalBaseModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscEventcalendarModule, {\n      declarations: [MbscEventcalendar, MbscEventcalendarComponent],\n      imports: [MbscCalBaseModule],\n      exports: [MbscEventcalendar, MbscEventcalendarComponent]\n    });\n  })();\n\n  return MbscEventcalendarModule;\n}();\n\nvar hasPromise = isBrowser && !!window.Promise;\nvar popupQueue = [];\nvar notificationQueue = [];\nvar activeNotification;\n\nfunction showPopup(popup) {\n  if (!popupQueue.length) {\n    popup.show();\n  }\n\n  popupQueue.push(popup);\n}\n\nfunction showNotification(notification) {\n  var isAny = notificationQueue.length;\n  notificationQueue.push(notification); // Only show notification if no popup is visible\n  // otherwise postpone it until popup is closed\n\n  if (!popupQueue.length) {\n    // If there's a visible notification, hide it.\n    // The notification will be shown after hide animation is complete\n    if (isAny) {\n      notificationQueue[0].hide();\n    } else {\n      // Prevent focus on show for notifications\n      notification.show(false, true);\n    }\n  }\n}\n\nfunction getSettings(queue, settings, resolve, more) {\n  //const active = mobiscroll.activeInstance;\n  return extend$1({\n    display: settings.display || 'center',\n    cssClass: 'mbsc-alert',\n    okText: settings.okText,\n    cancelText: settings.cancelText,\n    context: settings.context,\n    theme: settings.theme,\n    closeOnOverlayTap: false,\n    onBeforeClose: function onBeforeClose() {\n      queue.shift();\n    },\n    onHide: function onHide(ev, inst) {\n      //mobiscroll.activeInstance = active;\n      if (resolve) {\n        resolve(inst._resolve);\n      }\n\n      if (settings.callback) {\n        settings.callback(inst._resolve);\n      }\n\n      if (inst) {\n        inst.destroy();\n      } // Show next\n\n\n      if (popupQueue.length) {\n        popupQueue[0].show();\n      } else if (notificationQueue.length) {\n        // Prevent focus on show for notifications\n        notificationQueue[0].show(false, true);\n      }\n    }\n  }, more);\n}\n\nfunction getMessage(settings) {\n  return (settings.title ? '<h2>' + settings.title + '</h2>' : '') + '<p>' + (settings.message || '') + '</p>';\n}\n\nfunction showAlert(popup, settings, resolve) {\n  var inst = new Popup(popup, getSettings(popupQueue, settings, resolve));\n  showPopup(inst);\n}\n\nfunction showConfirm(popup, settings, resolve) {\n  var inst = new Popup(popup, getSettings(popupQueue, settings, resolve, {\n    buttons: ['cancel', 'ok'],\n    onSet: function onSet() {\n      inst._resolve = true;\n    }\n  }));\n  inst._resolve = false;\n  showPopup(inst);\n}\n\nfunction showPrompt(popup, settings, resolve) {\n  var input, label;\n  var inst = new Popup(popup, getSettings(popupQueue, settings, resolve, {\n    buttons: ['cancel', 'ok'],\n    onMarkupReady: function onMarkupReady(event, inst) {\n      var s = inst.settings;\n      label = inst._markup.find('label');\n      label.addClass('mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : ''));\n      input = inst._markup.find('input')[0];\n      setTimeout(function () {\n        input.focus();\n        input.setSelectionRange(0, input.value.length);\n      }, 300);\n    },\n    onSet: function onSet() {\n      inst._resolve = input.value;\n    }\n  }));\n  inst._resolve = null;\n  showPopup(inst);\n}\n\nfunction showSnackbar(popup, settings, resolve, cssClass, animation) {\n  var notificationTimer;\n  var inst = new Popup(popup, getSettings(notificationQueue, settings, resolve, {\n    display: settings.display || 'bottom',\n    animate: animation,\n    cssClass: (cssClass || 'mbsc-snackbar') + (settings.color ? ' mbsc-' + settings.color : ''),\n    scrollLock: false,\n    focusTrap: false,\n    buttons: [],\n    onMarkupReady: function onMarkupReady(event, inst) {\n      var s = inst.settings;\n\n      var button = inst._markup.find('button');\n\n      button.addClass('mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : ''));\n    },\n    onShow: function onShow(ev, inst) {\n      activeNotification = inst;\n\n      if (settings.duration !== false) {\n        notificationTimer = setTimeout(function () {\n          if (inst) {\n            inst.hide();\n          }\n        }, settings.duration || 3000);\n      }\n\n      if (settings.button) {\n        inst.tap($$1('.mbsc-snackbar-btn', ev.target), function () {\n          inst.hide();\n\n          if (settings.button.action) {\n            settings.button.action.call(this);\n          }\n        });\n      }\n    },\n    onClose: function onClose() {\n      activeNotification = null;\n      clearTimeout(notificationTimer);\n    }\n  }));\n  showNotification(inst);\n}\n\nfunction showToast(popup, settings, resolve) {\n  showSnackbar(popup, settings, resolve, 'mbsc-toast', 'fade');\n}\n\nfunction show(func, popup, settings) {\n  var p;\n\n  if (hasPromise) {\n    p = new Promise(function (resolve) {\n      func(popup, settings, resolve);\n    });\n  } else {\n    func(popup, settings);\n  }\n\n  return p;\n}\n\nmobiscroll.alert = function (settings) {\n  var popup = document.createElement('div');\n  popup.innerHTML = getMessage(settings);\n  return show(showAlert, popup, settings);\n};\n\nmobiscroll.confirm = function (settings) {\n  var popup = document.createElement('div');\n  popup.innerHTML = getMessage(settings);\n  return show(showConfirm, popup, settings);\n};\n\nmobiscroll.prompt = function (settings) {\n  var popup = document.createElement('div');\n  popup.innerHTML = getMessage(settings) + '<label class=\"mbsc-input\">' + (settings.label ? '<span class=\"mbsc-label\">' + settings.label + '</span>' : '') + '<input class=\"mbsc-control\" tabindex=\"0\" type=\"' + (settings.inputType || 'text') + '\" placeholder=\"' + (settings.placeholder || '') + '\" value=\"' + (settings.value || '') + '\">' + '</label>';\n  return show(showPrompt, popup, settings);\n};\n\nmobiscroll.snackbar = function (settings) {\n  var popup = document.createElement('div'),\n      btn = settings.button;\n  popup.innerHTML = '<div class=\"mbsc-snackbar-cont\"><div class=\"mbsc-snackbar-msg\">' + (settings.message || '') + '</div>' + (btn ? '<button class=\"mbsc-snackbar-btn mbsc-btn mbsc-btn-flat\">' + (btn.icon ? '<span class=\"mbsc-ic ' + (btn.text ? 'mbsc-btn-ic ' : '') + 'mbsc-ic-' + btn.icon + '\"></span>' : '') + (btn.text || '') + '</button>' : '') + '</div>';\n  return show(showSnackbar, popup, settings);\n};\n\nmobiscroll.toast = function (settings) {\n  var popup = document.createElement('div');\n  popup.innerHTML = '<div class=\"mbsc-toast-msg\">' + (settings.message || '') + '</div>';\n  return show(showToast, popup, settings);\n};\n\nmobiscroll.notification = {\n  dismiss: function dismiss() {\n    if (activeNotification) {\n      activeNotification.hide();\n    }\n  }\n};\nvar halfBorder$3 = os == 'ios' && majorVersion > 7;\n\nvar Form = function Form(el, settings) {\n  var s,\n      cssClass = '',\n      $ctx = $$1(el),\n      controls = {},\n      that = this;\n\n  function touched() {\n    $ctx.removeClass('mbsc-no-touch');\n  } // Call the parent constructor\n\n\n  Base.call(this, el, settings, true);\n\n  that.refresh = function (shallow) {\n    if (s.enhance) {\n      initControls($ctx, controls, s, shallow);\n    }\n  };\n  /**\r\n   * Form initialization.\r\n   */\n\n\n  that._init = function () {\n    if (!mobiscroll.themes.form[s.theme]) {\n      s.theme = 'mobiscroll';\n    }\n\n    if (!$ctx.hasClass('mbsc-form')) {\n      $ctx.show();\n      listen($ctx[0], 'touchstart', touched, {\n        passive: true\n      });\n    }\n\n    if (cssClass) {\n      $ctx.removeClass(cssClass);\n    } // --- TRIAL SERVER CODE START ---\n\n\n    cssClass = 'mbsc-form mbsc-no-touch mbsc-' + s.theme + (halfBorder$3 ? ' mbsc-form-hb' : '') + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr') + (s.inputStyle == 'box' ? ' mbsc-form-box' : '') + (s.inputStyle == 'outline' ? ' mbsc-form-outline' : ''); // --- TRIAL SERVER CODE END ---\n\n    $ctx.addClass(cssClass).removeClass('mbsc-cloak');\n    that.refresh();\n  };\n  /**\r\n   * Destroys the mobiscroll instance.\r\n   */\n\n\n  that._destroy = function () {\n    $ctx.removeClass(cssClass);\n    unlisten($ctx[0], 'touchstart', touched, {\n      passive: true\n    });\n\n    for (var id in controls) {\n      controls[id].destroy();\n    }\n  };\n  /**\r\n   * Object with the underlying form control instances\r\n   * keys are the element id's\r\n   */\n\n\n  that.controls = controls; // Constructor\n\n  s = that.settings;\n  that.init();\n}; // Extend defaults\n\n\nForm.prototype = {\n  _hasDef: true,\n  _hasTheme: true,\n  _hasLang: true,\n  _class: 'form',\n  _defaults: {\n    tap: hasGhostClick,\n    stopProp: true,\n    rtl: false,\n    enhance: true\n  }\n};\nclasses.Form = Form; // Init mbsc-form elements on page load\n\nautoInit('[mbsc-enhance],[mbsc-form]', Form, true);\n\nvar MbscForm = function (_super) {\n  __extends(MbscForm, _super);\n\n  function MbscForm(initialElem, _formService, zone) {\n    var _this = _super.call(this, initialElem, zone) || this;\n\n    _this._formService = _formService;\n    _this.enhance = false;\n    return _this;\n  }\n\n  MbscForm.prototype.ngOnInit = function () {\n    this.optionsObj = extend$1({}, this.options, this.inlineOptionsObj);\n    this._formService.options = this.optionsObj;\n  };\n\n  MbscForm.prototype.initControl = function () {\n    var opt = this.options;\n\n    if (opt && opt.enhance === undefined) {\n      opt.enhance = false;\n    }\n\n    var options = extend$1({}, opt, this.inlineOptionsObj);\n    this.instance = new Form(this.rootElem.nativeElement, options);\n  };\n\n  __decorate([Input$1('options'), __metadata(\"design:type\", Object)], MbscForm.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscForm.prototype, \"enhance\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscForm.prototype, \"context\", void 0);\n\n  __decorate([Input$1('input-style'), __metadata(\"design:type\", String)], MbscForm.prototype, \"inputStyle\", void 0);\n\n  __decorate([Input$1('label-style'), __metadata(\"design:type\", String)], MbscForm.prototype, \"labelStyle\", void 0);\n\n  __decorate([ViewChild('rootElement', {\n    static: false\n  }), __metadata(\"design:type\", ElementRef)], MbscForm.prototype, \"rootElem\", void 0);\n\n  MbscForm = __decorate([__metadata(\"design:paramtypes\", [ElementRef, MbscOptionsService, NgZone])], MbscForm);\n\n  MbscForm.ɵfac = function MbscForm_Factory(t) {\n    return new (t || MbscForm)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  MbscForm.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscForm,\n    selectors: [[\"mbsc-form\"]],\n    viewQuery: function MbscForm_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c2, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rootElem = _t.first);\n      }\n    },\n    inputs: {\n      options: \"options\",\n      enhance: \"enhance\",\n      context: \"context\",\n      inputStyle: [\"input-style\", \"inputStyle\"],\n      labelStyle: [\"label-style\", \"labelStyle\"]\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([MbscOptionsService]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 3,\n    vars: 0,\n    consts: [[\"rootElement\", \"\"]],\n    template: function MbscForm_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", null, 0);\n        ɵngcc0.ɵɵprojection(2);\n        ɵngcc0.ɵɵelementEnd();\n      }\n    },\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscForm;\n}(MbscBase);\n\nvar MbscTextarea = function (_super) {\n  __extends(MbscTextarea, _super);\n\n  function MbscTextarea(initialElem, _formService, _inputService, _control, zone) {\n    var _this = _super.call(this, initialElem, _formService, _inputService, _control, zone) || this;\n\n    _this._inputService = _inputService;\n    _inputService.input = _this;\n    return _this;\n  }\n\n  MbscTextarea.prototype.initControl = function () {\n    var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);\n    this.instance = new TextArea(this._initElem.nativeElement, options);\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscTextarea.prototype, \"rows\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscTextarea.prototype, \"wrap\", void 0);\n\n  MbscTextarea = __decorate([__param(1, Optional()), __param(3, Optional()), __metadata(\"design:paramtypes\", [ElementRef, MbscOptionsService, MbscInputService, NgControl, NgZone])], MbscTextarea);\n\n  MbscTextarea.ɵfac = function MbscTextarea_Factory(t) {\n    return new (t || MbscTextarea)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  MbscTextarea.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscTextarea,\n    selectors: [[\"mbsc-textarea\"]],\n    hostAttrs: [1, \"mbsc-control-ng\"],\n    inputs: {\n      rows: \"rows\",\n      wrap: \"wrap\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([MbscInputService]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 6,\n    vars: 30,\n    consts: [[1, \"mbsc-input-wrap\"], [3, \"placeholder\", \"ngModel\", \"disabled\", \"readonly\", \"ngModelChange\", \"blur\"], [\"initElement\", \"\"], [\"class\", \"mbsc-err-msg\", 4, \"ngIf\"], [1, \"mbsc-err-msg\"]],\n    template: function MbscTextarea_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"label\");\n        ɵngcc0.ɵɵprojection(1);\n        ɵngcc0.ɵɵelementStart(2, \"span\", 0)(3, \"textarea\", 1, 2);\n        ɵngcc0.ɵɵlistener(\"ngModelChange\", function MbscTextarea_Template_textarea_ngModelChange_3_listener($event) {\n          return ctx.innerValue = $event;\n        })(\"blur\", function MbscTextarea_Template_textarea_blur_3_listener($event) {\n          return ctx.onTouch($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(5, MbscTextarea_span_5_Template, 2, 1, \"span\", 3);\n        ɵngcc0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"mbsc-err\", ctx.error)(\"mbsc-input-box\", ctx.inputStyle == \"box\")(\"mbsc-input-outline\", ctx.inputStyle == \"outline\")(\"mbsc-label-stacked\", ctx.labelStyle == \"stacked\")(\"mbsc-label-inline\", ctx.labelStyle == \"inline\")(\"mbsc-label-floating\", ctx.labelStyle == \"floating\");\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"placeholder\", ctx.placeholder)(\"ngModel\", ctx.innerValue)(\"disabled\", ctx.disabled)(\"readonly\", ctx._readonly);\n        ɵngcc0.ɵɵattribute(\"name\", ctx.name)(\"rows\", ctx.rows)(\"wrap\", ctx.wrap)(\"minlength\", ctx.minlength)(\"maxlength\", ctx.maxlength)(\"autocomplete\", ctx.autocomplete)(\"autocapitalize\", ctx.autocapitalize)(\"autocorrect\", ctx.autocorrect)(\"spellcheck\", ctx.spellcheck)(\"autofocus\", ctx.autofocus)(\"required\", ctx.required)(\"data-icon\", ctx.icon ? ctx.icon : null)(\"data-icon-align\", ctx.iconAlign ? ctx.iconAlign : null);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.error && ctx.errorMessage);\n      }\n    },\n    directives: [ɵngcc1.DefaultValueAccessor, ɵngcc1.NgControlStatus, ɵngcc1.NgModel, ɵngcc1.MinLengthValidator, ɵngcc1.MaxLengthValidator, ɵngcc1.RequiredValidator, ɵngcc2.NgIf],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscTextarea;\n}(MbscInputBase);\n\nvar MbscDropdown = function (_super) {\n  __extends(MbscDropdown, _super);\n\n  function MbscDropdown(hostElem, formService, _inputService, control, zone) {\n    var _this = _super.call(this, hostElem, formService, _inputService, control, zone) || this;\n\n    _this._inputService = _inputService;\n    _inputService.input = _this;\n    return _this;\n  }\n\n  Object.defineProperty(MbscDropdown.prototype, \"value\", {\n    set: function (v) {\n      var _this = this;\n\n      this._value = v;\n      setTimeout(function () {\n        _this.instance._setText();\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscDropdown.prototype.initControl = function () {\n    var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);\n    this.instance = new Select(this._initElem.nativeElement, options);\n    var that = this;\n    setTimeout(function () {\n      that.instance._setText();\n    });\n  };\n\n  MbscDropdown.prototype.writeValue = function (v) {\n    this._value = v;\n\n    if (this.instance) {\n      var that_1 = this;\n      setTimeout(function () {\n        that_1.instance._setText();\n      });\n    }\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDropdown.prototype, \"label\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDropdown.prototype, \"icon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscDropdown.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], MbscDropdown.prototype, \"value\", null);\n\n  __decorate([Input$1('input-style'), __metadata(\"design:type\", String)], MbscDropdown.prototype, \"inputStyle\", void 0);\n\n  __decorate([Input$1('label-style'), __metadata(\"design:type\", String)], MbscDropdown.prototype, \"labelStyle\", void 0);\n\n  MbscDropdown = __decorate([__param(1, Optional()), __param(3, Optional()), __metadata(\"design:paramtypes\", [ElementRef, MbscOptionsService, MbscInputService, NgControl, NgZone])], MbscDropdown);\n\n  MbscDropdown.ɵfac = function MbscDropdown_Factory(t) {\n    return new (t || MbscDropdown)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  MbscDropdown.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscDropdown,\n    selectors: [[\"mbsc-dropdown\"]],\n    hostAttrs: [1, \"mbsc-control-ng\"],\n    inputs: {\n      value: \"value\",\n      label: \"label\",\n      icon: \"icon\",\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      inputStyle: [\"input-style\", \"inputStyle\"],\n      labelStyle: [\"label-style\", \"labelStyle\"]\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([MbscInputService]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 7,\n    vars: 19,\n    consts: [[1, \"mbsc-input-wrap\"], [3, \"ngModel\", \"disabled\", \"ngModelChange\", \"blur\"], [\"initElement\", \"\"], [\"class\", \"mbsc-err-msg\", 4, \"ngIf\"], [1, \"mbsc-err-msg\"]],\n    template: function MbscDropdown_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"label\");\n        ɵngcc0.ɵɵtext(1);\n        ɵngcc0.ɵɵelementStart(2, \"span\", 0)(3, \"select\", 1, 2);\n        ɵngcc0.ɵɵlistener(\"ngModelChange\", function MbscDropdown_Template_select_ngModelChange_3_listener($event) {\n          return ctx.innerValue = $event;\n        })(\"blur\", function MbscDropdown_Template_select_blur_3_listener($event) {\n          return ctx.onTouch($event);\n        });\n        ɵngcc0.ɵɵprojection(5);\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(6, MbscDropdown_span_6_Template, 2, 1, \"span\", 3);\n        ɵngcc0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"mbsc-err\", ctx.error)(\"mbsc-input-box\", ctx.inputStyle == \"box\")(\"mbsc-input-outline\", ctx.inputStyle == \"outline\")(\"mbsc-label-stacked\", ctx.labelStyle == \"stacked\")(\"mbsc-label-inline\", ctx.labelStyle == \"inline\")(\"mbsc-label-floating\", ctx.labelStyle == \"floating\");\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵtextInterpolate1(\" \", ctx.label, \" \");\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngModel\", ctx.innerValue)(\"disabled\", ctx.disabled);\n        ɵngcc0.ɵɵattribute(\"name\", ctx.name)(\"data-icon\", ctx.icon ? ctx.icon : null)(\"data-icon-align\", ctx.iconAlign ? ctx.iconAlign : null);\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.error && ctx.errorMessage);\n      }\n    },\n    directives: [ɵngcc1.SelectControlValueAccessor, ɵngcc1.NgControlStatus, ɵngcc1.NgModel, ɵngcc2.NgIf],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscDropdown;\n}(MbscFormValueBase);\n\nvar MbscButton = function (_super) {\n  __extends(MbscButton, _super);\n\n  function MbscButton(hostElem, formService, zone) {\n    var _this = _super.call(this, hostElem, formService, zone) || this;\n\n    _this._flat = false;\n    _this._block = false;\n    _this._outline = false;\n    _this._classesObj = {};\n    _this.type = 'button';\n    return _this;\n  }\n\n  Object.defineProperty(MbscButton.prototype, \"cssClasses\", {\n    get: function () {\n      for (var k in this._classesObj) {\n        delete this._classesObj[k];\n      }\n\n      this._classesObj['mbsc-btn-flat'] = this._flat;\n      this._classesObj['mbsc-btn-block'] = this._block;\n      this._classesObj['mbsc-btn-outline'] = this._outline;\n\n      if (this.classes) {\n        var cssClasses = this.classes.split(' ');\n\n        if (cssClasses.length) {\n          for (var i = 0; i < cssClasses.length; i++) {\n            if (cssClasses[i]) {\n              this._classesObj[cssClasses[i]] = true;\n            }\n          }\n        }\n      }\n\n      if (this.color) {\n        this._classesObj['mbsc-btn-' + this.color] = true;\n      }\n\n      return this._classesObj;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MbscButton.prototype, \"flat\", {\n    set: function (val) {\n      this._flat = emptyOrTrue(val);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MbscButton.prototype, \"block\", {\n    set: function (val) {\n      this._block = emptyOrTrue(val);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MbscButton.prototype, \"outline\", {\n    set: function (val) {\n      this._outline = emptyOrTrue(val);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscButton.prototype.initControl = function () {\n    var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);\n    this.instance = new Button(this._initElem.nativeElement, options);\n  };\n\n  __decorate([Input$1('class'), __metadata(\"design:type\", String)], MbscButton.prototype, \"classes\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscButton.prototype, \"type\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscButton.prototype, \"icon\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], MbscButton.prototype, \"flat\", null);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], MbscButton.prototype, \"block\", null);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], MbscButton.prototype, \"outline\", null);\n\n  MbscButton = __decorate([__param(1, Optional()), __metadata(\"design:paramtypes\", [ElementRef, MbscOptionsService, NgZone])], MbscButton);\n\n  MbscButton.ɵfac = function MbscButton_Factory(t) {\n    return new (t || MbscButton)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  MbscButton.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscButton,\n    selectors: [[\"mbsc-button\"]],\n    inputs: {\n      flat: \"flat\",\n      block: \"block\",\n      outline: \"outline\",\n      classes: [\"class\", \"classes\"],\n      type: \"type\",\n      icon: \"icon\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 3,\n    vars: 5,\n    consts: [[3, \"type\", \"ngClass\", \"disabled\"], [\"initElement\", \"\"]],\n    template: function MbscButton_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"button\", 0, 1);\n        ɵngcc0.ɵɵprojection(2);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"type\", ctx.type)(\"ngClass\", ctx.cssClasses)(\"disabled\", ctx.disabled);\n        ɵngcc0.ɵɵattribute(\"name\", ctx.name)(\"data-icon\", ctx.icon ? ctx.icon : null);\n      }\n    },\n    directives: [ɵngcc2.NgClass],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscButton;\n}(MbscFormBase);\n\nvar MbscCheckbox = function (_super) {\n  __extends(MbscCheckbox, _super);\n\n  function MbscCheckbox(hostElem, cdr, formService, _inputService, control, zone) {\n    var _this = _super.call(this, hostElem, formService, _inputService, control, zone) || this;\n\n    _this.cdr = cdr;\n    _this._colorClass = {};\n    return _this;\n  }\n\n  Object.defineProperty(MbscCheckbox.prototype, \"colorClass\", {\n    get: function () {\n      for (var k in this._colorClass) {\n        delete this._colorClass[k];\n      }\n\n      if (this.color) {\n        this._colorClass['mbsc-checkbox-' + this.color] = true;\n      }\n\n      if (this.error) {\n        this._colorClass['mbsc-err'] = true;\n      }\n\n      return this._colorClass;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscCheckbox.prototype.initControl = function () {\n    var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);\n    this.instance = new CheckBox(this._initElem.nativeElement, options);\n  };\n\n  MbscCheckbox.prototype.writeValue = function (v) {\n    this._value = v;\n    this.cdr.detectChanges();\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscCheckbox.prototype, \"color\", void 0);\n\n  __decorate([Input$1('input-style'), __metadata(\"design:type\", String)], MbscCheckbox.prototype, \"inputStyle\", void 0);\n\n  __decorate([Input$1('label-style'), __metadata(\"design:type\", String)], MbscCheckbox.prototype, \"labelStyle\", void 0);\n\n  MbscCheckbox = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, ChangeDetectorRef, MbscOptionsService, MbscInputService, NgControl, NgZone])], MbscCheckbox);\n\n  MbscCheckbox.ɵfac = function MbscCheckbox_Factory(t) {\n    return new (t || MbscCheckbox)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  MbscCheckbox.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscCheckbox,\n    selectors: [[\"mbsc-checkbox\"]],\n    hostAttrs: [1, \"mbsc-control-ng\"],\n    inputs: {\n      color: \"color\",\n      inputStyle: [\"input-style\", \"inputStyle\"],\n      labelStyle: [\"label-style\", \"labelStyle\"]\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 5,\n    vars: 7,\n    consts: [[3, \"ngClass\"], [\"type\", \"checkbox\", 3, \"disabled\", \"ngModel\", \"ngModelChange\", \"blur\"], [\"initElement\", \"\"], [\"class\", \"mbsc-err-msg\", 4, \"ngIf\"], [1, \"mbsc-err-msg\"]],\n    template: function MbscCheckbox_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"label\", 0)(1, \"input\", 1, 2);\n        ɵngcc0.ɵɵlistener(\"ngModelChange\", function MbscCheckbox_Template_input_ngModelChange_1_listener($event) {\n          return ctx.innerValue = $event;\n        })(\"blur\", function MbscCheckbox_Template_input_blur_1_listener($event) {\n          return ctx.onTouch($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵprojection(3);\n        ɵngcc0.ɵɵtemplate(4, MbscCheckbox_span_4_Template, 2, 1, \"span\", 3);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngClass\", ctx.colorClass);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"disabled\", ctx.disabled)(\"ngModel\", ctx.innerValue);\n        ɵngcc0.ɵɵattribute(\"name\", ctx.name)(\"data-label-style\", ctx.labelStyle)(\"data-input-style\", ctx.inputStyle);\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.error && ctx.errorMessage);\n      }\n    },\n    directives: [ɵngcc2.NgClass, ɵngcc1.CheckboxControlValueAccessor, ɵngcc1.NgControlStatus, ɵngcc1.NgModel, ɵngcc2.NgIf],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscCheckbox;\n}(MbscFormValueBase);\n\nvar MbscSwitch = function (_super) {\n  __extends(MbscSwitch, _super);\n\n  function MbscSwitch(hostElem, zone, _formService, control) {\n    var _this = _super.call(this, hostElem, zone, control, null, null) || this;\n\n    _this._formService = _formService;\n    _this.disabled = false;\n    _this.onChangeEmitter = new EventEmitter();\n    _this._colorClass = {};\n    return _this;\n  }\n\n  Object.defineProperty(MbscSwitch.prototype, \"value\", {\n    set: function (v) {\n      this.setNewValueProxy(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MbscSwitch.prototype, \"colorClass\", {\n    get: function () {\n      for (var k in this._colorClass) {\n        delete this._colorClass[k];\n      }\n\n      if (this.color) {\n        this._colorClass['mbsc-switch-' + this.color] = true;\n      }\n\n      if (this.error) {\n        this._colorClass['mbsc-err'] = true;\n      }\n\n      return this._colorClass;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscSwitch.prototype.setNewValue = function (v) {\n    if (this.instance) {\n      if (this.instance.getVal() !== v) {\n        this.instance.setVal(v, true, false);\n      }\n    }\n  };\n\n  MbscSwitch.prototype.ngOnInit = function () {\n    this._inheritedOptions = this._formService ? this._formService.options : {};\n\n    _super.prototype.ngOnInit.call(this);\n  };\n\n  MbscSwitch.prototype.initControl = function () {\n    var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);\n    this.instance = new Switch(this._initElem.nativeElement, options);\n\n    if (this.initialValue !== undefined) {\n      this.instance.setVal(this.initialValue, true, false);\n    }\n  };\n\n  __decorate([Input$1('options'), __metadata(\"design:type\", Object)], MbscSwitch.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscSwitch.prototype, \"disabled\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscSwitch.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscSwitch.prototype, \"color\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscSwitch.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscSwitch.prototype, \"errorMessage\", void 0);\n\n  __decorate([Input$1('value'), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [Boolean])], MbscSwitch.prototype, \"value\", null);\n\n  __decorate([Output('valueChange'), __metadata(\"design:type\", EventEmitter)], MbscSwitch.prototype, \"onChangeEmitter\", void 0);\n\n  __decorate([ViewChild('initElement', {\n    static: false\n  }), __metadata(\"design:type\", ElementRef)], MbscSwitch.prototype, \"_initElem\", void 0);\n\n  MbscSwitch = __decorate([__param(2, Optional()), __param(3, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, MbscOptionsService, NgControl])], MbscSwitch);\n\n  MbscSwitch.ɵfac = function MbscSwitch_Factory(t) {\n    return new (t || MbscSwitch)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8));\n  };\n\n  MbscSwitch.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscSwitch,\n    selectors: [[\"mbsc-switch\"]],\n    viewQuery: function MbscSwitch_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._initElem = _t.first);\n      }\n    },\n    hostAttrs: [1, \"mbsc-control-ng\"],\n    inputs: {\n      value: \"value\",\n      options: \"options\",\n      disabled: \"disabled\",\n      name: \"name\",\n      color: \"color\",\n      error: \"error\",\n      errorMessage: \"errorMessage\"\n    },\n    outputs: {\n      onChangeEmitter: \"valueChange\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 5,\n    vars: 6,\n    consts: [[3, \"ngClass\"], [\"class\", \"mbsc-err-msg\", 4, \"ngIf\"], [\"type\", \"checkbox\", \"data-role\", \"switch\", 3, \"disabled\", \"blur\"], [\"initElement\", \"\"], [1, \"mbsc-err-msg\"]],\n    template: function MbscSwitch_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"label\", 0);\n        ɵngcc0.ɵɵprojection(1);\n        ɵngcc0.ɵɵtemplate(2, MbscSwitch_span_2_Template, 2, 1, \"span\", 1);\n        ɵngcc0.ɵɵelementStart(3, \"input\", 2, 3);\n        ɵngcc0.ɵɵlistener(\"blur\", function MbscSwitch_Template_input_blur_3_listener($event) {\n          return ctx.onTouch($event);\n        });\n        ɵngcc0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngClass\", ctx.colorClass);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.error && ctx.errorMessage);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"disabled\", ctx.disabled);\n        ɵngcc0.ɵɵattribute(\"name\", ctx.name)(\"data-label-style\", ctx.labelStyle)(\"data-input-style\", ctx.inputStyle);\n      }\n    },\n    directives: [ɵngcc2.NgClass, ɵngcc2.NgIf],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscSwitch;\n}(MbscControlBase);\n\nvar MbscStepper = function (_super) {\n  __extends(MbscStepper, _super);\n\n  function MbscStepper(hostElement, zone, _formService, control) {\n    var _this = _super.call(this, hostElement, zone, control, null, null) || this;\n\n    _this._formService = _formService;\n    _this.min = undefined;\n    _this.max = undefined;\n    _this.step = undefined;\n    _this.val = undefined;\n    _this.disabled = false;\n    _this._colorClass = {};\n    _this.onChangeEmitter = new EventEmitter();\n    return _this;\n  }\n\n  Object.defineProperty(MbscStepper.prototype, \"readonly\", {\n    set: function (val) {\n      this._readonly = emptyOrTrue(val);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MbscStepper.prototype, \"value\", {\n    set: function (v) {\n      this.setNewValueProxy(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MbscStepper.prototype, \"colorClass\", {\n    get: function () {\n      for (var k in this._colorClass) {\n        delete this._colorClass[k];\n      }\n\n      if (this.color) {\n        this._colorClass['mbsc-stepper-' + this.color] = true;\n      }\n\n      return this._colorClass;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscStepper.prototype.setNewValue = function (v) {\n    if (this.instance && this.instance.getVal() !== v) {\n      this.instance.setVal(v, true, false);\n    }\n  };\n\n  MbscStepper.prototype.ngOnInit = function () {\n    this._inheritedOptions = this._formService ? this._formService.options : {};\n\n    _super.prototype.ngOnInit.call(this);\n  };\n\n  MbscStepper.prototype.initControl = function () {\n    var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);\n    this.instance = new Stepper(this._initElem.nativeElement, options);\n\n    if (this.initialValue !== undefined) {\n      this.instance.setVal(this.initialValue, true, false);\n    }\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], MbscStepper.prototype, \"readonly\", null);\n\n  __decorate([Input$1('options'), __metadata(\"design:type\", Object)], MbscStepper.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number), __metadata(\"design:paramtypes\", [Number])], MbscStepper.prototype, \"value\", null);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscStepper.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscStepper.prototype, \"min\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscStepper.prototype, \"max\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscStepper.prototype, \"step\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscStepper.prototype, \"val\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscStepper.prototype, \"disabled\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscStepper.prototype, \"color\", void 0);\n\n  __decorate([Output('valueChange'), __metadata(\"design:type\", EventEmitter)], MbscStepper.prototype, \"onChangeEmitter\", void 0);\n\n  __decorate([ViewChild('initElement', {\n    static: false\n  }), __metadata(\"design:type\", ElementRef)], MbscStepper.prototype, \"_initElem\", void 0);\n\n  MbscStepper = __decorate([__param(2, Optional()), __param(3, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, MbscOptionsService, NgControl])], MbscStepper);\n\n  MbscStepper.ɵfac = function MbscStepper_Factory(t) {\n    return new (t || MbscStepper)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8));\n  };\n\n  MbscStepper.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscStepper,\n    selectors: [[\"mbsc-stepper\"]],\n    viewQuery: function MbscStepper_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._initElem = _t.first);\n      }\n    },\n    hostAttrs: [1, \"mbsc-control-ng\"],\n    inputs: {\n      readonly: \"readonly\",\n      value: \"value\",\n      options: \"options\",\n      name: \"name\",\n      min: \"min\",\n      max: \"max\",\n      step: \"step\",\n      val: \"val\",\n      disabled: \"disabled\",\n      color: \"color\"\n    },\n    outputs: {\n      onChangeEmitter: \"valueChange\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 4,\n    vars: 10,\n    consts: [[3, \"ngClass\"], [\"data-role\", \"stepper\", 3, \"disabled\", \"readonly\"], [\"initElement\", \"\"]],\n    template: function MbscStepper_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵprojection(1);\n        ɵngcc0.ɵɵelement(2, \"input\", 1, 2);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngClass\", ctx.colorClass);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"disabled\", ctx.disabled)(\"readonly\", ctx._readonly);\n        ɵngcc0.ɵɵattribute(\"name\", ctx.name)(\"min\", ctx.min !== undefined ? ctx.min : null)(\"max\", ctx.max !== undefined ? ctx.max : null)(\"step\", ctx.step !== undefined ? ctx.step : null)(\"data-val\", ctx.val ? ctx.val : null)(\"data-label-style\", ctx.labelStyle)(\"data-input-style\", ctx.inputStyle);\n      }\n    },\n    directives: [ɵngcc2.NgClass],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscStepper;\n}(MbscControlBase);\n\nvar MbscProgress = function (_super) {\n  __extends(MbscProgress, _super);\n\n  function MbscProgress(hostElement, zone, _formService, control) {\n    var _this = _super.call(this, hostElement, zone, control, null, null) || this;\n\n    _this._formService = _formService;\n    _this.max = undefined;\n    _this.icon = undefined;\n    _this.iconAlign = undefined;\n    _this.val = undefined;\n    _this.disabled = false;\n    _this._colorClass = {};\n    return _this;\n  }\n\n  Object.defineProperty(MbscProgress.prototype, \"value\", {\n    set: function (v) {\n      this.setNewValueProxy(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MbscProgress.prototype, \"dataStepLabels\", {\n    get: function () {\n      if (typeof this.stepLabels === 'string') {\n        return this.stepLabels;\n      } else {\n        return null;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MbscProgress.prototype, \"colorClass\", {\n    get: function () {\n      for (var k in this._colorClass) {\n        delete this._colorClass[k];\n      }\n\n      if (this.color) {\n        this._colorClass['mbsc-progress-' + this.color] = true;\n      }\n\n      return this._colorClass;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscProgress.prototype.setNewValue = function (v) {\n    if (this.instance && this.instance.getVal() !== v) {\n      this.instance.setVal(v, true, false);\n    }\n  };\n\n  MbscProgress.prototype.ngOnInit = function () {\n    this._inheritedOptions = this._formService ? this._formService.options : {};\n\n    _super.prototype.ngOnInit.call(this);\n  };\n\n  MbscProgress.prototype.initControl = function () {\n    var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);\n    this.instance = new Progress(this._initElem.nativeElement, options);\n\n    if (this.initialValue !== undefined) {\n      this.instance.setVal(this.initialValue, true, false);\n    }\n  };\n\n  __decorate([Input$1('options'), __metadata(\"design:type\", Object)], MbscProgress.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number), __metadata(\"design:paramtypes\", [Number])], MbscProgress.prototype, \"value\", null);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscProgress.prototype, \"max\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscProgress.prototype, \"icon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscProgress.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscProgress.prototype, \"val\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscProgress.prototype, \"disabled\", void 0);\n\n  __decorate([Input$1('step-labels'), __metadata(\"design:type\", Array)], MbscProgress.prototype, \"stepLabels\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscProgress.prototype, \"color\", void 0);\n\n  __decorate([ViewChild('initElement', {\n    static: false\n  }), __metadata(\"design:type\", ElementRef)], MbscProgress.prototype, \"_initElem\", void 0);\n\n  MbscProgress = __decorate([__param(2, Optional()), __param(3, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, MbscOptionsService, NgControl])], MbscProgress);\n\n  MbscProgress.ɵfac = function MbscProgress_Factory(t) {\n    return new (t || MbscProgress)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8));\n  };\n\n  MbscProgress.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscProgress,\n    selectors: [[\"mbsc-progress\"]],\n    viewQuery: function MbscProgress_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._initElem = _t.first);\n      }\n    },\n    hostAttrs: [1, \"mbsc-control-ng\"],\n    inputs: {\n      value: \"value\",\n      options: \"options\",\n      max: \"max\",\n      icon: \"icon\",\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      val: \"val\",\n      disabled: \"disabled\",\n      stepLabels: [\"step-labels\", \"stepLabels\"],\n      color: \"color\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 4,\n    vars: 8,\n    consts: [[3, \"ngClass\"], [\"initElement\", \"\"]],\n    template: function MbscProgress_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"label\", 0);\n        ɵngcc0.ɵɵprojection(1);\n        ɵngcc0.ɵɵelement(2, \"progress\", null, 1);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngClass\", ctx.colorClass);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵattribute(\"data-step-labels\", ctx.dataStepLabels)(\"data-icon\", ctx.icon ? ctx.icon : null)(\"data-icon-align\", ctx.iconAlign ? ctx.iconAlign : null)(\"data-label-style\", ctx.labelStyle)(\"data-input-style\", ctx.inputStyle)(\"max\", ctx.max !== undefined ? ctx.max : null)(\"data-val\", ctx.val !== undefined ? ctx.val : null);\n      }\n    },\n    directives: [ɵngcc2.NgClass],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscProgress;\n}(MbscControlBase);\n\nvar groupName = 1;\n\nvar MbscRadioService = function () {\n  function MbscRadioService() {\n    this._lastValue = null;\n    this._valueObservable = new Observable();\n  }\n\n  Object.defineProperty(MbscRadioService.prototype, \"name\", {\n    get: function () {\n      if (!this._name) {\n        this._name = 'mbsc-radio-group-' + groupName++;\n      }\n\n      return this._name;\n    },\n    set: function (n) {\n      this._name = n;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MbscRadioService.prototype, \"multiSelect\", {\n    get: function () {\n      return this._multiSelect;\n    },\n    set: function (v) {\n      this._multiSelect = v;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscRadioService.prototype.onValueChanged = function () {\n    return this._valueObservable;\n  };\n\n  MbscRadioService.prototype.changeValue = function (v) {\n    this._valueObservable.next(v);\n\n    this._lastValue = v;\n  };\n\n  Object.defineProperty(MbscRadioService.prototype, \"getLastValue\", {\n    get: function () {\n      return this._lastValue;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MbscRadioService.prototype, \"color\", {\n    get: function () {\n      return this._color;\n    },\n    set: function (v) {\n      this._color = v;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscRadioService.ɵfac = function MbscRadioService_Factory(t) {\n    return new (t || MbscRadioService)();\n  };\n\n  MbscRadioService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: MbscRadioService,\n    factory: function (t) {\n      return MbscRadioService.ɵfac(t);\n    }\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscRadioService;\n}();\n\nvar MbscRadioGroupBase = function (_super) {\n  __extends(MbscRadioGroupBase, _super);\n\n  function MbscRadioGroupBase(hostElement, formService, _inputService, _radioService, control, zone) {\n    var _this = _super.call(this, hostElement, formService, _inputService, control, zone) || this;\n\n    _this._radioService = _radioService;\n    _this.valueObserver = _this._radioService.onValueChanged().subscribe(function (v) {\n      _this.innerValue = v;\n\n      _this.onTouch();\n    });\n    return _this;\n  }\n\n  Object.defineProperty(MbscRadioGroupBase.prototype, \"value\", {\n    set: function (v) {\n      this._value = v;\n\n      this._radioService.changeValue(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscRadioGroupBase.prototype.ngOnInit = function () {\n    _super.prototype.ngOnInit.call(this);\n\n    if (this.name) {\n      this._radioService.name = this.name;\n    }\n\n    if (this.color) {\n      this._radioService.color = this.color;\n    }\n  };\n\n  MbscRadioGroupBase.prototype.writeValue = function (v) {\n    this._value = v;\n\n    this._radioService.changeValue(v);\n  };\n\n  MbscRadioGroupBase.prototype.updateOptions = function () {};\n\n  MbscRadioGroupBase.prototype.ngOnDestroy = function () {\n    this._radioService.onValueChanged().unsubscribe(this.valueObserver);\n\n    _super.prototype.ngOnDestroy.call(this);\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscRadioGroupBase.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], MbscRadioGroupBase.prototype, \"value\", null);\n\n  MbscRadioGroupBase = __decorate([__param(1, Optional()), __param(2, Optional()), __metadata(\"design:paramtypes\", [ElementRef, MbscOptionsService, MbscInputService, MbscRadioService, NgControl, NgZone])], MbscRadioGroupBase);\n\n  MbscRadioGroupBase.ɵfac = function MbscRadioGroupBase_Factory(t) {\n    return new (t || MbscRadioGroupBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscRadioService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  MbscRadioGroupBase.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscRadioGroupBase,\n    selectors: [[\"\", \"mbsc-rg-b\", \"\"]],\n    inputs: {\n      value: \"value\",\n      name: \"name\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscRadioGroupBase;\n}(MbscFormValueBase);\n\nvar MbscRadioGroup = function (_super) {\n  __extends(MbscRadioGroup, _super);\n\n  function MbscRadioGroup(hostElement, formService, _inputService, radioService, control, zone) {\n    return _super.call(this, hostElement, formService, _inputService, radioService, control, zone) || this;\n  }\n\n  MbscRadioGroup = __decorate([__param(1, Optional()), __param(2, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, MbscOptionsService, MbscInputService, MbscRadioService, NgControl, NgZone])], MbscRadioGroup);\n\n  MbscRadioGroup.ɵfac = function MbscRadioGroup_Factory(t) {\n    return new (t || MbscRadioGroup)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscRadioService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  MbscRadioGroup.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscRadioGroup,\n    selectors: [[\"mbsc-radio-group\"]],\n    features: [ɵngcc0.ɵɵProvidersFeature([MbscRadioService]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscRadioGroup_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscRadioGroup;\n}(MbscRadioGroupBase);\n\nvar MbscRadio = function (_super) {\n  __extends(MbscRadio, _super);\n\n  function MbscRadio(hostElement, formService, _radioService, zone) {\n    var _this = _super.call(this, hostElement, formService, zone) || this;\n\n    _this._radioService = _radioService;\n    _this._colorClass = {};\n    var v = _this._radioService.getLastValue;\n\n    if (v !== null) {\n      _this.modelValue = v;\n    }\n\n    _this.valueObserver = _this._radioService.onValueChanged().subscribe(function (v) {\n      _this.modelValue = v;\n    });\n    return _this;\n  }\n\n  Object.defineProperty(MbscRadio.prototype, \"checked\", {\n    get: function () {\n      return this.value == this.modelValue;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MbscRadio.prototype, \"colorClass\", {\n    get: function () {\n      for (var k in this._colorClass) {\n        delete this._colorClass[k];\n      }\n\n      if (this.color) {\n        this._colorClass['mbsc-radio-' + this.color] = true;\n      }\n\n      if (this.error) {\n        this._colorClass['mbsc-err'] = true;\n      }\n\n      return this._colorClass;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscRadio.prototype.clicked = function (e) {\n    this._radioService.changeValue(this.value);\n  };\n\n  MbscRadio.prototype.initControl = function () {\n    var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);\n    this.instance = new Radio(this._initElem.nativeElement, options);\n  };\n\n  MbscRadio.prototype.ngOnInit = function () {\n    _super.prototype.ngOnInit.call(this);\n\n    this.name = this._radioService.name;\n    this.color = this._radioService.color;\n  };\n\n  MbscRadio.prototype.ngOnDestroy = function () {\n    this._radioService.onValueChanged().unsubscribe(this.valueObserver);\n\n    _super.prototype.ngOnDestroy.call(this);\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscRadio.prototype, \"value\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscRadio.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscRadio.prototype, \"errorMessage\", void 0);\n\n  MbscRadio = __decorate([__param(1, Optional()), __metadata(\"design:paramtypes\", [ElementRef, MbscOptionsService, MbscRadioService, NgZone])], MbscRadio);\n\n  MbscRadio.ɵfac = function MbscRadio_Factory(t) {\n    return new (t || MbscRadio)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(MbscRadioService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  MbscRadio.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscRadio,\n    selectors: [[\"mbsc-radio\"]],\n    hostAttrs: [1, \"mbsc-control-ng\"],\n    inputs: {\n      value: \"value\",\n      error: \"error\",\n      errorMessage: \"errorMessage\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 5,\n    vars: 7,\n    consts: [[3, \"ngClass\"], [\"type\", \"radio\", 3, \"value\", \"checked\", \"disabled\", \"click\"], [\"initElement\", \"\"], [\"class\", \"mbsc-err-msg\", 4, \"ngIf\"], [1, \"mbsc-err-msg\"]],\n    template: function MbscRadio_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"label\", 0)(1, \"input\", 1, 2);\n        ɵngcc0.ɵɵlistener(\"click\", function MbscRadio_Template_input_click_1_listener($event) {\n          return ctx.clicked($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵprojection(3);\n        ɵngcc0.ɵɵtemplate(4, MbscRadio_span_4_Template, 2, 1, \"span\", 3);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngClass\", ctx.colorClass);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"value\", ctx.value)(\"checked\", ctx.checked)(\"disabled\", ctx.disabled);\n        ɵngcc0.ɵɵattribute(\"name\", ctx.name)(\"value\", ctx.value);\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.error && ctx.errorMessage);\n      }\n    },\n    directives: [ɵngcc2.NgClass, ɵngcc2.NgIf],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscRadio;\n}(MbscFormBase);\n\nvar MbscSegmentedGroup = function (_super) {\n  __extends(MbscSegmentedGroup, _super);\n\n  function MbscSegmentedGroup(hostElement, formService, _inputService, radioService, control, zone) {\n    var _this = _super.call(this, hostElement, formService, _inputService, radioService, control, zone) || this;\n\n    _this.select = 'single';\n    return _this;\n  }\n\n  Object.defineProperty(MbscSegmentedGroup.prototype, \"multiSelect\", {\n    get: function () {\n      return this.select == 'multiple';\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscSegmentedGroup.prototype.ngOnInit = function () {\n    _super.prototype.ngOnInit.call(this);\n\n    this._radioService.multiSelect = this.multiSelect;\n\n    if (this.color) {\n      this._radioService.color = this.color;\n    }\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscSegmentedGroup.prototype, \"select\", void 0);\n\n  MbscSegmentedGroup = __decorate([__param(1, Optional()), __param(2, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, MbscOptionsService, MbscInputService, MbscRadioService, NgControl, NgZone])], MbscSegmentedGroup);\n\n  MbscSegmentedGroup.ɵfac = function MbscSegmentedGroup_Factory(t) {\n    return new (t || MbscSegmentedGroup)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscRadioService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  MbscSegmentedGroup.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscSegmentedGroup,\n    selectors: [[\"mbsc-segmented-group\"]],\n    inputs: {\n      select: \"select\"\n    },\n    features: [ɵngcc0.ɵɵProvidersFeature([MbscRadioService]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 2,\n    vars: 0,\n    consts: [[1, \"mbsc-segmented\", \"mbsc-no-touch\"]],\n    template: function MbscSegmentedGroup_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵprojection(1);\n        ɵngcc0.ɵɵelementEnd();\n      }\n    },\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscSegmentedGroup;\n}(MbscRadioGroupBase);\n\nvar MbscSegmented = function (_super) {\n  __extends(MbscSegmented, _super);\n\n  function MbscSegmented(hostElement, formService, _radioService, zone) {\n    var _this = _super.call(this, hostElement, formService, zone) || this;\n\n    _this._radioService = _radioService;\n    _this.checkedChange = new EventEmitter();\n    var v = _this._radioService.getLastValue;\n\n    if (v !== null) {\n      _this.modelValue = v;\n    }\n\n    _this.valueObserver = _this._radioService.onValueChanged().subscribe(function (v) {\n      _this.modelValue = v;\n    });\n    return _this;\n  }\n\n  Object.defineProperty(MbscSegmented.prototype, \"isChecked\", {\n    get: function () {\n      if (this.multiSelect) {\n        if (this.checked !== undefined) {\n          return this.checked;\n        } else {\n          return this.modelValue && this.modelValue.includes(this.value);\n        }\n      } else {\n        return this.value == this.modelValue;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscSegmented.prototype.clicked = function (e) {\n    if (this.multiSelect && this.checked !== undefined) {\n      this.checkedChange.emit(!!!this.checked);\n    } else {\n      if (this.multiSelect) {\n        if (this.modelValue.includes(this.value)) {\n          var i = this.modelValue.indexOf(this.value);\n          this.modelValue.splice(i, 1);\n        } else {\n          this.modelValue.push(this.value);\n        }\n\n        this._radioService.changeValue(this.modelValue);\n      } else {\n        this._radioService.changeValue(this.value);\n      }\n    }\n  };\n\n  Object.defineProperty(MbscSegmented.prototype, \"cssClass\", {\n    get: function () {\n      var cl = 'mbsc-segmented-item';\n\n      if (this.color) {\n        cl += ' mbsc-segmented-' + this.color;\n      }\n\n      return cl;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscSegmented.prototype.initControl = function () {\n    var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);\n    this.instance = new SegmentedItem(this._initElem.nativeElement, options);\n  };\n\n  MbscSegmented.prototype.ngOnInit = function () {\n    _super.prototype.ngOnInit.call(this);\n\n    this.name = this._radioService.name;\n    this.multiSelect = this._radioService.multiSelect;\n    this.color = this._radioService.color;\n  };\n\n  MbscSegmented.prototype.ngOnDestroy = function () {\n    this._radioService.onValueChanged().unsubscribe(this.valueObserver);\n\n    _super.prototype.ngOnDestroy.call(this);\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscSegmented.prototype, \"icon\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscSegmented.prototype, \"value\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscSegmented.prototype, \"checked\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscSegmented.prototype, \"checkedChange\", void 0);\n\n  MbscSegmented = __decorate([__param(1, Optional()), __metadata(\"design:paramtypes\", [ElementRef, MbscOptionsService, MbscRadioService, NgZone])], MbscSegmented);\n\n  MbscSegmented.ɵfac = function MbscSegmented_Factory(t) {\n    return new (t || MbscSegmented)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(MbscRadioService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  MbscSegmented.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscSegmented,\n    selectors: [[\"mbsc-segmented\"]],\n    hostVars: 2,\n    hostBindings: function MbscSegmented_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassMap(ctx.cssClass);\n      }\n    },\n    inputs: {\n      icon: \"icon\",\n      value: \"value\",\n      checked: \"checked\"\n    },\n    outputs: {\n      checkedChange: \"checkedChange\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 6,\n    vars: 8,\n    consts: [[1, \"mbsc-segmented-item-ready\"], [\"data-role\", \"segmented\", 3, \"type\", \"value\", \"checked\", \"disabled\", \"click\"], [\"initElement\", \"\"], [1, \"mbsc-segmented-content\"], [3, \"class\", 4, \"ngIf\"]],\n    template: function MbscSegmented_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"label\", 0)(1, \"input\", 1, 2);\n        ɵngcc0.ɵɵlistener(\"click\", function MbscSegmented_Template_input_click_1_listener($event) {\n          return ctx.clicked($event);\n        });\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵelementStart(3, \"span\", 3);\n        ɵngcc0.ɵɵtemplate(4, MbscSegmented_span_4_Template, 1, 3, \"span\", 4);\n        ɵngcc0.ɵɵprojection(5);\n        ɵngcc0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"type\", ctx.multiSelect ? \"checkbox\" : \"radio\")(\"value\", ctx.value)(\"checked\", ctx.isChecked)(\"disabled\", ctx.disabled);\n        ɵngcc0.ɵɵattribute(\"name\", ctx.name)(\"value\", ctx.value)(\"data-icon\", ctx.icon ? ctx.icon : null);\n        ɵngcc0.ɵɵadvance(3);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.icon);\n      }\n    },\n    directives: [ɵngcc2.NgIf],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscSegmented;\n}(MbscFormBase);\n\nvar MbscSlider = function (_super) {\n  __extends(MbscSlider, _super);\n\n  function MbscSlider(hostElement, _formService, zone, control) {\n    var _this = _super.call(this, hostElement, zone, control, null, null) || this;\n\n    _this._formService = _formService;\n    _this._dummy = undefined;\n    _this._needsTimeout = false;\n    _this.disabled = false;\n    _this._colorClass = {};\n    _this.onChangeEmitter = new EventEmitter();\n    return _this;\n  }\n\n  Object.defineProperty(MbscSlider.prototype, \"isMulti\", {\n    get: function () {\n      return this._lastValue instanceof Array;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MbscSlider.prototype, \"dummyArray\", {\n    get: function () {\n      if (!this._dummy || this.isMulti && this._lastValue && this._lastValue.length && this._dummy.length !== this._lastValue.length) {\n        this._dummy = Array(this.isMulti ? this._lastValue.length : 1).fill(0).map(function (x, i) {\n          return i;\n        });\n      }\n\n      return this._dummy;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MbscSlider.prototype, \"dataStepLabels\", {\n    get: function () {\n      if (typeof this.stepLabels === 'string') {\n        return this.stepLabels;\n      } else {\n        return null;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MbscSlider.prototype, \"value\", {\n    set: function (v) {\n      this.setNewValueProxy(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MbscSlider.prototype, \"colorClass\", {\n    get: function () {\n      for (var k in this._colorClass) {\n        delete this._colorClass[k];\n      }\n\n      if (this.color) {\n        this._colorClass['mbsc-slider-' + this.color] = true;\n      }\n\n      return this._colorClass;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscSlider.prototype.reInitialize = function () {\n    var _this = this;\n\n    this.instance.destroy();\n    this.setElement();\n    this.inputElements.forEach(function (input, index) {\n      if (index) {\n        _this.handleChange(input.nativeElement);\n      }\n    });\n    var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);\n    this.instance = new Slider(this.inputElements.first.nativeElement, options);\n  };\n\n  MbscSlider.prototype.setNewValue = function (v) {\n    var _this = this;\n\n    this._lastValue = v;\n\n    if (this.instance) {\n      var innerValue = this.instance.getVal();\n\n      if (this.isMulti && (!innerValue || innerValue.length != v.length)) {\n        setTimeout(function () {\n          _this.reInitialize();\n\n          _this.instance.setVal(_this._lastValue, true, false);\n        });\n      } else {\n        var changed = this.isMulti && !deepEqualsArray(innerValue, v) || !this.isMulti && innerValue !== v;\n\n        if (changed) {\n          this.instance.setVal(v, true, false);\n        }\n      }\n    }\n  };\n\n  MbscSlider.prototype.ngOnInit = function () {\n    this._inheritedOptions = this._formService ? this._formService.options : {};\n\n    _super.prototype.ngOnInit.call(this);\n  };\n\n  MbscSlider.prototype.initControl = function () {\n    var _this = this;\n\n    this.inputElements.forEach(function (input, index) {\n      if (index) {\n        _this.handleChange(input.nativeElement);\n      }\n    });\n    var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);\n    this.instance = new Slider(this.inputElements.first.nativeElement, options);\n\n    if (this.initialValue !== undefined && this.initialValue !== null) {\n      this.instance.setVal(this.initialValue, true, false);\n    }\n  };\n\n  __decorate([Input$1('options'), __metadata(\"design:type\", Object)], MbscSlider.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscSlider.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscSlider.prototype, \"tooltip\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscSlider.prototype, \"highlight\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscSlider.prototype, \"live\", void 0);\n\n  __decorate([Input$1('value-template'), __metadata(\"design:type\", String)], MbscSlider.prototype, \"valueTemplate\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscSlider.prototype, \"icon\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscSlider.prototype, \"val\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscSlider.prototype, \"max\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscSlider.prototype, \"min\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscSlider.prototype, \"step\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscSlider.prototype, \"disabled\", void 0);\n\n  __decorate([Input$1('step-labels'), __metadata(\"design:type\", Object)], MbscSlider.prototype, \"stepLabels\", void 0);\n\n  __decorate([Input$1('value'), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], MbscSlider.prototype, \"value\", null);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscSlider.prototype, \"color\", void 0);\n\n  __decorate([Output('valueChange'), __metadata(\"design:type\", EventEmitter)], MbscSlider.prototype, \"onChangeEmitter\", void 0);\n\n  __decorate([ViewChildren('inputElements'), __metadata(\"design:type\", QueryList)], MbscSlider.prototype, \"inputElements\", void 0);\n\n  MbscSlider = __decorate([__param(1, Optional()), __param(3, Optional()), __metadata(\"design:paramtypes\", [ElementRef, MbscOptionsService, NgZone, NgControl])], MbscSlider);\n\n  MbscSlider.ɵfac = function MbscSlider_Factory(t) {\n    return new (t || MbscSlider)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8));\n  };\n\n  MbscSlider.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscSlider,\n    selectors: [[\"mbsc-slider\"]],\n    viewQuery: function MbscSlider_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c3, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputElements = _t);\n      }\n    },\n    hostAttrs: [1, \"mbsc-control-ng\"],\n    inputs: {\n      value: \"value\",\n      options: \"options\",\n      name: \"name\",\n      tooltip: \"tooltip\",\n      highlight: \"highlight\",\n      live: \"live\",\n      valueTemplate: [\"value-template\", \"valueTemplate\"],\n      icon: \"icon\",\n      val: \"val\",\n      max: \"max\",\n      min: \"min\",\n      step: \"step\",\n      disabled: \"disabled\",\n      stepLabels: [\"step-labels\", \"stepLabels\"],\n      color: \"color\"\n    },\n    outputs: {\n      onChangeEmitter: \"valueChange\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 3,\n    vars: 2,\n    consts: [[3, \"ngClass\"], [\"type\", \"range\", 3, \"disabled\", \"blur\", 4, \"ngFor\", \"ngForOf\"], [\"type\", \"range\", 3, \"disabled\", \"blur\"], [\"inputElements\", \"\"]],\n    template: function MbscSlider_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"label\", 0);\n        ɵngcc0.ɵɵprojection(1);\n        ɵngcc0.ɵɵtemplate(2, MbscSlider_input_2_Template, 2, 15, \"input\", 1);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngClass\", ctx.colorClass);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngForOf\", ctx.dummyArray);\n      }\n    },\n    directives: [ɵngcc2.NgClass, ɵngcc2.NgForOf],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscSlider;\n}(MbscControlBase);\n\nvar MbscRating = function (_super) {\n  __extends(MbscRating, _super);\n\n  function MbscRating(hostElem, zone, formService, control) {\n    var _this = _super.call(this, hostElem, zone, control, null, null) || this;\n\n    _this.formService = formService;\n    _this.min = undefined;\n    _this.max = undefined;\n    _this.step = undefined;\n    _this.disabled = false;\n    _this.val = undefined;\n    _this.onChangeEmitter = new EventEmitter();\n    _this._colorClass = {};\n    return _this;\n  }\n\n  Object.defineProperty(MbscRating.prototype, \"readonly\", {\n    set: function (val) {\n      this._readonly = emptyOrTrue(val);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MbscRating.prototype, \"value\", {\n    set: function (v) {\n      this.setNewValueProxy(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MbscRating.prototype, \"colorClass\", {\n    get: function () {\n      for (var k in this._colorClass) {\n        delete this._colorClass[k];\n      }\n\n      if (this.color) {\n        this._colorClass['mbsc-rating-' + this.color] = true;\n      }\n\n      return this._colorClass;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscRating.prototype.setNewValue = function (v) {\n    if (this.instance) {\n      if (this.instance.getVal() !== v) {\n        this.instance.setVal(v, true, false);\n      }\n    }\n  };\n\n  MbscRating.prototype.ngOnInit = function () {\n    this._inheritedOptions = this.formService ? this.formService.options : {};\n\n    _super.prototype.ngOnInit.call(this);\n  };\n\n  MbscRating.prototype.initControl = function () {\n    var options = extend$1({}, this._inheritedOptions, this.options, this.inlineOptionsObj);\n    this.instance = new Rating(this.element, options);\n\n    if (this.initialValue !== undefined) {\n      this.instance.setVal(this.initialValue, true, false);\n    }\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscRating.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscRating.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscRating.prototype, \"min\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscRating.prototype, \"max\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscRating.prototype, \"step\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscRating.prototype, \"disabled\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscRating.prototype, \"empty\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscRating.prototype, \"filled\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], MbscRating.prototype, \"readonly\", null);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscRating.prototype, \"val\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscRating.prototype, \"template\", void 0);\n\n  __decorate([Input$1('value'), __metadata(\"design:type\", Number), __metadata(\"design:paramtypes\", [Number])], MbscRating.prototype, \"value\", null);\n\n  __decorate([Output('valueChange'), __metadata(\"design:type\", EventEmitter)], MbscRating.prototype, \"onChangeEmitter\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscRating.prototype, \"color\", void 0);\n\n  MbscRating = __decorate([__param(2, Optional()), __param(3, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, MbscOptionsService, NgControl])], MbscRating);\n\n  MbscRating.ɵfac = function MbscRating_Factory(t) {\n    return new (t || MbscRating)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8));\n  };\n\n  MbscRating.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscRating,\n    selectors: [[\"mbsc-rating\"]],\n    hostAttrs: [1, \"mbsc-control-ng\"],\n    inputs: {\n      readonly: \"readonly\",\n      value: \"value\",\n      options: \"options\",\n      name: \"name\",\n      min: \"min\",\n      max: \"max\",\n      step: \"step\",\n      disabled: \"disabled\",\n      empty: \"empty\",\n      filled: \"filled\",\n      val: \"val\",\n      template: \"template\",\n      color: \"color\"\n    },\n    outputs: {\n      onChangeEmitter: \"valueChange\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 3,\n    vars: 13,\n    consts: [[3, \"ngClass\"], [\"type\", \"rating\", \"data-role\", \"rating\", 3, \"disabled\", \"readonly\", \"blur\"]],\n    template: function MbscRating_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"label\", 0);\n        ɵngcc0.ɵɵprojection(1);\n        ɵngcc0.ɵɵelementStart(2, \"input\", 1);\n        ɵngcc0.ɵɵlistener(\"blur\", function MbscRating_Template_input_blur_2_listener($event) {\n          return ctx.onTouch($event);\n        });\n        ɵngcc0.ɵɵelementEnd()();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngClass\", ctx.colorClass);\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"disabled\", ctx.disabled)(\"readonly\", ctx._readonly);\n        ɵngcc0.ɵɵattribute(\"name\", ctx.name)(\"min\", ctx.min !== undefined ? ctx.min : null)(\"max\", ctx.max !== undefined ? ctx.max : null)(\"step\", ctx.step !== undefined ? ctx.step : null)(\"data-val\", ctx.val ? ctx.val : null)(\"data-template\", ctx.template ? ctx.template : null)(\"data-empty\", ctx.empty)(\"data-filled\", ctx.filled)(\"data-label-style\", ctx.labelStyle)(\"data-input-style\", ctx.inputStyle);\n      }\n    },\n    directives: [ɵngcc2.NgClass],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscRating;\n}(MbscControlBase);\n\nvar MbscFormGroup = function () {\n  function MbscFormGroup(initialElem) {\n    this.initialElem = initialElem;\n    this.collapsible = null;\n    this._open = false;\n    this.instance = null;\n    this.element = null;\n    this.element = initialElem;\n  }\n\n  Object.defineProperty(MbscFormGroup.prototype, \"open\", {\n    set: function (v) {\n      if (this._open != v && this.instance) {\n        if (v) {\n          this.instance.show();\n        } else {\n          this.instance.hide();\n        }\n      }\n\n      this._open = v;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscFormGroup.prototype.emptyOrTrue = function (v) {\n    return emptyOrTrue(v);\n  };\n\n  MbscFormGroup.prototype.ngAfterViewInit = function () {\n    if (this.collapsible !== null) {\n      this.instance = new CollapsibleBase(this.element.nativeElement, {\n        isOpen: this._open !== false\n      });\n    }\n  };\n\n  MbscFormGroup.prototype.ngOnDestroy = function () {\n    if (this.instance) {\n      this.instance.destroy();\n    }\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscFormGroup.prototype, \"collapsible\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [Boolean])], MbscFormGroup.prototype, \"open\", null);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscFormGroup.prototype, \"inset\", void 0);\n\n  MbscFormGroup = __decorate([__metadata(\"design:paramtypes\", [ElementRef])], MbscFormGroup);\n\n  MbscFormGroup.ɵfac = function MbscFormGroup_Factory(t) {\n    return new (t || MbscFormGroup)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MbscFormGroup.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscFormGroup,\n    selectors: [[\"mbsc-form-group\"]],\n    hostVars: 4,\n    hostBindings: function MbscFormGroup_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"mbsc-form-group-inset\", ctx.emptyOrTrue(ctx.inset))(\"mbsc-form-group\", !ctx.emptyOrTrue(ctx.inset));\n      }\n    },\n    inputs: {\n      collapsible: \"collapsible\",\n      open: \"open\",\n      inset: \"inset\"\n    },\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscFormGroup_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%] { display: block; }\"]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscFormGroup;\n}();\n\nvar MbscFormGroupTitle = function () {\n  function MbscFormGroupTitle() {}\n\n  MbscFormGroupTitle.ɵfac = function MbscFormGroupTitle_Factory(t) {\n    return new (t || MbscFormGroupTitle)();\n  };\n\n  MbscFormGroupTitle.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscFormGroupTitle,\n    selectors: [[\"mbsc-form-group-title\"]],\n    hostVars: 2,\n    hostBindings: function MbscFormGroupTitle_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"mbsc-form-group-title\", true);\n      }\n    },\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscFormGroupTitle_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%] { display: block; }\"]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscFormGroupTitle;\n}();\n\nvar MbscFormGroupContent = function () {\n  function MbscFormGroupContent() {}\n\n  MbscFormGroupContent.ɵfac = function MbscFormGroupContent_Factory(t) {\n    return new (t || MbscFormGroupContent)();\n  };\n\n  MbscFormGroupContent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscFormGroupContent,\n    selectors: [[\"mbsc-form-group-content\"]],\n    hostVars: 2,\n    hostBindings: function MbscFormGroupContent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"mbsc-form-group-content\", true);\n      }\n    },\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscFormGroupContent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%] { display: block; }\"]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscFormGroupContent;\n}();\n\nvar MbscAccordion = function () {\n  function MbscAccordion() {}\n\n  MbscAccordion.ɵfac = function MbscAccordion_Factory(t) {\n    return new (t || MbscAccordion)();\n  };\n\n  MbscAccordion.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscAccordion,\n    selectors: [[\"mbsc-accordion\"]],\n    hostVars: 2,\n    hostBindings: function MbscAccordion_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"mbsc-accordion\", true);\n      }\n    },\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscAccordion_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%] { display: block; }\"]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscAccordion;\n}();\n\nvar comp$3 = [MbscForm, MbscTextarea, MbscDropdown, MbscButton, MbscCheckbox, MbscSwitch, MbscStepper, MbscProgress, MbscRadioGroup, MbscRadioGroupBase, MbscRadio, MbscSegmentedGroup, MbscSegmented, MbscSlider, MbscRating, MbscFormGroup, MbscFormGroupTitle, MbscFormGroupContent, MbscAccordion];\n\nvar MbscFormsModule = function () {\n  function MbscFormsModule() {}\n\n  MbscFormsModule.ɵfac = function MbscFormsModule_Factory(t) {\n    return new (t || MbscFormsModule)();\n  };\n\n  MbscFormsModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscFormsModule\n  });\n  MbscFormsModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[FormsModule, CommonModule, MbscBaseModule, MbscInputModule], MbscInputModule]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscFormsModule, {\n      declarations: function () {\n        return [MbscForm, MbscTextarea, MbscDropdown, MbscButton, MbscCheckbox, MbscSwitch, MbscStepper, MbscProgress, MbscRadioGroup, MbscRadioGroupBase, MbscRadio, MbscSegmentedGroup, MbscSegmented, MbscSlider, MbscRating, MbscFormGroup, MbscFormGroupTitle, MbscFormGroupContent, MbscAccordion];\n      },\n      imports: function () {\n        return [FormsModule, CommonModule, MbscBaseModule, MbscInputModule];\n      },\n      exports: function () {\n        return [MbscForm, MbscTextarea, MbscDropdown, MbscButton, MbscCheckbox, MbscSwitch, MbscStepper, MbscProgress, MbscRadioGroup, MbscRadioGroupBase, MbscRadio, MbscSegmentedGroup, MbscSegmented, MbscSlider, MbscRating, MbscFormGroup, MbscFormGroupTitle, MbscFormGroupContent, MbscAccordion, MbscInputModule, MbscInput];\n      }\n    });\n  })();\n\n  return MbscFormsModule;\n}();\n\nvar defaults$5 = {\n  invalid: [],\n  showInput: true,\n  inputClass: '',\n  itemSelector: 'li'\n};\n\nvar List = function List(inst) {\n  var currLevel,\n      input,\n      prevent,\n      w,\n      orig = extend$1({}, inst.settings),\n      s = extend$1(inst.settings, defaults$5, orig),\n      layout = s.layout || (/top|bottom/.test(s.display) ? 'liquid' : ''),\n      isLiquid = layout == 'liquid',\n      origReadOnly = s.readonly,\n      elm = $$1(this),\n      id = this.id + '_dummy',\n      lvl = 0,\n      currWheelVector = [],\n      wa = s.wheelArray || createWheelArray(elm),\n      fwv = firstWheelVector(wa);\n\n  function getDepth(tree, l) {\n    var i;\n    lvl = l > lvl ? l : lvl;\n\n    for (i = 0; i < tree.length; i++) {\n      if (tree[i].children) {\n        getDepth(tree[i].children, l + 1);\n      }\n    }\n  }\n  /**\r\n   * Disables the invalid items on the wheels\r\n   * @param {Object} dw - the jQuery mobiscroll object\r\n   * @param {Number} nrWheels - the number of the current wheels\r\n   * @param {Array} whArray - The wheel array objects containing the wheel tree\r\n   * @param {Array} whVector - the wheel vector containing the current keys\r\n   */\n\n\n  function getDisabled(nrWheels, whArray, whVector) {\n    var i = 0,\n        disabled = [];\n\n    while (i < nrWheels) {\n      disabled[i] = getInvalidKeys(whVector, i, whArray);\n      i++;\n    }\n\n    return disabled;\n  }\n  /**\r\n   * Returns the invalid keys of one wheel as an array\r\n   * @param {Array} whVector - the wheel vector used to search for the wheel in the wheel array\r\n   * @param {Number} index - index of the wheel in the wheel vector, that we are interested in\r\n   * @param {Array} whArray - the wheel array we are searching in\r\n   * @return {Array} - list of invalid keys\r\n   */\n\n\n  function getInvalidKeys(whVector, index, whArray) {\n    var i = 0,\n        n,\n        whObjA = whArray,\n        invalids = [];\n\n    while (i < index) {\n      var ii = whVector[i];\n\n      for (n in whObjA) {\n        if (whObjA[n].key == ii) {\n          whObjA = whObjA[n].children;\n          break;\n        }\n      }\n\n      i++;\n    }\n\n    i = 0;\n\n    while (i < whObjA.length) {\n      if (whObjA[i].invalid) {\n        invalids.push(whObjA[i].key);\n      }\n\n      i++;\n    }\n\n    return invalids;\n  }\n  /**\r\n   * Creates a Boolean vector with true values (except one) that can be used as the readonly vector\r\n   * n - the length of the vector\r\n   * i - the index of the value that's going to be false\r\n   */\n\n\n  function createROVector(n, i) {\n    var a = [];\n\n    while (n) {\n      a[--n] = true;\n    }\n\n    a[i] = false;\n    return a;\n  }\n  /**\r\n   * Creates the wheel array from the vector provided\r\n   * wv - wheel vector containing the values that should be selected on the wheels\r\n   * l - the length of the wheel array\r\n   */\n\n\n  function generateWheelsFromVector(wv, l, index) {\n    var nextLevel,\n        j,\n        i = 0,\n        hasChildren = true,\n        w = [[]],\n        wtObjA = wa;\n\n    if (l) {\n      // if length is defined we need to generate that many wheels (even if they are empty)\n      for (j = 0; j < l; j++) {\n        if (isLiquid) {\n          w[0][j] = {};\n        } else {\n          w[j] = [{}];\n        }\n      }\n    }\n\n    while (hasChildren) {\n      if (isLiquid) {\n        w[0][i] = getWheelFromObjA(wtObjA, i);\n      } else {\n        w[i] = [getWheelFromObjA(wtObjA, i)];\n      }\n\n      j = 0;\n      nextLevel = null;\n\n      while (j < wtObjA.length && !nextLevel) {\n        if (wtObjA[j].key == wv[i] && (index !== undefined && i <= index || index === undefined)) {\n          nextLevel = wtObjA[j];\n        }\n\n        j++;\n      }\n\n      if (!nextLevel) {\n        nextLevel = getFirstValidItemObjOrInd(wtObjA);\n      }\n\n      if (nextLevel && nextLevel.children) {\n        wtObjA = nextLevel.children;\n        i++;\n      } else {\n        hasChildren = false;\n      }\n    }\n\n    return w;\n  }\n  /**\r\n   * Returns the first valid Wheel Node Object or its index from a Wheel Node Object Array\r\n   * getInd - if it is true then the return value is going to be the index, otherwise the object itself\r\n   */\n\n\n  function getFirstValidItemObjOrInd(wtObjA, getInd) {\n    if (!wtObjA) {\n      return false;\n    }\n\n    var i = 0,\n        obj;\n\n    while (i < wtObjA.length) {\n      if (!(obj = wtObjA[i++]).invalid) {\n        return getInd ? i - 1 : obj;\n      }\n    }\n\n    return false;\n  }\n\n  function getWheelFromObjA(objA, i) {\n    var wheel = {\n      data: [],\n      label: s.labels && s.labels[i] ? s.labels[i] : i\n    },\n        j = 0;\n\n    while (j < objA.length) {\n      wheel.data.push({\n        value: objA[j].key,\n        display: objA[j].value\n      });\n      j++;\n    }\n\n    return wheel;\n  }\n  /**\r\n   * Hides the last i number of wheels\r\n   * i - the last number of wheels that has to be hidden\r\n   */\n\n\n  function hideWheels(i) {\n    if (inst._isVisible) {\n      $$1('.mbsc-sc-whl-w', inst._markup).css('display', '').slice(i).hide();\n    }\n  }\n  /**\r\n   * Generates the first wheel vector from the wheeltree\r\n   * wt - the wheel tree object\r\n   * uses the lvl global variable to determine the length of the vector\r\n   */\n\n\n  function firstWheelVector(wa) {\n    var t = [],\n        ndObjA = wa,\n        obj,\n        ok = true,\n        i = 0;\n\n    while (ok) {\n      obj = getFirstValidItemObjOrInd(ndObjA);\n      t[i++] = obj.key;\n      ok = obj.children;\n\n      if (ok) {\n        ndObjA = ok;\n      }\n    }\n\n    return t;\n  }\n  /**\r\n   * Calculates the level of a wheel vector and the new wheel vector, depending on current wheel vector and the index of the changed wheel\r\n   * wv - current wheel vector\r\n   * index - index of the changed wheel\r\n   */\n\n\n  function calcLevelOfVector2(wv, index) {\n    var childIdx,\n        childName,\n        i,\n        level = 0,\n        ndObjA = wa,\n        next = true,\n        t = [];\n\n    while (next) {\n      if (wv[level] !== undefined && level <= index) {\n        i = 0;\n        childName = wv[level];\n        childIdx = undefined;\n\n        while (i < ndObjA.length && childIdx === undefined) {\n          if (ndObjA[i].key == wv[level] && !ndObjA[i].invalid) {\n            childIdx = i;\n          }\n\n          i++;\n        }\n      } else {\n        childIdx = getFirstValidItemObjOrInd(ndObjA, true);\n        childName = ndObjA[childIdx] && ndObjA[childIdx].key;\n      }\n\n      t[level] = childName;\n      level++;\n      next = ndObjA[childIdx] ? ndObjA[childIdx].children : false;\n      ndObjA = ndObjA[childIdx] && ndObjA[childIdx].children;\n    } // return the calculated level and the wheel vector as an object\n\n\n    return {\n      lvl: level,\n      nVector: t\n    };\n  }\n\n  function createWheelArray(ul) {\n    var wheelArray = [];\n    var children = ul.length > 1 ? ul : ul.children(s.itemSelector);\n    children.each(function (index) {\n      var that = $$1(this),\n          c = that.clone();\n      c.children('ul,ol').remove();\n      c.children(s.itemSelector).remove();\n      var v = inst._processMarkup ? inst._processMarkup(c) : c.html().replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, ''),\n          inv = that.attr('data-invalid') ? true : false,\n          wheelObj = {\n        key: that.attr('data-val') === undefined || that.attr('data-val') === null ? index : that.attr('data-val'),\n        value: v,\n        invalid: inv,\n        children: null\n      },\n          nest = s.itemSelector === 'li' ? that.children('ul,ol') : that.children(s.itemSelector);\n\n      if (nest.length) {\n        wheelObj.children = createWheelArray(nest);\n      }\n\n      wheelArray.push(wheelObj);\n    });\n    return wheelArray;\n  }\n\n  function changeWheels(values, index, o) {\n    var j,\n        i = (index || 0) + 1,\n        args = [],\n        w = {},\n        wheels = {};\n    w = generateWheelsFromVector(values, null, index);\n\n    for (j = 0; j < values.length; j++) {\n      inst._tempWheelArray[j] = values[j] = o.nVector[j] || 0;\n    }\n\n    while (i < o.lvl) {\n      wheels[i] = isLiquid ? w[0][i] : w[i][0];\n      args.push(i++);\n    }\n\n    hideWheels(o.lvl);\n    currWheelVector = values.slice(0);\n\n    if (args.length) {\n      prevent = true;\n      inst.changeWheel(wheels);\n    }\n  } // Calculate the maximum depth of the tree\n\n\n  getDepth(wa, 1);\n  w = generateWheelsFromVector(fwv, lvl); // Remove input if exists\n\n  $$1('#' + id).remove();\n\n  if (s.input) {\n    input = $$1(s.input);\n  } else if (s.showInput) {\n    input = $$1('<input type=\"text\" id=\"' + id + '\" value=\"\" class=\"' + s.inputClass + '\" placeholder=\"' + (s.placeholder || '') + '\" readonly />').insertBefore(elm);\n  }\n\n  if (input) {\n    inst.attachShow(input);\n  }\n\n  if (!s.wheelArray) {\n    elm.hide();\n  }\n\n  return {\n    wheels: w,\n    anchor: input,\n    layout: layout,\n    headerText: false,\n    setOnTap: lvl == 1,\n    formatValue: function formatValue(d) {\n      if (currLevel === undefined) {\n        currLevel = calcLevelOfVector2(d, d.length).lvl;\n      }\n\n      return d.slice(0, currLevel).join(' ');\n    },\n    parseValue: function parseValue(value) {\n      return value ? (value + '').split(' ') : (s.defaultValue || fwv).slice(0);\n    },\n    onBeforeShow: function onBeforeShow() {\n      var t = inst.getArrayVal(true);\n      currWheelVector = t.slice(0);\n      s.wheels = generateWheelsFromVector(t, lvl, lvl);\n      prevent = true;\n    },\n    onWheelGestureStart: function onWheelGestureStart(ev) {\n      s.readonly = createROVector(lvl, ev.index);\n    },\n    onWheelAnimationEnd: function onWheelAnimationEnd(ev) {\n      var index = ev.index,\n          values = inst.getArrayVal(true),\n          o = calcLevelOfVector2(values, index);\n      currLevel = o.lvl;\n      s.readonly = origReadOnly;\n\n      if (values[index] != currWheelVector[index]) {\n        changeWheels(values, index, o);\n      }\n    },\n    onFill: function onFill(ev) {\n      currLevel = undefined;\n\n      if (input) {\n        input.val(ev.valueText);\n      }\n    },\n    validate: function validate(data) {\n      var values = data.values,\n          index = data.index,\n          o = calcLevelOfVector2(values, values.length);\n      currLevel = o.lvl;\n\n      if (index === undefined) {\n        hideWheels(o.lvl);\n\n        if (!prevent) {\n          changeWheels(values, index, o);\n        }\n      }\n\n      prevent = false;\n      return {\n        disabled: getDisabled(currLevel, wa, values)\n      };\n    },\n    onDestroy: function onDestroy() {\n      if (input) {\n        $$1('#' + id).remove();\n      }\n\n      elm.show();\n    }\n  };\n};\n\nvar ImageScroller = Scroller;\n\npresets.image = function (inst) {\n  if (inst.settings.enhance) {\n    inst._processMarkup = function (li) {\n      var hasIcon = li.attr('data-icon');\n      li.children().each(function (i, v) {\n        v = $$1(v);\n\n        if (v.is('img')) {\n          $$1('<div class=\"mbsc-img-c\"></div>').insertAfter(v).append(v.addClass('mbsc-img'));\n        } else if (v.is('p')) {\n          v.addClass('mbsc-img-txt');\n        }\n      });\n\n      if (hasIcon) {\n        li.prepend('<div class=\"mbsc-ic mbsc-ic-' + hasIcon + '\"></div');\n      }\n\n      li.html('<div class=\"mbsc-img-w\">' + li.html() + '</div>');\n      return li.html();\n    };\n  }\n\n  return List.call(this, inst);\n};\n\nvar MbscImage = function (_super) {\n  __extends(MbscImage, _super);\n\n  function MbscImage(initialElement, zone, control, inputService, optionService, view) {\n    var _this = _super.call(this, initialElement, zone, control, inputService, view) || this;\n\n    _this.optionService = optionService;\n    _this.enhance = true;\n    _this.placeholder = '';\n    _this.options = {};\n    _this.onChangeEmitter = new EventEmitter();\n    return _this;\n  }\n\n  Object.defineProperty(MbscImage.prototype, \"value\", {\n    set: function (v) {\n      this.setNewValueProxy(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscImage.prototype.initControl = function () {\n    var _this = this;\n\n    var target = this.target;\n\n    if (target) {\n      if (typeof target !== 'string') {\n        if (target._elementRef && target._elementRef.nativeElement) {\n          target = target._elementRef.nativeElement;\n        } else if (target.getInputElement) {\n          target.getInputElement().then(function (inp) {\n            _this.updateOptions({\n              input: inp\n            }, true, false, false);\n          });\n        } else if (target.element) {\n          target = target.element;\n        }\n      }\n    }\n\n    var options = extend$1({\n      preset: 'image',\n      input: target\n    }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);\n    this.instance = new ImageScroller(this.element, options);\n\n    if (this.initialValue !== undefined) {\n      this.instance.setVal(this.initialValue, true, false);\n    }\n  };\n\n  MbscImage.prototype.setNewValue = function (v) {\n    if (this.instance && this.instance.getVal() !== v) {\n      this.instance.setVal(v, true, false);\n\n      if (this._inputService && this._inputService.input) {\n        this._inputService.input.innerValue = this.instance._value;\n      }\n    }\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscImage.prototype, \"defaultValue\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscImage.prototype, \"enhance\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscImage.prototype, \"inputClass\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscImage.prototype, \"invalid\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscImage.prototype, \"labels\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscImage.prototype, \"placeholder\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscImage.prototype, \"showInput\", void 0);\n\n  __decorate([Input$1('mbsc-data'), __metadata(\"design:type\", Array)], MbscImage.prototype, \"wheelArray\", void 0);\n\n  __decorate([Input$1('mbsc-options'), __metadata(\"design:type\", Object)], MbscImage.prototype, \"options\", void 0);\n\n  __decorate([Input$1('mbsc-target'), __metadata(\"design:type\", Object)], MbscImage.prototype, \"target\", void 0);\n\n  __decorate([Input$1('mbsc-image'), __metadata(\"design:type\", String), __metadata(\"design:paramtypes\", [String])], MbscImage.prototype, \"value\", null);\n\n  __decorate([Output('mbsc-imageChange'), __metadata(\"design:type\", EventEmitter)], MbscImage.prototype, \"onChangeEmitter\", void 0);\n\n  MbscImage = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscImage);\n\n  MbscImage.ɵfac = function MbscImage_Factory(t) {\n    return new (t || MbscImage)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscImage.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscImage,\n    selectors: [[\"\", \"mbsc-image\", \"\"]],\n    inputs: {\n      value: [\"mbsc-image\", \"value\"],\n      defaultValue: \"defaultValue\",\n      enhance: \"enhance\",\n      inputClass: \"inputClass\",\n      invalid: \"invalid\",\n      labels: \"labels\",\n      placeholder: \"placeholder\",\n      showInput: \"showInput\",\n      wheelArray: [\"mbsc-data\", \"wheelArray\"],\n      options: [\"mbsc-options\", \"options\"],\n      target: [\"mbsc-target\", \"target\"]\n    },\n    outputs: {\n      onChangeEmitter: \"mbsc-imageChange\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscImage;\n}(MbscScrollerBase);\n\nvar MbscImageComponent = function (_super) {\n  __extends(MbscImageComponent, _super);\n\n  function MbscImageComponent(initialElem, zone, listService, control, inputService, optionService) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;\n\n    _this.listService = listService;\n    _this.errorMessage = '';\n    _this.label = '';\n    _this.placeholder = '';\n    _this.showInput = false;\n    _this.inlineOptionsObj = {\n      itemSelector: 'mbsc-image-item',\n      showInput: false\n    };\n    return _this;\n  }\n\n  MbscImageComponent.prototype.setElement = function () {\n    if (this.itemWrapper) {\n      this.element = this.itemWrapper.nativeElement;\n    } else {\n      this.element = this.initialElem.nativeElement;\n    }\n  };\n\n  MbscImageComponent.prototype.ngOnInit = function () {\n    var _this = this;\n\n    _super.prototype.ngOnInit.call(this);\n\n    this.addRemoveHandler = this.listService.onAddRemove().subscribe(function (item) {\n      if (_this.instance) {\n        _this.instance.option({});\n      }\n    });\n  };\n\n  MbscImageComponent.prototype.ngAfterViewInit = function () {\n    _super.prototype.ngAfterViewInit.call(this);\n\n    this.setThemeClasses();\n  };\n\n  MbscImageComponent.prototype.initControl = function () {\n    if (!this.target) {\n      this.target = $$1('mbsc-input', this.initialElem.nativeElement)[0];\n    }\n\n    _super.prototype.initControl.call(this);\n  };\n\n  MbscImageComponent.prototype.ngOnDestroy = function () {\n    this.listService.onAddRemove().unsubscribe(this.addRemoveHandler);\n\n    _super.prototype.ngOnDestroy.call(this);\n  };\n\n  __decorate([Input$1('icon'), __metadata(\"design:type\", String)], MbscImageComponent.prototype, \"inputIcon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscImageComponent.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscImageComponent.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscImageComponent.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscImageComponent.prototype, \"errorMessage\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscImageComponent.prototype, \"options\", void 0);\n\n  __decorate([Input$1('data'), __metadata(\"design:type\", Array)], MbscImageComponent.prototype, \"wheelArray\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscImageComponent.prototype, \"label\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscImageComponent.prototype, \"placeholder\", void 0);\n\n  __decorate([ViewChild('itemWrapper', {\n    static: false\n  }), __metadata(\"design:type\", ElementRef)], MbscImageComponent.prototype, \"itemWrapper\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscImageComponent.prototype, \"showInput\", void 0);\n\n  MbscImageComponent = __decorate([__param(3, Optional()), __param(4, Optional()), __param(5, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, MbscListService, NgControl, MbscInputService, MbscOptionsService])], MbscImageComponent);\n\n  MbscImageComponent.ɵfac = function MbscImageComponent_Factory(t) {\n    return new (t || MbscImageComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscListService), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscImageComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscImageComponent,\n    selectors: [[\"mbsc-image\"]],\n    viewQuery: function MbscImageComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c4, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.itemWrapper = _t.first);\n      }\n    },\n    inputs: {\n      inputIcon: [\"icon\", \"inputIcon\"],\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      name: \"name\",\n      error: \"error\",\n      errorMessage: \"errorMessage\",\n      options: \"options\",\n      wheelArray: [\"data\", \"wheelArray\"],\n      label: \"label\",\n      placeholder: \"placeholder\",\n      showInput: \"showInput\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([MbscListService]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 4,\n    vars: 1,\n    consts: [[3, \"name\", \"theme\", \"disabled\", \"error\", \"errorMessage\", \"icon\", \"icon-align\", \"placeholder\", \"controlNg\", 4, \"ngIf\"], [\"itemWrapper\", \"\"], [3, \"name\", \"theme\", \"disabled\", \"error\", \"errorMessage\", \"icon\", \"icon-align\", \"placeholder\", \"controlNg\"]],\n    template: function MbscImageComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MbscImageComponent_mbsc_input_0_Template, 2, 10, \"mbsc-input\", 0);\n        ɵngcc0.ɵɵelementStart(1, \"span\", null, 1);\n        ɵngcc0.ɵɵprojection(3);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.inline || ctx.showInput);\n      }\n    },\n    directives: [ɵngcc2.NgIf, MbscInput],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscImageComponent;\n}(MbscImage);\n\nvar MbscImageItem = function () {\n  function MbscImageItem(listService) {\n    this.listService = listService;\n  }\n\n  MbscImageItem.prototype.ngAfterViewInit = function () {\n    this.listService.notifyAddRemove(this);\n  };\n\n  MbscImageItem.prototype.ngOnDestroy = function () {\n    this.listService.notifyAddRemove(this);\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscImageItem.prototype, \"value\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscImageItem.prototype, \"icon\", void 0);\n\n  MbscImageItem = __decorate([__metadata(\"design:paramtypes\", [MbscListService])], MbscImageItem);\n\n  MbscImageItem.ɵfac = function MbscImageItem_Factory(t) {\n    return new (t || MbscImageItem)(ɵngcc0.ɵɵdirectiveInject(MbscListService));\n  };\n\n  MbscImageItem.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscImageItem,\n    selectors: [[\"mbsc-image-item\"]],\n    hostVars: 2,\n    hostBindings: function MbscImageItem_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"data-val\", ctx.value)(\"data-icon\", ctx.icon);\n      }\n    },\n    inputs: {\n      value: \"value\",\n      icon: \"icon\"\n    },\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscImageItem_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscImageItem;\n}();\n\nvar MbscImageModule = function () {\n  function MbscImageModule() {}\n\n  MbscImageModule.ɵfac = function MbscImageModule_Factory(t) {\n    return new (t || MbscImageModule)();\n  };\n\n  MbscImageModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscImageModule\n  });\n  MbscImageModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, MbscScrollerBaseModule, MbscInputModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscImageModule, {\n      declarations: function () {\n        return [MbscImage, MbscImageComponent, MbscImageItem];\n      },\n      imports: function () {\n        return [CommonModule, MbscScrollerBaseModule, MbscInputModule];\n      },\n      exports: function () {\n        return [MbscImage, MbscImageComponent, MbscImageItem];\n      }\n    });\n  })();\n\n  return MbscImageModule;\n}();\n\nvar Measurement = Scroller;\nvar defaults$6 = {\n  batch: 50,\n  min: 0,\n  max: 100,\n  defaultUnit: '',\n  units: null,\n  unitNames: null,\n  invalid: [],\n  sign: false,\n  step: 0.05,\n  scale: 2,\n  convert: function convert(val) {\n    return val;\n  },\n  // Localization\n  decimalSeparator: '.',\n  signText: '&nbsp;',\n  wholeText: 'Whole',\n  fractionText: 'Fraction',\n  unitText: 'Unit'\n};\n\npresets.measurement = function (inst) {\n  var orig = extend$1({}, inst.settings),\n      s = extend$1(inst.settings, defaults$6, orig),\n      wheel = {},\n      w = [[]],\n      wholeInvalids = {},\n      wholeWheel = {},\n      fractionWheel = {},\n      fractions = [],\n      useSign = s.sign,\n      useUnits = s.units && s.units.length,\n      baseUnit = useUnits ? s.defaultUnit || s.units[0] : '',\n      units = [],\n      useFract = s.step < 1,\n      wholeStep = s.step > 1 ? s.step : 1,\n      fractLength = useFract ? Math.max(s.scale, (s.step + '').split('.')[1].length) : 1,\n      one = Math.pow(10, fractLength),\n      steps = Math.round(useFract ? s.step * one : s.step),\n      fractNr,\n      realValue,\n      oldUnit,\n      idxFract,\n      idxWhole,\n      idxUnit,\n      minVal,\n      maxVal,\n      minWhole,\n      maxWhole,\n      minFract,\n      maxFract,\n      wholeOffset = 0,\n      fractOffset = 0,\n      v,\n      j,\n      i = 0;\n\n  function getWhole(k) {\n    return Math.max(minWhole, Math.min(maxWhole, useFract ? k < 0 ? Math.ceil(k) : Math.floor(k) : step(Math.round(k - wholeOffset), steps) + wholeOffset));\n  }\n\n  function getFract(k) {\n    return useFract ? step((Math.abs(k) - Math.abs(getWhole(k))) * one - fractOffset, steps) + fractOffset : 0;\n  }\n\n  function getParts(v) {\n    var whole = getWhole(v),\n        fract = getFract(v),\n        sign = v < 0 ? '-' : '+';\n\n    if (fract >= one) {\n      if (v < 0) {\n        whole--;\n      } else {\n        whole++;\n      }\n\n      fract = 0;\n    }\n\n    return [sign, whole, fract];\n  }\n\n  function getNr(d) {\n    var whole = +d[idxWhole],\n        fract = useFract ? d[idxFract] / one * (whole < 0 ? -1 : 1) : 0;\n    return (useSign && d[0] == '-' ? -1 : 1) * (whole + fract);\n  }\n\n  function step(v, st) {\n    return Math.round(v / st) * st;\n  }\n\n  function convert(v, u1, u2) {\n    if (u1 === u2 || !s.convert) {\n      return v;\n    }\n\n    return s.convert.call(this, v, u1, u2);\n  }\n\n  function setMinMax(unit) {\n    var minv, maxv;\n    minVal = convert(s.min, baseUnit, unit);\n    maxVal = convert(s.max, baseUnit, unit);\n\n    if (useFract) {\n      minWhole = minVal < 0 ? Math.ceil(minVal) : Math.floor(minVal);\n      maxWhole = maxVal < 0 ? Math.ceil(maxVal) : Math.floor(maxVal);\n      minFract = getFract(minVal);\n      maxFract = getFract(maxVal);\n    } else {\n      minWhole = Math.round(minVal);\n      maxWhole = Math.round(maxVal);\n      maxWhole = minWhole + Math.floor((maxWhole - minWhole) / steps) * steps;\n      wholeOffset = minWhole % steps;\n    }\n\n    minv = minWhole;\n    maxv = maxWhole;\n\n    if (useSign) {\n      maxv = Math.abs(minv) > Math.abs(maxv) ? Math.abs(minv) : Math.abs(maxv);\n      minv = minv < 0 ? 0 : minv;\n    }\n\n    wholeWheel.min = minv < 0 ? Math.ceil(minv / wholeStep) : Math.floor(minv / wholeStep);\n    wholeWheel.max = maxv < 0 ? Math.ceil(maxv / wholeStep) : Math.floor(maxv / wholeStep);\n  }\n\n  function format(d) {\n    return getNr(d).toFixed(useFract ? fractLength : 0) + (useUnits ? ' ' + units[d[idxUnit]] : '');\n  } // Extended methods\n  // ---\n\n\n  inst.setVal = function (val, fill, change, temp, time) {\n    // Force parse if value is passed as an array\n    inst._setVal($$1.isArray(val) ? format(val) : val, fill, change, temp, time);\n  }; // ---\n  // Inits\n  // generate array from unitNames\n\n\n  if (s.units) {\n    for (j = 0; j < s.units.length; ++j) {\n      v = s.units[j];\n      units.push(s.unitNames ? s.unitNames[v] || v : v);\n    }\n  } // Check if sign is needed\n\n\n  if (useSign) {\n    useSign = false;\n\n    if (useUnits) {\n      for (j = 0; j < s.units.length; j++) {\n        if (convert(s.min, baseUnit, s.units[j]) < 0) {\n          useSign = true;\n        }\n      }\n    } else {\n      useSign = s.min < 0;\n    }\n  } // Sign wheel (if enabled)\n\n\n  if (useSign) {\n    w[0].push({\n      data: ['-', '+'],\n      label: s.signText\n    });\n    i++;\n  } // Whole wheel (later generated)\n\n\n  wholeWheel = {\n    label: s.wholeText,\n    data: function data(i) {\n      return minWhole % wholeStep + i * wholeStep;\n    },\n    getIndex: function getIndex(i) {\n      return Math.round((i - minWhole % wholeStep) / wholeStep);\n    }\n  };\n  w[0].push(wholeWheel);\n  idxWhole = i++;\n  setMinMax(baseUnit); // Fraction wheel\n\n  if (useFract) {\n    w[0].push(fractionWheel);\n    fractionWheel.data = [];\n    fractionWheel.label = s.fractionText;\n\n    for (j = fractOffset; j < one; j += steps) {\n      fractions.push(j);\n      fractionWheel.data.push({\n        value: j,\n        display: s.decimalSeparator + pad(j, fractLength)\n      });\n    }\n\n    idxFract = i++;\n    fractNr = Math.ceil(100 / steps);\n\n    if (s.invalid && s.invalid.length) {\n      // Calculate whole invalids\n      $$1.each(s.invalid, function (i, v) {\n        var w = v > 0 ? Math.floor(v) : Math.ceil(v);\n\n        if (w === 0) {\n          // We need to track +0 and -0 sepparately\n          w = v <= 0 ? -0.001 : 0.001;\n        }\n\n        wholeInvalids[w] = (wholeInvalids[w] || 0) + 1;\n\n        if (v === 0) {\n          w = 0.001;\n          wholeInvalids[w] = (wholeInvalids[w] || 0) + 1;\n        }\n      });\n      $$1.each(wholeInvalids, function (i, v) {\n        if (v < fractNr) {\n          delete wholeInvalids[i];\n        } else {\n          wholeInvalids[i] = i;\n        }\n      });\n    }\n  } // Unit wheel\n\n\n  if (useUnits) {\n    wheel = {\n      data: [],\n      label: s.unitText,\n      cssClass: 'mbsc-msr-whl-unit',\n      circular: false\n    };\n\n    for (j = 0; j < s.units.length; j++) {\n      wheel.data.push({\n        value: j,\n        display: units[j]\n      });\n    }\n\n    w[0].push(wheel);\n  }\n\n  idxUnit = i;\n  return {\n    wheels: w,\n    minWidth: useSign && useFract ? 70 : 80,\n    showLabel: false,\n    formatValue: format,\n    compClass: 'mbsc-msr mbsc-sc',\n    parseValue: function parseValue(v) {\n      var vv = (typeof v === 'number' ? v + '' : v) || s.defaultValue,\n          d = (vv + '').split(' '),\n          val = +d[0],\n          ret = [],\n          parts,\n          unit = '';\n\n      if (useUnits) {\n        unit = $$1.inArray(d[1], units);\n        unit = unit == -1 ? $$1.inArray(baseUnit, s.units) : unit;\n        unit = unit == -1 ? 0 : unit;\n      }\n\n      oldUnit = useUnits ? s.units[unit] : '';\n      setMinMax(oldUnit);\n      val = isNaN(val) ? 0 : val;\n      val = constrain(val, minVal, maxVal);\n      parts = getParts(val);\n      parts[1] = constrain(parts[1], minWhole, maxWhole);\n      realValue = val;\n\n      if (useSign) {\n        ret[0] = parts[0];\n        parts[1] = Math.abs(parts[1]);\n      }\n\n      ret[idxWhole] = parts[1];\n\n      if (useFract) {\n        ret[idxFract] = parts[2];\n      }\n\n      if (useUnits) {\n        ret[idxUnit] = unit;\n      }\n\n      return ret;\n    },\n    onCancel: function onCancel() {\n      realValue = undefined;\n    },\n    validate: function validate(data) {\n      var minus,\n          parts,\n          whole,\n          iparts,\n          from,\n          values = data.values,\n          index = data.index,\n          dir = data.direction,\n          dis = {},\n          disabled = [],\n          wheels = {},\n          newUnit = useUnits ? s.units[values[idxUnit]] : ''; // Sign changed\n\n      if (useSign && index === 0) {\n        realValue = Math.abs(realValue) * (values[0] == '-' ? -1 : 1);\n      } // Set real value if numbers changed\n\n\n      if (index === idxWhole || index === idxFract && useFract || realValue === undefined || index === undefined) {\n        realValue = getNr(values);\n        oldUnit = newUnit;\n      } // Convert value if unit changed\n\n\n      if (useUnits && index === idxUnit && oldUnit !== newUnit || index === undefined) {\n        setMinMax(newUnit);\n        realValue = convert(realValue, oldUnit, newUnit);\n        oldUnit = newUnit;\n        parts = getParts(realValue);\n\n        if (index !== undefined) {\n          //wholeWheel._refresh();\n          wheels[idxWhole] = wholeWheel;\n          inst.changeWheel(wheels);\n        }\n\n        if (useSign) {\n          values[0] = parts[0];\n        }\n      } // Disable invalid values\n\n\n      disabled[idxWhole] = [];\n\n      if (useSign) {\n        // Disable +/- signs\n        disabled[0] = [];\n\n        if (minVal > 0) {\n          disabled[0].push('-');\n          values[0] = '+';\n        }\n\n        if (maxVal < 0) {\n          disabled[0].push('+');\n          values[0] = '-';\n        }\n\n        from = Math.abs(values[0] == '-' ? minWhole : maxWhole);\n\n        for (i = from + wholeStep; i < from + 20 * wholeStep; i += wholeStep) {\n          disabled[idxWhole].push(i);\n          dis[i] = true;\n        }\n      }\n\n      realValue = constrain(realValue, minVal, maxVal);\n      parts = getParts(realValue);\n      whole = useSign ? Math.abs(parts[1]) : parts[1];\n      minus = useSign ? values[0] == '-' : realValue < 0;\n      values[idxWhole] = whole;\n\n      if (minus) {\n        // Need this for 0\n        parts[0] = '-';\n      }\n\n      if (useFract) {\n        values[idxFract] = parts[2];\n      } // Disable invalid values on whole wheel\n\n\n      $$1.each(useFract ? wholeInvalids : s.invalid, function (i, v) {\n        // disable whole user values\n        if (useSign && minus) {\n          if (v <= 0) {\n            v = Math.abs(v);\n          } else {\n            return;\n          }\n        }\n\n        v = step(convert(v, baseUnit, newUnit), useFract ? 1 : steps);\n        dis[v] = true;\n        disabled[idxWhole].push(v);\n      }); // Find nearest valid whole value\n\n      values[idxWhole] = inst.getValidValue(idxWhole, whole, dir, dis);\n      parts[1] = values[idxWhole] * (useSign && minus ? -1 : 1); // Validate fraction wheel values\n\n      if (useFract) {\n        disabled[idxFract] = []; // We need to make difference between +0 and -0, so we compare the strings instead of numbers\n\n        var p1 = useSign ? values[0] + values[1] : (realValue < 0 ? '-' : '+') + Math.abs(parts[1]),\n            p2 = (minVal < 0 ? '-' : '+') + Math.abs(minWhole),\n            p3 = (maxVal < 0 ? '-' : '+') + Math.abs(maxWhole); // Disable out of range fraction values\n\n        if (p1 === p2) {\n          $$1(fractions).each(function (i, v) {\n            if (minus ? v > minFract : v < minFract) {\n              disabled[idxFract].push(v);\n            }\n          });\n        }\n\n        if (p1 === p3) {\n          $$1(fractions).each(function (i, v) {\n            if (minus ? v < maxFract : v > maxFract) {\n              disabled[idxFract].push(v);\n            }\n          });\n        } // Disable invalid fraction values\n\n\n        $$1.each(s.invalid, function (i, v) {\n          iparts = getParts(convert(v, baseUnit, newUnit)); // Sign and whole part matches\n\n          if ((parts[0] === iparts[0] || parts[1] === 0 && iparts[1] === 0 && iparts[2] === 0) && parts[1] === iparts[1]) {\n            disabled[idxFract].push(iparts[2]);\n          }\n        });\n      }\n\n      return {\n        disabled: disabled,\n        valid: values\n      };\n    }\n  };\n};\n\nvar defaults$7 = {\n  min: -20,\n  max: 40,\n  defaultUnit: 'c',\n  units: ['c', 'k', 'f', 'r'],\n  unitNames: {\n    c: '°C',\n    k: 'K',\n    f: '°F',\n    r: '°R'\n  }\n},\n    cobj = {\n  c2k: function c2k(c) {\n    return c + 273.15;\n  },\n  c2f: function c2f(c) {\n    return c * 9 / 5 + 32;\n  },\n  c2r: function c2r(c) {\n    return (c + 273.15) * 9 / 5;\n  },\n  k2c: function k2c(k) {\n    return k - 273.15;\n  },\n  k2f: function k2f(k) {\n    return k * 9 / 5 - 459.67;\n  },\n  k2r: function k2r(k) {\n    return k * 9 / 5;\n  },\n  f2c: function f2c(f) {\n    return (f - 32) * 5 / 9;\n  },\n  f2k: function f2k(f) {\n    return (f + 459.67) * 5 / 9;\n  },\n  f2r: function f2r(f) {\n    return f + 459.67;\n  },\n  r2c: function r2c(r) {\n    return (r - 491.67) * 5 / 9;\n  },\n  r2k: function r2k(r) {\n    return r * 5 / 9;\n  },\n  r2f: function r2f(r) {\n    return r - 459.67;\n  }\n};\n\npresets.temperature = function (inst) {\n  var s = extend$1({}, defaults$7, inst.settings);\n  extend$1(inst.settings, s, {\n    sign: true,\n    convert: function convert(val, unit1, unit2) {\n      return cobj[unit1 + '2' + unit2](val);\n    }\n  });\n  return presets.measurement.call(this, inst);\n};\n\nvar defaults$8 = {\n  min: 0,\n  max: 100,\n  defaultUnit: 'km',\n  units: ['m', 'km', 'in', 'ft', 'yd', 'mi']\n},\n    cobj$1 = {\n  mm: 0.001,\n  cm: 0.01,\n  dm: 0.1,\n  m: 1,\n  dam: 10,\n  hm: 100,\n  km: 1000,\n  'in': 0.0254,\n  ft: 0.3048,\n  yd: 0.9144,\n  ch: 20.1168,\n  fur: 201.168,\n  mi: 1609.344,\n  lea: 4828.032\n};\n\npresets.distance = function (inst) {\n  var s = extend$1({}, defaults$8, inst.settings);\n  extend$1(inst.settings, s, {\n    sign: false,\n    convert: function convert(val, unit1, unit2) {\n      return val * cobj$1[unit1] / cobj$1[unit2];\n    }\n  });\n  return presets.measurement.call(this, inst);\n};\n\nvar defaults$9 = {\n  min: 0,\n  max: 100,\n  defaultUnit: 'kph',\n  units: ['kph', 'mph', 'mps', 'fps', 'knot'],\n  unitNames: {\n    kph: 'km/h',\n    mph: 'mi/h',\n    mps: 'm/s',\n    fps: 'ft/s',\n    knot: 'knot'\n  }\n},\n    cobj$2 = {\n  kph: 1,\n  mph: 1.60934,\n  mps: 3.6,\n  fps: 1.09728,\n  knot: 1.852\n};\n\npresets.speed = function (inst) {\n  var s = extend$1({}, defaults$9, inst.settings);\n  extend$1(inst.settings, s, {\n    sign: false,\n    convert: function convert(val, unit1, unit2) {\n      return val * cobj$2[unit1] / cobj$2[unit2];\n    }\n  });\n  return presets.measurement.call(this, inst);\n};\n\nvar defaults$a = {\n  min: 0,\n  max: 100,\n  defaultUnit: 'N',\n  units: ['N', 'kp', 'lbf', 'pdl']\n},\n    cobj$3 = {\n  N: 1,\n  kp: 9.80665,\n  lbf: 4.448222,\n  pdl: 0.138255\n};\n\npresets.force = function (inst) {\n  var s = extend$1({}, defaults$a, inst.settings);\n  extend$1(inst.settings, s, {\n    sign: false,\n    convert: function convert(val, unit1, unit2) {\n      return val * cobj$3[unit1] / cobj$3[unit2];\n    }\n  });\n  return presets.measurement.call(this, inst);\n};\n\nvar defaults$b = {\n  min: 0,\n  max: 1000,\n  defaultUnit: 'kg',\n  units: ['g', 'kg', 'oz', 'lb'],\n  unitNames: {\n    tlong: 't (long)',\n    tshort: 't (short)'\n  }\n},\n    cobj$4 = {\n  mg: 0.001,\n  cg: 0.01,\n  dg: 0.1,\n  g: 1,\n  dag: 10,\n  hg: 100,\n  kg: 1000,\n  t: 1000000,\n  drc: 1.7718452,\n  oz: 28.3495,\n  lb: 453.59237,\n  st: 6350.29318,\n  qtr: 12700.58636,\n  cwt: 50802.34544,\n  tlong: 1016046.9088,\n  tshort: 907184.74\n};\n\npresets.mass = function (inst) {\n  var s = extend$1({}, defaults$b, inst.settings);\n  extend$1(inst.settings, s, {\n    sign: false,\n    convert: function convert(val, unit1, unit2) {\n      return val * cobj$4[unit1] / cobj$4[unit2];\n    }\n  });\n  return presets.measurement.call(this, inst);\n};\n\nvar MbscMeasurementBase = function (_super) {\n  __extends(MbscMeasurementBase, _super);\n\n  function MbscMeasurementBase(initialElement, zone, control, inputService, optionService, view) {\n    var _this = _super.call(this, initialElement, zone, control, inputService, view) || this;\n\n    _this.optionService = optionService;\n    _this.preset = 'measurement';\n    _this.onChangeEmitter = new EventEmitter();\n    return _this;\n  }\n\n  Object.defineProperty(MbscMeasurementBase.prototype, \"value\", {\n    set: function (v) {\n      this.setNewValueProxy(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscMeasurementBase.prototype.setNewValue = function (v) {\n    if (this.instance) {\n      var innerValue = this.instance.getVal();\n\n      if (innerValue !== v) {\n        this.instance.setVal(v, true, false);\n\n        if (this._inputService && this._inputService.input) {\n          this._inputService.input.innerValue = this.instance._value;\n        }\n      }\n    }\n  };\n\n  MbscMeasurementBase.prototype.initControl = function () {\n    var options = extend$1({\n      preset: this.preset\n    }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);\n    this.instance = new Scroller(this.element, options);\n\n    if (this.initialValue !== undefined) {\n      this.instance.setVal(this.initialValue, true, false);\n    }\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscMeasurementBase.prototype, \"max\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscMeasurementBase.prototype, \"min\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscMeasurementBase.prototype, \"decimalSeparator\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscMeasurementBase.prototype, \"defaultValue\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscMeasurementBase.prototype, \"invalid\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscMeasurementBase.prototype, \"scale\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscMeasurementBase.prototype, \"step\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscMeasurementBase.prototype, \"defaultUnit\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscMeasurementBase.prototype, \"unitNames\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscMeasurementBase.prototype, \"units\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscMeasurementBase.prototype, \"wholeText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscMeasurementBase.prototype, \"fractionText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscMeasurementBase.prototype, \"signText\", void 0);\n\n  __decorate([Input$1('mbsc-measurement'), __metadata(\"design:type\", String), __metadata(\"design:paramtypes\", [String])], MbscMeasurementBase.prototype, \"value\", null);\n\n  __decorate([Output('mbsc-measurementChange'), __metadata(\"design:type\", EventEmitter)], MbscMeasurementBase.prototype, \"onChangeEmitter\", void 0);\n\n  MbscMeasurementBase = __decorate([__param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscMeasurementBase);\n\n  MbscMeasurementBase.ɵfac = function MbscMeasurementBase_Factory(t) {\n    return new (t || MbscMeasurementBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl), ɵngcc0.ɵɵdirectiveInject(MbscInputService), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscMeasurementBase.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscMeasurementBase,\n    selectors: [[\"\", \"mbsc-m-b\", \"\"]],\n    inputs: {\n      value: [\"mbsc-measurement\", \"value\"],\n      max: \"max\",\n      min: \"min\",\n      decimalSeparator: \"decimalSeparator\",\n      defaultValue: \"defaultValue\",\n      invalid: \"invalid\",\n      scale: \"scale\",\n      step: \"step\",\n      defaultUnit: \"defaultUnit\",\n      unitNames: \"unitNames\",\n      units: \"units\",\n      wholeText: \"wholeText\",\n      fractionText: \"fractionText\",\n      signText: \"signText\"\n    },\n    outputs: {\n      onChangeEmitter: \"mbsc-measurementChange\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscMeasurementBase;\n}(MbscScrollerBase);\n\nvar MbscMeasurementChild = function (_super) {\n  __extends(MbscMeasurementChild, _super);\n\n  function MbscMeasurementChild(initialElement, zone, control, inputService, optionService, view) {\n    return _super.call(this, initialElement, zone, control, inputService, optionService, view) || this;\n  }\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscMeasurementChild.prototype, \"convert\", void 0);\n\n  MbscMeasurementChild = __decorate([__metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscMeasurementChild);\n\n  MbscMeasurementChild.ɵfac = function MbscMeasurementChild_Factory(t) {\n    return new (t || MbscMeasurementChild)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl), ɵngcc0.ɵɵdirectiveInject(MbscInputService), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscMeasurementChild.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscMeasurementChild,\n    selectors: [[\"\", \"mbsc-m-c\", \"\"]],\n    inputs: {\n      convert: \"convert\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscMeasurementChild;\n}(MbscMeasurementBase);\n\nvar MbscMeasurement = function (_super) {\n  __extends(MbscMeasurement, _super);\n\n  function MbscMeasurement(initialElem, zone, control, inputService, optionService, view) {\n    return _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;\n  }\n\n  __decorate([Input$1(), __metadata(\"design:type\", Function)], MbscMeasurement.prototype, \"convert\", void 0);\n\n  __decorate([Input$1('mbsc-options'), __metadata(\"design:type\", Object)], MbscMeasurement.prototype, \"options\", void 0);\n\n  MbscMeasurement = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscMeasurement);\n\n  MbscMeasurement.ɵfac = function MbscMeasurement_Factory(t) {\n    return new (t || MbscMeasurement)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscMeasurement.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscMeasurement,\n    selectors: [[\"\", \"mbsc-measurement\", \"\"]],\n    inputs: {\n      convert: \"convert\",\n      options: [\"mbsc-options\", \"options\"]\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscMeasurement;\n}(MbscMeasurementBase);\n\nvar MbscMeasurementComponent = function (_super) {\n  __extends(MbscMeasurementComponent, _super);\n\n  function MbscMeasurementComponent(initialElem, zone, control, inputService, optionService) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;\n\n    _this.errorMessage = '';\n    _this.placeholder = '';\n    return _this;\n  }\n\n  MbscMeasurementComponent.prototype.ngAfterViewInit = function () {\n    _super.prototype.ngAfterViewInit.call(this);\n\n    this.setThemeClasses();\n  };\n\n  __decorate([Input$1('icon'), __metadata(\"design:type\", String)], MbscMeasurementComponent.prototype, \"inputIcon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscMeasurementComponent.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscMeasurementComponent.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscMeasurementComponent.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscMeasurementComponent.prototype, \"errorMessage\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscMeasurementComponent.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscMeasurementComponent.prototype, \"placeholder\", void 0);\n\n  MbscMeasurementComponent = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])], MbscMeasurementComponent);\n\n  MbscMeasurementComponent.ɵfac = function MbscMeasurementComponent_Factory(t) {\n    return new (t || MbscMeasurementComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscMeasurementComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscMeasurementComponent,\n    selectors: [[\"mbsc-measurement\"]],\n    inputs: {\n      inputIcon: [\"icon\", \"inputIcon\"],\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      name: \"name\",\n      error: \"error\",\n      errorMessage: \"errorMessage\",\n      options: \"options\",\n      placeholder: \"placeholder\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\", 4, \"ngIf\"], [3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\"]],\n    template: function MbscMeasurementComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MbscMeasurementComponent_mbsc_input_0_Template, 2, 13, \"mbsc-input\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.inline || ctx.showInput);\n      }\n    },\n    directives: [ɵngcc2.NgIf, MbscInput],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscMeasurementComponent;\n}(MbscMeasurement);\n\nvar MbscTemperature = function (_super) {\n  __extends(MbscTemperature, _super);\n\n  function MbscTemperature(initialElem, zone, control, inputService, optionService, view) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;\n\n    _this.options = {};\n    _this.onChangeEmitter = new EventEmitter();\n    _this.preset = 'temperature';\n    return _this;\n  }\n\n  Object.defineProperty(MbscTemperature.prototype, \"value\", {\n    set: function (v) {\n      this.setNewValueProxy(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  __decorate([Input$1('mbsc-options'), __metadata(\"design:type\", Object)], MbscTemperature.prototype, \"options\", void 0);\n\n  __decorate([Input$1('mbsc-temperature'), __metadata(\"design:type\", String), __metadata(\"design:paramtypes\", [String])], MbscTemperature.prototype, \"value\", null);\n\n  __decorate([Output('mbsc-temperatureChange'), __metadata(\"design:type\", EventEmitter)], MbscTemperature.prototype, \"onChangeEmitter\", void 0);\n\n  MbscTemperature = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscTemperature);\n\n  MbscTemperature.ɵfac = function MbscTemperature_Factory(t) {\n    return new (t || MbscTemperature)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscTemperature.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscTemperature,\n    selectors: [[\"\", \"mbsc-temperature\", \"\"]],\n    inputs: {\n      value: [\"mbsc-temperature\", \"value\"],\n      options: [\"mbsc-options\", \"options\"]\n    },\n    outputs: {\n      onChangeEmitter: \"mbsc-temperatureChange\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscTemperature;\n}(MbscMeasurementChild);\n\nvar MbscTemperatureComponent = function (_super) {\n  __extends(MbscTemperatureComponent, _super);\n\n  function MbscTemperatureComponent(initialElem, zone, control, inputService, optionService) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;\n\n    _this.errorMessage = '';\n    _this.placeholder = '';\n    return _this;\n  }\n\n  MbscTemperatureComponent.prototype.ngAfterViewInit = function () {\n    _super.prototype.ngAfterViewInit.call(this);\n\n    this.setThemeClasses();\n  };\n\n  __decorate([Input$1('icon'), __metadata(\"design:type\", String)], MbscTemperatureComponent.prototype, \"inputIcon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscTemperatureComponent.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscTemperatureComponent.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscTemperatureComponent.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscTemperatureComponent.prototype, \"errorMessage\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscTemperatureComponent.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscTemperatureComponent.prototype, \"placeholder\", void 0);\n\n  MbscTemperatureComponent = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])], MbscTemperatureComponent);\n\n  MbscTemperatureComponent.ɵfac = function MbscTemperatureComponent_Factory(t) {\n    return new (t || MbscTemperatureComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscTemperatureComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscTemperatureComponent,\n    selectors: [[\"mbsc-temperature\"]],\n    inputs: {\n      inputIcon: [\"icon\", \"inputIcon\"],\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      name: \"name\",\n      error: \"error\",\n      errorMessage: \"errorMessage\",\n      options: \"options\",\n      placeholder: \"placeholder\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\", 4, \"ngIf\"], [3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\"]],\n    template: function MbscTemperatureComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MbscTemperatureComponent_mbsc_input_0_Template, 2, 13, \"mbsc-input\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.inline || ctx.showInput);\n      }\n    },\n    directives: [ɵngcc2.NgIf, MbscInput],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscTemperatureComponent;\n}(MbscTemperature);\n\nvar MbscDistance = function (_super) {\n  __extends(MbscDistance, _super);\n\n  function MbscDistance(initialElem, zone, control, inputService, optionService, view) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;\n\n    _this.options = {};\n    _this.onChangeEmitter = new EventEmitter();\n    _this.preset = 'distance';\n    return _this;\n  }\n\n  Object.defineProperty(MbscDistance.prototype, \"value\", {\n    set: function (v) {\n      this.setNewValueProxy(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  __decorate([Input$1('mbsc-options'), __metadata(\"design:type\", Object)], MbscDistance.prototype, \"options\", void 0);\n\n  __decorate([Input$1('mbsc-distance'), __metadata(\"design:type\", String), __metadata(\"design:paramtypes\", [String])], MbscDistance.prototype, \"value\", null);\n\n  __decorate([Output('mbsc-distanceChange'), __metadata(\"design:type\", EventEmitter)], MbscDistance.prototype, \"onChangeEmitter\", void 0);\n\n  MbscDistance = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscDistance);\n\n  MbscDistance.ɵfac = function MbscDistance_Factory(t) {\n    return new (t || MbscDistance)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscDistance.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscDistance,\n    selectors: [[\"\", \"mbsc-distance\", \"\"]],\n    inputs: {\n      value: [\"mbsc-distance\", \"value\"],\n      options: [\"mbsc-options\", \"options\"]\n    },\n    outputs: {\n      onChangeEmitter: \"mbsc-distanceChange\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscDistance;\n}(MbscMeasurementBase);\n\nvar MbscDistanceComponent = function (_super) {\n  __extends(MbscDistanceComponent, _super);\n\n  function MbscDistanceComponent(initialElem, zone, control, inputService, optionService) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;\n\n    _this.errorMessage = '';\n    _this.placeholder = '';\n    return _this;\n  }\n\n  MbscDistanceComponent.prototype.ngAfterViewInit = function () {\n    _super.prototype.ngAfterViewInit.call(this);\n\n    this.setThemeClasses();\n  };\n\n  __decorate([Input$1('icon'), __metadata(\"design:type\", String)], MbscDistanceComponent.prototype, \"inputIcon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscDistanceComponent.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDistanceComponent.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscDistanceComponent.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDistanceComponent.prototype, \"errorMessage\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscDistanceComponent.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscDistanceComponent.prototype, \"placeholder\", void 0);\n\n  MbscDistanceComponent = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])], MbscDistanceComponent);\n\n  MbscDistanceComponent.ɵfac = function MbscDistanceComponent_Factory(t) {\n    return new (t || MbscDistanceComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscDistanceComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscDistanceComponent,\n    selectors: [[\"mbsc-distance\"]],\n    inputs: {\n      inputIcon: [\"icon\", \"inputIcon\"],\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      name: \"name\",\n      error: \"error\",\n      errorMessage: \"errorMessage\",\n      options: \"options\",\n      placeholder: \"placeholder\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\", 4, \"ngIf\"], [3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\"]],\n    template: function MbscDistanceComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MbscDistanceComponent_mbsc_input_0_Template, 2, 13, \"mbsc-input\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.inline || ctx.showInput);\n      }\n    },\n    directives: [ɵngcc2.NgIf, MbscInput],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscDistanceComponent;\n}(MbscDistance);\n\nvar MbscSpeed = function (_super) {\n  __extends(MbscSpeed, _super);\n\n  function MbscSpeed(initialElem, zone, control, inputService, optionService, view) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;\n\n    _this.options = {};\n    _this.onChangeEmitter = new EventEmitter();\n    _this.preset = 'speed';\n    return _this;\n  }\n\n  Object.defineProperty(MbscSpeed.prototype, \"value\", {\n    set: function (v) {\n      this.setNewValueProxy(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  __decorate([Input$1('mbsc-options'), __metadata(\"design:type\", Object)], MbscSpeed.prototype, \"options\", void 0);\n\n  __decorate([Input$1('mbsc-speed'), __metadata(\"design:type\", String), __metadata(\"design:paramtypes\", [String])], MbscSpeed.prototype, \"value\", null);\n\n  __decorate([Output('mbsc-speedChange'), __metadata(\"design:type\", EventEmitter)], MbscSpeed.prototype, \"onChangeEmitter\", void 0);\n\n  MbscSpeed = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscSpeed);\n\n  MbscSpeed.ɵfac = function MbscSpeed_Factory(t) {\n    return new (t || MbscSpeed)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscSpeed.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscSpeed,\n    selectors: [[\"\", \"mbsc-speed\", \"\"]],\n    inputs: {\n      value: [\"mbsc-speed\", \"value\"],\n      options: [\"mbsc-options\", \"options\"]\n    },\n    outputs: {\n      onChangeEmitter: \"mbsc-speedChange\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscSpeed;\n}(MbscMeasurementBase);\n\nvar MbscSpeedComponent = function (_super) {\n  __extends(MbscSpeedComponent, _super);\n\n  function MbscSpeedComponent(initialElem, zone, control, inputService, optionService) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;\n\n    _this.errorMessage = '';\n    _this.placeholder = '';\n    return _this;\n  }\n\n  MbscSpeedComponent.prototype.ngAfterViewInit = function () {\n    _super.prototype.ngAfterViewInit.call(this);\n\n    this.setThemeClasses();\n  };\n\n  __decorate([Input$1('icon'), __metadata(\"design:type\", String)], MbscSpeedComponent.prototype, \"inputIcon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscSpeedComponent.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscSpeedComponent.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscSpeedComponent.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscSpeedComponent.prototype, \"errorMessage\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscSpeedComponent.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscSpeedComponent.prototype, \"placeholder\", void 0);\n\n  MbscSpeedComponent = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])], MbscSpeedComponent);\n\n  MbscSpeedComponent.ɵfac = function MbscSpeedComponent_Factory(t) {\n    return new (t || MbscSpeedComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscSpeedComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscSpeedComponent,\n    selectors: [[\"mbsc-speed\"]],\n    inputs: {\n      inputIcon: [\"icon\", \"inputIcon\"],\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      name: \"name\",\n      error: \"error\",\n      errorMessage: \"errorMessage\",\n      options: \"options\",\n      placeholder: \"placeholder\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\", 4, \"ngIf\"], [3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\"]],\n    template: function MbscSpeedComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MbscSpeedComponent_mbsc_input_0_Template, 2, 13, \"mbsc-input\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.inline || ctx.showInput);\n      }\n    },\n    directives: [ɵngcc2.NgIf, MbscInput],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscSpeedComponent;\n}(MbscSpeed);\n\nvar MbscForce = function (_super) {\n  __extends(MbscForce, _super);\n\n  function MbscForce(initialElem, zone, control, inputService, optionService, view) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;\n\n    _this.options = {};\n    _this.onChangeEmitter = new EventEmitter();\n    _this.preset = 'force';\n    return _this;\n  }\n\n  Object.defineProperty(MbscForce.prototype, \"value\", {\n    set: function (v) {\n      this.setNewValueProxy(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  __decorate([Input$1('mbsc-options'), __metadata(\"design:type\", Object)], MbscForce.prototype, \"options\", void 0);\n\n  __decorate([Input$1('mbsc-force'), __metadata(\"design:type\", String), __metadata(\"design:paramtypes\", [String])], MbscForce.prototype, \"value\", null);\n\n  __decorate([Output('mbsc-forceChange'), __metadata(\"design:type\", EventEmitter)], MbscForce.prototype, \"onChangeEmitter\", void 0);\n\n  MbscForce = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscForce);\n\n  MbscForce.ɵfac = function MbscForce_Factory(t) {\n    return new (t || MbscForce)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscForce.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscForce,\n    selectors: [[\"\", \"mbsc-force\", \"\"]],\n    inputs: {\n      value: [\"mbsc-force\", \"value\"],\n      options: [\"mbsc-options\", \"options\"]\n    },\n    outputs: {\n      onChangeEmitter: \"mbsc-forceChange\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscForce;\n}(MbscMeasurementBase);\n\nvar MbscForceComponent = function (_super) {\n  __extends(MbscForceComponent, _super);\n\n  function MbscForceComponent(initialElem, zone, control, inputService, optionService) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;\n\n    _this.errorMessage = '';\n    _this.placeholder = '';\n    return _this;\n  }\n\n  MbscForceComponent.prototype.ngAfterViewInit = function () {\n    _super.prototype.ngAfterViewInit.call(this);\n\n    this.setThemeClasses();\n  };\n\n  __decorate([Input$1('icon'), __metadata(\"design:type\", String)], MbscForceComponent.prototype, \"inputIcon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscForceComponent.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscForceComponent.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscForceComponent.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscForceComponent.prototype, \"errorMessage\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscForceComponent.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscForceComponent.prototype, \"placeholder\", void 0);\n\n  MbscForceComponent = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])], MbscForceComponent);\n\n  MbscForceComponent.ɵfac = function MbscForceComponent_Factory(t) {\n    return new (t || MbscForceComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscForceComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscForceComponent,\n    selectors: [[\"mbsc-force\"]],\n    inputs: {\n      inputIcon: [\"icon\", \"inputIcon\"],\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      name: \"name\",\n      error: \"error\",\n      errorMessage: \"errorMessage\",\n      options: \"options\",\n      placeholder: \"placeholder\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\", 4, \"ngIf\"], [3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\"]],\n    template: function MbscForceComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MbscForceComponent_mbsc_input_0_Template, 2, 13, \"mbsc-input\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.inline || ctx.showInput);\n      }\n    },\n    directives: [ɵngcc2.NgIf, MbscInput],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscForceComponent;\n}(MbscForce);\n\nvar MbscMass = function (_super) {\n  __extends(MbscMass, _super);\n\n  function MbscMass(initialElem, zone, control, inputService, optionService, view) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;\n\n    _this.options = {};\n    _this.onChangeEmitter = new EventEmitter();\n    _this.preset = 'mass';\n    return _this;\n  }\n\n  Object.defineProperty(MbscMass.prototype, \"value\", {\n    set: function (v) {\n      this.setNewValueProxy(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  __decorate([Input$1('mbsc-options'), __metadata(\"design:type\", Object)], MbscMass.prototype, \"options\", void 0);\n\n  __decorate([Input$1('mbsc-mass'), __metadata(\"design:type\", String), __metadata(\"design:paramtypes\", [String])], MbscMass.prototype, \"value\", null);\n\n  __decorate([Output('mbsc-massChange'), __metadata(\"design:type\", EventEmitter)], MbscMass.prototype, \"onChangeEmitter\", void 0);\n\n  MbscMass = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscMass);\n\n  MbscMass.ɵfac = function MbscMass_Factory(t) {\n    return new (t || MbscMass)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscMass.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscMass,\n    selectors: [[\"\", \"mbsc-mass\", \"\"]],\n    inputs: {\n      value: [\"mbsc-mass\", \"value\"],\n      options: [\"mbsc-options\", \"options\"]\n    },\n    outputs: {\n      onChangeEmitter: \"mbsc-massChange\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscMass;\n}(MbscMeasurementBase);\n\nvar MbscMassComponent = function (_super) {\n  __extends(MbscMassComponent, _super);\n\n  function MbscMassComponent(initialElem, zone, control, inputService, optionService) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;\n\n    _this.errorMessage = '';\n    _this.placeholder = '';\n    return _this;\n  }\n\n  MbscMassComponent.prototype.ngAfterViewInit = function () {\n    _super.prototype.ngAfterViewInit.call(this);\n\n    this.setThemeClasses();\n  };\n\n  __decorate([Input$1('icon'), __metadata(\"design:type\", String)], MbscMassComponent.prototype, \"inputIcon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscMassComponent.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscMassComponent.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscMassComponent.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscMassComponent.prototype, \"errorMessage\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscMassComponent.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscMassComponent.prototype, \"placeholder\", void 0);\n\n  MbscMassComponent = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])], MbscMassComponent);\n\n  MbscMassComponent.ɵfac = function MbscMassComponent_Factory(t) {\n    return new (t || MbscMassComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscMassComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscMassComponent,\n    selectors: [[\"mbsc-mass\"]],\n    inputs: {\n      inputIcon: [\"icon\", \"inputIcon\"],\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      name: \"name\",\n      error: \"error\",\n      errorMessage: \"errorMessage\",\n      options: \"options\",\n      placeholder: \"placeholder\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\", 4, \"ngIf\"], [3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\"]],\n    template: function MbscMassComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MbscMassComponent_mbsc_input_0_Template, 2, 13, \"mbsc-input\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.inline || ctx.showInput);\n      }\n    },\n    directives: [ɵngcc2.NgIf, MbscInput],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscMassComponent;\n}(MbscMass);\n\nvar comp$4 = [MbscMeasurement, MbscMeasurementBase, MbscMeasurementChild, MbscMeasurementComponent, MbscTemperature, MbscTemperatureComponent, MbscDistance, MbscDistanceComponent, MbscSpeed, MbscSpeedComponent, MbscForce, MbscForceComponent, MbscMass, MbscMassComponent];\n\nvar MbscMeasurementModule = function () {\n  function MbscMeasurementModule() {}\n\n  MbscMeasurementModule.ɵfac = function MbscMeasurementModule_Factory(t) {\n    return new (t || MbscMeasurementModule)();\n  };\n\n  MbscMeasurementModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscMeasurementModule\n  });\n  MbscMeasurementModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, MbscScrollerBaseModule, MbscInputModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscMeasurementModule, {\n      declarations: function () {\n        return [MbscMeasurement, MbscMeasurementBase, MbscMeasurementChild, MbscMeasurementComponent, MbscTemperature, MbscTemperatureComponent, MbscDistance, MbscDistanceComponent, MbscSpeed, MbscSpeedComponent, MbscForce, MbscForceComponent, MbscMass, MbscMassComponent];\n      },\n      imports: function () {\n        return [CommonModule, MbscScrollerBaseModule, MbscInputModule];\n      },\n      exports: function () {\n        return [MbscMeasurement, MbscMeasurementBase, MbscMeasurementChild, MbscMeasurementComponent, MbscTemperature, MbscTemperatureComponent, MbscDistance, MbscDistanceComponent, MbscSpeed, MbscSpeedComponent, MbscForce, MbscForceComponent, MbscMass, MbscMassComponent];\n      }\n    });\n  })();\n\n  return MbscMeasurementModule;\n}(); // eslint-disable-next-line no-unused-vars\n\n\nvar guid$1 = 1;\n\nvar ScrollView = function ScrollView(elm, settings, inherit) {\n  var $activeItem,\n      $cont,\n      $ctx,\n      $wnd,\n      contWidth,\n      itemWidth,\n      isClick,\n      observer,\n      oldWidth,\n      posDebounce,\n      rtl,\n      scrollView,\n      snap,\n      s,\n      totalWidth,\n      touched,\n      trigger,\n      cssClasses = {},\n      animTime = 1000,\n      that = this,\n      $elm = $$1(elm);\n\n  function onResize(ev) {\n    clearTimeout(posDebounce);\n    posDebounce = setTimeout(function () {\n      size(!ev || ev.type !== 'load');\n    }, 200);\n  }\n\n  function onClick() {\n    if (isClick && this.parentNode === elm) {\n      onItemTap($$1(this), true);\n    }\n  }\n\n  function onItemTap($item, toggle) {\n    if (!$item.length) {\n      return;\n    }\n\n    toggle = that._onItemTap($item, toggle);\n    $activeItem = $item;\n\n    if ($item.parent()[0] == elm) {\n      var bl = $item.offset().left,\n          bp = $item[0].offsetLeft,\n          bw = $item[0].offsetWidth,\n          cl = $cont.offset().left;\n\n      if (rtl) {\n        bp = totalWidth - bp - bw;\n      } // Scroll item to view\n\n\n      if (s.variant == 'a') {\n        if (bl < cl) {\n          scrollView.scroll(rtl ? bp + bw - contWidth : -bp, animTime, true);\n        } else if (bl + bw > cl + contWidth) {\n          scrollView.scroll(rtl ? bp : contWidth - bp - bw, animTime, true);\n        }\n      } else {\n        // Scroll item to center\n        scrollView.scroll((contWidth / 2 - bp - bw / 2) * (rtl ? -1 : 1), animTime, true);\n      }\n    }\n\n    if (toggle) {\n      // Trigger tap event\n      trigger('onItemTap', {\n        target: $item[0]\n      });\n    }\n  }\n\n  function initMarkup() {\n    var $firstItem, props;\n\n    that._initMarkup($cont);\n\n    $elm.find('.mbsc-ripple').remove();\n    that._$items = $elm.children();\n\n    that._$items.each(function (i) {\n      var cssClass,\n          $item = $$1(this),\n          ref = $item.attr('data-ref');\n\n      if (!ref) {\n        ref = guid$1++;\n      }\n\n      if (i === 0) {\n        $firstItem = $item;\n      }\n\n      if (!$activeItem) {\n        $activeItem = that._getActiveItem($item);\n      }\n\n      props = that._getItemProps($item) || {};\n      cssClass = 'mbsc-scv-item mbsc-btn-e ' + (props.cssClass || '');\n      $item.attr('data-ref', ref).removeClass(cssClasses[ref]).addClass(cssClass);\n      cssClasses[ref] = cssClass;\n      /* TRIAL */\n    });\n\n    if (!$activeItem) {\n      $activeItem = $firstItem;\n    }\n\n    that._markupReady($cont);\n  }\n\n  function size(check, noScroll) {\n    var w = s.itemWidth,\n        layout = s.layout;\n    that.contWidth = contWidth = $cont.width();\n\n    if (that._checkResp()) {\n      return false;\n    }\n\n    if (check && oldWidth === contWidth || !contWidth) {\n      // Don't do anything if container width has not changed\n      return;\n    }\n\n    oldWidth = contWidth;\n\n    if (isNumeric(layout)) {\n      itemWidth = contWidth ? contWidth / layout : w;\n\n      if (itemWidth < w) {\n        layout = 'liquid';\n      }\n    }\n\n    if (w) {\n      if (layout == 'liquid') {\n        // The specified itemWidth will be handled as min width\n        itemWidth = contWidth ? contWidth / Math.min(Math.floor(contWidth / w), that._$items.length) : w;\n      } else if (layout == 'fixed') {\n        // Fixed width\n        itemWidth = w;\n      }\n    }\n\n    that._size(contWidth, itemWidth);\n\n    if (itemWidth) {\n      $elm.children().css('width', itemWidth + 'px');\n    }\n\n    that.totalWidth = totalWidth = elm.offsetWidth;\n    extend$1(scrollView.settings, {\n      contSize: contWidth,\n      maxSnapScroll: s.paging ? 1 : false,\n      maxScroll: 0,\n      minScroll: totalWidth > contWidth ? contWidth - totalWidth : 0,\n      snap: s.paging ? contWidth : snap ? itemWidth || '.mbsc-scv-item' : false,\n      elastic: totalWidth > contWidth ? itemWidth || contWidth : false\n    }); // Pass new values to scrollview\n\n    scrollView.refresh(noScroll); // Make sure the active item remains visible\n\n    if ($activeItem) {\n      onItemTap($activeItem, false);\n    }\n  } // Call the parent constructor\n\n\n  Base.call(this, elm, settings, true);\n\n  that.navigate = function ($item, toggle) {\n    onItemTap(that._getItem($item), toggle);\n  };\n\n  that.next = function (toggle) {\n    if ($activeItem) {\n      var $next = $activeItem.next();\n\n      if ($next.length) {\n        $activeItem = $next;\n        onItemTap($activeItem, toggle);\n      }\n    }\n  };\n\n  that.prev = function (toggle) {\n    if ($activeItem) {\n      var $prev = $activeItem.prev();\n\n      if ($prev.length) {\n        $activeItem = $prev;\n        onItemTap($activeItem, toggle);\n      }\n    }\n  };\n  /**\r\n   * Recalculates sizes.\r\n   */\n\n\n  that.refresh = that.position = function (noScroll) {\n    initMarkup();\n    size(false, noScroll);\n  };\n  /**\r\n   * Initialization.\r\n   */\n\n\n  that._init = function () {\n    var contClass;\n    $ctx = $$1(s.context);\n    $wnd = $$1(s.context == 'body' ? window : s.context);\n\n    that.__init();\n\n    rtl = s.rtl;\n    snap = s.itemWidth && s.layout != 'fixed' && s.snap === undefined ? true : s.snap;\n    contClass = 'mbsc-scv-c mbsc-no-touch' + ' mbsc-' + s.theme + ' ' + (s.cssClass || '') + ' ' + (s.wrapperClass || '') + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + (rtl ? ' mbsc-rtl' : ' mbsc-ltr') + (s.itemWidth ? ' mbsc-scv-hasw' : '') + (s.context == 'body' ? '' : ' mbsc-scv-ctx') + ' ' + (that._getContClass() || '');\n\n    if (!$cont) {\n      $cont = $$1('<div class=\"' + contClass + '\"><div class=\"mbsc-scv-sc\"></div></div>').on('click', '.mbsc-scv-item', onClick).insertAfter($elm);\n      $cont.find('.mbsc-scv-sc').append($elm); // When images are loaded, size migth change\n\n      $cont.find('img').on('load', onResize);\n      $wnd.on('orientationchange resize', onResize);\n      observer = resizeObserver($cont[0], onResize, s.zone);\n      scrollView = new ScrollViewBase($cont[0], {\n        axis: 'X',\n        contSize: 0,\n        maxScroll: 0,\n        maxSnapScroll: 1,\n        minScroll: 0,\n        snap: 1,\n        elastic: 1,\n        rtl: rtl,\n        mousewheel: s.mousewheel,\n        thresholdX: s.threshold,\n        stopProp: s.stopProp,\n        onStart: function onStart(ev) {\n          if (ev.domEvent.type == 'touchstart') {\n            isClick = false;\n\n            if (!touched) {\n              touched = true;\n              $ctx.find('.mbsc-no-touch').removeClass('mbsc-no-touch');\n            }\n          }\n        },\n        onBtnTap: function onBtnTap(ev) {\n          isClick = true; // Trigger click and activate target, if it's a form control\n\n          var domEvent = ev.domEvent,\n              target = domEvent.target;\n\n          if (domEvent.type === 'touchend' && s.tap) {\n            activateControl(target, getControlType($$1(target)), domEvent);\n          }\n        },\n        onGestureStart: function onGestureStart(ev) {\n          trigger('onGestureStart', ev);\n        },\n        onGestureEnd: function onGestureEnd(ev) {\n          trigger('onGestureEnd', ev);\n        },\n        onMove: function onMove(ev) {\n          trigger('onMove', ev);\n        },\n        onAnimationStart: function onAnimationStart(ev) {\n          trigger('onAnimationStart', ev);\n        },\n        onAnimationEnd: function onAnimationEnd(ev) {\n          trigger('onAnimationEnd', ev);\n        }\n      });\n    } else {\n      $cont.attr('class', contClass); // Remove ripple events (if theme changed)\n\n      if (elm.__mbscRippleOff) {\n        elm.__mbscRippleOff();\n      }\n    } // Prepare markup\n\n\n    $elm.css('display', '').addClass('mbsc-scv').removeClass('mbsc-cloak');\n    initMarkup();\n    trigger('onMarkupReady', {\n      target: $cont[0]\n    });\n    size();\n  };\n\n  that._size = noop;\n  that._initMarkup = noop;\n  that._markupReady = noop;\n  that._getContClass = noop;\n  that._getItemProps = noop;\n  that._getActiveItem = noop;\n  that.__init = noop;\n  that.__destroy = noop;\n  /**\r\n   * Destroy\r\n   */\n\n  that._destroy = function () {\n    that.__destroy();\n\n    $wnd.off('orientationchange resize', onResize);\n    $elm.removeClass('mbsc-scv').insertAfter($cont).find('.mbsc-scv-item').each(function () {\n      var $item = $$1(this);\n      $item.width('').removeClass(cssClasses[$item.attr('data-ref')]);\n    });\n    $cont.remove();\n    scrollView.destroy();\n    observer.detach();\n  };\n\n  that._getItem = function (item) {\n    if (typeof item !== 'object') {\n      item = that._$items.filter('[data-id=\"' + item + '\"]');\n    }\n\n    return $$1(item);\n  };\n\n  that._onItemTap = function ($item, toggle) {\n    if (toggle === undefined) {\n      return true;\n    }\n\n    return toggle;\n  }; // ---\n  // Constructor\n\n\n  s = that.settings;\n  trigger = that.trigger;\n\n  if (!inherit) {\n    that.init();\n  }\n}; // Defaults\n\n\nScrollView.prototype = {\n  _class: 'scrollview',\n  _hasDef: true,\n  _hasTheme: true,\n  _hasLang: true,\n  _responsive: true,\n  _defaults: {\n    tap: hasGhostClick,\n    stopProp: false,\n    context: 'body',\n    layout: 'liquid'\n  }\n};\nclasses.ScrollView = ScrollView;\n\nvar NavigationBase = function NavigationBase(elm, settings, inherit) {\n  var $ctx,\n      display,\n      multiple,\n      select,\n      selectedClass,\n      s,\n      $elm = $$1(elm),\n      that = this;\n\n  function removePagePadding() {\n    if (display && display != 'inline') {\n      $ctx.find('.mbsc-page').css('padding-' + display, '');\n    }\n  }\n\n  function selectItem($item) {\n    $item.addClass(selectedClass).attr('data-selected', 'true').attr('aria-selected', 'true');\n  }\n\n  function deselectItem($item) {\n    $item.removeClass(selectedClass).removeAttr('data-selected').removeAttr('aria-selected');\n  } // Call the parent constructor\n\n\n  ScrollView.call(this, elm, settings, true);\n\n  that.select = function ($item) {\n    if (!multiple) {\n      deselectItem(that._$items.filter('.mbsc-ms-item-sel'));\n    }\n\n    selectItem(that._getItem($item));\n  };\n\n  that.deselect = function ($item) {\n    deselectItem(that._getItem($item));\n  };\n\n  that.enable = function ($item) {\n    that._getItem($item).removeClass('mbsc-disabled').removeAttr('data-disabled').removeAttr('aria-disabled');\n  };\n\n  that.disable = function ($item) {\n    that._getItem($item).addClass('mbsc-disabled').attr('data-disabled', 'true').attr('aria-disabled', 'true');\n  };\n\n  that.setBadge = function ($item, content) {\n    var $badge;\n    $item = that._getItem($item).attr('data-badge', content);\n    $badge = $$1('.mbsc-ms-badge', $item);\n\n    if ($badge.length) {\n      if (content) {\n        $badge.html(content);\n      } else {\n        $badge.remove();\n      }\n    } else if (content) {\n      $item.append('<span class=\"mbsc-ms-badge\">' + content + '</span>');\n    }\n  };\n\n  that._markupReady = function ($cont) {\n    if (that._hasIcons) {\n      $cont.addClass('mbsc-ms-icons');\n    } else {\n      $cont.removeClass('mbsc-ms-icons');\n    }\n\n    if (that._hasText) {\n      $cont.addClass('mbsc-ms-txt');\n    } else {\n      $cont.removeClass('mbsc-ms-txt');\n    }\n\n    that.__markupReady($cont);\n  };\n\n  that._size = function (contWidth, itemWidth) {\n    that.__size(contWidth, itemWidth); // Add space to pages within context\n\n\n    if (display != 'inline') {\n      $ctx.find('.mbsc-page').css('padding-' + display, elm.offsetHeight + 'px');\n    }\n  };\n\n  that._onItemTap = function ($item, toggle) {\n    if (that.__onItemTap($item, toggle) === false) {\n      return false;\n    }\n\n    if (toggle === undefined) {\n      toggle = !multiple;\n    }\n\n    if (select && toggle && !$item.hasClass('mbsc-disabled')) {\n      if (multiple) {\n        if ($item.attr('data-selected') == 'true') {\n          deselectItem($item);\n        } else {\n          selectItem($item);\n        }\n      } else {\n        deselectItem(that._$items.filter('.mbsc-ms-item-sel'));\n        selectItem($item);\n      }\n    }\n\n    return toggle;\n  };\n\n  that._getActiveItem = function ($item) {\n    var selected = $item.attr('data-selected') == 'true';\n\n    if (select && !multiple && selected) {\n      return $item;\n    }\n  };\n\n  that._getItemProps = function ($item) {\n    var selected = $item.attr('data-selected') == 'true',\n        disabled = $item.attr('data-disabled') == 'true',\n        icon = $item.attr('data-icon'),\n        badge = $item.attr('data-badge');\n    $item.attr('data-role', 'button').attr('aria-selected', selected ? 'true' : 'false').attr('aria-disabled', disabled ? 'true' : 'false').find('.mbsc-ms-badge').remove();\n\n    if (badge) {\n      $item.append('<span class=\"mbsc-ms-badge\">' + badge + '</span>');\n    }\n\n    if (icon) {\n      that._hasIcons = true;\n    }\n\n    if ($item.text()) {\n      that._hasText = true;\n    }\n\n    return {\n      cssClass: 'mbsc-ms-item ' + (s.itemClass || '') + ' ' + (selected ? selectedClass : '') + (disabled ? ' mbsc-disabled ' + (s.disabledClass || '') : '') + (icon ? ' mbsc-ms-ic mbsc-ic mbsc-ic-' + icon : '')\n    };\n  };\n\n  that._getContClass = function () {\n    return ' mbsc-ms-c mbsc-ms-' + s.variant + ' mbsc-ms-' + display + (select ? '' : ' mbsc-ms-nosel') + (that.__getContClass() || '');\n  };\n\n  that.__init = function () {\n    that.___init();\n\n    $ctx = $$1(s.context); // Remove old padding from mbsc-page\n    // if display changed dynamically\n\n    removePagePadding();\n    display = s.display;\n    multiple = s.select == 'multiple';\n    select = s.select != 'off';\n    selectedClass = ' mbsc-ms-item-sel ' + (s.activeClass || '');\n    $elm.addClass('mbsc-ms mbsc-ms-base ' + (s.groupClass || ''));\n  };\n\n  that.__destroy = function () {\n    $elm.removeClass('mbsc-ms mbsc-ms-base ' + (s.groupClass || ''));\n    removePagePadding();\n\n    that.___destroy();\n  };\n\n  that.__onItemTap = noop;\n  that.__getContClass = noop;\n  that.__markupReady = noop;\n  that.__size = noop;\n  that.___init = noop;\n  that.___destroy = noop; // ---\n  // Constructor\n\n  s = that.settings;\n\n  if (!inherit) {\n    that.init();\n  }\n}; // Defaults\n\n\nNavigationBase.prototype = {\n  _defaults: extend$1({}, ScrollView.prototype._defaults)\n};\n\nvar Navigation = function Navigation(elm, settings) {\n  var $elm = $$1(elm),\n      $menu,\n      $popup,\n      menuClass,\n      s,\n      popup,\n      isList = $elm.is('ul,ol'),\n      that = this; // Call the parent constructor\n\n  NavigationBase.call(this, elm, settings, true);\n\n  that._initMarkup = function () {\n    if ($menu) {\n      $menu.remove();\n    }\n\n    if ($popup) {\n      $elm.append($popup.children());\n    }\n  };\n\n  that.__size = function (contWidth, itemWidth) {\n    var showMore,\n        showMoreWidth = itemWidth || 72,\n        itemsNr = that._$items.length,\n        itemsWidth = 0;\n    popup.hide(); // show more menu\n\n    if (s.type == 'bottom') {\n      $elm.removeClass('mbsc-scv-liq'); //.empty(); // empty list\n\n      $menu.remove();\n\n      that._$items.remove().each(function (i) {\n        var $item = $$1(this);\n        $elm.append($item);\n        itemsWidth += itemWidth || this.offsetWidth || 0; // if next item doesn't fit, add to show more menu\n\n        if (Math.round(itemsWidth + (i < itemsNr - 1 ? showMoreWidth : 0)) > contWidth) {\n          showMore = true;\n          $popup.append($item.css('width', '').addClass('mbsc-fr-btn-e'));\n        }\n      });\n\n      $menu.attr('class', menuClass + (s.moreIcon ? ' mbsc-menu-item-ic mbsc-ms-ic mbsc-ic mbsc-ic-' + s.moreIcon : '')).html(that._hasIcons && that._hasText ? s.moreText : ''); // add show more item if needed\n\n      if (showMore) {\n        $elm.append($menu);\n      }\n    }\n\n    if (s.layout == 'liquid') {\n      $elm.addClass('mbsc-scv-liq');\n    }\n  };\n\n  that.__onItemTap = function ($item) {\n    if ($item.hasClass('mbsc-menu-item') && that.trigger('onMenuShow', {\n      target: $item[0],\n      menu: popup\n    }) !== false) {\n      popup.show(false, true);\n      return false;\n    }\n  };\n\n  that.__getContClass = function () {\n    return s.type == 'hamburger' ? ' mbsc-ms-hamburger' : '';\n  };\n\n  that.__markupReady = function ($cont) {\n    if (s.type == 'hamburger') {\n      $popup.append(that._$items.addClass('mbsc-fr-btn-e'));\n      $menu.attr('class', menuClass + (s.menuIcon ? ' mbsc-menu-item-ic mbsc-ms-ic mbsc-ic mbsc-ic-' + s.menuIcon : '')).html(s.menuText || '');\n      $elm.append($menu);\n\n      if (!s.menuText || !s.menuIcon) {\n        $cont.removeClass('mbsc-ms-icons');\n      }\n\n      if (!s.menuText) {\n        $cont.removeClass('mbsc-ms-txt');\n      } else {\n        $cont.addClass('mbsc-ms-txt');\n      }\n    }\n  };\n\n  that.___init = function () {\n    var $target;\n\n    if (s.type == 'tab') {\n      s.display = s.display || 'top';\n      s.variant = s.variant || 'b';\n    } else if (s.type == 'bottom') {\n      s.display = s.display || 'bottom';\n      s.variant = s.variant || 'a';\n    } else if (s.type == 'hamburger') {\n      s.display = s.display || 'inline';\n      s.variant = s.variant || 'a';\n    }\n\n    menuClass = 'mbsc-scv-item mbsc-ms-item mbsc-btn-e mbsc-menu-item ' + (s.itemClass || '');\n\n    if (!$menu) {\n      $menu = $$1(isList ? '<li></li>' : '<div></div>');\n      $popup = $$1(isList ? '<ul></ul>' : '<div></div>').addClass('mbsc-scv mbsc-ms');\n    }\n\n    popup = new Popup($popup[0], {\n      display: 'bubble',\n      theme: s.theme,\n      lang: s.lang,\n      context: s.context,\n      buttons: [],\n      anchor: $menu,\n      onBeforeShow: function onBeforeShow(event, inst) {\n        $target = null;\n        inst.settings.cssClass = 'mbsc-wdg mbsc-ms-a mbsc-ms-more' + (that._hasText ? '' : ' mbsc-ms-more-icons');\n      },\n      onBeforeClose: function onBeforeClose() {\n        return that.trigger('onMenuHide', {\n          target: $target && $target[0],\n          menu: popup\n        });\n      },\n      onMarkupReady: function onMarkupReady(event, inst) {\n        that.tap(inst._markup.find('.mbsc-fr-c'), function (ev) {\n          $target = $$1(ev.target).closest('.mbsc-ms-item');\n\n          if ($target.length && !$target.hasClass('mbsc-disabled')) {\n            that.navigate($target, true);\n            popup.hide();\n          }\n        });\n      }\n    });\n  };\n\n  that.___destroy = function () {\n    popup.destroy();\n    $elm.append(that._$items);\n    $menu.remove();\n  }; // ---\n  // Constructor\n\n\n  s = that.settings;\n  that.init();\n}; // Defaults\n\n\nNavigation.prototype = {\n  _class: 'navigation',\n  _hasDef: true,\n  _hasTheme: true,\n  _hasLang: true,\n  _responsive: true,\n  _defaults: extend$1({}, NavigationBase.prototype._defaults, {\n    type: 'bottom',\n    moreText: 'More',\n    moreIcon: 'material-more-horiz',\n    menuIcon: 'material-menu'\n  })\n};\nclasses.Navigation = Navigation;\n\nvar MbscNotifyItemService = function () {\n  function MbscNotifyItemService() {\n    this._instanceObservable = new Observable();\n    this._addRemoveObservable = new Observable();\n    this.inst = null;\n  }\n\n  MbscNotifyItemService.prototype.notifyInstanceReady = function (instance) {\n    this.inst = instance;\n\n    this._instanceObservable.next(instance);\n  };\n\n  MbscNotifyItemService.prototype.notifyAddRemove = function (item) {\n    this._addRemoveObservable.next(item);\n  };\n\n  MbscNotifyItemService.prototype.onInstanceReady = function () {\n    return this._instanceObservable;\n  };\n\n  MbscNotifyItemService.prototype.onAddRemove = function () {\n    return this._addRemoveObservable;\n  };\n\n  MbscNotifyItemService.ɵfac = function MbscNotifyItemService_Factory(t) {\n    return new (t || MbscNotifyItemService)();\n  };\n\n  MbscNotifyItemService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: MbscNotifyItemService,\n    factory: function (t) {\n      return MbscNotifyItemService.ɵfac(t);\n    }\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscNotifyItemService;\n}();\n\nvar MbscScrollItemBase = function () {\n  function MbscScrollItemBase(notifyItemService, _elem) {\n    var _this = this;\n\n    this.notifyItemService = notifyItemService;\n    this._elem = _elem;\n    this._instance = undefined;\n    this.instanceObserver = this.notifyItemService.onInstanceReady().subscribe(function (instance) {\n      _this._instance = instance;\n    });\n\n    if (notifyItemService.inst) {\n      this._instance = notifyItemService.inst;\n    }\n  }\n\n  Object.defineProperty(MbscScrollItemBase.prototype, \"nativeElement\", {\n    get: function () {\n      return this._elem.nativeElement;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscScrollItemBase.prototype.ngAfterViewInit = function () {\n    this.notifyItemService.notifyAddRemove(this);\n  };\n\n  MbscScrollItemBase.prototype.ngOnDestroy = function () {\n    this.notifyItemService.onInstanceReady().unsubscribe(this.instanceObserver);\n    this.notifyItemService.notifyAddRemove(this);\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscScrollItemBase.prototype, \"id\", void 0);\n\n  MbscScrollItemBase = __decorate([__metadata(\"design:paramtypes\", [MbscNotifyItemService, ElementRef])], MbscScrollItemBase);\n\n  MbscScrollItemBase.ɵfac = function MbscScrollItemBase_Factory(t) {\n    return new (t || MbscScrollItemBase)(ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MbscScrollItemBase.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscScrollItemBase,\n    selectors: [[\"mbsc-si-b\"]],\n    inputs: {\n      id: \"id\"\n    }\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscScrollItemBase;\n}();\n\nvar MbscScrollViewBase = function (_super) {\n  __extends(MbscScrollViewBase, _super);\n\n  function MbscScrollViewBase(initialElem, zone, notifyItemService) {\n    var _this = _super.call(this, initialElem, zone) || this;\n\n    _this.notifyItemService = notifyItemService;\n    _this.onItemTap = new EventEmitter();\n    _this.onMarkupReady = new EventEmitter();\n    _this.onAnimationStart = new EventEmitter();\n    _this.onAnimationEnd = new EventEmitter();\n    _this.onMove = new EventEmitter();\n    _this.onGestureStart = new EventEmitter();\n    _this.onGestureEnd = new EventEmitter();\n    return _this;\n  }\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscScrollViewBase.prototype, \"context\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscScrollViewBase.prototype, \"itemWidth\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscScrollViewBase.prototype, \"layout\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscScrollViewBase.prototype, \"mousewheel\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscScrollViewBase.prototype, \"snap\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscScrollViewBase.prototype, \"threshold\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscScrollViewBase.prototype, \"paging\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscScrollViewBase.prototype, \"onItemTap\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscScrollViewBase.prototype, \"onMarkupReady\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscScrollViewBase.prototype, \"onAnimationStart\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscScrollViewBase.prototype, \"onAnimationEnd\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscScrollViewBase.prototype, \"onMove\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscScrollViewBase.prototype, \"onGestureStart\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscScrollViewBase.prototype, \"onGestureEnd\", void 0);\n\n  MbscScrollViewBase = __decorate([__metadata(\"design:paramtypes\", [ElementRef, NgZone, MbscNotifyItemService])], MbscScrollViewBase);\n\n  MbscScrollViewBase.ɵfac = function MbscScrollViewBase_Factory(t) {\n    return new (t || MbscScrollViewBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService));\n  };\n\n  MbscScrollViewBase.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscScrollViewBase,\n    selectors: [[\"mbsc-s-b\"]],\n    inputs: {\n      context: \"context\",\n      itemWidth: \"itemWidth\",\n      layout: \"layout\",\n      mousewheel: \"mousewheel\",\n      snap: \"snap\",\n      threshold: \"threshold\",\n      paging: \"paging\"\n    },\n    outputs: {\n      onItemTap: \"onItemTap\",\n      onMarkupReady: \"onMarkupReady\",\n      onAnimationStart: \"onAnimationStart\",\n      onAnimationEnd: \"onAnimationEnd\",\n      onMove: \"onMove\",\n      onGestureStart: \"onGestureStart\",\n      onGestureEnd: \"onGestureEnd\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscScrollViewBase;\n}(MbscBase);\n\nvar MbscScrollViewBaseModule = function () {\n  function MbscScrollViewBaseModule() {}\n\n  MbscScrollViewBaseModule.ɵfac = function MbscScrollViewBaseModule_Factory(t) {\n    return new (t || MbscScrollViewBaseModule)();\n  };\n\n  MbscScrollViewBaseModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscScrollViewBaseModule\n  });\n  MbscScrollViewBaseModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, MbscBaseModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscScrollViewBaseModule, {\n      declarations: function () {\n        return [MbscScrollItemBase, MbscScrollViewBase];\n      },\n      imports: function () {\n        return [CommonModule, MbscBaseModule];\n      }\n    });\n  })();\n\n  return MbscScrollViewBaseModule;\n}();\n\nvar MbscNavItemBase = function (_super) {\n  __extends(MbscNavItemBase, _super);\n\n  function MbscNavItemBase(notifyItemService, elem) {\n    var _this = _super.call(this, notifyItemService, elem) || this;\n\n    _this.selectedChange = new EventEmitter();\n    return _this;\n  }\n\n  Object.defineProperty(MbscNavItemBase.prototype, \"disabled\", {\n    get: function () {\n      return this._disabled;\n    },\n    set: function (v) {\n      this._disabled = v;\n\n      if (this._instance) {\n        if (this._disabled) {\n          this._instance.disable(this._elem.nativeElement);\n        } else {\n          this._instance.enable(this._elem.nativeElement);\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MbscNavItemBase.prototype, \"selected\", {\n    get: function () {\n      return this._selected;\n    },\n    set: function (v) {\n      this._selected = v;\n\n      if (this._instance) {\n        if (this._selected) {\n          this._instance.select(this._elem.nativeElement);\n        } else {\n          this._instance.deselect(this._elem.nativeElement);\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscNavItemBase.prototype.toggle = function () {\n    this._selected = !this._selected;\n    this.selectedChange.emit(this._selected);\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNavItemBase.prototype, \"icon\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [Boolean])], MbscNavItemBase.prototype, \"disabled\", null);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean), __metadata(\"design:paramtypes\", [Boolean])], MbscNavItemBase.prototype, \"selected\", null);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscNavItemBase.prototype, \"selectedChange\", void 0);\n\n  MbscNavItemBase = __decorate([__metadata(\"design:paramtypes\", [MbscNotifyItemService, ElementRef])], MbscNavItemBase);\n\n  MbscNavItemBase.ɵfac = function MbscNavItemBase_Factory(t) {\n    return new (t || MbscNavItemBase)(ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MbscNavItemBase.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscNavItemBase,\n    selectors: [[\"mbsc-ni-b\"]],\n    inputs: {\n      disabled: \"disabled\",\n      selected: \"selected\",\n      icon: \"icon\"\n    },\n    outputs: {\n      selectedChange: \"selectedChange\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscNavItemBase;\n}(MbscScrollItemBase);\n\nvar MbscNavigationBase = function (_super) {\n  __extends(MbscNavigationBase, _super);\n\n  function MbscNavigationBase(initialElem, zone, notifyItemService) {\n    return _super.call(this, initialElem, zone, notifyItemService) || this;\n  }\n\n  MbscNavigationBase.prototype.tapHandler = function (event, inst) {\n    var selection = this.select || inst && inst.settings.select;\n\n    switch (selection) {\n      case 'multiple':\n        {\n          var item = this._getItem(event.target);\n\n          item.toggle();\n          break;\n        }\n\n      case 'single':\n        {\n          var item = this._getItem(event.target);\n\n          if (item && !item.selected) {\n            this.items.forEach(function (item) {\n              if (item.selected) {\n                item.toggle();\n              }\n            });\n            item.toggle();\n          }\n        }\n    }\n\n    event.inst = inst;\n    this.onItemTap.emit(event);\n  };\n\n  MbscNavigationBase.prototype._getItem = function (nativeEl) {\n    return this.items.find(function (item) {\n      return item.nativeElement === nativeEl;\n    });\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNavigationBase.prototype, \"display\", void 0);\n\n  __decorate([Input$1('options'), __metadata(\"design:type\", Object)], MbscNavigationBase.prototype, \"options\", void 0);\n\n  __decorate([ContentChildren(MbscNavItemBase), __metadata(\"design:type\", QueryList)], MbscNavigationBase.prototype, \"items\", void 0);\n\n  MbscNavigationBase = __decorate([__metadata(\"design:paramtypes\", [ElementRef, NgZone, MbscNotifyItemService])], MbscNavigationBase);\n\n  MbscNavigationBase.ɵfac = function MbscNavigationBase_Factory(t) {\n    return new (t || MbscNavigationBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService));\n  };\n\n  MbscNavigationBase.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscNavigationBase,\n    selectors: [[\"mbsc-n-b\"]],\n    contentQueries: function MbscNavigationBase_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MbscNavItemBase, 4);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.items = _t);\n      }\n    },\n    inputs: {\n      display: \"display\",\n      options: \"options\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscNavigationBase;\n}(MbscScrollViewBase);\n\nvar MbscNavigationBaseModule = function () {\n  function MbscNavigationBaseModule() {}\n\n  MbscNavigationBaseModule.ɵfac = function MbscNavigationBaseModule_Factory(t) {\n    return new (t || MbscNavigationBaseModule)();\n  };\n\n  MbscNavigationBaseModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscNavigationBaseModule\n  });\n  MbscNavigationBaseModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, MbscScrollViewBaseModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscNavigationBaseModule, {\n      declarations: function () {\n        return [MbscNavigationBase, MbscNavItemBase];\n      },\n      imports: function () {\n        return [CommonModule, MbscScrollViewBaseModule];\n      }\n    });\n  })();\n\n  return MbscNavigationBaseModule;\n}();\n\nvar MbscNavItem = function (_super) {\n  __extends(MbscNavItem, _super);\n\n  function MbscNavItem(notifyItemService, elem, inj, routerToken) {\n    var _this = _super.call(this, notifyItemService, elem) || this;\n\n    _this.inj = inj;\n    _this.routerLinkActiveOptions = {\n      exact: false\n    };\n    _this.instObserver = notifyItemService.onInstanceReady().subscribe(function (instance) {\n      if (_this.initialBadge) {\n        instance.setBadge(_this.nativeElement, _this.initialBadge);\n      }\n    });\n\n    if (routerToken) {\n      _this.injectedRouter = routerToken;\n      _this.activatedRoute = _this.inj.get(_this.injectedRouter.routerState.root.__proto__.constructor, null);\n    }\n\n    if (_this.injectedRouter) {\n      _this.injectedRouter.events.subscribe(function (ev) {\n        clearTimeout(_this.debounceHandler);\n        _this.debounceHandler = setTimeout(function () {\n          _this.checkSelected();\n        });\n      });\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(MbscNavItem.prototype, \"badge\", {\n    set: function (badge) {\n      if (this._instance) {\n        this._instance.setBadge(this.nativeElement, badge);\n      } else {\n        this.initialBadge = badge;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscNavItem.prototype.checkSelected = function () {\n    if (this.injectedRouter && this.routerLink !== null && this.routerLink !== undefined) {\n      var commands = Array.isArray(this.routerLink) ? this.routerLink : [this.routerLink];\n      var urlTree = this.injectedRouter.createUrlTree(commands, {\n        relativeTo: this.activatedRoute\n      });\n      var selected = this.injectedRouter.isActive(urlTree, this.routerLinkActiveOptions.exact);\n\n      if (selected) {\n        this._selected = selected;\n      }\n\n      if (this._instance) {\n        if (selected) {\n          this._instance.select(this._elem.nativeElement);\n        } else {\n          this._instance.deselect(this._elem.nativeElement);\n        }\n      }\n    }\n  };\n\n  MbscNavItem.prototype.ngOnDestroy = function () {\n    this.notifyItemService.onInstanceReady().unsubscribe(this.instObserver);\n\n    _super.prototype.ngOnDestroy.call(this);\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", String), __metadata(\"design:paramtypes\", [String])], MbscNavItem.prototype, \"badge\", null);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscNavItem.prototype, \"routerLink\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscNavItem.prototype, \"routerLinkActiveOptions\", void 0);\n\n  MbscNavItem = __decorate([__param(3, Optional()), __metadata(\"design:paramtypes\", [MbscNotifyItemService, ElementRef, Injector, MbscRouterToken])], MbscNavItem);\n\n  MbscNavItem.ɵfac = function MbscNavItem_Factory(t) {\n    return new (t || MbscNavItem)(ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(MbscRouterToken, 8));\n  };\n\n  MbscNavItem.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscNavItem,\n    selectors: [[\"mbsc-nav-item\"]],\n    hostVars: 4,\n    hostBindings: function MbscNavItem_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"data-icon\", ctx.icon)(\"data-disabled\", ctx.disabled)(\"data-selected\", ctx.selected)(\"data-id\", ctx.id);\n      }\n    },\n    inputs: {\n      badge: \"badge\",\n      routerLink: \"routerLink\",\n      routerLinkActiveOptions: \"routerLinkActiveOptions\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscNavItem_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscNavItem;\n}(MbscNavItemBase);\n\nvar MbscNav = function (_super) {\n  __extends(MbscNav, _super);\n\n  function MbscNav(initialElem, zone, notifyItemService, optionService) {\n    var _this = _super.call(this, initialElem, zone, notifyItemService) || this;\n\n    _this.optionService = optionService;\n    _this.select = 'single';\n    _this.onMenuHide = new EventEmitter();\n    _this.onMenuShow = new EventEmitter();\n    return _this;\n  }\n\n  MbscNav.prototype.initControl = function () {\n    var _this = this;\n\n    var onItemTap = this.tapHandler.bind(this);\n    var onItemTapUser = this.options && this.options.onItemTap;\n\n    if (onItemTapUser) {\n      onItemTap = function (event, inst) {\n        _this.tapHandler(event, inst);\n\n        return onItemTapUser(event, inst);\n      };\n    }\n\n    var options = extend$1({\n      type: this.type\n    }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, {\n      onItemTap: onItemTap\n    });\n    this.instance = new Navigation(this.initialElem.nativeElement, options);\n    this.notifyItemService.notifyInstanceReady(this.instance);\n    this.addRemoveObserver = this.notifyItemService.onAddRemove().subscribe(function (item) {\n      _this.instance.refresh();\n    });\n  };\n\n  MbscNav.prototype.ngOnDestroy = function () {\n    this.notifyItemService.onAddRemove().unsubscribe(this.addRemoveObserver);\n\n    _super.prototype.ngOnDestroy.call(this);\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNav.prototype, \"moreText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNav.prototype, \"moreIcon\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNav.prototype, \"menuText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNav.prototype, \"menuIcon\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscNav.prototype, \"onMenuHide\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscNav.prototype, \"onMenuShow\", void 0);\n\n  __decorate([ContentChildren(MbscNavItem), __metadata(\"design:type\", QueryList)], MbscNav.prototype, \"items\", void 0);\n\n  MbscNav = __decorate([__param(3, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, MbscNotifyItemService, MbscOptionsService])], MbscNav);\n\n  MbscNav.ɵfac = function MbscNav_Factory(t) {\n    return new (t || MbscNav)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscNav.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscNav,\n    selectors: [[\"mbsc-nav\"]],\n    contentQueries: function MbscNav_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MbscNavItem, 4);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.items = _t);\n      }\n    },\n    hostAttrs: [1, \"mbsc-cloak\"],\n    inputs: {\n      moreText: \"moreText\",\n      moreIcon: \"moreIcon\",\n      menuText: \"menuText\",\n      menuIcon: \"menuIcon\"\n    },\n    outputs: {\n      onMenuHide: \"onMenuHide\",\n      onMenuShow: \"onMenuShow\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([MbscNotifyItemService]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscNav_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscNav;\n}(MbscNavigationBase);\n\nvar MbscBottomNav = function (_super) {\n  __extends(MbscBottomNav, _super);\n\n  function MbscBottomNav(initialElem, zone, navItemService, optionService) {\n    var _this = _super.call(this, initialElem, zone, navItemService, optionService) || this;\n\n    _this.type = 'bottom';\n    return _this;\n  }\n\n  MbscBottomNav = __decorate([__param(3, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, MbscNotifyItemService, MbscOptionsService])], MbscBottomNav);\n\n  MbscBottomNav.ɵfac = function MbscBottomNav_Factory(t) {\n    return new (t || MbscBottomNav)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscBottomNav.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscBottomNav,\n    selectors: [[\"mbsc-bottom-nav\"]],\n    hostAttrs: [1, \"mbsc-cloak\"],\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([MbscNotifyItemService]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscBottomNav_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscBottomNav;\n}(MbscNav);\n\nvar MbscHamburgerNav = function (_super) {\n  __extends(MbscHamburgerNav, _super);\n\n  function MbscHamburgerNav(initialElem, zone, navItemService, optionService) {\n    var _this = _super.call(this, initialElem, zone, navItemService, optionService) || this;\n\n    _this.type = 'hamburger';\n    return _this;\n  }\n\n  MbscHamburgerNav = __decorate([__param(3, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, MbscNotifyItemService, MbscOptionsService])], MbscHamburgerNav);\n\n  MbscHamburgerNav.ɵfac = function MbscHamburgerNav_Factory(t) {\n    return new (t || MbscHamburgerNav)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscHamburgerNav.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscHamburgerNav,\n    selectors: [[\"mbsc-hamburger-nav\"]],\n    hostAttrs: [1, \"mbsc-cloak\"],\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([MbscNotifyItemService]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscHamburgerNav_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscHamburgerNav;\n}(MbscNav);\n\nvar MbscTabNav = function (_super) {\n  __extends(MbscTabNav, _super);\n\n  function MbscTabNav(initialElem, zone, navItemService, optionService) {\n    var _this = _super.call(this, initialElem, zone, navItemService, optionService) || this;\n\n    _this.type = 'tab';\n    return _this;\n  }\n\n  MbscTabNav = __decorate([__param(3, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, MbscNotifyItemService, MbscOptionsService])], MbscTabNav);\n\n  MbscTabNav.ɵfac = function MbscTabNav_Factory(t) {\n    return new (t || MbscTabNav)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscTabNav.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscTabNav,\n    selectors: [[\"mbsc-tab-nav\"]],\n    hostAttrs: [1, \"mbsc-cloak\"],\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([MbscNotifyItemService]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscTabNav_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscTabNav;\n}(MbscNav);\n\nvar comps = [MbscNavItem, MbscNav, MbscBottomNav, MbscHamburgerNav, MbscTabNav];\n\nvar MbscNavigationModule = function () {\n  function MbscNavigationModule() {}\n\n  MbscNavigationModule_1 = MbscNavigationModule;\n\n  MbscNavigationModule.forRoot = function (config) {\n    return {\n      ngModule: MbscNavigationModule_1,\n      providers: [{\n        provide: MbscRouterToken,\n        useExisting: config.angularRouter\n      }]\n    };\n  };\n\n  var MbscNavigationModule_1;\n\n  MbscNavigationModule.ɵfac = function MbscNavigationModule_Factory(t) {\n    return new (t || MbscNavigationModule)();\n  };\n\n  MbscNavigationModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscNavigationModule\n  });\n  MbscNavigationModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, MbscNavigationBaseModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscNavigationModule, {\n      declarations: function () {\n        return [MbscNavItem, MbscNav, MbscBottomNav, MbscHamburgerNav, MbscTabNav];\n      },\n      imports: function () {\n        return [CommonModule, MbscNavigationBaseModule];\n      },\n      exports: function () {\n        return [MbscNavItem, MbscNav, MbscBottomNav, MbscHamburgerNav, MbscTabNav];\n      }\n    });\n  })();\n\n  return MbscNavigationModule;\n}();\n\nvar NumberScroller = Measurement;\npresets.number = presets.measurement;\n\nvar MbscNumber = function (_super) {\n  __extends(MbscNumber, _super);\n\n  function MbscNumber(initialElem, zone, control, inputService, optionService, view) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, view) || this;\n\n    _this.optionService = optionService;\n    _this.options = {};\n    _this.onChangeEmitter = new EventEmitter();\n    return _this;\n  }\n\n  Object.defineProperty(MbscNumber.prototype, \"value\", {\n    set: function (v) {\n      if (!this.control) {\n        this.setNewValueProxy(v);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscNumber.prototype.setNewValue = function (v) {\n    if (this.instance) {\n      var innerValue = this.instance.getVal();\n\n      if (innerValue !== v) {\n        this.instance.setVal(v, true, false);\n\n        if (this._inputService && this._inputService.input) {\n          this._inputService.input.innerValue = this.instance._value;\n        }\n      }\n    }\n  };\n\n  MbscNumber.prototype.initControl = function () {\n    var options = extend$1({\n      preset: 'number'\n    }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);\n    this.instance = new NumberScroller(this.element, options);\n\n    if (this.initialValue !== undefined) {\n      this.instance.setVal(this.initialValue, true, false);\n    }\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumber.prototype, \"decimalSeparator\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumber.prototype, \"defaultValue\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscNumber.prototype, \"invalid\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscNumber.prototype, \"max\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscNumber.prototype, \"min\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscNumber.prototype, \"scale\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscNumber.prototype, \"step\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumber.prototype, \"wholeText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumber.prototype, \"fractionText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumber.prototype, \"signText\", void 0);\n\n  __decorate([Input$1('mbsc-options'), __metadata(\"design:type\", Object)], MbscNumber.prototype, \"options\", void 0);\n\n  __decorate([Input$1('mbsc-number'), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], MbscNumber.prototype, \"value\", null);\n\n  __decorate([Output('mbsc-numberChange'), __metadata(\"design:type\", EventEmitter)], MbscNumber.prototype, \"onChangeEmitter\", void 0);\n\n  MbscNumber = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscNumber);\n\n  MbscNumber.ɵfac = function MbscNumber_Factory(t) {\n    return new (t || MbscNumber)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscNumber.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscNumber,\n    selectors: [[\"\", \"mbsc-number\", \"\"]],\n    inputs: {\n      value: [\"mbsc-number\", \"value\"],\n      decimalSeparator: \"decimalSeparator\",\n      defaultValue: \"defaultValue\",\n      invalid: \"invalid\",\n      max: \"max\",\n      min: \"min\",\n      scale: \"scale\",\n      step: \"step\",\n      wholeText: \"wholeText\",\n      fractionText: \"fractionText\",\n      signText: \"signText\",\n      options: [\"mbsc-options\", \"options\"]\n    },\n    outputs: {\n      onChangeEmitter: \"mbsc-numberChange\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscNumber;\n}(MbscScrollerBase);\n\nvar MbscNumberComponent = function (_super) {\n  __extends(MbscNumberComponent, _super);\n\n  function MbscNumberComponent(initialElem, zone, control, inputService, optionService) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;\n\n    _this.errorMessage = '';\n    _this.placeholder = '';\n    return _this;\n  }\n\n  MbscNumberComponent.prototype.ngAfterViewInit = function () {\n    _super.prototype.ngAfterViewInit.call(this);\n\n    this.setThemeClasses();\n  };\n\n  __decorate([Input$1('icon'), __metadata(\"design:type\", String)], MbscNumberComponent.prototype, \"inputIcon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscNumberComponent.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumberComponent.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscNumberComponent.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumberComponent.prototype, \"errorMessage\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscNumberComponent.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumberComponent.prototype, \"placeholder\", void 0);\n\n  MbscNumberComponent = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])], MbscNumberComponent);\n\n  MbscNumberComponent.ɵfac = function MbscNumberComponent_Factory(t) {\n    return new (t || MbscNumberComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscNumberComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscNumberComponent,\n    selectors: [[\"mbsc-number\"]],\n    inputs: {\n      inputIcon: [\"icon\", \"inputIcon\"],\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      name: \"name\",\n      error: \"error\",\n      errorMessage: \"errorMessage\",\n      options: \"options\",\n      placeholder: \"placeholder\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\", 4, \"ngIf\"], [3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\"]],\n    template: function MbscNumberComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MbscNumberComponent_mbsc_input_0_Template, 2, 13, \"mbsc-input\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.inline || ctx.showInput);\n      }\n    },\n    directives: [ɵngcc2.NgIf, MbscInput],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscNumberComponent;\n}(MbscNumber);\n\nvar MbscNumberModule = function () {\n  function MbscNumberModule() {}\n\n  MbscNumberModule.ɵfac = function MbscNumberModule_Factory(t) {\n    return new (t || MbscNumberModule)();\n  };\n\n  MbscNumberModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscNumberModule\n  });\n  MbscNumberModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, MbscScrollerBaseModule, MbscInputModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscNumberModule, {\n      declarations: function () {\n        return [MbscNumber, MbscNumberComponent];\n      },\n      imports: function () {\n        return [CommonModule, MbscScrollerBaseModule, MbscInputModule];\n      },\n      exports: function () {\n        return [MbscNumber, MbscNumberComponent];\n      }\n    });\n  })();\n\n  return MbscNumberModule;\n}();\n\nvar presets$1 = {};\n\nvar Numpad = function Numpad(el, settings, inherit) {\n  var $markup,\n      deleteBtn,\n      disabledClass,\n      ph,\n      pos,\n      s,\n      mask,\n      sX,\n      sY,\n      eX,\n      eY,\n      diffX,\n      diffY,\n      action,\n      interval,\n      tempValueArray,\n      tempTotal,\n      trigger,\n      total,\n      valueArray,\n      $elm = $$1(el),\n      that = this,\n      actions = [],\n      tempActions = [],\n      tempVariables = {},\n      variables = {},\n      customKeys = {},\n      numericKeys = {\n    48: 0,\n    49: 1,\n    50: 2,\n    51: 3,\n    52: 4,\n    53: 5,\n    54: 6,\n    55: 7,\n    56: 8,\n    57: 9,\n    96: 0,\n    97: 1,\n    98: 2,\n    99: 3,\n    100: 4,\n    101: 5,\n    102: 6,\n    103: 7,\n    104: 8,\n    105: 9\n  };\n\n  function display(manual) {\n    // Validate\n    var i,\n        ret = s.validate.call(el, {\n      values: tempValueArray.slice(0),\n      variables: tempVariables\n    }, that) || [],\n        disabled = ret && ret.disabled || [];\n    that._isValid = ret.invalid ? false : true; // Generate formatted value\n\n    that._tempValue = s.formatValue.call(el, tempValueArray.slice(0), tempVariables, that);\n    pos = tempValueArray.length;\n    tempTotal = ret.length || total;\n\n    if (that._isVisible\n    /* TRIALCOND */\n    ) {\n      // Fill template with numbers\n      $$1('.mbsc-np-ph', $markup).each(function (i) {\n        $$1(this).html(s.fill == 'ltr' ? i >= pos ? ph : mask || tempValueArray[i] : i >= total - tempTotal ? i + pos < total ? ph : mask || tempValueArray[i + pos - total] : '');\n      }); // Fill variable placeholders\n\n      $$1('.mbsc-np-cph', $markup).each(function () {\n        $$1(this).html(tempVariables[$$1(this).attr('data-var')] || $$1(this).attr('data-ph'));\n      }); // Disable all numeric buttons if template is full\n\n      if (pos === total) {\n        for (i = 0; i <= 9; i++) {\n          disabled.push(i);\n        }\n      } // Disable invalid buttons\n\n\n      $$1('.mbsc-np-btn', $markup).removeClass(disabledClass);\n\n      for (i = 0; i < disabled.length; i++) {\n        $$1('.mbsc-np-btn[data-val=\"' + disabled[i] + '\"]', $markup).addClass(disabledClass);\n      } // Disable set button\n\n\n      if (that._isValid) {\n        $$1('.mbsc-fr-btn-s .mbsc-fr-btn', $markup).removeClass(disabledClass);\n      } else {\n        $$1('.mbsc-fr-btn-s .mbsc-fr-btn', $markup).addClass(disabledClass);\n      } // Fill input if in live mode\n\n\n      if (that.live) {\n        that._hasValue = manual || that._hasValue;\n        fillValue(manual, false, manual);\n\n        if (manual) {\n          trigger('onSet', {\n            valueText: that._value\n          });\n        }\n      }\n    }\n  }\n\n  function fillValue(fill, disp, change, temp) {\n    if (disp) {\n      display();\n    }\n\n    if (!temp) {\n      valueArray = tempValueArray.slice(0);\n      variables = extend$1({}, tempVariables);\n      actions = tempActions.slice(0);\n      that._value = that._hasValue ? that._tempValue : null;\n    }\n\n    if (fill) {\n      if (that._isInput) {\n        $elm.val(that._hasValue && that._isValid ? that._value : '');\n      }\n\n      trigger('onFill', {\n        valueText: that._hasValue ? that._tempValue : '',\n        change: change\n      });\n\n      if (change) {\n        that._preventChange = true;\n        $elm.trigger('change');\n      }\n    }\n  }\n\n  function loadValues(values) {\n    var i,\n        vars,\n        val = values || [],\n        ret = [];\n    tempActions = [];\n    tempVariables = {};\n\n    for (i = 0; i < val.length; i++) {\n      //if (isNaN(parseInt(val[i]))) {\n      if (/:/.test(val[i])) {\n        vars = val[i].split(':');\n        tempVariables[vars[0]] = vars[1];\n        tempActions.push(vars[0]);\n      } else {\n        ret.push(val[i]);\n        tempActions.push('digit');\n      }\n    }\n\n    return ret;\n  }\n\n  function triggerInput(btn, ev) {\n    trigger('onInput', {\n      domEvent: ev,\n      target: btn,\n      values: tempValueArray.slice(0),\n      valueText: that._tempValue,\n      variables: tempVariables\n    });\n  }\n\n  function addKeys(keys, pos) {\n    if (keys) {\n      keys = $$1.isArray(keys) ? keys : [keys];\n      keys.forEach(function (key) {\n        customKeys[key] = pos;\n      });\n    }\n  }\n\n  function onNumberTap(btn, val, ev) {\n    if (!pos && !val && !s.allowLeadingZero || btn.hasClass('mbsc-disabled') || btn.hasClass('mbsc-np-btn-empty')) {\n      return;\n    }\n\n    if (pos < total\n    /* TRIALCOND */\n    ) {\n      tempActions.push('digit');\n      tempValueArray.push(val);\n      display(true);\n      triggerInput(btn[0], ev);\n    }\n  }\n\n  function onCustomTap(btn, ev) {\n    var i,\n        v,\n        val = btn.attr('data-val'),\n        track = btn.attr('data-track') !== 'false',\n        variable = btn.attr('data-var');\n\n    if (!btn.hasClass('mbsc-disabled')) {\n      if (variable) {\n        v = variable.split(':');\n\n        if (track) {\n          tempActions.push(v[0]);\n        }\n\n        tempVariables[v[0]] = v[2] === undefined ? v[1] : tempVariables[v[0]] == v[1] ? v[2] : v[1];\n      }\n\n      if (val.length + pos <= tempTotal) {\n        for (i = 0; i < val.length; ++i) {\n          v = isNumeric(val[i]) ? +val[i] : val[i];\n\n          if (s.allowLeadingZero || pos || v) {\n            tempActions.push('digit');\n            tempValueArray.push(v);\n            pos = tempValueArray.length;\n          }\n        }\n      }\n\n      display(true);\n      triggerInput(btn[0], ev);\n    }\n  }\n\n  function onDeleteTap(ev) {\n    var i,\n        old,\n        act = tempActions.pop();\n\n    if (pos || act !== 'digit') {\n      if (act !== 'digit' && tempVariables[act]) {\n        delete tempVariables[act];\n        old = tempActions.slice(0);\n        tempActions = [];\n\n        for (i = 0; i < old.length; i++) {\n          if (old[i] !== act) {\n            tempActions.push(old[i]);\n          }\n        }\n      } else {\n        tempValueArray.pop();\n      }\n\n      display(true);\n      triggerInput(deleteBtn, ev);\n    }\n  }\n\n  function startDelete(ev) {\n    action = true;\n    sX = getCoord(ev, 'X');\n    sY = getCoord(ev, 'Y');\n    clearInterval(interval);\n    clearTimeout(interval);\n    onDeleteTap(ev);\n    interval = setInterval(function () {\n      onDeleteTap(ev);\n    }, 150);\n  }\n\n  function stopDelete() {\n    clearInterval(interval);\n    action = false;\n  }\n\n  function onStart(ev) {\n    if (testTouch(ev, this)) {\n      if (ev.type == 'keydown' && ev.keyCode != 32) {\n        return;\n      }\n\n      startDelete(ev);\n\n      if (ev.type == 'mousedown') {\n        $$1(document).on('mousemove', onMove).on('mouseup', onEnd);\n      }\n    }\n  }\n\n  function onMove(ev) {\n    if (action) {\n      eX = getCoord(ev, 'X');\n      eY = getCoord(ev, 'Y');\n      diffX = eX - sX;\n      diffY = eY - sY;\n\n      if (Math.abs(diffX) > 7 || Math.abs(diffY) > 7) {\n        stopDelete();\n      }\n    }\n  }\n\n  function onEnd(ev) {\n    if (action) {\n      ev.preventDefault();\n      stopDelete();\n\n      if (ev.type == 'mouseup') {\n        $$1(document).off('mousemove', onMove).off('mouseup', onEnd);\n      }\n    }\n  } // Call the parent constructor\n\n\n  Frame.call(this, el, settings, true); // Public functions\n\n  /**\r\n   * Sets the value\r\n   */\n\n  that.setVal = that._setVal = function (val, fill, change, temp) {\n    that._hasValue = val !== null && val !== undefined;\n    tempValueArray = loadValues($$1.isArray(val) ? val.slice(0) : s.parseValue.call(el, val, that));\n    fillValue(fill, true, change === undefined ? fill : change, temp);\n  };\n  /**\r\n   * Returns the selected value\r\n   */\n\n\n  that.getVal = that._getVal = function (temp) {\n    return that._hasValue || temp ? that[temp ? '_tempValue' : '_value'] : null;\n  };\n  /*\r\n   * Sets the value (passed as an array)\r\n   */\n\n\n  that.setArrayVal = that.setVal;\n  /*\r\n   * Returns the selected wheel values as an array\r\n   */\n\n  that.getArrayVal = function (temp) {\n    return temp ? tempValueArray.slice(0) : that._hasValue ? valueArray.slice(0) : null;\n  }; // Protected overrides\n\n  /* TRIALFUNC */\n\n\n  that._readValue = function () {\n    var v = $elm.val() || '';\n\n    if (v !== '') {\n      that._hasValue = true;\n    }\n\n    if (mask) {\n      tempVariables = {};\n      tempActions = [];\n      tempValueArray = [];\n    } else {\n      tempVariables = that._hasValue ? variables : {};\n      tempActions = that._hasValue ? actions : [];\n      tempValueArray = that._hasValue && valueArray ? valueArray.slice(0) : loadValues(s.parseValue.call(el, v, that));\n      fillValue(false, true);\n    }\n  };\n\n  that._fillValue = function () {\n    that._hasValue = true;\n    fillValue(true, false, true);\n  };\n\n  that._generateContent = function () {\n    var i,\n        j,\n        v,\n        k = 1,\n        leftKey = s.leftKey,\n        rightKey = s.rightKey,\n        template = '',\n        html = ''; // Display\n\n    html += '<div class=\"mbsc-np-hdr\"><div role=\"button\" tabindex=\"0\" aria-label=\"' + s.deleteText + '\" class=\"mbsc-np-del mbsc-fr-btn-e mbsc-ic mbsc-ic-' + s.deleteIcon + '\"></div><div class=\"mbsc-np-dsp\">'; // Process template\n\n    template = s.template.replace(/d/g, '<span class=\"mbsc-np-ph\">' + ph + '</span>').replace(/&#100;/g, 'd'); // Generate the template for custom buttons\n\n    template = template.replace(/{([a-zA-Z0-9]*):?([a-zA-Z0-9\\-_]*)}/g, '<span class=\"mbsc-np-cph\" data-var=\"$1\" data-ph=\"$2\">$2</span>');\n    html += template;\n    html += '</div></div>'; // Digit buttons\n\n    html += '<div class=\"mbsc-np-tbl-c mbsc-w-p\"><div class=\"mbsc-np-tbl\">';\n\n    for (i = 0; i < 4; i++) {\n      html += '<div class=\"mbsc-np-row\">';\n\n      for (j = 0; j < 3; j++) {\n        v = k;\n\n        if (k == 10 || k == 12) {\n          v = '';\n        } else if (k == 11) {\n          v = 0;\n        }\n\n        if (v === '') {\n          if (k == 10 && leftKey) {\n            addKeys(leftKey.keys, 'left');\n            html += '<div role=\"button\" tabindex=\"0\" class=\"mbsc-np-btn mbsc-np-btn-custom mbsc-np-btn-custom-left mbsc-fr-btn-e\" ' + (leftKey.variable ? 'data-var=\"' + leftKey.variable + '\"' : '') + ' data-val=\"' + (leftKey.value || '') + '\" ' + (leftKey.track !== undefined ? ' data-track=\"' + leftKey.track + '\"' : '') + '>' + leftKey.text + '</div>';\n          } else if (k == 12 && s.rightKey) {\n            addKeys(rightKey.keys, 'right');\n            html += '<div role=\"button\" tabindex=\"0\" class=\"mbsc-np-btn mbsc-np-btn-custom mbsc-np-btn-custom-right mbsc-fr-btn-e\" ' + (rightKey.variable ? 'data-var=\"' + rightKey.variable + '\"' : '') + ' data-val=\"' + (rightKey.value || '') + '\" ' + (rightKey.track !== undefined ? ' data-track=\"' + rightKey.track + '\"' : '') + ' >' + rightKey.text + '</div>';\n          } else {\n            html += '<div class=\"mbsc-np-btn mbsc-np-btn-empty\"></div>';\n          }\n        } else {\n          html += '<div tabindex=\"0\" role=\"button\" class=\"mbsc-np-btn mbsc-fr-btn-e\" data-val=\"' + v + '\">' + v\n          /* TRIAL */\n          + '</div>';\n        }\n\n        k++;\n      }\n\n      html += '</div>';\n    }\n\n    html += '</div></div>';\n    return html;\n  };\n\n  that._markupReady = function () {\n    $markup = that._markup;\n    display();\n  };\n\n  that._attachEvents = function ($m) {\n    $m.on('keydown', function (ev) {\n      var btn,\n          key = ev.keyCode;\n\n      if (customKeys[key] !== undefined) {\n        btn = $$1('.mbsc-np-btn-custom-' + customKeys[key], $m);\n\n        if (btn.length) {\n          if (btn.attr('data-var') === 'sign:-:') {\n            tempVariables.sign = key === 107 || key === 187 ? '-' : '';\n          }\n\n          onCustomTap(btn, ev);\n        }\n      } else if (numericKeys[key] !== undefined) {\n        onNumberTap($$1('.mbsc-np-btn[data-val=\"' + numericKeys[key] + '\"]', $m), numericKeys[key], ev);\n      } else if (key == 8) {\n        ev.preventDefault();\n        onDeleteTap(ev);\n      }\n    });\n    that.tap($$1('.mbsc-np-btn', $m), function (ev) {\n      var btn = $$1(this);\n\n      if (btn.hasClass('mbsc-np-btn-custom')) {\n        onCustomTap(btn, ev);\n      } else {\n        onNumberTap(btn, +btn.attr('data-val'), ev);\n      }\n    }, false, 30, true);\n    deleteBtn = $$1('.mbsc-np-del', $m)[0];\n    listen(deleteBtn, 'touchstart', onStart, {\n      passive: true\n    });\n    listen(deleteBtn, 'mousedown', onStart);\n    listen(deleteBtn, 'keydown', onStart);\n    listen(deleteBtn, 'touchmove', onMove, {\n      passive: true\n    });\n    listen(deleteBtn, 'mousemove', onMove);\n    listen(deleteBtn, 'touchend', onEnd);\n    listen(deleteBtn, 'mouseup', onEnd);\n    listen(deleteBtn, 'keyup', onEnd);\n  };\n\n  that.__init = function () {\n    s = that.settings;\n    s.template = s.template.replace(/\\\\d/, '&#100;');\n    ph = s.placeholder;\n    total = (s.template.match(/d/g) || []).length;\n    disabledClass = 'mbsc-disabled ' + (s.disabledClass || '');\n    mask = s.mask;\n    trigger = that.trigger;\n\n    if (mask && $elm.is('input')) {\n      $elm.attr('type', 'password');\n    }\n  };\n\n  that._indexOf = function (cont, v) {\n    var i;\n\n    for (i = 0; i < cont.length; ++i) {\n      if (cont[i].toString() === v.toString()) {\n        return i;\n      }\n    }\n\n    return -1;\n  }; // Constructor\n\n\n  if (!inherit) {\n    that.init();\n  }\n}; // Extend defaults\n\n\nNumpad.prototype = {\n  _hasDef: true,\n  _hasTheme: true,\n  _hasLang: true,\n  _responsive: true,\n  _class: 'numpad',\n  _presets: presets$1,\n  _defaults: extend$1({}, Frame.prototype._defaults, {\n    template: 'dd.dd',\n    placeholder: '0',\n    deleteIcon: 'backspace',\n    allowLeadingZero: false,\n    headerText: false,\n    fill: 'rtl',\n    compClass: 'mbsc-np',\n    // Localization\n    deleteText: 'Delete',\n    decimalSeparator: '.',\n    thousandsSeparator: ',',\n    // @todo\n    // ---\n    //fillFullTemplate: true,\n    // ---\n    validate: noop,\n    parseValue: noop,\n    formatValue: function formatValue(value, variables, inst) {\n      var i,\n          j = 1,\n          s = inst.settings,\n          ph = s.placeholder,\n          template = s.template,\n          valueLen = value.length,\n          tempLen = template.length,\n          res = '';\n\n      for (i = 0; i < tempLen; i++) {\n        if (template[tempLen - i - 1] == 'd') {\n          if (j <= valueLen) {\n            res = value[valueLen - j] + res;\n          } else {\n            res = ph + res;\n          }\n\n          j++;\n        } else {\n          res = template[tempLen - i - 1] + res;\n        }\n      }\n\n      $$1.each(variables, function (i, v) {\n        res = res.replace('{' + i + '}', v);\n      });\n      return $$1('<div>' + res + '</div>').text();\n    }\n  })\n};\nclasses.Numpad = Numpad;\nmobiscroll.themes.numpad = mobiscroll.themes.frame; // Decimal preset\n// ---\n\nvar decimalDefaults = {\n  entryMode: 'template',\n  min: 0,\n  max: 99.99,\n  maxScale: 4,\n  prefix: '',\n  suffix: '',\n  returnAffix: false\n};\n\npresets$1.decimal = function (inst) {\n  var orig = extend$1({}, inst.settings),\n      conditionalDefaults = {\n    scale: orig.entryMode == 'freeform' ? undefined : 2\n  },\n      s = extend$1(inst.settings, decimalDefaults, conditionalDefaults, orig),\n      scale = s.scale,\n      min = +s.min.toFixed(scale),\n      max = +s.max.toFixed(scale),\n      negativeNum = min < 0,\n      thousandRegex = new RegExp(s.thousandsSeparator, 'g'),\n      maxIntLength = (Math.floor(Math.max(max, Math.abs(min))) + '').length + 1,\n      freeEntry = s.entryMode == 'freeform';\n  /**\r\n   * Returns the number from the digits\r\n   * @param {Array} digitArray\r\n   * @param {boolean} isNegative\r\n   */\n\n  function getNumber(digitArray, isNegative) {\n    var ret = +digitArray.map(function (v, i) {\n      return (i === 0 && v === '.' ? '0' : '') + v;\n    }).join(''); // in the case of NOT the freeEntry mode, the decimal point wont be part of the digits array\n    // in that case the value will need to be adjusted to the right scale\n\n    if (!freeEntry) {\n      for (var i = 0; i < scale; i++) {\n        ret /= 10;\n      }\n    }\n\n    return isNegative ? ret * -1 : ret;\n  }\n  /**\r\n   * Returns the formatted value from the array of digits\r\n   * @param {Array} digitArray\r\n   */\n\n\n  function getFormatted(digitArray, forInput) {\n    var numberStr = '';\n\n    if (freeEntry && (scale === undefined || !forInput)) {\n      if (digitArray[0] === '.') {\n        // add missing leading zero when only the decimal point is pressed\n        numberStr += '0';\n      }\n\n      numberStr += digitArray.join('');\n    } else {\n      numberStr = getNumber(digitArray).toFixed(scale);\n    } // split the value by the decimal separator to add thousand separators to the integer part\n\n\n    var parts = numberStr.split('.'),\n        integer = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, s.thousandsSeparator),\n        dec = parts[1] ? s.decimalSeparator + parts[1] : ''; // when decimal separator also needed when there is no decimal part in free entry mode\n    // because this function also used for the displayed number on the numpad, not only for the input\n\n    if (parts[1] !== undefined && !parts[1].length && freeEntry) {\n      dec = s.decimalSeparator;\n    }\n\n    return integer + dec;\n  } // Extended methods\n  // ---\n\n\n  inst.setVal = function (val, fill, change, temp) {\n    if (typeof val === 'string') {\n      val = +val.replace(s.thousandsSeparator, '').replace(s.decimalSeparator, '.');\n    }\n\n    return inst._setVal(constrain(val, min, max), fill, change, temp);\n  };\n\n  inst.getVal = function (temp) {\n    var val = inst._getVal(temp),\n        valNr = (val + '').replace(thousandRegex, '').replace(s.decimalSeparator, '.');\n\n    return isNumeric(valNr) ? +valNr : val;\n  }; // ---\n\n\n  var numberTemplate = Array(maxIntLength).join('d'); // in the case of freeEntry, the decimal point should not be part of the template\n\n  if (freeEntry) {\n    if (scale !== undefined) {\n      // +2 index required:\n      // - 1 for the decimal point\n      // - 1 for the join method, since the \"d\"s will be the separators (and there's one separator less than value)\n      numberTemplate += scale ? Array(scale + 2).join('d') : '';\n    } else {\n      numberTemplate += Array(s.maxScale + 2).join('d');\n    }\n  } else {\n    // +1 required for the join method, since the \"d\"s will be the separators (and there's one separator less than value)\n    numberTemplate += scale ? '.' + Array(scale + 1).join('d') : '';\n  }\n\n  var template = (negativeNum ? '{sign}' : '') + s.prefix.replace(/d/g, '\\\\d') + numberTemplate + s.suffix.replace(/d/g, '\\\\d');\n  return {\n    template: template,\n    leftKey: negativeNum ? {\n      text: '-/+',\n      variable: 'sign:-:',\n      track: false,\n      keys: [107, 109, 187, 189]\n    } : undefined,\n    rightKey: freeEntry ? {\n      text: s.decimalSeparator,\n      value: '.',\n      keys: [110, 190]\n    } : undefined,\n    allowLeadingZero: freeEntry,\n    parseValue: function parseValue(value) {\n      var i,\n          m,\n          v = value || s.defaultValue,\n          ret = [],\n          fixScale = scale !== undefined ? scale : s.maxScale;\n\n      if (value === 0 || value === '0') {\n        return [0];\n      }\n\n      if (v) {\n        v = (v + '').replace(thousandRegex, '').replace(s.decimalSeparator, '.');\n        m = v.match(/\\d+\\.?\\d*/g);\n\n        if (m) {\n          m = (+m[0]).toFixed(fixScale);\n\n          for (i = 0; i < m.length; i++) {\n            if (m[i] != '.') {\n              if (+m[i]) {\n                ret.push(+m[i]);\n              } else if (ret.length) {\n                // No leading 0s\n                // in freeEntry mode, zeros after the decimal point are only necessary if there are other nonzero digits after them\n                // for example 10.0001 - decimal zeros are required => 10.0001 => [1, 0, ., 0, 0, 0, 1]\n                // for example 10.1000 - decimal zeros are not required => 10.1 => [1, 0, ., 1]\n                var decIndex = m.indexOf('.');\n                var nonZero = m.length > i + 1 && m.substring(i + 1).match(/[1-9]+/);\n\n                if (!freeEntry || i < decIndex || nonZero) {\n                  ret.push(0);\n                }\n              }\n            } else if (freeEntry) {\n              // in the case of freeEntry, the decimal point should be part of the input digits\n              ret.push('.');\n            }\n          }\n\n          var decimalIndex = m.indexOf('.'); // if there are no digits after the point remove the point\n\n          if (m.length <= decimalIndex + 1 || !m.substring(decimalIndex + 1).match(/[1-9]+/)) {\n            ret.splice(ret.indexOf('.'), 1);\n          }\n        }\n      }\n\n      if (value < 0) {\n        // make the sign the last thing to manipulate\n        ret.unshift('sign:' + '-');\n      }\n\n      return ret;\n    },\n    formatValue: function formatValue(value, variables) {\n      var v = getFormatted(value, true),\n          nr = getNumber(value, variables && variables.sign == '-');\n      return (nr < 0 ? '-' : '') + (s.returnAffix ? s.prefix + v + s.suffix : v);\n    },\n    validate: function validate(data) {\n      var i,\n          digits = data.values,\n          v = getFormatted(digits),\n          nr = getNumber(digits, data.variables && data.variables.sign == '-'),\n          disabled = [],\n          invalid = nr > max || nr < min || (s.invalid ? inst._indexOf(s.invalid, nr) != -1 : false);\n\n      if (!digits.length && !s.allowLeadingZero && !freeEntry) {\n        disabled.push(0);\n      }\n\n      if (digits.length >= maxIntLength || digits.indexOf('.') !== -1) {\n        disabled.push('.');\n      }\n\n      if (freeEntry) {\n        if (digits.length == 1 && digits[0] === 0) {\n          for (i = 0; i <= 9; i++) {\n            disabled.push(i);\n          }\n        }\n\n        if (!digits.length || digits[digits.length - 1] == '.') {\n          invalid = true;\n        } // Only allow max maxScale decimal values\n\n\n        var sca = scale !== undefined ? scale : s.maxScale; // >= meaning: starting zero digit may be missing, that's why\n\n        if (digits.length >= sca + 1 && digits[digits.length - sca - 1] == '.') {\n          for (i = 0; i <= 9; i++) {\n            disabled.push(i);\n          }\n        }\n      } // Display the formatted value\n\n\n      if (inst.isVisible()) {\n        $$1('.mbsc-np-dsp', inst._markup).html((data.variables.sign || '') + s.prefix + v + s.suffix || '&nbsp;');\n      }\n\n      return {\n        disabled: disabled,\n        invalid: invalid\n      };\n    }\n  };\n}; // ---\n// Timespan preset\n// ---\n\n\nfunction getSeconds(value) {\n  var i = 0,\n      m = 1,\n      ret = 0;\n\n  while (value.length) {\n    if (i > 3) {\n      m = 60 * 60;\n    } else if (i > 1) {\n      m = 60;\n    }\n\n    ret = ret + value.pop() * m * (i % 2 ? 10 : 1);\n    i++;\n  }\n\n  return ret;\n}\n\nvar parts = ['h', 'm', 's'],\n    timespanDefaults = {\n  min: 0,\n  max: 362439,\n  //99 * 60 * 60 + 99 * 60 + 99\n  defaultValue: 0,\n  hourTextShort: 'h',\n  minuteTextShort: 'm',\n  secTextShort: 's'\n};\n\npresets$1.timespan = function (inst) {\n  var orig = extend$1({}, inst.settings),\n      s = extend$1(inst.settings, timespanDefaults, orig),\n      labels = {\n    h: s.hourTextShort.replace(/d/g, '\\\\d'),\n    m: s.minuteTextShort.replace(/d/g, '\\\\d'),\n    s: s.secTextShort.replace(/d/g, '\\\\d')\n  },\n      template = 'd<span class=\"mbsc-np-sup mbsc-np-time\">' + labels.s + '</span>';\n\n  function formatTime(seconds) {\n    var p,\n        ret = '',\n        m = 60 * 60;\n    $$1(parts).each(function (i, v) {\n      p = Math.floor(seconds / m);\n      seconds -= p * m;\n      m /= 60;\n\n      if (p > 0 || v == 's' && !ret) {\n        ret = ret + (ret ? ' ' : '') + p + labels[v];\n      }\n    });\n    return ret;\n  }\n\n  if (s.max > 9) {\n    template = 'd' + template;\n  }\n\n  if (s.max > 99) {\n    template = '<span class=\"mbsc-np-ts-m\">' + (s.max > 639 ? 'd' : '') + 'd</span><span class=\"mbsc-np-sup mbsc-np-time\">' + labels.m + '</span>' + template;\n  }\n\n  if (s.max > 6039) {\n    template = '<span class=\"mbsc-np-ts-h\">' + (s.max > 38439 ? 'd' : '') + 'd</span><span class=\"mbsc-np-sup mbsc-np-time\">' + labels.h + '</span>' + template;\n  } // Extended methods\n  // ---\n\n\n  inst.setVal = function (val, fill, change, temp) {\n    if (isNumeric(val)) {\n      val = formatTime(val);\n    }\n\n    return inst._setVal(val, fill, change, temp);\n  };\n\n  inst.getVal = function (temp) {\n    return inst._hasValue || temp ? getSeconds(inst.getArrayVal(temp)) : null;\n  }; // ---\n\n\n  return {\n    template: template,\n    parseValue: function parseValue(value) {\n      var p,\n          vv = value || formatTime(s.defaultValue),\n          ret = [];\n\n      if (vv) {\n        $$1(parts).each(function (i, v) {\n          p = new RegExp('(\\\\d+)' + labels[v], 'gi').exec(vv);\n\n          if (p) {\n            p = +p[1];\n\n            if (p > 9) {\n              ret.push(Math.floor(p / 10));\n              ret.push(p % 10);\n            } else {\n              if (ret.length) {\n                // No leading 0s\n                ret.push(0);\n              }\n\n              if (p || ret.length) {\n                // No leading 0s\n                ret.push(p);\n              }\n            }\n          } else if (ret.length) {\n            ret.push(0);\n            ret.push(0);\n          }\n        });\n      }\n\n      return ret;\n    },\n    formatValue: function formatValue(value) {\n      return formatTime(getSeconds(value));\n    },\n    validate: function validate(data) {\n      var value = data.values,\n          v = getSeconds(value.slice(0)),\n          disabled = [];\n\n      if (!value.length) {\n        disabled.push(0);\n      }\n\n      return {\n        disabled: disabled,\n        invalid: v > s.max || v < s.min || (s.invalid ? inst._indexOf(s.invalid, +v) != -1 : false)\n      };\n    }\n  };\n}; // ---\n// Time preset\n// ---\n\n\nvar timeDefaults = {\n  timeFormat: 'hh:ii A',\n  amText: 'am',\n  pmText: 'pm'\n};\n\npresets$1.time = function (inst) {\n  var orig = extend$1({}, inst.settings),\n      s = extend$1(inst.settings, timeDefaults, orig),\n      timeFormat = s.timeFormat.split(':'),\n      isAmPM = s.timeFormat.match(/a/i),\n      am = isAmPM ? isAmPM[0] == 'a' ? s.amText : s.amText.toUpperCase() : '',\n      pm = isAmPM ? isAmPM[0] == 'a' ? s.pmText : s.pmText.toUpperCase() : '',\n      l = 0,\n      minH = s.min ? '' + s.min.getHours() : '',\n      maxH = s.max ? '' + s.max.getHours() : '',\n      minM = s.min ? '' + (s.min.getMinutes() < 10 ? '0' + s.min.getMinutes() : s.min.getMinutes()) : '',\n      maxM = s.max ? '' + (s.max.getMinutes() < 10 ? '0' + s.max.getMinutes() : s.max.getMinutes()) : '',\n      minS = s.min ? '' + (s.min.getSeconds() < 10 ? '0' + s.min.getSeconds() : s.min.getSeconds()) : '',\n      maxS = s.max ? '' + (s.max.getSeconds() < 10 ? '0' + s.max.getSeconds() : s.max.getSeconds()) : '';\n\n  if (s.min) {\n    s.min.setFullYear(2014, 7, 20);\n  }\n\n  if (s.max) {\n    s.max.setFullYear(2014, 7, 20);\n  }\n\n  function getFormattedTime(value, variables) {\n    var i,\n        ret = '';\n\n    for (i = 0; i < value.length; ++i) {\n      ret += value[i] + (i % 2 == (value.length % 2 == 1 ? 0 : 1) && i != value.length - 1 ? ':' : '');\n    }\n\n    $$1.each(variables, function (i, v) {\n      ret += ' ' + v;\n    });\n    return ret;\n  }\n\n  function disableButtons(value) {\n    var i,\n        isMinH,\n        isMaxH,\n        isMinM,\n        isMaxM,\n        invH,\n        invM,\n        invS,\n        hour,\n        minutes,\n        disabled = [],\n        digitNr = 2 * timeFormat.length;\n    l = digitNr;\n\n    if (!value.length) {\n      if (isAmPM) {\n        disabled.push(0);\n        disabled.push(s.leftKey.value);\n      }\n\n      disabled.push(s.rightKey.value);\n    }\n\n    if (!isAmPM && (digitNr - value.length < 2 || value[0] != 1 && (value[0] > 2 || value[1] > 3) && digitNr - value.length <= 2)) {\n      disabled.push('30');\n      disabled.push('00');\n    }\n\n    if ((isAmPM ? value[0] > 1 || value[1] > 2 : value[0] != 1 && (value[0] > 2 || value[1] > 3)) && value[0]) {\n      // if the hour number is not a two digit number\n      value.unshift(0);\n      l = digitNr - 1;\n    }\n\n    if (value.length == digitNr) {\n      for (i = 0; i <= 9; ++i) {\n        disabled.push(i);\n      }\n    } else if (value.length == 1 && isAmPM && value[0] == 1 || value.length && value.length % 2 === 0 || !isAmPM && value[0] == 2 && value[1] > 3 && value.length % 2 == 1) {\n      for (i = 6; i <= 9; ++i) {\n        disabled.push(i);\n      }\n    }\n\n    hour = value[1] !== undefined ? '' + value[0] + value[1] : '';\n    minutes = +maxM == +(value[3] !== undefined ? '' + value[2] + value[3] : '');\n\n    if (s.invalid) {\n      for (i = 0; i < s.invalid.length; ++i) {\n        invH = s.invalid[i].getHours();\n        invM = s.invalid[i].getMinutes();\n        invS = s.invalid[i].getSeconds();\n\n        if (invH == +hour) {\n          if (timeFormat.length == 2 && (invM < 10 ? 0 : +('' + invM)[0]) == +value[2]) {\n            // disable invalid minutes\n            disabled.push(invM < 10 ? invM : +('' + invM)[1]);\n            break;\n          } else if ((invS < 10 ? 0 : +('' + invS)[0]) == +value[4]) {\n            // disable invalid sec\n            disabled.push(invS < 10 ? invS : +('' + invS)[1]);\n            break;\n          }\n        }\n      }\n    }\n\n    if (s.min || s.max) {\n      isMinH = +minH == +hour;\n      isMaxH = +maxH == +hour;\n      isMaxM = isMaxH && minutes;\n      isMinM = isMinH && minutes;\n\n      if (value.length === 0) {\n        for (i = isAmPM ? 2 : minH > 19 ? minH[0] : 3; i <= (minH[0] == 1 ? 9 : minH[0] - 1); ++i) {\n          // disables values lower than min and leves the 1,2 buttons\n          disabled.push(i);\n        }\n\n        if (minH >= 10) {\n          disabled.push(0);\n\n          if (minH[0] == 2) {\n            //if 2x hour is min\n            for (i = 3; i <= 9; ++i) {\n              disabled.push(i);\n            }\n          }\n        }\n\n        if (maxH && maxH < 10 || minH && minH >= 10) {\n          //disables values between min and max values\n          for (i = maxH && maxH < 10 ? +maxH[0] + 1 : 0; i < (minH && minH >= 10 ? minH[0] : 10); ++i) {\n            disabled.push(i);\n          }\n        }\n      }\n\n      if (value.length == 1) {\n        if (value[0] === 0) {\n          // disable min values if 24h format, and starts with 0\n          for (i = 0; i < minH[0]; ++i) {\n            //kiveve minH[0] == 1 ? 9 :\n            disabled.push(i);\n          }\n        }\n\n        if (minH && value[0] !== 0 && (isAmPM ? value[0] == 1 : value[0] == 2)) {\n          // don't allow lower values entered, ex. 2:56\n          for (i = isAmPM ? 3 : 4; i <= 9; ++i) {\n            disabled.push(i);\n          }\n        }\n\n        if (value[0] == minH[0]) {\n          // is min value\n          for (i = 0; i < minH[1]; ++i) {\n            disabled.push(i);\n          }\n        }\n\n        if (value[0] == maxH[0] && !isAmPM) {\n          // is max value\n          for (i = +maxH[1] + 1; i <= 9; ++i) {\n            disabled.push(i);\n          }\n        }\n      }\n\n      if (value.length == 2 && (isMinH || isMaxH)) {\n        for (i = isMaxH ? +maxM[0] + 1 : 0; i < (isMinH ? +minM[0] : 10); ++i) {\n          disabled.push(i);\n        }\n      }\n\n      if (value.length == 3 && (isMaxH && value[2] == maxM[0] || isMinH && value[2] == minM[0])) {\n        for (i = isMaxH && value[2] == maxM[0] ? +maxM[1] + 1 : 0; i < (isMinH && value[2] == minM[0] ? +minM[1] : 10); ++i) {\n          disabled.push(i);\n        }\n      }\n\n      if (value.length == 4 && (isMinM || isMaxM)) {\n        for (i = isMaxM ? +maxS[0] + 1 : 0; i < (isMinM ? +minS[0] : 10); ++i) {\n          disabled.push(i);\n        }\n      }\n\n      if (value.length == 5 && (isMinM && value[4] == minS[0] || isMaxM && value[4] == maxS[0])) {\n        for (i = isMaxM && value[4] == maxS[0] ? +maxS[1] + 1 : 0; i < (isMinM && value[4] == minS[0] ? +minS[1] : 10); ++i) {\n          disabled.push(i);\n        }\n      }\n    }\n\n    return disabled;\n  }\n\n  return {\n    placeholder: '-',\n    allowLeadingZero: true,\n    template: (timeFormat.length == 3 ? 'dd:dd:dd' : timeFormat.length == 2 ? 'dd:dd' : 'dd') + (isAmPM ? '<span class=\"mbsc-np-sup\">{ampm:--}</span>' : ''),\n    leftKey: isAmPM ? {\n      text: am,\n      variable: 'ampm:' + am,\n      value: '00'\n    } : {\n      text: ':00',\n      value: '00'\n    },\n    rightKey: isAmPM ? {\n      text: pm,\n      variable: 'ampm:' + pm,\n      value: '00'\n    } : {\n      text: ':30',\n      value: '30'\n    },\n    parseValue: function parseValue(value) {\n      var i,\n          m,\n          v = value || s.defaultValue,\n          ret = [];\n\n      if (v) {\n        v = v + '';\n        m = v.match(/\\d/g);\n\n        if (m) {\n          for (i = 0; i < m.length; i++) {\n            ret.push(+m[i]);\n          }\n        }\n\n        if (isAmPM) {\n          ret.push('ampm:' + (v.match(new RegExp(s.pmText, 'gi')) ? pm : am));\n        }\n      }\n\n      return ret;\n    },\n    formatValue: function formatValue(value, variables) {\n      return getFormattedTime(value, variables);\n    },\n    validate: function validate(data) {\n      var value = data.values,\n          variables = data.variables,\n          formattedTime = getFormattedTime(value, variables),\n          d = value.length >= 3 ? new Date(2014, 7, 20, '' + value[0] + (value.length % 2 === 0 ? value[1] : ''), '' + value[value.length % 2 === 0 ? 2 : 1] + value[value.length % 2 === 0 ? 3 : 2]) : '';\n      return {\n        disabled: disableButtons(value),\n        length: l,\n        invalid: (isAmPM ? !new RegExp('^(0?[1-9]|1[012])(:[0-5]\\\\d)?(:[0-5][0-9])' + ' (?:' + s.amText + '|' + s.pmText + ')$', 'i').test(formattedTime) : !/^([0-1]?[0-9]|2[0-4]):([0-5][0-9])(:[0-5][0-9])?$/.test(formattedTime)) || (s.invalid ? inst._indexOf(s.invalid, d) != -1 : false) || !((s.min ? s.min <= d : true) && (s.max ? d <= s.max : true))\n      };\n    }\n  };\n}; // Date preset\n// ---\n\n\nvar dateDefaults = {\n  dateOrder: 'mdy',\n  dateFormat: 'mm/dd/yy',\n  delimiter: '/'\n};\n\npresets$1.date = function (inst) {\n  var yi,\n      mi,\n      di,\n      i,\n      indexArray = [],\n      orig = extend$1({}, inst.settings),\n      s = extend$1(inst.settings, dateTimeDefaults, dateDefaults, orig),\n      templ = s.dateOrder,\n      minM = s.min ? '' + (s.getMonth(s.min) + 1) : 0,\n      maxM = s.max ? '' + (s.getMonth(s.max) + 1) : 0,\n      minD = s.min ? '' + s.getDay(s.min) : 0,\n      maxD = s.max ? '' + s.getDay(s.max) : 0,\n      minY = s.min ? '' + s.getYear(s.min) : 0,\n      maxY = s.max ? '' + s.getYear(s.max) : 0;\n  templ = templ.replace(/y+/gi, 'yyyy');\n  templ = templ.replace(/m+/gi, 'mm');\n  templ = templ.replace(/d+/gi, 'dd');\n  yi = templ.toUpperCase().indexOf('Y');\n  mi = templ.toUpperCase().indexOf('M');\n  di = templ.toUpperCase().indexOf('D');\n  templ = '';\n  indexArray.push({\n    val: yi,\n    n: 'yyyy'\n  }, {\n    val: mi,\n    n: 'mm'\n  }, {\n    val: di,\n    n: 'dd'\n  });\n  indexArray.sort(function (a, b) {\n    return a.val - b.val;\n  });\n  $$1.each(indexArray, function (i, v) {\n    templ += v.n;\n  });\n  yi = templ.indexOf('y');\n  mi = templ.indexOf('m');\n  di = templ.indexOf('d');\n  templ = '';\n\n  for (i = 0; i < 8; ++i) {\n    templ += 'd';\n\n    if (i + 1 == yi || i + 1 == mi || i + 1 == di) {\n      templ += s.delimiter;\n    }\n  }\n\n  function isleapYear(year) {\n    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n  }\n\n  function disableButtons(value) {\n    var i,\n        j,\n        invY,\n        invM,\n        invD,\n        disabled = [],\n        year = value[yi + 3] !== undefined ? '' + value[yi] + value[yi + 1] + value[yi + 2] + value[yi + 3] : '',\n        month = value[mi + 1] !== undefined ? '' + value[mi] + value[mi + 1] : '',\n        day = value[di + 1] !== undefined ? '' + value[di] + value[di + 1] : '',\n        maxDay = '' + s.getMaxDayOfMonth(year || 2012, month - 1 || 0),\n        // Use a leap year if no year present to allow day 29 to be enetered\n    isMin = minY === year && +minM === +month,\n        isMax = maxY === year && +maxM === +month;\n\n    if (s.invalid) {\n      for (i = 0; i < s.invalid.length; ++i) {\n        invY = s.getYear(s.invalid[i]);\n        invM = s.getMonth(s.invalid[i]);\n        invD = s.getDay(s.invalid[i]);\n\n        if (invY == +year && invM + 1 == +month) {\n          //disable the ivalid day\n          if ((invD < 10 ? 0 : +('' + invD)[0]) == +value[di]) {\n            disabled.push(invD < 10 ? invD : +('' + invD)[1]);\n            break;\n          }\n        }\n\n        if (invM + 1 == +month && invD == +day) {\n          //disable invalid year\n          if (('' + invY).substring(0, 3) == '' + value[yi] + value[yi + 1] + value[yi + 2]) {\n            disabled.push(('' + invY)[3]);\n            break;\n          }\n        }\n\n        if (invY == +year && invD == +day) {\n          //disable the ivalid month\n          if ((invM < 10 ? 0 : +('' + (invM + 1))[0]) == +value[mi]) {\n            disabled.push(invM < 10 ? invM : +('' + (invM + 1))[1]);\n            break;\n          }\n        }\n      }\n    } // month check\n\n\n    if (day == '31' && (value.length == mi || value.length == mi + 1)) {\n      // disable 30 day months\n      if (value[mi] != 1) {\n        disabled.push(2, 4, 6, 9, 11);\n      } else {\n        disabled.push(1);\n      }\n    }\n\n    if (day == '30' && value[mi] === 0 && value.length <= mi + 1) {\n      // disable february\n      disabled.push(2);\n    }\n\n    if (value.length == mi) {\n      // before month's first digit set, disable values outside min/max\n      for (i = maxY === year && +maxM < 10 ? 1 : 2; i <= 9; ++i) {\n        disabled.push(i);\n      }\n\n      if (minY === year && +minM >= 10) {\n        disabled.push(0);\n      }\n    }\n\n    if (value.length == mi + 1) {\n      // before month's second digit set\n      if (value[mi] == 1) {\n        // if two digit month number\n        for (i = maxY === year ? +maxM[1] + 1 : 3; i <= 9; ++i) {\n          disabled.push(i);\n        }\n\n        if (minY == year) {\n          // if min year diable lower values\n          for (i = 0; i < +minM[1]; ++i) {\n            disabled.push(i);\n          }\n        }\n      }\n\n      if (value[mi] === 0) {\n        //if month number starts with 0\n        disabled.push(0);\n\n        if (maxY === year || minY === year) {\n          // if min/max diable lower/greater values\n          for (i = maxY === year ? +day > +maxD ? +maxM : +maxM + 1 : 0; i <= (minY === year ? +day < +minD ? +minM - 1 : +minM - 1 : 9); ++i) {\n            disabled.push(i);\n          }\n        }\n      }\n    } // day check\n\n\n    if (value.length == di) {\n      // before day first digit set\n      for (i = isMax ? (+maxD > 10 ? +maxD[0] : 0) + 1 : +maxDay[0] + 1; i <= 9; ++i) {\n        disabled.push(i);\n      }\n\n      if (isMin) {\n        // if is min year and month disable lower values\n        for (i = 0; i < (+minD < 10 ? 0 : minD[0]); ++i) {\n          disabled.push(i);\n        }\n      }\n    }\n\n    if (value.length == di + 1) {\n      // before day second digit set\n      if (value[di] >= 3 || month == '02') {\n        //disable greater values than the maxDay's second digit\n        for (i = +maxDay[1] + 1; i <= 9; ++i) {\n          disabled.push(i);\n        }\n      }\n\n      if (isMax && +maxD[0] == value[di]) {\n        //if max year and month disable greater values\n        for (i = +maxD[1] + 1; i <= 9; ++i) {\n          disabled.push(i);\n        }\n      }\n\n      if (isMin && minD[0] == value[di]) {\n        //if min year and month disable lower values\n        for (i = 0; i < +minD[1]; ++i) {\n          disabled.push(i);\n        }\n      }\n\n      if (value[di] === 0) {\n        // if month first digit 0\n        disabled.push(0);\n\n        if (isMax || isMin) {\n          // disable greater/lower valies if min or max\n          for (i = isMax ? +maxD + 1 : 1; i <= (isMin ? +minD - 1 : 9); ++i) {\n            disabled.push(i);\n          }\n        }\n      }\n    } // year check\n\n\n    if (value[yi + 2] !== undefined && month == '02' && day == '29') {\n      // if 29th and february than just leap years allowed\n      for (j = +('' + value[yi] + value[yi + 1] + value[yi + 2] + 0); j <= +('' + value[yi] + value[yi + 1] + value[yi + 2] + 9); ++j) {\n        disabled.push(!isleapYear(j) ? j % 10 : '');\n      }\n    }\n\n    if (value.length == yi) {\n      // before year's first digit set\n      if (s.min) {\n        // disable lower values\n        for (i = 0; i < +minY[0]; ++i) {\n          disabled.push(i);\n        }\n      }\n\n      if (s.max) {\n        //disable greater values\n        for (i = +maxY[0] + 1; i <= 9; ++i) {\n          disabled.push(i);\n        }\n      }\n\n      disabled.push(0);\n    }\n\n    if (s.min || s.max) {\n      for (j = 1; j < 4; ++j) {\n        if (value.length == yi + j) {\n          // before year's i-th digit set\n          if (value[yi + j - 1] == +minY[j - 1] && (j == 3 ? value[yi + j - 2] == +minY[j - 2] : true)) {\n            for (i = 0; i < +minY[j] + (j == 3 && value[mi + 1] && +minM > +month ? 1 : 0); ++i) {\n              //if month less than min-month than doesn't allow minYear\n              disabled.push(i);\n            }\n          }\n\n          if (value[yi + j - 1] == +maxY[j - 1] && (j == 3 ? value[yi + j - 2] == +maxY[j - 2] : true)) {\n            for (i = +maxY[j] + (j == 3 && +maxM < +month ? 0 : 1); i <= 9; ++i) {\n              //if month greater than max-month than doesn't allow maxYear\n              disabled.push(i);\n            }\n          }\n        }\n      }\n    }\n\n    return disabled;\n  }\n\n  function calcDate(value) {\n    return new Date(+('' + value[yi] + value[yi + 1] + value[yi + 2] + value[yi + 3]), +('' + value[mi] + value[mi + 1]) - 1, +('' + value[di] + value[di + 1]));\n  } // Extended methods\n  // ---\n\n\n  inst.getVal = function (temp) {\n    return inst._hasValue || temp ? calcDate(inst.getArrayVal(temp)) : null;\n  }; // ---\n\n\n  return {\n    placeholder: '-',\n    fill: 'ltr',\n    allowLeadingZero: true,\n    template: templ,\n    parseValue: function parseValue(value) {\n      var i,\n          ret = [],\n          v = value || s.defaultValue,\n          d = parseDate(s.dateFormat, v, s);\n\n      if (v) {\n        for (i = 0; i < indexArray.length; ++i) {\n          if (/m/i.test(indexArray[i].n)) {\n            ret = ret.concat(((s.getMonth(d) < 9 ? '0' : '') + (s.getMonth(d) + 1)).split(''));\n          } else if (/d/i.test(indexArray[i].n)) {\n            ret = ret.concat(((s.getDay(d) < 10 ? '0' : '') + s.getDay(d)).split(''));\n          } else {\n            ret = ret.concat((s.getYear(d) + '').split(''));\n          }\n        }\n      }\n\n      return ret;\n    },\n    formatValue: function formatValue(value) {\n      return formatDate(s.dateFormat, calcDate(value), s);\n    },\n    validate: function validate(data) {\n      var value = data.values,\n          d = calcDate(value);\n      return {\n        disabled: disableButtons(value),\n        invalid: !(d != 'Invalid Date' && (s.min ? s.min <= d : true) && (s.max ? d <= s.max : true)) || (s.invalid ? inst._indexOf(s.invalid, d) != -1 : false)\n      };\n    }\n  };\n}; // ---\n\n\nvar MbscNumpadBase = function (_super) {\n  __extends(MbscNumpadBase, _super);\n\n  function MbscNumpadBase(initialElem, zone, control, inputService, optionService, view) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, view) || this;\n\n    _this.optionService = optionService;\n    _this.onSet = new EventEmitter();\n    _this.onClear = new EventEmitter();\n    _this.onInput = new EventEmitter();\n    return _this;\n  }\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscNumpadBase.prototype, \"allowLeadingZero\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadBase.prototype, \"deleteIcon\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadBase.prototype, \"fill\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscNumpadBase.prototype, \"leftKey\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadBase.prototype, \"mask\", void 0);\n\n  __decorate([Input$1('char-placeholder'), __metadata(\"design:type\", String)], MbscNumpadBase.prototype, \"placeholderChar\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscNumpadBase.prototype, \"rightKey\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadBase.prototype, \"template\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Function)], MbscNumpadBase.prototype, \"validate\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscNumpadBase.prototype, \"onSet\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscNumpadBase.prototype, \"onClear\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscNumpadBase.prototype, \"onInput\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadBase.prototype, \"cancelText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadBase.prototype, \"clearText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadBase.prototype, \"setText\", void 0);\n\n  MbscNumpadBase = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscNumpadBase);\n\n  MbscNumpadBase.ɵfac = function MbscNumpadBase_Factory(t) {\n    return new (t || MbscNumpadBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscNumpadBase.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscNumpadBase,\n    selectors: [[\"\", \"mbsc-n-b\", \"\"]],\n    inputs: {\n      allowLeadingZero: \"allowLeadingZero\",\n      deleteIcon: \"deleteIcon\",\n      fill: \"fill\",\n      leftKey: \"leftKey\",\n      mask: \"mask\",\n      placeholderChar: [\"char-placeholder\", \"placeholderChar\"],\n      rightKey: \"rightKey\",\n      template: \"template\",\n      validate: \"validate\",\n      cancelText: \"cancelText\",\n      clearText: \"clearText\",\n      setText: \"setText\"\n    },\n    outputs: {\n      onSet: \"onSet\",\n      onClear: \"onClear\",\n      onInput: \"onInput\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscNumpadBase;\n}(MbscFrameBase);\n\nvar MbscNumpad = function (_super) {\n  __extends(MbscNumpad, _super);\n\n  function MbscNumpad(initialElem, zone, control, inputService, optionService, view) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;\n\n    _this.options = {};\n    _this.preset = undefined;\n    _this.onChangeEmitter = new EventEmitter();\n    return _this;\n  }\n\n  Object.defineProperty(MbscNumpad.prototype, \"value\", {\n    set: function (v) {\n      if (!this.control) {\n        this.setNewValueProxy(v);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscNumpad.prototype.setNewValue = function (v) {\n    if (this.instance) {\n      var innerValue = this.instance.getVal();\n\n      if (innerValue !== v) {\n        this.instance.setVal(v, true, false);\n\n        if (this._inputService && this._inputService.input) {\n          this._inputService.input.innerValue = this.instance._value;\n        }\n      }\n    }\n  };\n\n  MbscNumpad.prototype.initControl = function () {\n    var options = extend$1({\n      preset: this.preset\n    }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);\n    this.instance = new Numpad(this.element, options);\n\n    if (this.initialValue !== undefined) {\n      this.instance.setVal(this.initialValue, true, false);\n    }\n  };\n\n  __decorate([Input$1('mbsc-options'), __metadata(\"design:type\", Object)], MbscNumpad.prototype, \"options\", void 0);\n\n  __decorate([Input$1('mbsc-numpad'), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], MbscNumpad.prototype, \"value\", null);\n\n  __decorate([Output('mbsc-numpadChange'), __metadata(\"design:type\", EventEmitter)], MbscNumpad.prototype, \"onChangeEmitter\", void 0);\n\n  MbscNumpad = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscNumpad);\n\n  MbscNumpad.ɵfac = function MbscNumpad_Factory(t) {\n    return new (t || MbscNumpad)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscNumpad.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscNumpad,\n    selectors: [[\"\", \"mbsc-numpad\", \"\"]],\n    inputs: {\n      value: [\"mbsc-numpad\", \"value\"],\n      options: [\"mbsc-options\", \"options\"]\n    },\n    outputs: {\n      onChangeEmitter: \"mbsc-numpadChange\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscNumpad;\n}(MbscNumpadBase);\n\nvar MbscNumpadComponent = function (_super) {\n  __extends(MbscNumpadComponent, _super);\n\n  function MbscNumpadComponent(initialElem, zone, control, inputService, optionService) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;\n\n    _this.errorMessage = '';\n    _this.placeholder = '';\n    return _this;\n  }\n\n  MbscNumpadComponent.prototype.ngAfterViewInit = function () {\n    _super.prototype.ngAfterViewInit.call(this);\n\n    this.setThemeClasses();\n  };\n\n  __decorate([Input$1('icon'), __metadata(\"design:type\", String)], MbscNumpadComponent.prototype, \"inputIcon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscNumpadComponent.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadComponent.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscNumpadComponent.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadComponent.prototype, \"errorMessage\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscNumpadComponent.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadComponent.prototype, \"placeholder\", void 0);\n\n  MbscNumpadComponent = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])], MbscNumpadComponent);\n\n  MbscNumpadComponent.ɵfac = function MbscNumpadComponent_Factory(t) {\n    return new (t || MbscNumpadComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscNumpadComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscNumpadComponent,\n    selectors: [[\"mbsc-numpad\"]],\n    inputs: {\n      inputIcon: [\"icon\", \"inputIcon\"],\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      name: \"name\",\n      error: \"error\",\n      errorMessage: \"errorMessage\",\n      options: \"options\",\n      placeholder: \"placeholder\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\", 4, \"ngIf\"], [3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\"]],\n    template: function MbscNumpadComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MbscNumpadComponent_mbsc_input_0_Template, 2, 13, \"mbsc-input\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.inline || ctx.showInput);\n      }\n    },\n    directives: [ɵngcc2.NgIf, MbscInput],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscNumpadComponent;\n}(MbscNumpad);\n\nvar MbscNumpadDecimal = function (_super) {\n  __extends(MbscNumpadDecimal, _super);\n\n  function MbscNumpadDecimal(initialElem, zone, control, inputService, optionService, view) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;\n\n    _this.options = {};\n    _this.onChangeEmitter = new EventEmitter();\n    _this.preset = 'decimal';\n    return _this;\n  }\n\n  Object.defineProperty(MbscNumpadDecimal.prototype, \"value\", {\n    set: function (v) {\n      if (this.instance || v !== '') {\n        this.setNewValueProxy(v);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  __decorate([Input$1('mbsc-numpad-decimal'), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], MbscNumpadDecimal.prototype, \"value\", null);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadDecimal.prototype, \"decimalSeparator\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscNumpadDecimal.prototype, \"defaultValue\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadDecimal.prototype, \"entryMode\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscNumpadDecimal.prototype, \"invalid\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscNumpadDecimal.prototype, \"scale\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscNumpadDecimal.prototype, \"maxScale\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscNumpadDecimal.prototype, \"min\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscNumpadDecimal.prototype, \"max\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadDecimal.prototype, \"prefix\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscNumpadDecimal.prototype, \"returnAffix\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadDecimal.prototype, \"suffix\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadDecimal.prototype, \"thousandsSeparator\", void 0);\n\n  __decorate([Input$1('mbsc-options'), __metadata(\"design:type\", Object)], MbscNumpadDecimal.prototype, \"options\", void 0);\n\n  __decorate([Output('mbsc-numpad-decimalChange'), __metadata(\"design:type\", EventEmitter)], MbscNumpadDecimal.prototype, \"onChangeEmitter\", void 0);\n\n  MbscNumpadDecimal = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscNumpadDecimal);\n\n  MbscNumpadDecimal.ɵfac = function MbscNumpadDecimal_Factory(t) {\n    return new (t || MbscNumpadDecimal)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscNumpadDecimal.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscNumpadDecimal,\n    selectors: [[\"\", \"mbsc-numpad-decimal\", \"\"]],\n    inputs: {\n      value: [\"mbsc-numpad-decimal\", \"value\"],\n      decimalSeparator: \"decimalSeparator\",\n      defaultValue: \"defaultValue\",\n      entryMode: \"entryMode\",\n      invalid: \"invalid\",\n      scale: \"scale\",\n      maxScale: \"maxScale\",\n      min: \"min\",\n      max: \"max\",\n      prefix: \"prefix\",\n      returnAffix: \"returnAffix\",\n      suffix: \"suffix\",\n      thousandsSeparator: \"thousandsSeparator\",\n      options: [\"mbsc-options\", \"options\"]\n    },\n    outputs: {\n      onChangeEmitter: \"mbsc-numpad-decimalChange\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscNumpadDecimal;\n}(MbscNumpad);\n\nvar MbscNumpadDecimalComponent = function (_super) {\n  __extends(MbscNumpadDecimalComponent, _super);\n\n  function MbscNumpadDecimalComponent(initialElem, zone, control, inputService, optionService) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;\n\n    _this.errorMessage = '';\n    _this.placeholder = '';\n    return _this;\n  }\n\n  MbscNumpadDecimalComponent.prototype.ngAfterViewInit = function () {\n    _super.prototype.ngAfterViewInit.call(this);\n\n    this.setThemeClasses();\n  };\n\n  __decorate([Input$1('icon'), __metadata(\"design:type\", String)], MbscNumpadDecimalComponent.prototype, \"inputIcon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscNumpadDecimalComponent.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadDecimalComponent.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscNumpadDecimalComponent.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadDecimalComponent.prototype, \"errorMessage\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscNumpadDecimalComponent.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadDecimalComponent.prototype, \"placeholder\", void 0);\n\n  MbscNumpadDecimalComponent = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])], MbscNumpadDecimalComponent);\n\n  MbscNumpadDecimalComponent.ɵfac = function MbscNumpadDecimalComponent_Factory(t) {\n    return new (t || MbscNumpadDecimalComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscNumpadDecimalComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscNumpadDecimalComponent,\n    selectors: [[\"mbsc-numpad-decimal\"]],\n    inputs: {\n      inputIcon: [\"icon\", \"inputIcon\"],\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      name: \"name\",\n      error: \"error\",\n      errorMessage: \"errorMessage\",\n      options: \"options\",\n      placeholder: \"placeholder\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\", 4, \"ngIf\"], [3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\"]],\n    template: function MbscNumpadDecimalComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MbscNumpadDecimalComponent_mbsc_input_0_Template, 2, 13, \"mbsc-input\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.inline || ctx.showInput);\n      }\n    },\n    directives: [ɵngcc2.NgIf, MbscInput],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscNumpadDecimalComponent;\n}(MbscNumpadDecimal);\n\nvar MbscNumpadDate = function (_super) {\n  __extends(MbscNumpadDate, _super);\n\n  function MbscNumpadDate(initialElem, zone, control, inputService, optionService, view) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;\n\n    _this.options = {};\n    _this.onChangeEmitter = new EventEmitter();\n    return _this;\n  }\n\n  Object.defineProperty(MbscNumpadDate.prototype, \"value\", {\n    set: function (v) {\n      if (this.instance || v !== '') {\n        this.setNewValueProxy(v);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscNumpadDate.prototype.setNewValue = function (v) {\n    if (this.instance) {\n      var innerValue = this.instance.getVal();\n\n      if (innerValue && !v || !innerValue && v || innerValue && v && innerValue.getTime() !== v.getTime()) {\n        this.instance.setVal(v, true, false);\n\n        if (this._inputService && this._inputService.input) {\n          this._inputService.input.innerValue = this.instance._value;\n        }\n      }\n    }\n  };\n\n  MbscNumpadDate.prototype.initControl = function () {\n    var options = extend$1({\n      preset: 'date'\n    }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);\n    this.instance = new Numpad(this.element, options);\n\n    if (this.initialValue !== undefined && this.initialValue !== \"\") {\n      this.instance.setVal(this.initialValue, true, false);\n    }\n  };\n\n  __decorate([Input$1('mbsc-numpad-date'), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], MbscNumpadDate.prototype, \"value\", null);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadDate.prototype, \"dateFormat\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadDate.prototype, \"dateOrder\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadDate.prototype, \"delimiter\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadDate.prototype, \"defaultValue\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscNumpadDate.prototype, \"invalid\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Date)], MbscNumpadDate.prototype, \"min\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Date)], MbscNumpadDate.prototype, \"max\", void 0);\n\n  __decorate([Input$1('mbsc-options'), __metadata(\"design:type\", Object)], MbscNumpadDate.prototype, \"options\", void 0);\n\n  __decorate([Output('mbsc-numpad-dateChange'), __metadata(\"design:type\", EventEmitter)], MbscNumpadDate.prototype, \"onChangeEmitter\", void 0);\n\n  MbscNumpadDate = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscNumpadDate);\n\n  MbscNumpadDate.ɵfac = function MbscNumpadDate_Factory(t) {\n    return new (t || MbscNumpadDate)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscNumpadDate.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscNumpadDate,\n    selectors: [[\"\", \"mbsc-numpad-date\", \"\"]],\n    inputs: {\n      value: [\"mbsc-numpad-date\", \"value\"],\n      dateFormat: \"dateFormat\",\n      dateOrder: \"dateOrder\",\n      delimiter: \"delimiter\",\n      defaultValue: \"defaultValue\",\n      invalid: \"invalid\",\n      min: \"min\",\n      max: \"max\",\n      options: [\"mbsc-options\", \"options\"]\n    },\n    outputs: {\n      onChangeEmitter: \"mbsc-numpad-dateChange\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscNumpadDate;\n}(MbscNumpadBase);\n\nvar MbscNumpadDateComponent = function (_super) {\n  __extends(MbscNumpadDateComponent, _super);\n\n  function MbscNumpadDateComponent(initialElem, zone, control, inputService, optionService) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;\n\n    _this.errorMessage = '';\n    _this.placeholder = '';\n    return _this;\n  }\n\n  MbscNumpadDateComponent.prototype.ngAfterViewInit = function () {\n    _super.prototype.ngAfterViewInit.call(this);\n\n    this.setThemeClasses();\n  };\n\n  __decorate([Input$1('icon'), __metadata(\"design:type\", String)], MbscNumpadDateComponent.prototype, \"inputIcon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscNumpadDateComponent.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadDateComponent.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscNumpadDateComponent.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadDateComponent.prototype, \"errorMessage\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscNumpadDateComponent.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadDateComponent.prototype, \"placeholder\", void 0);\n\n  MbscNumpadDateComponent = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])], MbscNumpadDateComponent);\n\n  MbscNumpadDateComponent.ɵfac = function MbscNumpadDateComponent_Factory(t) {\n    return new (t || MbscNumpadDateComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscNumpadDateComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscNumpadDateComponent,\n    selectors: [[\"mbsc-numpad-date\"]],\n    inputs: {\n      inputIcon: [\"icon\", \"inputIcon\"],\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      name: \"name\",\n      error: \"error\",\n      errorMessage: \"errorMessage\",\n      options: \"options\",\n      placeholder: \"placeholder\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\", 4, \"ngIf\"], [3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\"]],\n    template: function MbscNumpadDateComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MbscNumpadDateComponent_mbsc_input_0_Template, 2, 13, \"mbsc-input\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.inline || ctx.showInput);\n      }\n    },\n    directives: [ɵngcc2.NgIf, MbscInput],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscNumpadDateComponent;\n}(MbscNumpadDate);\n\nvar MbscNumpadTime = function (_super) {\n  __extends(MbscNumpadTime, _super);\n\n  function MbscNumpadTime(initialElem, zone, control, inputService, optionService, view) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;\n\n    _this.options = {};\n    _this.onChangeEmitter = new EventEmitter();\n    return _this;\n  }\n\n  Object.defineProperty(MbscNumpadTime.prototype, \"value\", {\n    set: function (v) {\n      if (this.instance || v !== '') {\n        this.setNewValueProxy(v);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscNumpadTime.prototype.setNewValue = function (v) {\n    if (this.instance) {\n      var innerValue = this.instance.getVal();\n\n      if (innerValue !== v) {\n        this.instance.setVal(v, true, false);\n\n        if (this._inputService && this._inputService.input) {\n          this._inputService.input.innerValue = this.instance._value;\n        }\n      }\n    }\n  };\n\n  MbscNumpadTime.prototype.initControl = function () {\n    var options = extend$1({\n      preset: 'time'\n    }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);\n    this.instance = new Numpad(this.element, options);\n\n    if (this.initialValue !== undefined && this.initialValue !== \"\") {\n      this.instance.setVal(this.initialValue, true, false);\n    }\n  };\n\n  __decorate([Input$1('mbsc-numpad-time'), __metadata(\"design:type\", String), __metadata(\"design:paramtypes\", [String])], MbscNumpadTime.prototype, \"value\", null);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadTime.prototype, \"defaultValue\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscNumpadTime.prototype, \"invalid\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Date)], MbscNumpadTime.prototype, \"max\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Date)], MbscNumpadTime.prototype, \"min\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadTime.prototype, \"timeFormat\", void 0);\n\n  __decorate([Input$1('mbsc-options'), __metadata(\"design:type\", Object)], MbscNumpadTime.prototype, \"options\", void 0);\n\n  __decorate([Output('mbsc-numpad-timeChange'), __metadata(\"design:type\", EventEmitter)], MbscNumpadTime.prototype, \"onChangeEmitter\", void 0);\n\n  MbscNumpadTime = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscNumpadTime);\n\n  MbscNumpadTime.ɵfac = function MbscNumpadTime_Factory(t) {\n    return new (t || MbscNumpadTime)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscNumpadTime.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscNumpadTime,\n    selectors: [[\"\", \"mbsc-numpad-time\", \"\"]],\n    inputs: {\n      value: [\"mbsc-numpad-time\", \"value\"],\n      defaultValue: \"defaultValue\",\n      invalid: \"invalid\",\n      max: \"max\",\n      min: \"min\",\n      timeFormat: \"timeFormat\",\n      options: [\"mbsc-options\", \"options\"]\n    },\n    outputs: {\n      onChangeEmitter: \"mbsc-numpad-timeChange\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscNumpadTime;\n}(MbscNumpadBase);\n\nvar MbscNumpadTimeComponent = function (_super) {\n  __extends(MbscNumpadTimeComponent, _super);\n\n  function MbscNumpadTimeComponent(initialElem, zone, control, inputService, optionService) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;\n\n    _this.errorMessage = '';\n    _this.placeholder = '';\n    return _this;\n  }\n\n  MbscNumpadTimeComponent.prototype.ngAfterViewInit = function () {\n    _super.prototype.ngAfterViewInit.call(this);\n\n    this.setThemeClasses();\n  };\n\n  __decorate([Input$1('icon'), __metadata(\"design:type\", String)], MbscNumpadTimeComponent.prototype, \"inputIcon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscNumpadTimeComponent.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadTimeComponent.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscNumpadTimeComponent.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadTimeComponent.prototype, \"errorMessage\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscNumpadTimeComponent.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadTimeComponent.prototype, \"placeholder\", void 0);\n\n  MbscNumpadTimeComponent = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])], MbscNumpadTimeComponent);\n\n  MbscNumpadTimeComponent.ɵfac = function MbscNumpadTimeComponent_Factory(t) {\n    return new (t || MbscNumpadTimeComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscNumpadTimeComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscNumpadTimeComponent,\n    selectors: [[\"mbsc-numpad-time\"]],\n    inputs: {\n      inputIcon: [\"icon\", \"inputIcon\"],\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      name: \"name\",\n      error: \"error\",\n      errorMessage: \"errorMessage\",\n      options: \"options\",\n      placeholder: \"placeholder\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\", 4, \"ngIf\"], [3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\"]],\n    template: function MbscNumpadTimeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MbscNumpadTimeComponent_mbsc_input_0_Template, 2, 13, \"mbsc-input\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.inline || ctx.showInput);\n      }\n    },\n    directives: [ɵngcc2.NgIf, MbscInput],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscNumpadTimeComponent;\n}(MbscNumpadTime);\n\nvar MbscNumpadTimespan = function (_super) {\n  __extends(MbscNumpadTimespan, _super);\n\n  function MbscNumpadTimespan(initialElem, zone, control, inputService, optionService, view) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, view) || this;\n\n    _this.options = {};\n    _this.onChangeEmitter = new EventEmitter();\n    _this.preset = 'timespan';\n    return _this;\n  }\n\n  Object.defineProperty(MbscNumpadTimespan.prototype, \"value\", {\n    set: function (v) {\n      if (this.instance || v !== '') {\n        this.setNewValueProxy(v);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  __decorate([Input$1('mbsc-numpad-timespan'), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], MbscNumpadTimespan.prototype, \"value\", null);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscNumpadTimespan.prototype, \"defaultValue\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscNumpadTimespan.prototype, \"invalid\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscNumpadTimespan.prototype, \"min\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscNumpadTimespan.prototype, \"max\", void 0);\n\n  __decorate([Input$1('mbsc-options'), __metadata(\"design:type\", Object)], MbscNumpadTimespan.prototype, \"options\", void 0);\n\n  __decorate([Output('mbsc-numpad-timespanChange'), __metadata(\"design:type\", EventEmitter)], MbscNumpadTimespan.prototype, \"onChangeEmitter\", void 0);\n\n  MbscNumpadTimespan = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscNumpadTimespan);\n\n  MbscNumpadTimespan.ɵfac = function MbscNumpadTimespan_Factory(t) {\n    return new (t || MbscNumpadTimespan)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscNumpadTimespan.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscNumpadTimespan,\n    selectors: [[\"\", \"mbsc-numpad-timespan\", \"\"]],\n    inputs: {\n      value: [\"mbsc-numpad-timespan\", \"value\"],\n      defaultValue: \"defaultValue\",\n      invalid: \"invalid\",\n      min: \"min\",\n      max: \"max\",\n      options: [\"mbsc-options\", \"options\"]\n    },\n    outputs: {\n      onChangeEmitter: \"mbsc-numpad-timespanChange\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscNumpadTimespan;\n}(MbscNumpad);\n\nvar MbscNumpadTimespanComponent = function (_super) {\n  __extends(MbscNumpadTimespanComponent, _super);\n\n  function MbscNumpadTimespanComponent(initialElem, zone, control, inputService, optionService) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;\n\n    _this.errorMessage = '';\n    _this.placeholder = '';\n    return _this;\n  }\n\n  MbscNumpadTimespanComponent.prototype.ngAfterViewInit = function () {\n    _super.prototype.ngAfterViewInit.call(this);\n\n    this.setThemeClasses();\n  };\n\n  __decorate([Input$1('icon'), __metadata(\"design:type\", String)], MbscNumpadTimespanComponent.prototype, \"inputIcon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscNumpadTimespanComponent.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadTimespanComponent.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscNumpadTimespanComponent.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadTimespanComponent.prototype, \"errorMessage\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscNumpadTimespanComponent.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNumpadTimespanComponent.prototype, \"placeholder\", void 0);\n\n  MbscNumpadTimespanComponent = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])], MbscNumpadTimespanComponent);\n\n  MbscNumpadTimespanComponent.ɵfac = function MbscNumpadTimespanComponent_Factory(t) {\n    return new (t || MbscNumpadTimespanComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscNumpadTimespanComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscNumpadTimespanComponent,\n    selectors: [[\"mbsc-numpad-timespan\"]],\n    inputs: {\n      inputIcon: [\"icon\", \"inputIcon\"],\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      name: \"name\",\n      error: \"error\",\n      errorMessage: \"errorMessage\",\n      options: \"options\",\n      placeholder: \"placeholder\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\", 4, \"ngIf\"], [3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\"]],\n    template: function MbscNumpadTimespanComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MbscNumpadTimespanComponent_mbsc_input_0_Template, 2, 13, \"mbsc-input\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.inline || ctx.showInput);\n      }\n    },\n    directives: [ɵngcc2.NgIf, MbscInput],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscNumpadTimespanComponent;\n}(MbscNumpadTimespan);\n\nvar comps$1 = [MbscNumpad, MbscNumpadBase, MbscNumpadComponent, MbscNumpadDecimal, MbscNumpadDecimalComponent, MbscNumpadDate, MbscNumpadDateComponent, MbscNumpadTime, MbscNumpadTimeComponent, MbscNumpadTimespan, MbscNumpadTimespanComponent];\n\nvar MbscNumpadModule = function () {\n  function MbscNumpadModule() {}\n\n  MbscNumpadModule.ɵfac = function MbscNumpadModule_Factory(t) {\n    return new (t || MbscNumpadModule)();\n  };\n\n  MbscNumpadModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscNumpadModule\n  });\n  MbscNumpadModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, MbscFrameBaseModule, MbscInputModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscNumpadModule, {\n      declarations: function () {\n        return [MbscNumpad, MbscNumpadBase, MbscNumpadComponent, MbscNumpadDecimal, MbscNumpadDecimalComponent, MbscNumpadDate, MbscNumpadDateComponent, MbscNumpadTime, MbscNumpadTimeComponent, MbscNumpadTimespan, MbscNumpadTimespanComponent];\n      },\n      imports: function () {\n        return [CommonModule, MbscFrameBaseModule, MbscInputModule];\n      },\n      exports: function () {\n        return [MbscNumpad, MbscNumpadBase, MbscNumpadComponent, MbscNumpadDecimal, MbscNumpadDecimalComponent, MbscNumpadDate, MbscNumpadDateComponent, MbscNumpadTime, MbscNumpadTimeComponent, MbscNumpadTimespan, MbscNumpadTimespanComponent];\n      }\n    });\n  })();\n\n  return MbscNumpadModule;\n}();\n\nvar Optionlist = function Optionlist(elm, settings) {\n  var that = this; // Call the parent constructor\n\n  NavigationBase.call(this, elm, settings, true);\n  /**\r\n   * Optionlist initialization.\r\n   */\n\n  that.___init = function () {}; // Constructor\n\n\n  that.init();\n}; // Defaults\n\n\nOptionlist.prototype = {\n  _class: 'optionlist',\n  _hasDef: true,\n  _hasTheme: true,\n  _hasLang: true,\n  _responsive: true,\n  _defaults: extend$1({}, NavigationBase.prototype._defaults, {\n    select: 'multiple',\n    variant: 'a',\n    display: 'inline'\n  })\n};\nclasses.Optionlist = Optionlist;\nmobiscroll.themes.optionlist = mobiscroll.themes.navigation;\n\nvar MbscOptionItem = function (_super) {\n  __extends(MbscOptionItem, _super);\n\n  function MbscOptionItem(notifyItemService, _elem) {\n    return _super.call(this, notifyItemService, _elem) || this;\n  }\n\n  MbscOptionItem = __decorate([__metadata(\"design:paramtypes\", [MbscNotifyItemService, ElementRef])], MbscOptionItem);\n\n  MbscOptionItem.ɵfac = function MbscOptionItem_Factory(t) {\n    return new (t || MbscOptionItem)(ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MbscOptionItem.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscOptionItem,\n    selectors: [[\"mbsc-option-item\"]],\n    hostVars: 4,\n    hostBindings: function MbscOptionItem_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"data-icon\", ctx.icon)(\"data-disabled\", ctx.disabled)(\"data-selected\", ctx.selected)(\"data-id\", ctx.id);\n      }\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscOptionItem_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscOptionItem;\n}(MbscNavItemBase);\n\nvar MbscOptionlist = function (_super) {\n  __extends(MbscOptionlist, _super);\n\n  function MbscOptionlist(initialElem, zone, notifyItemService, optionService) {\n    var _this = _super.call(this, initialElem, zone, notifyItemService) || this;\n\n    _this.optionService = optionService;\n    return _this;\n  }\n\n  MbscOptionlist.prototype.initControl = function () {\n    var _this = this;\n\n    var onItemTap = this.tapHandler.bind(this);\n    var onItemTapUser = this.options && this.options.onItemTap;\n\n    if (onItemTapUser) {\n      onItemTap = function (event, inst) {\n        _this.tapHandler(event, inst);\n\n        return onItemTapUser(event, inst);\n      };\n    }\n\n    var options = extend$1({}, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, {\n      onItemTap: onItemTap\n    });\n    this.instance = new Optionlist(this.initialElem.nativeElement, options);\n    this.notifyItemService.notifyInstanceReady(this.instance);\n    this.addRemoveObserver = this.notifyItemService.onAddRemove().subscribe(function (item) {\n      _this.instance.refresh();\n    });\n  };\n\n  MbscOptionlist.prototype.ngOnDestroy = function () {\n    this.notifyItemService.onAddRemove().unsubscribe(this.addRemoveObserver);\n\n    _super.prototype.ngOnDestroy.call(this);\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscOptionlist.prototype, \"select\", void 0);\n\n  __decorate([ContentChildren(MbscOptionItem), __metadata(\"design:type\", QueryList)], MbscOptionlist.prototype, \"items\", void 0);\n\n  MbscOptionlist = __decorate([__param(3, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, MbscNotifyItemService, MbscOptionsService])], MbscOptionlist);\n\n  MbscOptionlist.ɵfac = function MbscOptionlist_Factory(t) {\n    return new (t || MbscOptionlist)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscOptionlist.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscOptionlist,\n    selectors: [[\"mbsc-optionlist\"]],\n    contentQueries: function MbscOptionlist_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MbscOptionItem, 4);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.items = _t);\n      }\n    },\n    hostAttrs: [1, \"mbsc-cloak\"],\n    inputs: {\n      select: \"select\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([MbscNotifyItemService]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscOptionlist_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscOptionlist;\n}(MbscNavigationBase);\n\nvar MbscOptionlistModule = function () {\n  function MbscOptionlistModule() {}\n\n  MbscOptionlistModule.ɵfac = function MbscOptionlistModule_Factory(t) {\n    return new (t || MbscOptionlistModule)();\n  };\n\n  MbscOptionlistModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscOptionlistModule\n  });\n  MbscOptionlistModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[MbscNavigationBaseModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscOptionlistModule, {\n      declarations: [MbscOptionItem, MbscOptionlist],\n      imports: [MbscNavigationBaseModule],\n      exports: [MbscOptionItem, MbscOptionlist]\n    });\n  })();\n\n  return MbscOptionlistModule;\n}(); // ---\n\n\nvar Page = function Page(el, settings) {\n  var cssClass = '',\n      $elm = $$1(el),\n      that = this,\n      s = that.settings; // Call the parent constructor\n\n  Base.call(this, el, settings, true);\n  /**\r\n   * Page initialization.\r\n   */\n\n  that._init = function () {\n    var ctx = s.context,\n        $ctx = $$1(ctx),\n        $topMenu = $ctx.find('.mbsc-ms-top .mbsc-ms'),\n        $bottomMenu = $ctx.find('.mbsc-ms-bottom .mbsc-ms'),\n        css = {};\n\n    if (ctx == 'body') {\n      $$1('body,html').addClass('mbsc-page-ctx');\n    } else {\n      $ctx.addClass('mbsc-page-ctx');\n    }\n\n    if (cssClass) {\n      $elm.removeClass(cssClass);\n    }\n\n    if ($topMenu.length) {\n      css.paddingTop = $topMenu[0].offsetHeight;\n    }\n\n    if ($bottomMenu.length) {\n      css.paddingBottom = $bottomMenu[0].offsetHeight;\n    }\n\n    cssClass = 'mbsc-page mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + (s.rtl ? ' mbsc-rtl' : ' mbsc-ltr');\n    $elm.addClass(cssClass).removeClass('mbsc-cloak').css(css);\n  };\n  /**\r\n   * Destroys the mobiscroll instance.\r\n   */\n\n\n  that._destroy = function () {\n    $elm.removeClass(cssClass);\n  }; // Constructor\n\n\n  s = that.settings;\n  that.init();\n}; // Extend defaults\n\n\nPage.prototype = {\n  _hasDef: true,\n  _hasTheme: true,\n  _hasLang: true,\n  _class: 'page',\n  _defaults: {\n    context: 'body'\n  }\n};\nclasses.Page = Page;\nmobiscroll.themes.page.mobiscroll = {}; // ---\n// Page end\n// Init mbsc-page elements on page load or when mbsc-enhance event is triggeres\n\nautoInit('[mbsc-page]', Page);\n\nvar MbscPage = function (_super) {\n  __extends(MbscPage, _super);\n\n  function MbscPage(hostElement, optionsService, zone) {\n    var _this = _super.call(this, hostElement, zone) || this;\n\n    _this.optionsService = optionsService;\n    return _this;\n  }\n\n  MbscPage.prototype.ngOnInit = function () {\n    var optionsObj = extend$1({}, this.options, this.inlineOptionsObj);\n    this.optionsService.options = optionsObj;\n  };\n\n  MbscPage.prototype.initControl = function () {\n    var options = extend$1({}, this.options, this.inlineOptionsObj);\n    this.instance = new Page(this.initElem.nativeElement, options);\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscPage.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscPage.prototype, \"context\", void 0);\n\n  __decorate([ViewChild('initElement', {\n    static: false\n  }), __metadata(\"design:type\", ElementRef)], MbscPage.prototype, \"initElem\", void 0);\n\n  MbscPage = __decorate([__metadata(\"design:paramtypes\", [ElementRef, MbscOptionsService, NgZone])], MbscPage);\n\n  MbscPage.ɵfac = function MbscPage_Factory(t) {\n    return new (t || MbscPage)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  MbscPage.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscPage,\n    selectors: [[\"mbsc-page\"]],\n    viewQuery: function MbscPage_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.initElem = _t.first);\n      }\n    },\n    inputs: {\n      options: \"options\",\n      context: \"context\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([MbscOptionsService]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 3,\n    vars: 0,\n    consts: [[\"initElement\", \"\"]],\n    template: function MbscPage_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", null, 0);\n        ɵngcc0.ɵɵprojection(2);\n        ɵngcc0.ɵɵelementEnd();\n      }\n    },\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscPage;\n}(MbscBase);\n\nvar MbscNote = function () {\n  function MbscNote(initialElem) {\n    this.initialElem = initialElem;\n    this.color = 'primary';\n  }\n\n  Object.defineProperty(MbscNote.prototype, \"classNames\", {\n    get: function () {\n      return 'mbsc-note mbsc-note-' + this.color;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscNote.prototype, \"color\", void 0);\n\n  MbscNote = __decorate([__metadata(\"design:paramtypes\", [ElementRef])], MbscNote);\n\n  MbscNote.ɵfac = function MbscNote_Factory(t) {\n    return new (t || MbscNote)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n\n  MbscNote.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscNote,\n    selectors: [[\"mbsc-note\"]],\n    hostVars: 2,\n    hostBindings: function MbscNote_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassMap(ctx.classNames);\n      }\n    },\n    inputs: {\n      color: \"color\"\n    },\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscNote_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"[_nghost-%COMP%] { display: block; }\"]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscNote;\n}();\n\nvar MbscAvatar = function () {\n  function MbscAvatar() {\n    this.draggable = false;\n  }\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscAvatar.prototype, \"draggable\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscAvatar.prototype, \"src\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscAvatar.prototype, \"alt\", void 0);\n\n  MbscAvatar.ɵfac = function MbscAvatar_Factory(t) {\n    return new (t || MbscAvatar)();\n  };\n\n  MbscAvatar.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscAvatar,\n    selectors: [[\"mbsc-avatar\"]],\n    inputs: {\n      draggable: \"draggable\",\n      src: \"src\",\n      alt: \"alt\"\n    },\n    decls: 1,\n    vars: 3,\n    consts: [[1, \"mbsc-avatar\", 3, \"src\", \"alt\", \"draggable\"]],\n    template: function MbscAvatar_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelement(0, \"img\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"src\", ctx.src, ɵngcc0.ɵɵsanitizeUrl)(\"alt\", ctx.alt)(\"draggable\", ctx.draggable);\n      }\n    },\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscAvatar;\n}();\n\nvar MbscPageModule = function () {\n  function MbscPageModule() {}\n\n  MbscPageModule.ɵfac = function MbscPageModule_Factory(t) {\n    return new (t || MbscPageModule)();\n  };\n\n  MbscPageModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscPageModule\n  });\n  MbscPageModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[MbscBaseModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscPageModule, {\n      declarations: [MbscPage, MbscNote, MbscAvatar],\n      imports: [MbscBaseModule],\n      exports: [MbscPage, MbscNote, MbscAvatar]\n    });\n  })();\n\n  return MbscPageModule;\n}();\n\nvar MbscPopup = function (_super) {\n  __extends(MbscPopup, _super);\n\n  function MbscPopup(initialElem, optionService, zone) {\n    var _this = _super.call(this, initialElem, zone) || this;\n\n    _this.optionService = optionService;\n    _this.onBeforeClose = new EventEmitter();\n    _this.onBeforeShow = new EventEmitter();\n    _this.onCancel = new EventEmitter();\n    _this.onClose = new EventEmitter();\n    _this.onDestroy = new EventEmitter();\n    _this.onFill = new EventEmitter();\n    _this.onMarkupReady = new EventEmitter();\n    _this.onPosition = new EventEmitter();\n    _this.onShow = new EventEmitter();\n    _this.onSet = new EventEmitter();\n    return _this;\n  }\n\n  MbscPopup.prototype.ngAfterViewInit = function () {\n    this.getInlineEvents();\n    var options = extend$1({}, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj);\n    this.instance = new Popup(this.initialElem.nativeElement, options);\n  };\n\n  __decorate([Input$1('options'), __metadata(\"design:type\", Object)], MbscPopup.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscPopup.prototype, \"anchor\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscPopup.prototype, \"animate\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscPopup.prototype, \"buttons\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscPopup.prototype, \"closeOnOverlayTap\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscPopup.prototype, \"context\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscPopup.prototype, \"disabled\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscPopup.prototype, \"display\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscPopup.prototype, \"focusOnClose\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscPopup.prototype, \"focusTrap\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscPopup.prototype, \"headerText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscPopup.prototype, \"showOnFocus\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscPopup.prototype, \"showOnTap\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscPopup.prototype, \"touchUi\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscPopup.prototype, \"okText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscPopup.prototype, \"cancelText\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscPopup.prototype, \"onBeforeClose\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscPopup.prototype, \"onBeforeShow\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscPopup.prototype, \"onCancel\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscPopup.prototype, \"onClose\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscPopup.prototype, \"onDestroy\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscPopup.prototype, \"onFill\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscPopup.prototype, \"onMarkupReady\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscPopup.prototype, \"onPosition\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscPopup.prototype, \"onShow\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscPopup.prototype, \"onSet\", void 0);\n\n  MbscPopup = __decorate([__param(1, Optional()), __metadata(\"design:paramtypes\", [ElementRef, MbscOptionsService, NgZone])], MbscPopup);\n\n  MbscPopup.ɵfac = function MbscPopup_Factory(t) {\n    return new (t || MbscPopup)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n\n  MbscPopup.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscPopup,\n    selectors: [[\"mbsc-popup\"]],\n    hostAttrs: [1, \"mbsc-cloak\"],\n    inputs: {\n      options: \"options\",\n      anchor: \"anchor\",\n      animate: \"animate\",\n      buttons: \"buttons\",\n      closeOnOverlayTap: \"closeOnOverlayTap\",\n      context: \"context\",\n      disabled: \"disabled\",\n      display: \"display\",\n      focusOnClose: \"focusOnClose\",\n      focusTrap: \"focusTrap\",\n      headerText: \"headerText\",\n      showOnFocus: \"showOnFocus\",\n      showOnTap: \"showOnTap\",\n      touchUi: \"touchUi\",\n      okText: \"okText\",\n      cancelText: \"cancelText\"\n    },\n    outputs: {\n      onBeforeClose: \"onBeforeClose\",\n      onBeforeShow: \"onBeforeShow\",\n      onCancel: \"onCancel\",\n      onClose: \"onClose\",\n      onDestroy: \"onDestroy\",\n      onFill: \"onFill\",\n      onMarkupReady: \"onMarkupReady\",\n      onPosition: \"onPosition\",\n      onShow: \"onShow\",\n      onSet: \"onSet\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscPopup_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscPopup;\n}(MbscBase);\n\nvar MbscWidget = function (_super) {\n  __extends(MbscWidget, _super);\n\n  function MbscWidget() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  MbscWidget.ɵfac = /*@__PURE__*/function () {\n    var ɵMbscWidget_BaseFactory;\n    return function MbscWidget_Factory(t) {\n      return (ɵMbscWidget_BaseFactory || (ɵMbscWidget_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(MbscWidget)))(t || MbscWidget);\n    };\n  }();\n\n  MbscWidget.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscWidget,\n    selectors: [[\"mbsc-widget\"]],\n    hostAttrs: [1, \"mbsc-cloak\"],\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscWidget_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscWidget;\n}(MbscPopup);\n\nvar MbscPopupModule = function () {\n  function MbscPopupModule() {}\n\n  MbscPopupModule.ɵfac = function MbscPopupModule_Factory(t) {\n    return new (t || MbscPopupModule)();\n  };\n\n  MbscPopupModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscPopupModule\n  });\n  MbscPopupModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[MbscBaseModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscPopupModule, {\n      declarations: [MbscPopup, MbscWidget],\n      imports: [MbscBaseModule],\n      exports: [MbscPopup, MbscWidget]\n    });\n  })();\n\n  return MbscPopupModule;\n}();\n\nvar RangePicker = Scroller;\nvar defaults$c = {\n  autoCorrect: true,\n  showSelector: true,\n  minRange: 1,\n  rangeTap: true\n};\n\npresets.range = function (inst) {\n  // Private functions\n  // ---\n  function normalize(d, ref) {\n    if (d) {\n      d.setFullYear(ref.getFullYear());\n      d.setMonth(ref.getMonth());\n      d.setDate(ref.getDate());\n    }\n  }\n\n  function normalizeTime(date, isEnd) {\n    var o = inst._order,\n        d = new Date(date);\n\n    if (o.h === undefined) {\n      d.setHours(isEnd ? 23 : 0);\n    }\n\n    if (o.i === undefined) {\n      d.setMinutes(isEnd ? 59 : 0);\n    }\n\n    if (o.s === undefined) {\n      d.setSeconds(isEnd ? 59 : 0);\n    }\n\n    d.setMilliseconds(isEnd ? 999 : 0);\n    return d;\n  }\n\n  function updateInputs(change) {\n    inst._startDate = startDate = tempStartDate;\n    inst._endDate = endDate = tempEndDate;\n\n    if (s.startInput) {\n      $$1(s.startInput).val(inst.startVal);\n\n      if (change) {\n        $$1(s.startInput).trigger('change');\n      }\n    }\n\n    if (s.endInput) {\n      $$1(s.endInput).val(inst.endVal);\n\n      if (change) {\n        $$1(s.endInput).trigger('change');\n      }\n    }\n  }\n\n  function addDays(d, days) {\n    return new Date(d.getFullYear(), d.getMonth(), d.getDate() + days);\n  }\n\n  function checkRangeSize(curr) {\n    if (hasTime) {\n      // Check exact times in milliseconds for min and max ranges\n      if (tempEndDate - tempStartDate > s.maxRange - 1) {\n        if (curr) {\n          tempStartDate = new Date(Math.max(minDate, tempEndDate - s.maxRange + 1));\n        } else {\n          tempEndDate = new Date(Math.min(maxDate, +tempStartDate + s.maxRange - 1));\n        }\n      }\n\n      if (tempEndDate - tempStartDate < s.minRange - 1) {\n        if (curr) {\n          tempStartDate = new Date(Math.max(minDate, tempEndDate - s.minRange + 1));\n        } else {\n          tempEndDate = new Date(Math.min(maxDate, +tempStartDate + s.minRange - 1));\n        }\n      }\n    } else {\n      // Work with days only, not milliseconds. This way daylight saving times are handled\n      if (Math.ceil((tempEndDate - tempStartDate) / oneDay) > maxDays) {\n        if (curr) {\n          tempStartDate = normalizeTime(Math.max(minDate, addDays(tempEndDate, 1 - maxDays)), false);\n        } else {\n          tempEndDate = normalizeTime(Math.min(maxDate, addDays(tempStartDate, maxDays - 1)), true);\n        }\n      }\n\n      if (Math.ceil((tempEndDate - tempStartDate) / oneDay) < minDays) {\n        if (curr) {\n          tempStartDate = normalizeTime(Math.max(minDate, addDays(tempEndDate, 1 - minDays)), false);\n        } else {\n          tempEndDate = normalizeTime(Math.min(maxDate, addDays(tempStartDate, minDays - 1)), true);\n        }\n      }\n    }\n  }\n\n  function validate(dates, ui) {\n    var ret = true;\n\n    if (dates && tempStartDate && tempEndDate) {\n      // We need to check this 2 times, because the\n      // corrected range is constrained by min/max dates\n      checkRangeSize(curr);\n      checkRangeSize(!curr);\n    }\n\n    if (!tempStartDate || !tempEndDate) {\n      ret = false;\n    }\n\n    if (ui) {\n      highlightDays();\n    }\n\n    return ret;\n  }\n\n  function calcDayNr() {\n    return tempStartDate && tempEndDate ? Math.max(1, Math.round((new Date(tempEndDate).setHours(0, 0, 0, 0) - new Date(tempStartDate).setHours(0, 0, 0, 0)) / 86400000) + 1) : 0;\n  }\n\n  function selectTab(tab) {\n    tab.addClass(selectedClass).attr('aria-checked', 'true');\n  }\n\n  function setActiveTab() {\n    if (showSelector && ctx) {\n      $$1('.mbsc-range-btn', ctx).removeClass(selectedClass).removeAttr('aria-checked');\n      selectTab($$1('.mbsc-range-btn', ctx).eq(curr));\n    }\n  }\n\n  function highlightDays() {\n    var start,\n        startT,\n        end,\n        endT,\n        hl,\n        nr = 0,\n        startClass = autoChange || !curr ? ' mbsc-cal-day-hl mbsc-cal-sel-start' : ' mbsc-cal-sel-start',\n        endClass = autoChange || curr ? ' mbsc-cal-day-hl mbsc-cal-sel-end' : ' mbsc-cal-sel-end';\n    inst.startVal = tempStartDate ? formatDate(format, tempStartDate, s) : '';\n    inst.endVal = tempEndDate ? formatDate(format, tempEndDate, s) : '';\n\n    if (ctx) {\n      $$1('.mbsc-range-btn-v-start', ctx).html(inst.startVal || '&nbsp;');\n      $$1('.mbsc-range-btn-v-end', ctx).html(inst.endVal || '&nbsp;'); // Highlight dates\n\n      start = tempStartDate ? new Date(tempStartDate) : null;\n      end = tempEndDate ? new Date(tempEndDate) : null;\n\n      if (!start && end) {\n        start = new Date(end);\n      }\n\n      if (!end && start) {\n        end = new Date(start);\n      }\n\n      hl = curr ? end : start;\n      $$1('.mbsc-cal-day-picker .mbsc-cal-day-hl', ctx).removeClass(highlightClass);\n      $$1('.mbsc-cal-day-picker .mbsc-selected', ctx).removeClass('mbsc-cal-sel-start mbsc-cal-sel-end ' + selectedClass).removeAttr('aria-selected');\n\n      if (start && end) {\n        startT = start.setHours(0, 0, 0, 0);\n        endT = end.setHours(0, 0, 0, 0);\n\n        while (end >= start && nr < 126) {\n          $$1('.mbsc-cal-day[data-full=\"' + hl.getFullYear() + '-' + (hl.getMonth() + 1) + '-' + hl.getDate() + '\"]', ctx).addClass(selectedClass + ' ' + (hl.getTime() === startT ? startClass : '') + (hl.getTime() === endT ? endClass : '')).attr('aria-selected', 'true');\n          hl.setDate(hl.getDate() + (curr ? -1 : 1));\n          hl.setHours(0, 0, 0, 0);\n          nr++;\n        }\n      }\n    }\n  }\n\n  function setTimeInfo(d, end) {\n    return {\n      h: d ? d.getHours() : end ? 23 : 0,\n      i: d ? d.getMinutes() : end ? 59 : 0,\n      s: d ? d.getSeconds() : end ? 59 : 0\n    };\n  }\n\n  function validateDates() {\n    if (tempStartDate) {\n      init = true;\n      inst.setDate(tempStartDate, false, 0, true);\n      tempStartDate = inst.getDate(true);\n    }\n\n    if (tempEndDate) {\n      init = true;\n      inst.setDate(tempEndDate, false, 0, true);\n      tempEndDate = inst.getDate(true);\n    }\n  }\n\n  function onBtnClick(ev) {\n    if (testTouch(ev, this)) {\n      inst._showDayPicker();\n\n      inst.setActiveDate($$1(this).attr('data-select'));\n    }\n  } // ---\n\n\n  var base,\n      ctx,\n      dayChange,\n      format,\n      hasTime,\n      init,\n      maxDate,\n      minDate,\n      set,\n      tempStartDate,\n      tempStartTime,\n      tempEndDate,\n      tempEndTime,\n      timeOnly,\n      showSelector,\n      startDate = inst._startDate,\n      endDate = inst._endDate,\n      curr = 0,\n      now = new Date(),\n      orig = extend$1({}, inst.settings),\n      s = extend$1(inst.settings, defaults$c, orig),\n      startAnchor = s.anchor,\n      autoChange = s.rangeTap,\n      oneDay = 24 * 60 * 60 * 1000,\n      minDays = Math.max(1, Math.ceil(s.minRange / oneDay)),\n      maxDays = Math.max(1, Math.ceil(s.maxRange / oneDay)),\n      disabledClass = 'mbsc-disabled ' + (s.disabledClass || ''),\n      selectedClass = 'mbsc-selected ' + (s.selectedClass || ''),\n      highlightClass = 'mbsc-cal-day-hl',\n      def = s.defaultValue === null ? [] : s.defaultValue || [new Date(now.setHours(0, 0, 0, 0)), new Date(now.getFullYear(), now.getMonth(), now.getDate() + 6, 23, 59, 59, 999)];\n\n  if (autoChange) {\n    s.tabs = true;\n  }\n\n  base = CalendarBase.call(this, inst);\n  format = inst._format;\n  hasTime = /time/i.test(s.controls.join(','));\n  timeOnly = s.controls.join('') === 'time';\n  showSelector = s.showSelector;\n  maxDate = s.max ? normalizeTime(makeDate(s.max, format, s), true) : Infinity;\n  minDate = s.min ? normalizeTime(makeDate(s.min, format, s), false) : -Infinity;\n  def[0] = makeDate(def[0], format, s, s.isoParts);\n  def[1] = makeDate(def[1], format, s, s.isoParts);\n\n  if (s.startInput) {\n    inst.attachShow($$1(s.startInput), function () {\n      curr = 0;\n      s.anchor = startAnchor || $$1(s.startInput);\n    });\n  }\n\n  if (s.endInput) {\n    inst.attachShow($$1(s.endInput), function () {\n      curr = 1;\n      s.anchor = startAnchor || $$1(s.endInput);\n    });\n  }\n\n  inst._getDayProps = function (d, props) {\n    var start = tempStartDate ? new Date(tempStartDate.getFullYear(), tempStartDate.getMonth(), tempStartDate.getDate()) : null,\n        end = tempEndDate ? new Date(tempEndDate.getFullYear(), tempEndDate.getMonth(), tempEndDate.getDate()) : null;\n    return {\n      selected: start && end && d >= start && d <= tempEndDate,\n      cssClass: props.cssClass + ' ' + ((autoChange || !curr) && start && start.getTime() === d.getTime() || (autoChange || curr) && end && end.getTime() === d.getTime() ? highlightClass : '') + (start && start.getTime() === d.getTime() ? ' mbsc-cal-sel-start' : '') + (end && end.getTime() === d.getTime() ? ' mbsc-cal-sel-end' : '')\n    };\n  }; // Extended methods\n  // ---\n\n\n  inst.setVal = function (values, fill, change, temp, time) {\n    var v = values || [],\n        d = values;\n    tempStartDate = makeDate(v[0], format, s, s.isoParts);\n    tempEndDate = makeDate(v[1], format, s, s.isoParts);\n    validateDates();\n    inst.startVal = tempStartDate ? formatDate(format, tempStartDate, s) : '';\n    inst.endVal = tempEndDate ? formatDate(format, tempEndDate, s) : '';\n    d = base.parseValue(curr ? tempEndDate : tempStartDate, inst);\n\n    if (!temp) {\n      inst._startDate = startDate = tempStartDate;\n      inst._endDate = endDate = tempEndDate;\n    }\n\n    set = true;\n\n    inst._setVal(d, fill, change, temp, time);\n  };\n\n  inst.getVal = function (temp) {\n    return temp ? [returnDate(tempStartDate, s, format), returnDate(tempEndDate, s, format)] : inst._hasValue ? [returnDate(startDate, s, format), returnDate(endDate, s, format)] : null;\n  };\n\n  inst.setActiveDate = function (active) {\n    var hl; //if (!autoChange) {\n\n    curr = active == 'start' ? 0 : 1; //}\n\n    hl = active == 'start' ? tempStartDate : tempEndDate;\n\n    if (inst.isVisible()) {\n      //if (!autoChange) {\n      setActiveTab();\n\n      if (!autoChange) {\n        $$1('.mbsc-cal-table .mbsc-cal-day-hl', ctx).removeClass(highlightClass);\n\n        if (hl) {\n          $$1('.mbsc-cal-day[data-full=\"' + hl.getFullYear() + '-' + (hl.getMonth() + 1) + '-' + hl.getDate() + '\"]', ctx).addClass(highlightClass);\n        }\n      }\n\n      if (hl) {\n        init = true;\n        inst.setDate(hl, false, 1000, true);\n      }\n    }\n  };\n\n  inst.getValue = inst.getVal; // ---\n  // ---\n\n  return extend$1({}, base, {\n    highlight: false,\n    outerMonthChange: false,\n    formatValue: function formatValue() {\n      return inst.startVal + (s.endInput ? '' : inst.endVal ? ' - ' + inst.endVal : '');\n    },\n    parseValue: function parseValue(v) {\n      var parts = v ? v.split(' - ') : [],\n          startVal = s.startInput ? $$1(s.startInput).val() : parts[0],\n          endVal = s.endInput ? $$1(s.endInput).val() : parts[1];\n      s.defaultValue = def[1]; // used by parseDate\n\n      endDate = endVal ? parseDate(format, endVal, s) : def[1];\n      s.defaultValue = def[0]; // used by parseDate\n\n      startDate = startVal ? parseDate(format, startVal, s) : def[2];\n      s.defaultValue = def[curr];\n      inst.startVal = startDate ? formatDate(format, startDate, s) : '';\n      inst.endVal = endDate ? formatDate(format, endDate, s) : '';\n      inst._startDate = startDate;\n      inst._endDate = endDate;\n      return base.parseValue(curr ? endDate : startDate, inst);\n    },\n    onFill: function onFill(ev) {\n      updateInputs(ev.change);\n    },\n    onBeforeClose: function onBeforeClose(ev) {\n      // Don't allow invalid selection\n      if (ev.button === 'set' && !validate(true, true)) {\n        inst.setActiveDate(curr ? 'start' : 'end');\n        return false;\n      }\n    },\n    onHide: function onHide() {\n      base.onHide.call(inst);\n      curr = 0;\n      ctx = null;\n      s.anchor = startAnchor;\n    },\n    onClear: function onClear() {\n      if (autoChange) {\n        curr = 0;\n      }\n    },\n    onBeforeShow: function onBeforeShow() {\n      tempStartDate = startDate || def[0];\n      tempEndDate = endDate || def[1];\n      tempStartTime = setTimeInfo(tempStartDate, 0);\n      tempEndTime = setTimeInfo(tempEndDate, 1);\n\n      if (s.counter) {\n        s.headerText = function () {\n          var nr = calcDayNr();\n          return (nr > 1 ? s.selectedPluralText || s.selectedText : s.selectedText).replace(/{count}/, nr);\n        };\n      }\n\n      set = true;\n    },\n    onMarkupReady: function onMarkupReady(ev) {\n      var html; // Validate start end end dates\n\n      validateDates(); // Set the current date (start or end)\n\n      if (curr && tempEndDate || !curr && tempStartDate) {\n        init = true;\n        inst.setDate(curr ? tempEndDate : tempStartDate, false, 0, true);\n      }\n\n      highlightDays(); // Call calbase\n\n      base.onMarkupReady.call(this, ev);\n      ctx = $$1(ev.target);\n      ctx.addClass('mbsc-range');\n\n      if (showSelector) {\n        html = '<div class=\"mbsc-range-btn-t\" role=\"radiogroup\">' + '<div class=\"mbsc-range-btn-c mbsc-range-btn-start\"><div role=\"radio\" data-select=\"start\" class=\"mbsc-fr-btn-e mbsc-fr-btn-nhl mbsc-range-btn\">' + s.fromText + '<div class=\"mbsc-range-btn-v mbsc-range-btn-v-start\">' + (inst.startVal || '&nbsp;') + '</div></div></div>' + '<div class=\"mbsc-range-btn-c mbsc-range-btn-end\"><div role=\"radio\" data-select=\"end\" class=\"mbsc-fr-btn-e mbsc-fr-btn-nhl mbsc-range-btn\">' + s.toText + '<div class=\"mbsc-range-btn-v mbsc-range-btn-v-end\">' + (inst.endVal || '&nbsp;') + '</div></div></div>' + '</div>';\n\n        if (s.headerText) {\n          $$1('.mbsc-fr-hdr', ctx).after(html);\n        } else {\n          $$1('.mbsc-fr-w', ctx).prepend(html);\n        }\n\n        setActiveTab();\n      }\n\n      $$1('.mbsc-range-btn', ctx).each(function (i, el) {\n        listen(el, 'touchstart', onBtnClick, {\n          passive: true\n        });\n        listen(el, 'click', onBtnClick);\n      });\n    },\n    onDayChange: function onDayChange(day) {\n      day.active = curr ? 'end' : 'start';\n      dayChange = true;\n    },\n    onSetDate: function onSetDate(day) {\n      var d;\n\n      if (!init) {\n        d = normalizeTime(day.date, curr);\n\n        if (!set || dayChange) {\n          if (autoChange && dayChange) {\n            if (curr == 1 && d < tempStartDate) {\n              curr = 0;\n            }\n\n            if (curr) {\n              d.setHours(tempEndTime.h, tempEndTime.i, tempEndTime.s, 999);\n            } else {\n              d.setHours(tempStartTime.h, tempStartTime.i, tempStartTime.s, 0);\n            }\n          }\n\n          if (curr) {\n            tempEndDate = new Date(d);\n            tempEndTime = setTimeInfo(tempEndDate);\n          } else {\n            tempStartDate = new Date(d);\n            tempStartTime = setTimeInfo(tempStartDate);\n          } // Make sure times are on the same day for comparison\n\n\n          if (timeOnly && s.autoCorrect) {\n            normalize(tempStartDate, d);\n            normalize(tempEndDate, d);\n          } // Set end date on start selection if rangeTap is enabled\n\n\n          if (autoChange && dayChange && !curr) {\n            //tempEndDate = new Date(d.setHours(23, 59, 59, 999));\n            tempEndDate = null;\n          }\n        }\n      }\n\n      if (timeOnly && !s.autoCorrect && tempEndDate < tempStartDate) {\n        // Set end time to next day\n        tempEndDate = new Date(tempEndDate.setDate(tempEndDate.getDate() + 1));\n      } // Validate min/max ranges\n\n\n      inst._isValid = validate(set || dayChange || s.autoCorrect, !init);\n      day.active = curr ? 'end' : 'start'; // Toggle start/end if rangeTap is enabled\n\n      if (!init && autoChange) {\n        if (dayChange) {\n          curr = curr ? 0 : 1;\n        }\n\n        setActiveTab();\n      }\n\n      if (inst.isVisible()) {\n        // Disable set button\n        if (inst._isValid) {\n          $$1('.mbsc-fr-btn-s .mbsc-fr-btn', inst._markup).removeClass(disabledClass);\n        } else {\n          $$1('.mbsc-fr-btn-s .mbsc-fr-btn', inst._markup).addClass(disabledClass);\n        }\n      }\n\n      dayChange = false;\n      set = false;\n      init = false;\n    },\n    onTabChange: function onTabChange(ev) {\n      if (ev.tab != 'calendar') {\n        inst.setDate(curr ? tempEndDate : tempStartDate, false, 1000, true);\n      }\n\n      validate(true, true);\n    }\n  });\n};\n\nvar RANGE_SUB_TEMPLATE = \"<mbsc-input\\n    [controlNg]=\\\"false\\\" [name]=\\\"name\\\" [theme]=\\\"theme\\\" [disabled]=\\\"disabled\\\" [placeholder]=\\\"placeholder\\\"\\n    [error]=\\\"error\\\" [errorMessage]=\\\"errorMessage\\\" \\n    [icon]=\\\"inputIcon\\\" [icon-align]=\\\"iconAlign\\\">\\n    <ng-content></ng-content>\\n</mbsc-input>\";\n\nvar MbscRangeStartComponent = function () {\n  function MbscRangeStartComponent(host, parent, zone, control) {\n    this.host = host;\n    this.parent = parent;\n    this.zone = zone;\n    this.control = control;\n    this.theme = undefined;\n    this.errorMessage = '';\n    this.placeholder = '';\n    this.rangeIndex = 0;\n    this.oldAccessor = null;\n\n    this.onChange = function (value) {};\n\n    this.onTouch = function () {};\n\n    this.initialSet = true;\n    this.checkAccessor();\n  }\n\n  Object.defineProperty(MbscRangeStartComponent.prototype, \"element\", {\n    get: function () {\n      var i = $$1(this.host.nativeElement).find('input');\n      return i[0];\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscRangeStartComponent.prototype.checkAccessor = function () {\n    if (this.control) {\n      if (this.control.valueAccessor !== this) {\n        this.oldAccessor = this.control.valueAccessor;\n      }\n\n      this.control.valueAccessor = this;\n    }\n  };\n\n  MbscRangeStartComponent.prototype.handleChange = function () {\n    var _this = this;\n\n    $$1(this.element).on('change', function () {\n      _this.zone.run(function () {\n        var arr = _this.parent.instance.getVal(),\n            value = arr ? arr[_this.rangeIndex] : undefined,\n            current = undefined,\n            valueText = _this.parent.instance[_this.rangeIndex === 0 ? 'startVal' : 'endVal'];\n\n        if (arr && value && _this.element.value !== valueText && _this.parent.enableManualEdit) {\n          var newArr = new Array(2),\n              otherIndex = _this.rangeIndex === 1 ? 0 : 1;\n          newArr[_this.rangeIndex] = _this.element.value;\n          newArr[otherIndex] = arr[otherIndex];\n\n          _this.parent.instance.setVal(newArr, true, true);\n        } else {\n          if (_this.control && _this.control.value && _this.control.value instanceof Array) {\n            current = _this.control.value[_this.rangeIndex];\n          } else if (_this.control && _this.control.value) {\n            current = _this.control.value;\n          }\n\n          if (_this.control) {\n            if (!isDateEqual(current, value)) {\n              _this.onChange(value);\n\n              _this.control.control.patchValue(value);\n            }\n          }\n        }\n      });\n    });\n  };\n\n  MbscRangeStartComponent.prototype.ngAfterViewInit = function () {\n    this.handleChange();\n    this.checkAccessor();\n  };\n\n  MbscRangeStartComponent.prototype.registerOnChange = function (fn) {\n    this.onChange = fn;\n  };\n\n  MbscRangeStartComponent.prototype.registerOnTouched = function (fn) {\n    this.onTouch = fn;\n  };\n\n  MbscRangeStartComponent.prototype.setDisabledState = function (isDisabled) {\n    this.disabled = isDisabled;\n\n    if (this.oldAccessor && this.oldAccessor.setDisabledState) {\n      this.oldAccessor.setDisabledState(isDisabled);\n    }\n  };\n\n  MbscRangeStartComponent.prototype.writeValue = function (v) {\n    var _this = this;\n\n    if (this.parent && this.parent.instance) {\n      var arr_1 = this.parent.instance.getVal(),\n          val = arr_1 && arr_1.length ? arr_1[this.rangeIndex] : undefined;\n\n      if (!isDateEqual(v, val)) {\n        if (v === undefined) {\n          arr_1 = undefined;\n        } else {\n          arr_1 = arr_1 || [];\n          arr_1[this.rangeIndex] = v;\n        }\n\n        this.parent.instance.setVal(arr_1, true, false);\n\n        if (this.initialSet) {\n          setTimeout(function () {\n            _this.parent.instance.setVal(arr_1, true, false);\n\n            _this.initialSet = false;\n          });\n        }\n      }\n    }\n  };\n\n  __decorate([Input$1('icon'), __metadata(\"design:type\", String)], MbscRangeStartComponent.prototype, \"inputIcon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscRangeStartComponent.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscRangeStartComponent.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscRangeStartComponent.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscRangeStartComponent.prototype, \"errorMessage\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscRangeStartComponent.prototype, \"disabled\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscRangeStartComponent.prototype, \"placeholder\", void 0);\n\n  MbscRangeStartComponent = __decorate([__param(1, Inject(forwardRef(function () {\n    return MbscRangeComponent;\n  }))), __param(3, Optional()), __metadata(\"design:paramtypes\", [ElementRef, MbscRangeComponent, NgZone, NgControl])], MbscRangeStartComponent);\n\n  MbscRangeStartComponent.ɵfac = function MbscRangeStartComponent_Factory(t) {\n    return new (t || MbscRangeStartComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(forwardRef(function () {\n      return MbscRangeComponent;\n    })), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8));\n  };\n\n  MbscRangeStartComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscRangeStartComponent,\n    selectors: [[\"mbsc-range-start\"]],\n    inputs: {\n      errorMessage: \"errorMessage\",\n      placeholder: \"placeholder\",\n      disabled: \"disabled\",\n      inputIcon: [\"icon\", \"inputIcon\"],\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      name: \"name\",\n      error: \"error\"\n    },\n    ngContentSelectors: _c1,\n    decls: 2,\n    vars: 9,\n    consts: [[3, \"controlNg\", \"name\", \"theme\", \"disabled\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\"]],\n    template: function MbscRangeStartComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"mbsc-input\", 0);\n        ɵngcc0.ɵɵprojection(1);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"controlNg\", false)(\"name\", ctx.name)(\"theme\", ctx.theme)(\"disabled\", ctx.disabled)(\"placeholder\", ctx.placeholder)(\"error\", ctx.error)(\"errorMessage\", ctx.errorMessage)(\"icon\", ctx.inputIcon)(\"icon-align\", ctx.iconAlign);\n      }\n    },\n    directives: [MbscInput],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscRangeStartComponent;\n}();\n\nvar MbscRangeEndComponent = function (_super) {\n  __extends(MbscRangeEndComponent, _super);\n\n  function MbscRangeEndComponent(el, parent, zone, control) {\n    var _this = _super.call(this, el, parent, zone, control) || this;\n\n    _this.rangeIndex = 1;\n    return _this;\n  }\n\n  MbscRangeEndComponent = __decorate([__param(1, Inject(forwardRef(function () {\n    return MbscRangeComponent;\n  }))), __param(3, Optional()), __metadata(\"design:paramtypes\", [ElementRef, MbscRangeComponent, NgZone, NgControl])], MbscRangeEndComponent);\n\n  MbscRangeEndComponent.ɵfac = function MbscRangeEndComponent_Factory(t) {\n    return new (t || MbscRangeEndComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(forwardRef(function () {\n      return MbscRangeComponent;\n    })), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8));\n  };\n\n  MbscRangeEndComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscRangeEndComponent,\n    selectors: [[\"mbsc-range-end\"]],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 2,\n    vars: 9,\n    consts: [[3, \"controlNg\", \"name\", \"theme\", \"disabled\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\"]],\n    template: function MbscRangeEndComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"mbsc-input\", 0);\n        ɵngcc0.ɵɵprojection(1);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"controlNg\", false)(\"name\", ctx.name)(\"theme\", ctx.theme)(\"disabled\", ctx.disabled)(\"placeholder\", ctx.placeholder)(\"error\", ctx.error)(\"errorMessage\", ctx.errorMessage)(\"icon\", ctx.inputIcon)(\"icon-align\", ctx.iconAlign);\n      }\n    },\n    directives: [MbscInput],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscRangeEndComponent;\n}(MbscRangeStartComponent);\n\nvar MbscRange = function (_super) {\n  __extends(MbscRange, _super);\n\n  function MbscRange(initialElem, zone, control, inputService, optionService, view) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, view) || this;\n\n    _this.optionService = optionService;\n    _this.onSetDate = new EventEmitter();\n    _this.onCellHoverIn = new EventEmitter();\n    _this.onCellHoverOut = new EventEmitter();\n    _this.onDayChange = new EventEmitter();\n    _this.options = {};\n    _this.onChangeEmitter = new EventEmitter();\n    return _this;\n  }\n\n  Object.defineProperty(MbscRange.prototype, \"endInput\", {\n    set: function (v) {\n      var element = v;\n\n      if (typeof v == \"string\") {\n        var hasInput = $$1(v).find('input');\n\n        if (hasInput.length) {\n          element = hasInput[0];\n        }\n      }\n\n      this._endInput = element;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MbscRange.prototype, \"startInput\", {\n    set: function (v) {\n      var element = v;\n\n      if (typeof v == \"string\") {\n        var hasInput = $$1(v).find('input');\n\n        if (hasInput.length) {\n          element = hasInput[0];\n        }\n      }\n\n      this._startInput = element;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MbscRange.prototype, \"value\", {\n    set: function (v) {\n      this.setNewValueProxy(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscRange.prototype.setNewValue = function (v) {\n    if (this.instance) {\n      if (!deepEqualsArray(v, this.instance.getVal())) {\n        this.instance.setVal(v, true, false);\n\n        if (this._inputService && this._inputService.input) {\n          this._inputService.input.innerValue = this.instance._value;\n        }\n      }\n    }\n  };\n\n  Object.defineProperty(MbscRange.prototype, \"optionExtensions\", {\n    get: function () {\n      var _this = this;\n\n      var externalOnClose = this.options && this.options.onClose;\n      var externalOnFill = this.options && this.options.onFill;\n      var onCloseEmitter = this.onClose;\n      return {\n        onFill: function (event, inst) {\n          if (!_this._wrapper) {\n            if (_this.oldAccessor) {\n              _this.oldAccessor.writeValue(event.valueText);\n            }\n          }\n\n          if (externalOnFill) {\n            externalOnFill(event, inst);\n          }\n        },\n        onClose: function (event, inst) {\n          _this.onTouch();\n\n          if (externalOnClose) {\n            externalOnClose(event, inst);\n          }\n\n          if (onCloseEmitter) {\n            event.inst = inst;\n            onCloseEmitter.emit(event);\n          }\n        }\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscRange.prototype.initControl = function () {\n    var options = extend$1({\n      preset: 'range',\n      skipShow: this._wrapper\n    }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, {\n      endInput: this._wrapper ? this.end.element : this._endInput,\n      startInput: this._wrapper ? this.start.element : this._startInput\n    }, this.optionExtensions);\n    this.instance = new RangePicker(this._wrapper ? this.initialElem.nativeElement : this.element, options);\n\n    if (this.initialValue) {\n      this.instance.setVal(this.initialValue, true, false);\n    }\n  };\n\n  MbscRange.prototype.ngAfterContentInit = function () {\n    if (this.start || this.end) {\n      this._wrapper = true;\n    } else {\n      this._wrapper = false;\n    }\n  };\n\n  MbscRange.prototype.handleChange = function () {\n    var _this = this;\n\n    if (this._wrapper) {\n      $$1(this.start.element).on('change', function () {\n        _this.zone.run(function () {\n          var value = _this.instance.getVal();\n\n          if (_this.control) {\n            if (!deepEqualsArray(_this.control.value, value)) {\n              _this.onChange(value);\n\n              _this.control.control.patchValue(value);\n            }\n          } else {\n            _this.onChangeEmitter.emit(value);\n          }\n        });\n      });\n      $$1(this.end.element).on('change', function () {\n        _this.zone.run(function () {\n          var value = _this.instance.getVal();\n\n          if (_this.control) {\n            if (!deepEqualsArray(_this.control.value, value)) {\n              _this.onChange(value);\n\n              _this.control.control.patchValue(value);\n            }\n          } else {\n            _this.onChangeEmitter.emit(value);\n          }\n        });\n      });\n    } else {\n      var that_1 = this;\n      $$1(this.element).on('change', function () {\n        that_1.zone.run(function () {\n          if (that_1.element.value !== that_1.instance._value && that_1.enableManualEdit) {\n            var v = that_1.element.value && that_1.element.value.split(' - ');\n\n            if (v) {\n              that_1.instance.setVal(v, true, true);\n            }\n          } else {\n            var value = that_1.instance.getVal();\n\n            if (that_1.control) {\n              that_1.onChange(value);\n              that_1.control.control.patchValue(value);\n            } else {\n              that_1.onChangeEmitter.emit(value);\n            }\n          }\n        });\n      });\n    }\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscRange.prototype, \"autoCorrect\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscRange.prototype, \"controls\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], MbscRange.prototype, \"endInput\", null);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscRange.prototype, \"maxRange\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscRange.prototype, \"minRange\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscRange.prototype, \"showSelector\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], MbscRange.prototype, \"startInput\", null);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscRange.prototype, \"fromText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscRange.prototype, \"toText\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscRange.prototype, \"onSetDate\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscRange.prototype, \"onCellHoverIn\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscRange.prototype, \"onCellHoverOut\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscRange.prototype, \"onDayChange\", void 0);\n\n  __decorate([ContentChild(MbscRangeStartComponent, {\n    static: false\n  }), __metadata(\"design:type\", MbscRangeStartComponent)], MbscRange.prototype, \"start\", void 0);\n\n  __decorate([ContentChild(MbscRangeEndComponent, {\n    static: false\n  }), __metadata(\"design:type\", MbscRangeEndComponent)], MbscRange.prototype, \"end\", void 0);\n\n  __decorate([Input$1('mbsc-options'), __metadata(\"design:type\", Object)], MbscRange.prototype, \"options\", void 0);\n\n  __decorate([Input$1('mbsc-range'), __metadata(\"design:type\", Array), __metadata(\"design:paramtypes\", [Array])], MbscRange.prototype, \"value\", null);\n\n  __decorate([Output('mbsc-rangeChange'), __metadata(\"design:type\", EventEmitter)], MbscRange.prototype, \"onChangeEmitter\", void 0);\n\n  MbscRange = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscRange);\n\n  MbscRange.ɵfac = function MbscRange_Factory(t) {\n    return new (t || MbscRange)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscRange.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscRange,\n    selectors: [[\"\", \"mbsc-range\", \"\"]],\n    contentQueries: function MbscRange_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MbscRangeStartComponent, 5);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MbscRangeEndComponent, 5);\n      }\n\n      if (rf & 2) {\n        var _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.start = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.end = _t.first);\n      }\n    },\n    inputs: {\n      endInput: \"endInput\",\n      startInput: \"startInput\",\n      value: [\"mbsc-range\", \"value\"],\n      autoCorrect: \"autoCorrect\",\n      controls: \"controls\",\n      maxRange: \"maxRange\",\n      minRange: \"minRange\",\n      showSelector: \"showSelector\",\n      fromText: \"fromText\",\n      toText: \"toText\",\n      options: [\"mbsc-options\", \"options\"]\n    },\n    outputs: {\n      onSetDate: \"onSetDate\",\n      onCellHoverIn: \"onCellHoverIn\",\n      onCellHoverOut: \"onCellHoverOut\",\n      onDayChange: \"onDayChange\",\n      onChangeEmitter: \"mbsc-rangeChange\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscRange;\n}(MbscCalBase);\n\nvar MbscRangeComponent = function (_super) {\n  __extends(MbscRangeComponent, _super);\n\n  function MbscRangeComponent(initialElem, zone, control, inputService, optionService) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;\n\n    _this.errorMessage = '';\n    _this.placeholder = '';\n    return _this;\n  }\n\n  MbscRangeComponent.prototype.ngAfterViewInit = function () {\n    _super.prototype.ngAfterViewInit.call(this);\n\n    this.setThemeClasses();\n  };\n\n  __decorate([Input$1('icon'), __metadata(\"design:type\", String)], MbscRangeComponent.prototype, \"inputIcon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscRangeComponent.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscRangeComponent.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscRangeComponent.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscRangeComponent.prototype, \"errorMessage\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscRangeComponent.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscRangeComponent.prototype, \"placeholder\", void 0);\n\n  MbscRangeComponent = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])], MbscRangeComponent);\n\n  MbscRangeComponent.ɵfac = function MbscRangeComponent_Factory(t) {\n    return new (t || MbscRangeComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscRangeComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscRangeComponent,\n    selectors: [[\"mbsc-range\"]],\n    inputs: {\n      inputIcon: [\"icon\", \"inputIcon\"],\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      name: \"name\",\n      error: \"error\",\n      errorMessage: \"errorMessage\",\n      options: \"options\",\n      placeholder: \"placeholder\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c6,\n    decls: 3,\n    vars: 1,\n    consts: [[3, \"controlNg\", \"name\", \"theme\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\", 4, \"ngIf\"], [3, \"controlNg\", \"name\", \"theme\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\"]],\n    template: function MbscRangeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef(_c5);\n        ɵngcc0.ɵɵprojection(0);\n        ɵngcc0.ɵɵprojection(1, 1);\n        ɵngcc0.ɵɵtemplate(2, MbscRangeComponent_mbsc_input_2_Template, 2, 10, \"mbsc-input\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵadvance(2);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx._wrapper && (!ctx.inline || ctx.showInput));\n      }\n    },\n    directives: [ɵngcc2.NgIf, MbscInput],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscRangeComponent;\n}(MbscRange);\n\nvar MbscRangeModule = function () {\n  function MbscRangeModule() {}\n\n  MbscRangeModule.ɵfac = function MbscRangeModule_Factory(t) {\n    return new (t || MbscRangeModule)();\n  };\n\n  MbscRangeModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscRangeModule\n  });\n  MbscRangeModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, MbscCalBaseModule, MbscInputModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscRangeModule, {\n      declarations: function () {\n        return [MbscRangeStartComponent, MbscRangeEndComponent, MbscRange, MbscRangeComponent];\n      },\n      imports: function () {\n        return [CommonModule, MbscCalBaseModule, MbscInputModule];\n      },\n      exports: function () {\n        return [MbscRangeStartComponent, MbscRangeEndComponent, MbscRange, MbscRangeComponent];\n      }\n    });\n  })();\n\n  return MbscRangeModule;\n}();\n\nvar MbscScroller = function (_super) {\n  __extends(MbscScroller, _super);\n\n  function MbscScroller(initialElement, zone, control, inputService, optionService, view) {\n    var _this = _super.call(this, initialElement, zone, control, inputService, view) || this;\n\n    _this.optionService = optionService;\n    _this.options = {};\n    _this.onChangeEmitter = new EventEmitter();\n    return _this;\n  }\n\n  Object.defineProperty(MbscScroller.prototype, \"value\", {\n    set: function (v) {\n      this.setNewValueProxy(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscScroller.prototype.setNewValue = function (v) {\n    if (this.instance) {\n      var innerValue = this.instance.getVal();\n\n      if (innerValue !== v) {\n        this.instance.setVal(v, true, false);\n\n        if (this._inputService && this._inputService.input) {\n          this._inputService.input.innerValue = this.instance._value;\n        }\n      }\n    }\n  };\n\n  MbscScroller.prototype.initControl = function () {\n    var options = extend$1({}, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);\n    this.instance = new Scroller(this.element, options);\n\n    if (this.initialValue !== undefined) {\n      this.instance.setVal(this.initialValue, true, false);\n    }\n  };\n\n  __decorate([Input$1('mbsc-options'), __metadata(\"design:type\", Object)], MbscScroller.prototype, \"options\", void 0);\n\n  __decorate([Input$1('mbsc-scroller'), __metadata(\"design:type\", String), __metadata(\"design:paramtypes\", [String])], MbscScroller.prototype, \"value\", null);\n\n  __decorate([Output('mbsc-scrollerChange'), __metadata(\"design:type\", EventEmitter)], MbscScroller.prototype, \"onChangeEmitter\", void 0);\n\n  MbscScroller = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscScroller);\n\n  MbscScroller.ɵfac = function MbscScroller_Factory(t) {\n    return new (t || MbscScroller)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscScroller.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscScroller,\n    selectors: [[\"\", \"mbsc-scroller\", \"\"]],\n    inputs: {\n      value: [\"mbsc-scroller\", \"value\"],\n      options: [\"mbsc-options\", \"options\"]\n    },\n    outputs: {\n      onChangeEmitter: \"mbsc-scrollerChange\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscScroller;\n}(MbscScrollerBase);\n\nvar MbscScrollerComponent = function (_super) {\n  __extends(MbscScrollerComponent, _super);\n\n  function MbscScrollerComponent(initialElem, zone, control, inputService, optionService) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;\n\n    _this.errorMessage = '';\n    _this.placeholder = '';\n    return _this;\n  }\n\n  MbscScrollerComponent.prototype.ngAfterViewInit = function () {\n    _super.prototype.ngAfterViewInit.call(this);\n\n    this.setThemeClasses();\n  };\n\n  __decorate([Input$1('icon'), __metadata(\"design:type\", String)], MbscScrollerComponent.prototype, \"inputIcon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscScrollerComponent.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscScrollerComponent.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscScrollerComponent.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscScrollerComponent.prototype, \"errorMessage\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscScrollerComponent.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscScrollerComponent.prototype, \"placeholder\", void 0);\n\n  MbscScrollerComponent = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])], MbscScrollerComponent);\n\n  MbscScrollerComponent.ɵfac = function MbscScrollerComponent_Factory(t) {\n    return new (t || MbscScrollerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscScrollerComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscScrollerComponent,\n    selectors: [[\"mbsc-scroller\"]],\n    inputs: {\n      inputIcon: [\"icon\", \"inputIcon\"],\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      name: \"name\",\n      error: \"error\",\n      errorMessage: \"errorMessage\",\n      options: \"options\",\n      placeholder: \"placeholder\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\", 4, \"ngIf\"], [3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\"]],\n    template: function MbscScrollerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MbscScrollerComponent_mbsc_input_0_Template, 2, 13, \"mbsc-input\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.inline || ctx.showInput);\n      }\n    },\n    directives: [ɵngcc2.NgIf, MbscInput],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscScrollerComponent;\n}(MbscScroller);\n\nvar MbscScrollerModule = function () {\n  function MbscScrollerModule() {}\n\n  MbscScrollerModule.ɵfac = function MbscScrollerModule_Factory(t) {\n    return new (t || MbscScrollerModule)();\n  };\n\n  MbscScrollerModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscScrollerModule\n  });\n  MbscScrollerModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, MbscScrollerBaseModule, MbscInputModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscScrollerModule, {\n      declarations: function () {\n        return [MbscScroller, MbscScrollerComponent];\n      },\n      imports: function () {\n        return [CommonModule, MbscScrollerBaseModule, MbscInputModule];\n      },\n      exports: function () {\n        return [MbscScroller, MbscScrollerComponent];\n      }\n    });\n  })();\n\n  return MbscScrollerModule;\n}();\n\nvar MbscScrollView = function (_super) {\n  __extends(MbscScrollView, _super);\n\n  function MbscScrollView(initialElem, zone, notifyItemService, optionService) {\n    var _this = _super.call(this, initialElem, zone, notifyItemService) || this;\n\n    _this.optionService = optionService;\n    return _this;\n  }\n\n  MbscScrollView.prototype.initControl = function () {\n    var _this = this;\n\n    var options = extend$1({}, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj);\n    this.instance = new ScrollView(this.initialElem.nativeElement, options);\n    this.notifyItemService.notifyInstanceReady(this.instance);\n    this.addRemoveObserver = this.notifyItemService.onAddRemove().subscribe(function (item) {\n      _this.instance.refresh();\n    });\n  };\n\n  MbscScrollView.prototype.ngOnDestroy = function () {\n    this.notifyItemService.onAddRemove().unsubscribe(this.addRemoveObserver);\n\n    _super.prototype.ngOnDestroy.call(this);\n  };\n\n  __decorate([Input$1('mbsc-options'), __metadata(\"design:type\", Object)], MbscScrollView.prototype, \"options\", void 0);\n\n  MbscScrollView = __decorate([__param(3, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, MbscNotifyItemService, MbscOptionsService])], MbscScrollView);\n\n  MbscScrollView.ɵfac = function MbscScrollView_Factory(t) {\n    return new (t || MbscScrollView)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscScrollView.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscScrollView,\n    selectors: [[\"\", \"mbsc-scrollview\", \"\"]],\n    hostAttrs: [1, \"mbsc-cloak\"],\n    inputs: {\n      options: [\"mbsc-options\", \"options\"]\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([MbscNotifyItemService]), ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscScrollView;\n}(MbscScrollViewBase);\n\nvar MbscScrollViewItem = function (_super) {\n  __extends(MbscScrollViewItem, _super);\n\n  function MbscScrollViewItem(initialElem, notifyItemService) {\n    return _super.call(this, notifyItemService, initialElem) || this;\n  }\n\n  MbscScrollViewItem = __decorate([__metadata(\"design:paramtypes\", [ElementRef, MbscNotifyItemService])], MbscScrollViewItem);\n\n  MbscScrollViewItem.ɵfac = function MbscScrollViewItem_Factory(t) {\n    return new (t || MbscScrollViewItem)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService));\n  };\n\n  MbscScrollViewItem.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscScrollViewItem,\n    selectors: [[\"\", \"mbsc-scrollview-item\", \"\"]],\n    hostVars: 1,\n    hostBindings: function MbscScrollViewItem_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"data-id\", ctx.id);\n      }\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscScrollViewItem;\n}(MbscScrollItemBase);\n\nvar MbscScrollViewComponent = function (_super) {\n  __extends(MbscScrollViewComponent, _super);\n\n  function MbscScrollViewComponent(initialElem, zone, notifyItemService, optionService) {\n    return _super.call(this, initialElem, zone, notifyItemService, optionService) || this;\n  }\n\n  __decorate([Input$1('options'), __metadata(\"design:type\", Object)], MbscScrollViewComponent.prototype, \"options\", void 0);\n\n  MbscScrollViewComponent = __decorate([__param(3, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, MbscNotifyItemService, MbscOptionsService])], MbscScrollViewComponent);\n\n  MbscScrollViewComponent.ɵfac = function MbscScrollViewComponent_Factory(t) {\n    return new (t || MbscScrollViewComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscScrollViewComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscScrollViewComponent,\n    selectors: [[\"mbsc-scrollview\"]],\n    inputs: {\n      options: \"options\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵProvidersFeature([MbscNotifyItemService]), ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscScrollViewComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscScrollViewComponent;\n}(MbscScrollView);\n\nvar MbscScrollViewItemComponent = function (_super) {\n  __extends(MbscScrollViewItemComponent, _super);\n\n  function MbscScrollViewItemComponent(initialElem, notifyItemService) {\n    return _super.call(this, initialElem, notifyItemService) || this;\n  }\n\n  MbscScrollViewItemComponent = __decorate([__metadata(\"design:paramtypes\", [ElementRef, MbscNotifyItemService])], MbscScrollViewItemComponent);\n\n  MbscScrollViewItemComponent.ɵfac = function MbscScrollViewItemComponent_Factory(t) {\n    return new (t || MbscScrollViewItemComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MbscNotifyItemService));\n  };\n\n  MbscScrollViewItemComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscScrollViewItemComponent,\n    selectors: [[\"mbsc-scrollview-item\"]],\n    hostVars: 1,\n    hostBindings: function MbscScrollViewItemComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵattribute(\"data-id\", ctx.id);\n      }\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function MbscScrollViewItemComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscScrollViewItemComponent;\n}(MbscScrollViewItem);\n\nvar MbscScrollViewModule = function () {\n  function MbscScrollViewModule() {}\n\n  MbscScrollViewModule.ɵfac = function MbscScrollViewModule_Factory(t) {\n    return new (t || MbscScrollViewModule)();\n  };\n\n  MbscScrollViewModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscScrollViewModule\n  });\n  MbscScrollViewModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[MbscScrollViewBaseModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscScrollViewModule, {\n      declarations: [MbscScrollView, MbscScrollViewComponent, MbscScrollViewItem, MbscScrollViewItemComponent],\n      imports: [MbscScrollViewBaseModule],\n      exports: [MbscScrollView, MbscScrollViewComponent, MbscScrollViewItem, MbscScrollViewItemComponent]\n    });\n  })();\n\n  return MbscScrollViewModule;\n}();\n\nvar Select$1 = Scroller;\nvar defaults$d = {\n  inputClass: '',\n  rtl: false,\n  showInput: true,\n  groupLabel: 'Groups',\n  dataHtml: 'html',\n  dataText: 'text',\n  dataValue: 'value',\n  dataGroup: 'group',\n  dataDisabled: 'disabled',\n  filterPlaceholderText: 'Type to filter',\n  filterEmptyText: 'No results',\n  filterClearIcon: 'material-close'\n};\n\npresets.select = function (inst, settings) {\n  var $input,\n      dataArray,\n      filterLength,\n      filterText,\n      group,\n      groupArray,\n      groupWheel,\n      groups,\n      groupWheelIdx,\n      hasRemoteData,\n      option,\n      optionArray,\n      optionWheel,\n      optionWheelIdx,\n      prevent,\n      defaultValue = '',\n      selectedTexts = {},\n      animTime = 1000,\n      elm = this,\n      $elm = $$1(elm),\n      orig = extend$1({}, inst.settings),\n      s = extend$1(inst.settings, defaults$d, orig),\n      $filterEmpty = $$1('<div class=\"mbsc-sel-empty\">' + s.filterEmptyText + '</div>'),\n      origReadOnly = s.readonly,\n      options = {},\n      layout = s.layout || (/top|bottom|inline/.test(s.display) || s.filter ? 'liquid' : ''),\n      isLiquid = layout == 'liquid' || !s.touchUi,\n      multiple = isNumeric(s.select) ? s.select : s.select == 'multiple' || $elm.prop('multiple'),\n      tapSelect = multiple || (s.filter || s.tapSelect ? 1 : false),\n      id = this.id + '_dummy',\n      lbl = $$1('label[for=\"' + this.id + '\"]').attr('for', id),\n      label = s.label !== undefined ? s.label : lbl.length ? lbl.text() : $elm.attr('name'),\n      groupSetup = s.group,\n      hasData = !!s.data,\n      hasGroups = hasData ? !!s.group : $$1('optgroup', $elm).length,\n      hasGroupWheel = hasGroups && groupSetup && groupSetup.groupWheel !== false,\n      groupSep = hasGroups && groupSetup && hasGroupWheel && groupSetup.clustered === true,\n      groupHdr = hasGroups && (!groupSetup || groupSetup.header !== false && !groupSep),\n      values = $elm.val() || (multiple ? [] : ['']),\n      invalid = [];\n\n  function prepareData(filter) {\n    var gr,\n        html,\n        lbl,\n        opt,\n        txt,\n        val,\n        l = 0,\n        c = 0,\n        groupIndexes = {};\n    options = {};\n    groups = {};\n    optionArray = [];\n    groupArray = []; // Reset invalids\n\n    invalid.length = 0;\n\n    if (hasData) {\n      $$1.each(dataArray, function (i, v) {\n        txt = v[s.dataText] + ''; // Convert to string\n\n        html = v[s.dataHtml];\n        val = v[s.dataValue];\n        lbl = v[s.dataGroup];\n        opt = {\n          value: val,\n          html: html,\n          text: txt,\n          index: i,\n          cssClass: groupHdr ? 'mbsc-sel-gr-itm' : ''\n        };\n        options[val] = opt;\n\n        if (!filter || matchesFilter(txt, filter)) {\n          optionArray.push(opt);\n\n          if (hasGroups) {\n            if (groupIndexes[lbl] === undefined) {\n              gr = {\n                text: lbl,\n                value: c,\n                options: [],\n                index: c\n              };\n              groups[c] = gr;\n              groupIndexes[lbl] = c;\n              groupArray.push(gr);\n              c++;\n            } else {\n              gr = groups[groupIndexes[lbl]];\n            }\n\n            if (groupSep) {\n              opt.index = gr.options.length;\n            }\n\n            opt.group = groupIndexes[lbl];\n            gr.options.push(opt);\n          }\n\n          if (v[s.dataDisabled]) {\n            invalid.push(val);\n          }\n        }\n      });\n    } else {\n      if (hasGroups) {\n        var addGroup = true;\n        $$1('optgroup', $elm).each(function (i) {\n          groups[i] = {\n            text: this.label,\n            value: i,\n            options: [],\n            index: i\n          };\n          addGroup = true;\n          $$1('option', this).each(function (j) {\n            opt = {\n              value: this.value,\n              text: this.text,\n              index: groupSep ? j : l++,\n              group: i,\n              cssClass: groupHdr ? 'mbsc-sel-gr-itm' : ''\n            };\n            options[this.value] = opt;\n\n            if (!filter || matchesFilter(this.text, filter)) {\n              if (addGroup) {\n                groupArray.push(groups[i]);\n                addGroup = false;\n              }\n\n              optionArray.push(opt);\n              groups[i].options.push(opt);\n\n              if (this.disabled) {\n                invalid.push(this.value);\n              }\n            }\n          });\n        });\n      } else {\n        $$1('option', $elm).each(function (i) {\n          opt = {\n            value: this.value,\n            text: this.text,\n            index: i\n          };\n          options[this.value] = opt;\n\n          if (!filter || matchesFilter(this.text, filter)) {\n            optionArray.push(opt);\n\n            if (this.disabled) {\n              invalid.push(this.value);\n            }\n          }\n        });\n      }\n    }\n\n    if (s.defaultValue) {\n      defaultValue = s.defaultValue;\n    } else if (optionArray.length) {\n      defaultValue = optionArray[0].value;\n    } else {\n      defaultValue = '';\n    }\n\n    if (groupHdr) {\n      optionArray = [];\n      l = 0;\n      $$1.each(groups, function (i, gr) {\n        if (gr.options.length) {\n          val = '__group' + i;\n          opt = {\n            text: gr.text,\n            value: val,\n            group: i,\n            index: l++,\n            cssClass: 'mbsc-sel-gr'\n          };\n          options[val] = opt;\n          optionArray.push(opt);\n          invalid.push(opt.value);\n          $$1.each(gr.options, function (j, opt) {\n            opt.index = l++;\n            optionArray.push(opt);\n          });\n        }\n      });\n    }\n\n    if ($filterEmpty) {\n      if (optionArray.length) {\n        $filterEmpty.removeClass('mbsc-sel-empty-v');\n      } else {\n        $filterEmpty.addClass('mbsc-sel-empty-v');\n      }\n    }\n  }\n\n  function genValues(data, tapSelect, label, multiple, cssClass) {\n    var i,\n        values = [];\n\n    for (i = 0; i < data.length; i++) {\n      values.push({\n        value: data[i].value,\n        display: data[i].html || data[i].text,\n        cssClass: data[i].cssClass\n      });\n    }\n\n    return {\n      circular: false,\n      multiple: tapSelect && !multiple ? 1 : multiple,\n      cssClass: (tapSelect && !multiple ? 'mbsc-sel-one' : '') + ' ' + cssClass,\n      data: values,\n      label: label\n    };\n  }\n\n  function genGroupWheel() {\n    return genValues(groupArray, tapSelect, s.groupLabel, false, 'mbsc-sel-gr-whl');\n  }\n\n  function genOptWheel() {\n    return genValues(groupSep && groups[group] ? groups[group].options : optionArray, tapSelect, label, multiple, '');\n  }\n\n  function genWheels() {\n    var w = [[]];\n\n    if (hasGroupWheel) {\n      groupWheel = genGroupWheel();\n\n      if (isLiquid) {\n        w[0][groupWheelIdx] = groupWheel;\n      } else {\n        w[groupWheelIdx] = [groupWheel];\n      }\n    }\n\n    optionWheel = genOptWheel();\n\n    if (isLiquid) {\n      w[0][optionWheelIdx] = optionWheel;\n    } else {\n      w[optionWheelIdx] = [optionWheel];\n    }\n\n    return w;\n  }\n\n  function getOption(v) {\n    if (multiple) {\n      if (v && isString(v)) {\n        v = v.split(',');\n      }\n\n      if ($$1.isArray(v)) {\n        v = v[0];\n      }\n    }\n\n    option = v === undefined || v === null || v === '' ? defaultValue : v;\n\n    if (!options[option] && optionArray && optionArray.length) {\n      option = optionArray[0].value;\n    }\n\n    if (hasGroupWheel) {\n      group = options[option] ? options[option].group : null;\n    }\n  }\n\n  function getText(opt) {\n    return selectedTexts[opt] || (options[opt] ? options[opt].text : '');\n  }\n\n  function formatValue(d, inst, fill) {\n    var i,\n        opt,\n        sel = [],\n        selected = fill ? inst._selected : inst._tempSelected;\n\n    if (tapSelect) {\n      for (i in selected[optionWheelIdx]) {\n        sel.push(getText(i));\n      }\n\n      return sel.join(', ');\n    }\n\n    opt = d[optionWheelIdx];\n    return getText(opt);\n  }\n\n  function onFill() {\n    var i,\n        html = '',\n        val = inst.getVal(),\n        txt = s.formatValue.call(elm, inst.getArrayVal(), inst, true);\n\n    if (!(s.filter && s.display == 'inline')) {\n      $input.val(txt);\n    } // If we have a native select, but data was passed in setting,\n    // create an option tag with the selected value\n\n\n    if ($elm.is('select') && hasData) {\n      if (multiple) {\n        for (i = 0; i < val.length; i++) {\n          html += '<option value=\"' + val[i] + '\">' + getText(val[i]) + '</option>';\n        }\n      } else {\n        html = '<option value=\"' + (val === null ? '' : val) + '\">' + txt + '</option>';\n      }\n\n      $elm.html(html);\n    }\n\n    if (elm !== $input[0]) {\n      // if the target is the same, we should not overwrite it\n      $elm.val(val);\n    }\n  }\n\n  function changeWheel() {\n    var wheels = {};\n    wheels[optionWheelIdx] = genOptWheel();\n    prevent = true;\n    inst.changeWheel(wheels);\n  }\n\n  function matchesFilter(str, filter) {\n    filter = filter.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'); // escape the special characters\n\n    return str.match(new RegExp(filter, 'ig'));\n  }\n\n  function getData(data) {\n    return s.data.dataField ? data[s.data.dataField] : s.data.processResponse ? s.data.processResponse(data) : data;\n  }\n\n  function prepareWheels(filter) {\n    var wheels = {};\n    prepareData(filter);\n    getOption(option);\n    s.wheels = genWheels();\n    wheels[optionWheelIdx] = optionWheel;\n    inst._tempWheelArray[optionWheelIdx] = option;\n\n    if (hasGroupWheel) {\n      wheels[groupWheelIdx] = groupWheel;\n      inst._tempWheelArray[groupWheelIdx] = group;\n    }\n\n    inst.changeWheel(wheels, 0, true);\n    onFill();\n  }\n\n  function triggerOnFilter(value) {\n    return inst.trigger('onFilter', {\n      filterText: value\n    });\n  }\n\n  function loadGroupOptions(values) {\n    if (values[groupWheelIdx] != group) {\n      group = values[groupWheelIdx];\n      option = groups[group].options[0].value;\n      values[optionWheelIdx] = option;\n\n      if (groupSep) {\n        changeWheel();\n      } else {\n        inst.setArrayVal(values, false, false, true, animTime);\n      }\n    }\n  } // Extended methods\n  // ---\n\n\n  inst.setVal = function (val, fill, change, temp, time) {\n    if (tapSelect) {\n      if (val !== null && val !== undefined && !multiple) {\n        val = [val];\n      }\n\n      if (val && isString(val)) {\n        val = val.split(',');\n      }\n\n      inst._tempSelected[optionWheelIdx] = arrayToObject(val);\n\n      if (!temp) {\n        inst._selected[optionWheelIdx] = arrayToObject(val);\n      }\n\n      val = val ? val[0] : null;\n\n      if (hasGroupWheel) {\n        var opt = options[val],\n            gr = opt && opt.group;\n        inst._tempSelected[groupWheelIdx] = arrayToObject([gr]);\n\n        if (!temp) {\n          inst._selected[groupWheelIdx] = arrayToObject([gr]);\n        }\n      }\n    }\n\n    inst._setVal(val, fill, change, temp, time);\n  };\n\n  inst.getVal = function (temp, group) {\n    var val;\n\n    if (tapSelect) {\n      val = objectToArray(temp ? inst._tempSelected[optionWheelIdx] : inst._selected[optionWheelIdx]);\n      val = multiple ? val : val.length ? val[0] : null;\n    } else {\n      val = temp ? inst._tempWheelArray : inst._hasValue ? inst._wheelArray : null;\n      val = val ? val[optionWheelIdx] : null;\n    }\n\n    return multiple ? val : val !== undefined ? hasGroups && group ? [options[val] ? options[val].group : null, val] : val : null;\n  };\n\n  inst.refresh = function (data, filter, callback) {\n    callback = callback || noop;\n\n    if (data) {\n      dataArray = data;\n\n      if (!hasRemoteData) {\n        // Save data, otherwise it will get lost on an option call,\n        // and filtering does not work as well after async data update\n        s.data = data;\n      }\n    } else if ($$1.isArray(s.data)) {\n      dataArray = s.data;\n    }\n\n    if (!data && hasRemoteData && filter === undefined) {\n      // reload the data from remote source\n      getJson(s.data.url, function (data) {\n        dataArray = getData(data);\n        prepareWheels();\n        callback();\n      }, s.data.dataType);\n    } else {\n      prepareWheels(filter);\n      callback();\n    }\n  }; // ---\n  // Inits\n  // ---\n\n\n  if (!settings.invalid) {\n    s.invalid = invalid;\n  }\n\n  if (hasGroupWheel) {\n    groupWheelIdx = 0;\n    optionWheelIdx = 1;\n  } else {\n    groupWheelIdx = -1;\n    optionWheelIdx = 0;\n  }\n\n  if (tapSelect) {\n    if (multiple && $elm.is('select')) {\n      $elm.prop('multiple', true);\n    }\n\n    if (values && isString(values)) {\n      values = values.split(',');\n    }\n\n    inst._selected[optionWheelIdx] = arrayToObject(values);\n  } // Remove dummy element if exists\n\n\n  if (inst._$input) {\n    inst._$input.remove();\n  } // Check if mobiscroll form already initialized this select\n\n\n  if ($elm.next().is('.mbsc-select-input')) {\n    $input = $elm.next().removeAttr('tabindex');\n  } else {\n    if (s.input) {\n      $input = $$1(s.input);\n    } else {\n      // Create dummy input\n      if (s.filter && s.display == 'inline') {\n        inst._$input = $$1('<div class=\"mbsc-sel-input-wrap\"><input type=\"text\" id=\"' + id + '\" class=\"mbsc-select-input mbsc-control ' + s.inputClass + '\" readonly /></div>');\n      } else {\n        $input = $$1('<input type=\"text\" id=\"' + id + '\" class=\"mbsc-select-input mbsc-control ' + s.inputClass + '\" readonly />');\n        inst._$input = $input;\n      }\n\n      if (s.showInput) {\n        inst._$input.insertAfter($elm);\n\n        if (!$input) {\n          $input = inst._$input.find('#' + id);\n        }\n      }\n    }\n  } // Show scroller on input tap\n\n\n  inst.attachShow($input.attr('placeholder', s.placeholder || ''));\n\n  if ($input[0] !== elm) {\n    $elm.addClass('mbsc-sel-hdn').attr('tabindex', -1);\n\n    if (!s.showInput) {\n      $elm.attr('data-enhance', false);\n    }\n  }\n\n  if (tapSelect && !(s.rows % 2)) {\n    s.rows = s.rows - 1;\n  }\n\n  if (s.filter) {\n    filterLength = s.filter.minLength || 0;\n  }\n\n  hasRemoteData = s.data && s.data.url;\n\n  if (hasRemoteData) {\n    inst.refresh();\n  } else {\n    if (hasData) {\n      dataArray = s.data;\n    }\n\n    prepareData();\n    getOption($elm.val());\n  } // ---\n\n\n  return {\n    layout: layout,\n    headerText: false,\n    anchor: $input,\n    compClass: 'mbsc-sc mbsc-sel' + (tapSelect ? ' mbsc-sel-multi' : ''),\n    setOnTap: hasGroupWheel ? [false, true] : true,\n    formatValue: formatValue,\n    tapSelect: tapSelect,\n    parseValue: function parseValue(val) {\n      getOption(val === undefined ? $elm.val() : val);\n      return hasGroupWheel ? [group, option] : [option];\n    },\n    validate: function validate(data) {\n      var index = data.index,\n          disabled = [];\n      disabled[optionWheelIdx] = s.invalid;\n\n      if (groupSep && !prevent && index === undefined) {\n        changeWheel();\n      }\n\n      prevent = false;\n      return {\n        disabled: disabled\n      };\n    },\n    onRead: onFill,\n    onFill: onFill,\n    onMarkupReady: function onMarkupReady(event, inst) {\n      if (s.filter) {\n        var $filterInput,\n            debounce,\n            filterInput,\n            $cont = $$1('.mbsc-fr-w', event.target),\n            $filterClear = $$1('<span class=\"mbsc-sel-filter-clear mbsc-ic mbsc-ic-' + s.filterClearIcon + '\"></span>');\n\n        if (s.display == 'inline') {\n          $filterInput = $input;\n          $input.parent().find('.mbsc-sel-filter-clear').remove();\n        } else {\n          $cont.find('.mbsc-fr-c').before('<div class=\"mbsc-input mbsc-sel-filter-cont mbsc-control-w mbsc-' + s.theme + (s.baseTheme ? ' mbsc-' + s.baseTheme : '') + '\"><span class=\"mbsc-input-wrap\"><input tabindex=\"0\" type=\"text\" class=\"mbsc-sel-filter-input mbsc-control\"/></span></div>');\n          $filterInput = $cont.find('.mbsc-sel-filter-input');\n        }\n\n        filterText = null;\n        filterInput = $filterInput[0];\n        $filterInput.prop('readonly', false).attr('placeholder', s.filterPlaceholderText).parent().append($filterClear);\n        $cont.find('.mbsc-fr-c').prepend($filterEmpty); // Will focus in the input on show\n\n        inst._activeElm = filterInput;\n        inst.tap($filterClear, function () {\n          filterText = null;\n          filterInput.value = '';\n          inst.refresh();\n          $filterClear.removeClass('mbsc-sel-filter-show-clear');\n          triggerOnFilter('');\n        });\n        $filterInput.on('keydown', function (ev) {\n          // Enter and Esc\n          if (ev.keyCode == 13 || ev.keyCode == 27) {\n            ev.stopPropagation();\n            filterInput.blur();\n          }\n        }).on('input', function () {\n          clearTimeout(debounce);\n\n          if (filterInput.value.length) {\n            $filterClear.addClass('mbsc-sel-filter-show-clear');\n          } else {\n            $filterClear.removeClass('mbsc-sel-filter-show-clear');\n          }\n\n          debounce = setTimeout(function () {\n            if (filterText === filterInput.value || triggerOnFilter(filterInput.value) === false) {\n              return;\n            }\n\n            filterText = filterInput.value;\n\n            if (filterText.length >= filterLength || !filterText.length) {\n              if (hasRemoteData && s.data.remoteFilter) {\n                getJson(s.data.url + encodeURIComponent(filterText), function (data) {\n                  inst.refresh(getData(data));\n                }, s.data.dataType);\n              } else {\n                inst.refresh(undefined, filterText);\n              }\n            }\n          }, 500);\n        });\n      }\n    },\n    onBeforeShow: function onBeforeShow() {\n      if (multiple && s.counter) {\n        s.headerText = function () {\n          var length = 0;\n          $$1.each(inst._tempSelected[optionWheelIdx], function () {\n            length++;\n          });\n          return (length > 1 ? s.selectedPluralText || s.selectedText : s.selectedText).replace(/{count}/, length);\n        };\n      }\n\n      getOption($elm.val());\n\n      if (tapSelect && hasGroupWheel) {\n        inst._selected[groupWheelIdx] = arrayToObject([group]);\n      }\n\n      if (s.filter) {\n        prepareData(undefined);\n      }\n\n      inst.settings.wheels = genWheels();\n      prevent = true;\n    },\n    onWheelGestureStart: function onWheelGestureStart(ev) {\n      if (ev.index == groupWheelIdx) {\n        s.readonly = [false, true];\n      }\n    },\n    onWheelAnimationEnd: function onWheelAnimationEnd(ev) {\n      var values = inst.getArrayVal(true);\n\n      if (ev.index == groupWheelIdx) {\n        s.readonly = origReadOnly;\n\n        if (!tapSelect) {\n          loadGroupOptions(values);\n        }\n      } else if (ev.index == optionWheelIdx && values[optionWheelIdx] != option) {\n        option = values[optionWheelIdx];\n\n        if (hasGroupWheel && options[option] && options[option].group != group) {\n          group = options[option].group;\n          values[groupWheelIdx] = group;\n          inst._tempSelected[groupWheelIdx] = arrayToObject([group]);\n          inst.setArrayVal(values, false, false, true, animTime);\n        }\n      }\n    },\n    onItemTap: function onItemTap(ev) {\n      var values;\n\n      if (ev.index == optionWheelIdx) {\n        selectedTexts[ev.value] = options[ev.value].text;\n\n        if (tapSelect && !multiple && ev.selected) {\n          inst._prevItemTap = true;\n          return false;\n        }\n      }\n\n      if (ev.index == groupWheelIdx && tapSelect) {\n        if (ev.selected) {\n          inst._prevItemTap = true;\n          return false;\n        }\n\n        values = inst.getArrayVal(true);\n        values[groupWheelIdx] = ev.value;\n        loadGroupOptions(values);\n      }\n    },\n    onClose: function onClose() {\n      if (hasRemoteData && s.data.remoteFilter && filterText) {\n        inst.refresh();\n      }\n    },\n    onDestroy: function onDestroy() {\n      // Remove dummy input\n      if (inst._$input) {\n        inst._$input.remove();\n      } // Revert select attributes and classes\n\n\n      $elm.removeClass('mbsc-sel-hdn').removeAttr('tabindex');\n    }\n  };\n};\n\nvar MbscSelect = function (_super) {\n  __extends(MbscSelect, _super);\n\n  function MbscSelect(initialElement, zone, control, inputService, optionService, view) {\n    var _this = _super.call(this, initialElement, zone, control, inputService, view) || this;\n\n    _this.optionService = optionService;\n    _this.placeholder = '';\n    _this.onFilter = new EventEmitter();\n    _this.options = {};\n    _this.onChangeEmitter = new EventEmitter();\n    return _this;\n  }\n\n  Object.defineProperty(MbscSelect.prototype, \"value\", {\n    set: function (v) {\n      if (!this.control) {\n        this.setNewValueProxy(v);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscSelect.prototype.refreshData = function (newData) {\n    this.instance.refresh(newData);\n  };\n\n  MbscSelect.prototype.initControl = function () {\n    var target = this.target;\n\n    if (target) {\n      if (typeof target !== 'string' && target._elementRef && target._elementRef.nativeElement) {\n        target = target._elementRef.nativeElement;\n        var inputUnder = $$1('input', target);\n\n        if (inputUnder.length) {\n          target = inputUnder;\n        }\n      }\n    } else {\n      var contentInput = $$1('input', this.initialElem.nativeElement).length;\n\n      if (contentInput) {\n        target = this.element;\n      }\n\n      if (!target && this.initialElem.nativeElement.nodeName === 'ION-INPUT') {\n        target = this.initialElem.nativeElement;\n      }\n    }\n\n    var options = extend$1({\n      preset: 'select',\n      input: target\n    }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);\n    this.instance = new Select$1(this.element, options);\n\n    if (this.initialValue !== undefined) {\n      this.instance.setVal(this.initialValue, true, false);\n    }\n  };\n\n  MbscSelect.prototype.setElement = function () {\n    this.element = this.initialElem.nativeElement;\n    var contentSelect = $$1('select', this.initialElem.nativeElement);\n\n    if (contentSelect.length) {\n      this.element = contentSelect[0];\n    } else {\n      _super.prototype.setElement.call(this);\n    }\n  };\n\n  MbscSelect.prototype.ngOnInit = function () {\n    this.isMulti = this.options && this.options.select && this.options.select !== 'single';\n    this.cloneDictionary.data = [];\n\n    _super.prototype.ngOnInit.call(this);\n  };\n\n  MbscSelect.prototype.setNewValue = function (v) {\n    if (this.instance) {\n      var changed = void 0;\n\n      if (this.isMulti) {\n        changed = !deepEqualsArray(v, this.instance.getVal());\n      } else {\n        var innerValue = this.instance.getVal();\n        changed = innerValue !== v;\n      }\n\n      if (changed) {\n        this.instance.setVal(v, true, false);\n\n        if (this._inputService && this._inputService.input) {\n          this._inputService.input.innerValue = this.instance._value;\n        }\n      }\n    }\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscSelect.prototype, \"counter\", void 0);\n\n  __decorate([Input$1('mbsc-data'), __metadata(\"design:type\", Object)], MbscSelect.prototype, \"data\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscSelect.prototype, \"dataText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscSelect.prototype, \"dataGroup\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscSelect.prototype, \"dataValue\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscSelect.prototype, \"filter\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscSelect.prototype, \"filterPlaceholderText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscSelect.prototype, \"filterEmptyText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscSelect.prototype, \"group\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscSelect.prototype, \"groupLabel\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscSelect.prototype, \"inputClass\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscSelect.prototype, \"invalid\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscSelect.prototype, \"label\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscSelect.prototype, \"placeholder\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscSelect.prototype, \"select\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscSelect.prototype, \"showInput\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscSelect.prototype, \"onFilter\", void 0);\n\n  __decorate([Input$1('mbsc-options'), __metadata(\"design:type\", Object)], MbscSelect.prototype, \"options\", void 0);\n\n  __decorate([Input$1('mbsc-target'), __metadata(\"design:type\", Object)], MbscSelect.prototype, \"target\", void 0);\n\n  __decorate([Input$1('mbsc-select'), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], MbscSelect.prototype, \"value\", null);\n\n  __decorate([Output('mbsc-selectChange'), __metadata(\"design:type\", EventEmitter)], MbscSelect.prototype, \"onChangeEmitter\", void 0);\n\n  MbscSelect = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscSelect);\n\n  MbscSelect.ɵfac = function MbscSelect_Factory(t) {\n    return new (t || MbscSelect)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscSelect.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscSelect,\n    selectors: [[\"\", \"mbsc-select\", \"\"]],\n    inputs: {\n      value: [\"mbsc-select\", \"value\"],\n      counter: \"counter\",\n      data: [\"mbsc-data\", \"data\"],\n      dataText: \"dataText\",\n      dataGroup: \"dataGroup\",\n      dataValue: \"dataValue\",\n      filter: \"filter\",\n      filterPlaceholderText: \"filterPlaceholderText\",\n      filterEmptyText: \"filterEmptyText\",\n      group: \"group\",\n      groupLabel: \"groupLabel\",\n      inputClass: \"inputClass\",\n      invalid: \"invalid\",\n      label: \"label\",\n      placeholder: \"placeholder\",\n      select: \"select\",\n      showInput: \"showInput\",\n      options: [\"mbsc-options\", \"options\"],\n      target: [\"mbsc-target\", \"target\"]\n    },\n    outputs: {\n      onFilter: \"onFilter\",\n      onChangeEmitter: \"mbsc-selectChange\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscSelect;\n}(MbscScrollerBase);\n\nvar MbscSelectComponent = function (_super) {\n  __extends(MbscSelectComponent, _super);\n\n  function MbscSelectComponent(initialElem, zone, control, inputService, optionService) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;\n\n    _this.errorMessage = '';\n    _this.dropdown = true;\n    _this.placeholder = '';\n    return _this;\n  }\n\n  MbscSelectComponent.prototype.ngAfterViewInit = function () {\n    _super.prototype.ngAfterViewInit.call(this);\n\n    this.setThemeClasses();\n  };\n\n  MbscSelectComponent.prototype.ngOnInit = function () {\n    _super.prototype.ngOnInit.call(this);\n\n    if (this.inline) {\n      var showInput = this.showInput || this.options && this.options.showInput;\n      var filter = this.filter || this.options && this.options.filter;\n\n      if (showInput === undefined) {\n        this.inlineOptionsObj.showInput = this.showInput = !!filter;\n      }\n    }\n  };\n\n  __decorate([Input$1('icon'), __metadata(\"design:type\", String)], MbscSelectComponent.prototype, \"inputIcon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscSelectComponent.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscSelectComponent.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscSelectComponent.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscSelectComponent.prototype, \"errorMessage\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscSelectComponent.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscSelectComponent.prototype, \"data\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscSelectComponent.prototype, \"dropdown\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscSelectComponent.prototype, \"placeholder\", void 0);\n\n  MbscSelectComponent = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])], MbscSelectComponent);\n\n  MbscSelectComponent.ɵfac = function MbscSelectComponent_Factory(t) {\n    return new (t || MbscSelectComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscSelectComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscSelectComponent,\n    selectors: [[\"mbsc-select\"]],\n    inputs: {\n      inputIcon: [\"icon\", \"inputIcon\"],\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      name: \"name\",\n      error: \"error\",\n      errorMessage: \"errorMessage\",\n      options: \"options\",\n      data: \"data\",\n      dropdown: \"dropdown\",\n      placeholder: \"placeholder\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\", 4, \"ngIf\"], [3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\"]],\n    template: function MbscSelectComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MbscSelectComponent_mbsc_input_0_Template, 2, 13, \"mbsc-input\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.inline || ctx.showInput);\n      }\n    },\n    directives: [ɵngcc2.NgIf, MbscInput],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscSelectComponent;\n}(MbscSelect);\n\nvar MbscSelectModule = function () {\n  function MbscSelectModule() {}\n\n  MbscSelectModule.ɵfac = function MbscSelectModule_Factory(t) {\n    return new (t || MbscSelectModule)();\n  };\n\n  MbscSelectModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscSelectModule\n  });\n  MbscSelectModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, MbscScrollerBaseModule, MbscInputModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscSelectModule, {\n      declarations: function () {\n        return [MbscSelect, MbscSelectComponent];\n      },\n      imports: function () {\n        return [CommonModule, MbscScrollerBaseModule, MbscInputModule];\n      },\n      exports: function () {\n        return [MbscSelect, MbscSelectComponent];\n      }\n    });\n  })();\n\n  return MbscSelectModule;\n}();\n\nvar Timer = Scroller;\nvar defaults$e = {\n  autostart: false,\n  step: 1,\n  // in seconds\n  useShortLabels: false,\n  // Localization\n  labels: ['Years', 'Months', 'Days', 'Hours', 'Minutes', 'Seconds', ''],\n  labelsShort: ['Yrs', 'Mths', 'Days', 'Hrs', 'Mins', 'Secs', ''],\n  startText: 'Start',\n  stopText: 'Stop',\n  resetText: 'Reset',\n  lapText: 'Lap',\n  hideText: 'Hide',\n  mode: 'countdown'\n};\n\npresets.timer = function (inst) {\n  /**\r\n   * Converts a date to UTC\r\n   * @param   d   (Date)  Date to convert\r\n   * @return      (Date)  Date converted to UTC\r\n   */\n  function toUtc(d) {\n    return new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds());\n  }\n  /**\r\n   * Calculates the parts of the time differnce\r\n   * @param   time    (Integer)   Time in milliseconds\r\n   * @return          (Object)    Time splitted to the required parts (years, months, days, hours, minutes, seconds)\r\n   */\n\n\n  function getParts(time) {\n    var ret = {};\n\n    if (dateMode && obj[max].index > obj.days.index) {\n      var i,\n          v,\n          o,\n          prev,\n          now = new Date(),\n          d2 = up ? now : origTime,\n          d1 = up ? origTime : now;\n      d1 = toUtc(d1);\n      d2 = toUtc(d2);\n      ret.years = d2.getFullYear() - d1.getFullYear();\n      ret.months = d2.getMonth() - d1.getMonth();\n      ret.days = d2.getDate() - d1.getDate();\n      ret.hours = d2.getHours() - d1.getHours();\n      ret.minutes = d2.getMinutes() - d1.getMinutes();\n      ret.seconds = d2.getSeconds() - d1.getSeconds();\n      ret.fract = (d2.getMilliseconds() - d1.getMilliseconds()) / 10;\n\n      for (i = unique.length; i > 0; i--) {\n        v = unique[i - 1];\n        o = obj[v];\n        prev = unique[$$1.inArray(v, unique) - 1];\n\n        if (obj[prev] && ret[v] < 0) {\n          ret[prev]--;\n          ret[v] += prev == 'months' ? 32 - new Date(d2.getFullYear(), d2.getMonth(), 32).getDate() : o.until + 1;\n        }\n      }\n\n      if (max == 'months') {\n        ret.months += ret.years * 12;\n        delete ret.years;\n      }\n    } else {\n      $$1(unique).each(function (i, v) {\n        if (obj[v].index <= obj[max].index) {\n          ret[v] = Math.floor(time / obj[v].limit);\n          time -= ret[v] * obj[v].limit;\n        }\n      });\n    }\n\n    return ret;\n  }\n  /**\r\n   * Generates a specific wheel\r\n   * @param   v   (String)  Unique identifier\r\n   */\n\n\n  function genWheel(v) {\n    var st = 1,\n        o = obj[v],\n        wh = o.wheel,\n        prefix = o.prefix,\n        from = 0,\n        until = o.until,\n        next = obj[unique[$$1.inArray(v, unique) - 1]];\n\n    if (o.index <= obj[max].index && (!next || next.limit > step)) {\n      if (!wheels[v]) {\n        w[0].push(wh);\n      }\n\n      wheels[v] = 1;\n      wh.data = [];\n      wh.label = o.label || '';\n      wh.cssClass = 'mbsc-timer-whl-' + v;\n\n      if (step >= o.limit) {\n        // Calculate steps on last wheel\n        st = Math.max(Math.round(step / o.limit), 1);\n        tstep = st * o.limit; // Timer is calculated with rounded step\n      }\n\n      if (v == max) {\n        wh.min = 0;\n\n        wh.data = function (i) {\n          return {\n            value: i,\n            display: genValue(i, prefix, o.label)\n          };\n        };\n\n        wh.getIndex = function (v) {\n          return v;\n        };\n      } else {\n        for (i = from; i <= until; i += st) {\n          wh.data.push({\n            value: i,\n            display: genValue(i, prefix, o.label)\n          });\n        }\n      }\n    }\n  }\n\n  function genValue(i, prefix, lbl) {\n    return (prefix || '') + (i < 10 ? '0' : '') + i + '<span class=\"mbsc-timer-lbl\">' + lbl + '</span>';\n  }\n  /**\r\n   * Converts the time into array containing the parts\r\n   * @param   time    (Integer)   Time in milliseconds\r\n   * @return          (Array)     Time splitted to the required parts (years, months, days, hours, minutes, seconds)\r\n   */\n\n\n  function getArray(time) {\n    var arr = [],\n        st,\n        p = getParts(time);\n    $$1(unique).each(function (i, v) {\n      if (wheels[v]) {\n        st = Math.max(Math.round(step / obj[v].limit), 1);\n        arr.push(Math.round(p[v] / st) * st);\n      }\n    });\n    return arr;\n  }\n  /**\r\n   * Calculates the time\r\n   * @param   reset   (Boolean)   Reset the timer or not\r\n   */\n\n\n  function calcTime(reset) {\n    if (dateMode) {\n      time = origTime - new Date();\n\n      if (time < 0) {\n        time *= -1;\n        up = true;\n      } else {\n        up = false;\n      }\n\n      timer = 0;\n      infinit = true;\n    } else if (origTime !== undefined) {\n      infinit = false;\n      time = origTime * 1000;\n      up = s.mode != 'countdown';\n\n      if (reset) {\n        timer = 0;\n      }\n    } else {\n      time = 0;\n      up = s.mode != 'countdown';\n      infinit = up;\n\n      if (reset) {\n        timer = 0;\n      }\n    }\n  }\n\n  function updateUI() {\n    if (running) {\n      $$1('.mbsc-fr-w', ctx).addClass('mbsc-timer-running mbsc-timer-locked');\n      $$1('.mbsc-timer-btn-toggle-c > div', ctx).text(s.stopText);\n\n      if (inst.buttons.start.icon) {\n        $$1('.mbsc-timer-btn-toggle-c > div', ctx).removeClass('mbsc-ic-' + inst.buttons.start.icon);\n      }\n\n      if (inst.buttons.stop.icon) {\n        $$1('.mbsc-timer-btn-toggle-c > div', ctx).addClass('mbsc-ic-' + inst.buttons.stop.icon);\n      }\n\n      if (s.mode == 'stopwatch') {\n        $$1('.mbsc-timer-btn-resetlap-c > div', ctx).text(s.lapText);\n\n        if (inst.buttons.reset.icon) {\n          $$1('.mbsc-timer-btn-resetlap-c > div', ctx).removeClass('mbsc-ic-' + inst.buttons.reset.icon);\n        }\n\n        if (inst.buttons.lap.icon) {\n          $$1('.mbsc-timer-btn-resetlap-c > div', ctx).addClass('mbsc-ic-' + inst.buttons.lap.icon);\n        }\n      }\n    } else {\n      $$1('.mbsc-fr-w', ctx).removeClass('mbsc-timer-running');\n      $$1('.mbsc-timer-btn-toggle-c > div', ctx).text(s.startText);\n\n      if (inst.buttons.start.icon) {\n        $$1('.mbsc-timer-btn-toggle-c > div', ctx).addClass('mbsc-ic-' + inst.buttons.start.icon);\n      }\n\n      if (inst.buttons.stop.icon) {\n        $$1('.mbsc-timer-btn-toggle-c > div', ctx).removeClass('mbsc-ic-' + inst.buttons.stop.icon);\n      }\n\n      if (s.mode == 'stopwatch') {\n        $$1('.mbsc-timer-btn-resetlap-c > div', ctx).text(s.resetText);\n\n        if (inst.buttons.reset.icon) {\n          $$1('.mbsc-timer-btn-resetlap-c > div', ctx).addClass('mbsc-ic-' + inst.buttons.reset.icon);\n        }\n\n        if (inst.buttons.lap.icon) {\n          $$1('.mbsc-timer-btn-resetlap-c > div', ctx).removeClass('mbsc-ic-' + inst.buttons.lap.icon);\n        }\n      }\n    }\n  }\n\n  var i,\n      interval,\n      tstep,\n      startTime,\n      started,\n      ellapsed,\n      time,\n      timer,\n      up,\n      ctx,\n      lap,\n      orig = extend$1({}, inst.settings),\n      s = extend$1(inst.settings, defaults$e, orig),\n      lbls = s.useShortLabels ? s.labelsShort : s.labels,\n      animTime = 1000,\n      buttons = ['resetlap', 'toggle'],\n      unique = ['years', 'months', 'days', 'hours', 'minutes', 'seconds', 'fract'],\n      obj = {\n    'years': {\n      index: 6,\n      until: 10,\n      limit: 1000 * 60 * 60 * 24 * 365,\n      label: lbls[0],\n      wheel: {}\n    },\n    'months': {\n      index: 5,\n      until: 11,\n      limit: 1000 * 60 * 60 * 24 * 30,\n      label: lbls[1],\n      wheel: {}\n    },\n    'days': {\n      index: 4,\n      until: 31,\n      limit: 1000 * 60 * 60 * 24,\n      label: lbls[2],\n      wheel: {}\n    },\n    'hours': {\n      index: 3,\n      until: 23,\n      limit: 1000 * 60 * 60,\n      label: lbls[3],\n      wheel: {}\n    },\n    'minutes': {\n      index: 2,\n      until: 59,\n      limit: 1000 * 60,\n      label: lbls[4],\n      wheel: {}\n    },\n    'seconds': {\n      index: 1,\n      until: 59,\n      limit: 1000,\n      label: lbls[5],\n      wheel: {}\n    },\n    'fract': {\n      index: 0,\n      until: 99,\n      limit: 10,\n      label: lbls[6],\n      prefix: '.',\n      wheel: {}\n    }\n  },\n      wheels = {},\n      laps = [],\n      lastLap = 0,\n      running = false,\n      stopped = true,\n      infinit = false,\n      step = Math.max(10, s.step * 1000),\n      max = s.maxWheel,\n      locked = s.mode == 'stopwatch' || dateMode,\n      origTime = s.targetTime,\n      dateMode = origTime && origTime.getTime !== undefined,\n      w = [[]]; // Extended methods\n  // ---\n  // Start the counter\n\n  inst.start = function () {\n    if (stopped) {\n      inst.reset();\n    }\n\n    if (!running) {\n      calcTime();\n\n      if (!infinit && timer >= time) {\n        return;\n      }\n\n      running = true;\n      stopped = false;\n      started = new Date();\n      startTime = timer;\n      s.readonly = true;\n      inst.setVal(getArray(up ? timer : time - timer), true, true, false, 100);\n      interval = setInterval(function () {\n        timer = new Date() - started + startTime;\n        inst.setVal(getArray(up ? timer : time - timer), true, true, false, Math.min(100, tstep - 10));\n\n        if (!infinit && timer + tstep >= time) {\n          clearInterval(interval);\n          setTimeout(function () {\n            // Do last tick with precision\n            inst.stop();\n            timer = time;\n            inst.setVal(getArray(up ? timer : 0), true, true, false, 100);\n            inst.trigger('onFinish', {\n              time: time\n            });\n            stopped = true;\n          }, time - timer);\n        }\n      }, tstep);\n      updateUI();\n      inst.trigger('onStart');\n    }\n  }; // Stop the counter\n\n\n  inst.stop = function () {\n    if (running) {\n      running = false;\n      clearInterval(interval); // Time correction\n\n      timer = new Date() - started + startTime;\n      updateUI();\n      inst.trigger('onStop', {\n        ellapsed: timer\n      });\n    }\n  };\n\n  inst.toggle = function () {\n    if (running) {\n      inst.stop();\n    } else {\n      inst.start();\n    }\n  }; // Reset the counter\n\n\n  inst.reset = function () {\n    inst.stop();\n    timer = 0;\n    laps = [];\n    lastLap = 0;\n    inst.setVal(getArray(up ? 0 : time), true, true, false, animTime);\n    inst.settings.readonly = locked;\n    stopped = true;\n\n    if (!locked) {\n      $$1('.mbsc-fr-w', ctx).removeClass('mbsc-timer-locked');\n    }\n\n    inst.trigger('onReset');\n  }; // Lap\n\n\n  inst.lap = function () {\n    if (running) {\n      ellapsed = new Date() - started + startTime;\n      lap = ellapsed - lastLap;\n      lastLap = ellapsed;\n      laps.push(ellapsed);\n      inst.trigger('onLap', {\n        ellapsed: ellapsed,\n        lap: lap,\n        laps: laps\n      });\n    }\n  };\n\n  inst.resetlap = function () {\n    if (running && s.mode == 'stopwatch') {\n      inst.lap();\n    } else {\n      inst.reset();\n    }\n  };\n\n  inst.getTime = function () {\n    return time;\n  };\n\n  inst.setTime = function (t) {\n    origTime = t / 1000;\n    time = t;\n  };\n\n  inst.getEllapsedTime = function () {\n    return stopped ? 0 : running ? new Date() - started + startTime : timer;\n  };\n\n  inst.setEllapsedTime = function (t, change) {\n    if (!stopped) {\n      startTime = timer = t;\n      started = new Date();\n      inst.setVal(getArray(up ? timer : time - timer), true, change, false, animTime);\n    }\n  }; // ---\n  // Constructor\n\n\n  calcTime(true);\n\n  if (!max && !time) {\n    max = 'minutes';\n  }\n\n  if (s.display !== 'inline') {\n    buttons.unshift('hide');\n  } // Determine maximum wheel\n\n\n  if (!max) {\n    $$1(unique).each(function (i, v) {\n      if (!max && time >= obj[v].limit) {\n        max = v;\n        return false;\n      }\n    });\n  } // Generate wheels\n\n\n  $$1(unique).each(function (i, v) {\n    genWheel(v);\n  });\n  tstep = Math.max(97, tstep); // timer step cannot be less then 100 ms\n\n  if (s.autostart) {\n    setTimeout(function () {\n      inst.start();\n    }, 0);\n  }\n\n  inst.handlers.toggle = inst.toggle;\n  inst.handlers.start = inst.start;\n  inst.handlers.stop = inst.stop;\n  inst.handlers.resetlap = inst.resetlap;\n  inst.handlers.reset = inst.reset;\n  inst.handlers.lap = inst.lap;\n  inst.buttons.toggle = {\n    parentClass: 'mbsc-timer-btn-toggle-c',\n    text: s.startText,\n    icon: s.startIcon,\n    handler: 'toggle'\n  };\n  inst.buttons.start = {\n    text: s.startText,\n    icon: s.startIcon,\n    handler: 'start'\n  };\n  inst.buttons.stop = {\n    text: s.stopText,\n    icon: s.stopIcon,\n    handler: 'stop'\n  };\n  inst.buttons.reset = {\n    text: s.resetText,\n    icon: s.resetIcon,\n    handler: 'reset'\n  };\n  inst.buttons.lap = {\n    text: s.lapText,\n    icon: s.lapIcon,\n    handler: 'lap'\n  };\n  inst.buttons.resetlap = {\n    parentClass: 'mbsc-timer-btn-resetlap-c',\n    text: s.resetText,\n    icon: s.resetIcon,\n    handler: 'resetlap'\n  };\n  inst.buttons.hide = {\n    parentClass: 'mbsc-timer-btn-hide-c',\n    text: s.hideText,\n    icon: s.closeIcon,\n    handler: 'cancel'\n  }; // Return settings\n\n  return {\n    minWidth: 100,\n    wheels: w,\n    headerText: false,\n    readonly: locked,\n    buttons: buttons,\n    compClass: 'mbsc-timer mbsc-sc',\n    parseValue: function parseValue() {\n      return getArray(up ? 0 : time);\n    },\n    formatValue: function formatValue(d) {\n      var ret = '',\n          j = 0;\n      $$1(unique).each(function (i, v) {\n        if (v == 'fract') {\n          return;\n        }\n\n        if (wheels[v]) {\n          ret += d[j] + (v == 'seconds' && wheels.fract ? '.' + d[j + 1] : '') + ' ' + lbls[i] + ' ';\n          j++;\n        }\n      });\n      return ret;\n    },\n    validate: function validate(data) {\n      var values = data.values,\n          i = data.index,\n          j = 0;\n\n      if (stopped && i !== undefined) {\n        origTime = 0;\n        $$1(unique).each(function (i, v) {\n          if (wheels[v]) {\n            origTime += obj[v].limit * values[j];\n            j++;\n          }\n        });\n        origTime /= 1000;\n        calcTime(true);\n      }\n    },\n    onBeforeShow: function onBeforeShow() {\n      s.showLabel = true;\n    },\n    onMarkupReady: function onMarkupReady(ev) {\n      ctx = $$1(ev.target);\n      updateUI();\n\n      if (locked) {\n        $$1('.mbsc-fr-w', ctx).addClass('mbsc-timer-locked');\n      }\n    },\n    onPosition: function onPosition(ev) {\n      // Force width to fit buttons\n      $$1('.mbsc-fr-w', ev.target).css('min-width', 0).css('min-width', $$1('.mbsc-fr-btn-cont', ev.target)[0].offsetWidth);\n    },\n    onDestroy: function onDestroy() {\n      clearInterval(interval);\n    }\n  };\n};\n\nvar MbscTimer = function (_super) {\n  __extends(MbscTimer, _super);\n\n  function MbscTimer(initialElement, zone, control, inputService, optionService, view) {\n    var _this = _super.call(this, initialElement, zone, control, inputService, view) || this;\n\n    _this.optionService = optionService;\n    _this.onLap = new EventEmitter();\n    _this.onFinish = new EventEmitter();\n    _this.onReset = new EventEmitter();\n    _this.onStart = new EventEmitter();\n    _this.onStop = new EventEmitter();\n    _this.options = {};\n    _this.onChangeEmitter = new EventEmitter();\n    return _this;\n  }\n\n  Object.defineProperty(MbscTimer.prototype, \"value\", {\n    set: function (v) {\n      this.setNewValueProxy(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscTimer.prototype.setNewValue = function (v) {\n    if (this.instance) {\n      if (!this.instance._timer || Math.abs(this.instance._timer - v) > 10) {\n        this.instance.setEllapsedTime(v, false);\n\n        if (this._inputService && this._inputService.input) {\n          this._inputService.input.innerValue = this.instance._value;\n        }\n      }\n    }\n  };\n\n  MbscTimer.prototype.handleChange = function () {\n    var that = this;\n    $$1(this.element).on('change', function () {\n      that.zone.run(function () {\n        that.instance._timer = that.instance.getEllapsedTime();\n\n        if (that.control) {\n          that.control.control.patchValue(that.instance._timer);\n        } else {\n          that.onChangeEmitter.emit(that.instance._timer);\n        }\n      });\n    });\n  };\n\n  MbscTimer.prototype.initControl = function () {\n    var options = extend$1({\n      preset: 'timer'\n    }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);\n    this.instance = new Timer(this.element, options);\n\n    if (this.initialValue !== undefined) {\n      this.instance.setVal(this.initialValue, true, false);\n    }\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscTimer.prototype, \"autostart\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscTimer.prototype, \"maxWheel\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscTimer.prototype, \"mode\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscTimer.prototype, \"step\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscTimer.prototype, \"targetTime\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscTimer.prototype, \"useShortLabels\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscTimer.prototype, \"hideText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscTimer.prototype, \"labels\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscTimer.prototype, \"labelsShort\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscTimer.prototype, \"lapText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscTimer.prototype, \"resetText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscTimer.prototype, \"startText\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscTimer.prototype, \"stopText\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscTimer.prototype, \"onLap\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscTimer.prototype, \"onFinish\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscTimer.prototype, \"onReset\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscTimer.prototype, \"onStart\", void 0);\n\n  __decorate([Output(), __metadata(\"design:type\", EventEmitter)], MbscTimer.prototype, \"onStop\", void 0);\n\n  __decorate([Input$1('mbsc-options'), __metadata(\"design:type\", Object)], MbscTimer.prototype, \"options\", void 0);\n\n  __decorate([Input$1('mbsc-timer'), __metadata(\"design:type\", Object), __metadata(\"design:paramtypes\", [Object])], MbscTimer.prototype, \"value\", null);\n\n  __decorate([Output('mbsc-timerChange'), __metadata(\"design:type\", EventEmitter)], MbscTimer.prototype, \"onChangeEmitter\", void 0);\n\n  MbscTimer = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscTimer);\n\n  MbscTimer.ɵfac = function MbscTimer_Factory(t) {\n    return new (t || MbscTimer)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscTimer.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscTimer,\n    selectors: [[\"\", \"mbsc-timer\", \"\"]],\n    inputs: {\n      value: [\"mbsc-timer\", \"value\"],\n      autostart: \"autostart\",\n      maxWheel: \"maxWheel\",\n      mode: \"mode\",\n      step: \"step\",\n      targetTime: \"targetTime\",\n      useShortLabels: \"useShortLabels\",\n      hideText: \"hideText\",\n      labels: \"labels\",\n      labelsShort: \"labelsShort\",\n      lapText: \"lapText\",\n      resetText: \"resetText\",\n      startText: \"startText\",\n      stopText: \"stopText\",\n      options: [\"mbsc-options\", \"options\"]\n    },\n    outputs: {\n      onLap: \"onLap\",\n      onFinish: \"onFinish\",\n      onReset: \"onReset\",\n      onStart: \"onStart\",\n      onStop: \"onStop\",\n      onChangeEmitter: \"mbsc-timerChange\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscTimer;\n}(MbscScrollerBase);\n\nvar MbscTimerComponent = function (_super) {\n  __extends(MbscTimerComponent, _super);\n\n  function MbscTimerComponent(initialElem, zone, control, inputService, optionService) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;\n\n    _this.errorMessage = '';\n    _this.placeholder = '';\n    return _this;\n  }\n\n  MbscTimerComponent.prototype.ngAfterViewInit = function () {\n    _super.prototype.ngAfterViewInit.call(this);\n\n    this.setThemeClasses();\n  };\n\n  __decorate([Input$1('icon'), __metadata(\"design:type\", String)], MbscTimerComponent.prototype, \"inputIcon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscTimerComponent.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscTimerComponent.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscTimerComponent.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscTimerComponent.prototype, \"errorMessage\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscTimerComponent.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscTimerComponent.prototype, \"placeholder\", void 0);\n\n  MbscTimerComponent = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])], MbscTimerComponent);\n\n  MbscTimerComponent.ɵfac = function MbscTimerComponent_Factory(t) {\n    return new (t || MbscTimerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscTimerComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscTimerComponent,\n    selectors: [[\"mbsc-timer\"]],\n    inputs: {\n      inputIcon: [\"icon\", \"inputIcon\"],\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      name: \"name\",\n      error: \"error\",\n      errorMessage: \"errorMessage\",\n      options: \"options\",\n      placeholder: \"placeholder\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\", 4, \"ngIf\"], [3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\"]],\n    template: function MbscTimerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MbscTimerComponent_mbsc_input_0_Template, 2, 13, \"mbsc-input\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.inline || ctx.showInput);\n      }\n    },\n    directives: [ɵngcc2.NgIf, MbscInput],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscTimerComponent;\n}(MbscTimer);\n\nvar MbscTimerModule = function () {\n  function MbscTimerModule() {}\n\n  MbscTimerModule.ɵfac = function MbscTimerModule_Factory(t) {\n    return new (t || MbscTimerModule)();\n  };\n\n  MbscTimerModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscTimerModule\n  });\n  MbscTimerModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, MbscScrollerBaseModule, MbscInputModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscTimerModule, {\n      declarations: function () {\n        return [MbscTimer, MbscTimerComponent];\n      },\n      imports: function () {\n        return [CommonModule, MbscScrollerBaseModule, MbscInputModule];\n      },\n      exports: function () {\n        return [MbscTimer, MbscTimerComponent];\n      }\n    });\n  })();\n\n  return MbscTimerModule;\n}();\n\nvar Timespan = Scroller;\nvar defaults$f = {\n  wheelOrder: 'hhiiss',\n  useShortLabels: false,\n  min: 0,\n  max: Infinity,\n  // Localization\n  labels: ['Years', 'Months', 'Days', 'Hours', 'Minutes', 'Seconds'],\n  //, ''],\n  labelsShort: ['Yrs', 'Mths', 'Days', 'Hrs', 'Mins', 'Secs'] //, '']\n\n};\n\npresets.timespan = function (inst) {\n  /**\r\n   * Calculates the parts of the time differnce.\r\n   * @param {Integer} time - Time in milliseconds.\r\n   * @return {Object} - Time splitted to the required parts (years, months, days, hours, minutes, seconds).\r\n   */\n  function getParts(time) {\n    var ret = {};\n    $$1(unique).each(function (i, v) {\n      ret[v] = wheels[v] ? Math.floor(time / obj[v].limit) : 0;\n      time -= ret[v] * obj[v].limit;\n    });\n    return ret;\n  }\n  /**\r\n   * Generates a specific wheel.\r\n   * @param {String} v - Unique identifier.\r\n   */\n\n\n  function genWheel(v) {\n    var leading = false,\n        st = steps[wheels[v] - 1] || 1,\n        o = obj[v],\n        lbl = o.label,\n        w = o.wheel;\n    w.data = [];\n    w.label = o.label;\n\n    if (ord.match(new RegExp(o.re + o.re, 'i'))) {\n      leading = true;\n    }\n\n    if (v == max) {\n      w.min = minParts[v];\n      w.max = maxParts[v];\n\n      w.data = function (i) {\n        return {\n          value: i * st,\n          display: genValue(i * st, leading, lbl)\n        };\n      };\n\n      w.getIndex = function (v) {\n        return Math.round(v / st);\n      };\n    } else {\n      for (i = 0; i <= o.until; i += st) {\n        w.data.push({\n          value: i,\n          display: genValue(i, leading, lbl)\n        });\n      }\n    }\n  }\n\n  function genValue(i, leading, lbl) {\n    return (i < 10 && leading ? '0' : '') + i + '<span class=\"mbsc-ts-lbl\">' + lbl + '</span>';\n  }\n\n  function calcTime(arr) {\n    var j = 0,\n        time = 0;\n    $$1.each(o, function (i, v) {\n      if (!isNaN(+arr[j])) {\n        time += obj[v.v].limit * arr[i];\n      }\n    });\n    return time;\n  }\n\n  function step(v, st) {\n    return Math.floor(v / st) * st;\n  }\n\n  var i,\n      j,\n      p,\n      minParts,\n      maxParts,\n      orig = extend$1({}, inst.settings),\n      s = extend$1(inst.settings, defaults$f, orig),\n      ord = s.wheelOrder,\n      lbls = s.useShortLabels ? s.labelsShort : s.labels,\n      unique = ['years', 'months', 'days', 'hours', 'minutes', 'seconds'],\n      //, 'fract'],\n  obj = {\n    'years': {\n      ord: 0,\n      index: 6,\n      until: 10,\n      limit: 1000 * 60 * 60 * 24 * 365,\n      label: lbls[0],\n      re: 'y',\n      wheel: {}\n    },\n    'months': {\n      ord: 1,\n      index: 5,\n      until: 11,\n      limit: 1000 * 60 * 60 * 24 * 30,\n      label: lbls[1],\n      re: 'm',\n      wheel: {}\n    },\n    'days': {\n      ord: 2,\n      index: 4,\n      until: 31,\n      limit: 1000 * 60 * 60 * 24,\n      label: lbls[2],\n      re: 'd',\n      wheel: {}\n    },\n    'hours': {\n      ord: 3,\n      index: 3,\n      until: 23,\n      limit: 1000 * 60 * 60,\n      label: lbls[3],\n      re: 'h',\n      wheel: {}\n    },\n    'minutes': {\n      ord: 4,\n      index: 2,\n      until: 59,\n      limit: 1000 * 60,\n      label: lbls[4],\n      re: 'i',\n      wheel: {}\n    },\n    'seconds': {\n      ord: 5,\n      index: 1,\n      until: 59,\n      limit: 1000,\n      label: lbls[5],\n      re: 's',\n      wheel: {}\n    } //,\n    //'fract': { index: 0, until: 99, limit: 10, label: lbls[6], prefix: '.', short: 'u' }\n\n  },\n      o = [],\n      steps = s.steps || [],\n      wheels = {},\n      max = 'seconds',\n      defaultVal = s.defaultValue || Math.max(s.min, Math.min(0, s.max)),\n      w = [[]]; // Constructor\n  // Generate wheels\n\n  $$1(unique).each(function (i, v) {\n    j = ord.search(new RegExp(obj[v].re, 'i'));\n\n    if (j > -1) {\n      o.push({\n        o: j,\n        v: v\n      });\n\n      if (obj[v].index > obj[max].index) {\n        max = v;\n      }\n    }\n  });\n  o.sort(function (a, b) {\n    return a.o > b.o ? 1 : -1;\n  });\n  $$1.each(o, function (i, v) {\n    wheels[v.v] = i + 1;\n    w[0].push(obj[v.v].wheel);\n  });\n  minParts = getParts(s.min);\n  maxParts = getParts(s.max);\n  $$1.each(o, function (i, v) {\n    genWheel(v.v);\n  }); // Extended methods\n  // ---\n\n  inst.getVal = function (temp, formatted) {\n    return formatted ? inst._getVal(temp) : inst._hasValue || temp ? calcTime(inst.getArrayVal(temp)) : null;\n  }; // ---\n  // Return settings\n\n\n  return {\n    minWidth: 100,\n    showLabel: true,\n    wheels: w,\n    compClass: 'mbsc-ts mbsc-sc',\n    parseValue: function parseValue(val) {\n      var ret = [],\n          m;\n\n      if (isNumeric(val) || !val) {\n        p = getParts(val || defaultVal);\n        $$1.each(o, function (i, v) {\n          ret.push(p[v.v]);\n        });\n      } else {\n        $$1.each(o, function (i, v) {\n          m = new RegExp('(\\\\d+)\\\\s?(' + s.labels[obj[v.v].ord] + '|' + s.labelsShort[obj[v.v].ord] + ')', 'gi').exec(val);\n          ret.push(m ? m[1] : 0);\n        });\n      }\n\n      $$1(ret).each(function (i, v) {\n        // Steps\n        ret[i] = step(v, steps[i] || 1);\n      });\n      return ret;\n    },\n    formatValue: function formatValue(d) {\n      var ret = '';\n      $$1.each(o, function (i, v) {\n        ret += +d[i] ? d[i] + ' ' + obj[v.v].label + ' ' : '';\n      });\n      return ret ? ret.replace(/\\s+$/g, '') : 0;\n    },\n    validate: function validate(data) {\n      var p,\n          i,\n          index,\n          dis,\n          values = data.values,\n          dir = data.direction,\n          disabled = [],\n          maxprop = true,\n          minprop = true;\n      $$1(unique).each(function (x, v) {\n        if (wheels[v] !== undefined) {\n          index = wheels[v] - 1;\n          disabled[index] = [];\n          dis = {};\n\n          if (v != max) {\n            if (maxprop) {\n              for (i = maxParts[v] + 1; i <= obj[v].until; i++) {\n                dis[i] = true;\n              }\n            }\n\n            if (minprop) {\n              for (i = 0; i < minParts[v]; i++) {\n                dis[i] = true;\n              }\n            }\n          }\n\n          values[index] = inst.getValidValue(index, values[index], dir, dis);\n          p = getParts(calcTime(values));\n          maxprop = maxprop && p[v] == maxParts[v];\n          minprop = minprop && p[v] == minParts[v];\n          $$1.each(dis, function (i) {\n            disabled[index].push(i);\n          });\n        }\n      });\n      return {\n        disabled: disabled\n      };\n    }\n  };\n};\n\nvar MbscTimespan = function (_super) {\n  __extends(MbscTimespan, _super);\n\n  function MbscTimespan(initialElement, zone, control, inputService, optionService, view) {\n    var _this = _super.call(this, initialElement, zone, control, inputService, view) || this;\n\n    _this.optionService = optionService;\n    _this.options = {};\n    _this.onChangeEmitter = new EventEmitter();\n    return _this;\n  }\n\n  Object.defineProperty(MbscTimespan.prototype, \"value\", {\n    set: function (v) {\n      this.setNewValueProxy(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscTimespan.prototype.setNewValue = function (v) {\n    if (this.instance) {\n      var innerValue = this.instance.getVal();\n\n      if (innerValue !== v) {\n        this.instance.setVal(v, true, false);\n\n        if (this._inputService && this._inputService.input) {\n          this._inputService.input.innerValue = this.instance._value;\n        }\n      }\n    }\n  };\n\n  MbscTimespan.prototype.initControl = function () {\n    var options = extend$1({\n      preset: 'timespan'\n    }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);\n    this.instance = new Timespan(this.element, options);\n\n    if (this.initialValue !== undefined) {\n      this.instance.setVal(this.initialValue, true, false);\n    }\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscTimespan.prototype, \"defaultValue\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscTimespan.prototype, \"max\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Number)], MbscTimespan.prototype, \"min\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscTimespan.prototype, \"steps\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscTimespan.prototype, \"useShortLabels\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscTimespan.prototype, \"wheelOrder\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscTimespan.prototype, \"labels\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscTimespan.prototype, \"labelsShort\", void 0);\n\n  __decorate([Input$1('mbsc-options'), __metadata(\"design:type\", Object)], MbscTimespan.prototype, \"options\", void 0);\n\n  __decorate([Input$1('mbsc-timespan'), __metadata(\"design:type\", Number), __metadata(\"design:paramtypes\", [Number])], MbscTimespan.prototype, \"value\", null);\n\n  __decorate([Output('mbsc-timespanChange'), __metadata(\"design:type\", EventEmitter)], MbscTimespan.prototype, \"onChangeEmitter\", void 0);\n\n  MbscTimespan = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscTimespan);\n\n  MbscTimespan.ɵfac = function MbscTimespan_Factory(t) {\n    return new (t || MbscTimespan)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscTimespan.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscTimespan,\n    selectors: [[\"\", \"mbsc-timespan\", \"\"]],\n    inputs: {\n      value: [\"mbsc-timespan\", \"value\"],\n      defaultValue: \"defaultValue\",\n      max: \"max\",\n      min: \"min\",\n      steps: \"steps\",\n      useShortLabels: \"useShortLabels\",\n      wheelOrder: \"wheelOrder\",\n      labels: \"labels\",\n      labelsShort: \"labelsShort\",\n      options: [\"mbsc-options\", \"options\"]\n    },\n    outputs: {\n      onChangeEmitter: \"mbsc-timespanChange\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscTimespan;\n}(MbscScrollerBase);\n\nvar MbscTimespanComponent = function (_super) {\n  __extends(MbscTimespanComponent, _super);\n\n  function MbscTimespanComponent(initialElem, zone, control, inputService, optionService) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;\n\n    _this.errorMessage = '';\n    _this.placeholder = '';\n    return _this;\n  }\n\n  MbscTimespanComponent.prototype.ngAfterViewInit = function () {\n    _super.prototype.ngAfterViewInit.call(this);\n\n    this.setThemeClasses();\n  };\n\n  __decorate([Input$1('icon'), __metadata(\"design:type\", String)], MbscTimespanComponent.prototype, \"inputIcon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscTimespanComponent.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscTimespanComponent.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscTimespanComponent.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscTimespanComponent.prototype, \"errorMessage\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscTimespanComponent.prototype, \"options\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscTimespanComponent.prototype, \"placeholder\", void 0);\n\n  MbscTimespanComponent = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])], MbscTimespanComponent);\n\n  MbscTimespanComponent.ɵfac = function MbscTimespanComponent_Factory(t) {\n    return new (t || MbscTimespanComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscTimespanComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscTimespanComponent,\n    selectors: [[\"mbsc-timespan\"]],\n    inputs: {\n      inputIcon: [\"icon\", \"inputIcon\"],\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      name: \"name\",\n      error: \"error\",\n      errorMessage: \"errorMessage\",\n      options: \"options\",\n      placeholder: \"placeholder\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\", 4, \"ngIf\"], [3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\"]],\n    template: function MbscTimespanComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MbscTimespanComponent_mbsc_input_0_Template, 2, 13, \"mbsc-input\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.inline || ctx.showInput);\n      }\n    },\n    directives: [ɵngcc2.NgIf, MbscInput],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscTimespanComponent;\n}(MbscTimespan);\n\nvar MbscTimespanModule = function () {\n  function MbscTimespanModule() {}\n\n  MbscTimespanModule.ɵfac = function MbscTimespanModule_Factory(t) {\n    return new (t || MbscTimespanModule)();\n  };\n\n  MbscTimespanModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscTimespanModule\n  });\n  MbscTimespanModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, MbscScrollerBaseModule, MbscInputModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscTimespanModule, {\n      declarations: function () {\n        return [MbscTimespan, MbscTimespanComponent];\n      },\n      imports: function () {\n        return [CommonModule, MbscScrollerBaseModule, MbscInputModule];\n      },\n      exports: function () {\n        return [MbscTimespan, MbscTimespanComponent];\n      }\n    });\n  })();\n\n  return MbscTimespanModule;\n}();\n\nvar Treelist = Scroller;\npresets.treelist = List;\n\nvar MbscTreelist = function (_super) {\n  __extends(MbscTreelist, _super);\n\n  function MbscTreelist(initialElement, zone, control, inputService, optionService, view) {\n    var _this = _super.call(this, initialElement, zone, control, inputService, view) || this;\n\n    _this.optionService = optionService;\n    _this.placeholder = '';\n    _this.options = {};\n    _this.onChangeEmitter = new EventEmitter();\n    return _this;\n  }\n\n  Object.defineProperty(MbscTreelist.prototype, \"value\", {\n    set: function (v) {\n      this.setNewValueProxy(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  MbscTreelist.prototype.initControl = function () {\n    var _this = this;\n\n    var target = this.target;\n\n    if (target) {\n      if (typeof target !== 'string' && target._elementRef && target._elementRef.nativeElement) {\n        target = target._elementRef.nativeElement;\n      } else if (target.getInputElement) {\n        target.getInputElement().then(function (inp) {\n          _this.updateOptions({\n            input: inp\n          }, true, false, false);\n        });\n      }\n    }\n\n    var options = extend$1({\n      preset: 'treelist',\n      input: target\n    }, this.optionService ? this.optionService.options : {}, this.options, this.inlineOptionsObj, this.optionExtensions);\n    this.instance = new Treelist(this.element, options);\n\n    if (this.initialValue !== undefined) {\n      this.instance.setVal(this.initialValue, true, false);\n    }\n  };\n\n  MbscTreelist.prototype.setNewValue = function (v) {\n    if (this.instance && this.instance.getVal() !== v) {\n      this.instance.setVal(v, true, false);\n\n      if (this._inputService && this._inputService.input) {\n        this._inputService.input.innerValue = this.instance._value;\n      }\n    }\n  };\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscTreelist.prototype, \"defaultValue\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscTreelist.prototype, \"inputClass\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscTreelist.prototype, \"invalid\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Array)], MbscTreelist.prototype, \"labels\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscTreelist.prototype, \"placeholder\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscTreelist.prototype, \"showInput\", void 0);\n\n  __decorate([Input$1('mbsc-data'), __metadata(\"design:type\", Array)], MbscTreelist.prototype, \"wheelArray\", void 0);\n\n  __decorate([Input$1('mbsc-options'), __metadata(\"design:type\", Object)], MbscTreelist.prototype, \"options\", void 0);\n\n  __decorate([Input$1('mbsc-target'), __metadata(\"design:type\", Object)], MbscTreelist.prototype, \"target\", void 0);\n\n  __decorate([Input$1('mbsc-treelist'), __metadata(\"design:type\", String), __metadata(\"design:paramtypes\", [String])], MbscTreelist.prototype, \"value\", null);\n\n  __decorate([Output('mbsc-treelistChange'), __metadata(\"design:type\", EventEmitter)], MbscTreelist.prototype, \"onChangeEmitter\", void 0);\n\n  MbscTreelist = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService, ViewContainerRef])], MbscTreelist);\n\n  MbscTreelist.ɵfac = function MbscTreelist_Factory(t) {\n    return new (t || MbscTreelist)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef));\n  };\n\n  MbscTreelist.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MbscTreelist,\n    selectors: [[\"\", \"mbsc-treelist\", \"\"]],\n    inputs: {\n      value: [\"mbsc-treelist\", \"value\"],\n      defaultValue: \"defaultValue\",\n      inputClass: \"inputClass\",\n      invalid: \"invalid\",\n      labels: \"labels\",\n      placeholder: \"placeholder\",\n      showInput: \"showInput\",\n      wheelArray: [\"mbsc-data\", \"wheelArray\"],\n      options: [\"mbsc-options\", \"options\"],\n      target: [\"mbsc-target\", \"target\"]\n    },\n    outputs: {\n      onChangeEmitter: \"mbsc-treelistChange\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscTreelist;\n}(MbscScrollerBase);\n\nvar MbscTreelistComponent = function (_super) {\n  __extends(MbscTreelistComponent, _super);\n\n  function MbscTreelistComponent(initialElem, zone, control, inputService, optionService) {\n    var _this = _super.call(this, initialElem, zone, control, inputService, optionService, null) || this;\n\n    _this.errorMessage = '';\n    _this.placeholder = '';\n    _this.showInput = false;\n    _this.inlineOptionsObj = {\n      showInput: false\n    };\n    return _this;\n  }\n\n  MbscTreelistComponent.prototype.ngAfterViewInit = function () {\n    _super.prototype.ngAfterViewInit.call(this);\n\n    this.setThemeClasses();\n  };\n\n  __decorate([Input$1('icon'), __metadata(\"design:type\", String)], MbscTreelistComponent.prototype, \"inputIcon\", void 0);\n\n  __decorate([Input$1('icon-align'), __metadata(\"design:type\", String)], MbscTreelistComponent.prototype, \"iconAlign\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscTreelistComponent.prototype, \"name\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Boolean)], MbscTreelistComponent.prototype, \"error\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscTreelistComponent.prototype, \"errorMessage\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", Object)], MbscTreelistComponent.prototype, \"options\", void 0);\n\n  __decorate([Input$1('data'), __metadata(\"design:type\", Array)], MbscTreelistComponent.prototype, \"wheelArray\", void 0);\n\n  __decorate([Input$1(), __metadata(\"design:type\", String)], MbscTreelistComponent.prototype, \"placeholder\", void 0);\n\n  MbscTreelistComponent = __decorate([__param(2, Optional()), __param(3, Optional()), __param(4, Optional()), __metadata(\"design:paramtypes\", [ElementRef, NgZone, NgControl, MbscInputService, MbscOptionsService])], MbscTreelistComponent);\n\n  MbscTreelistComponent.ɵfac = function MbscTreelistComponent_Factory(t) {\n    return new (t || MbscTreelistComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl, 8), ɵngcc0.ɵɵdirectiveInject(MbscInputService, 8), ɵngcc0.ɵɵdirectiveInject(MbscOptionsService, 8));\n  };\n\n  MbscTreelistComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MbscTreelistComponent,\n    selectors: [[\"mbsc-treelist\"]],\n    inputs: {\n      inputIcon: [\"icon\", \"inputIcon\"],\n      iconAlign: [\"icon-align\", \"iconAlign\"],\n      name: \"name\",\n      error: \"error\",\n      errorMessage: \"errorMessage\",\n      options: \"options\",\n      wheelArray: [\"data\", \"wheelArray\"],\n      placeholder: \"placeholder\"\n    },\n    exportAs: [\"mobiscroll\"],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\", 4, \"ngIf\"], [3, \"controlNg\", \"name\", \"theme\", \"themeVariant\", \"label-style\", \"input-style\", \"disabled\", \"dropdown\", \"placeholder\", \"error\", \"errorMessage\", \"icon\", \"icon-align\"]],\n    template: function MbscTreelistComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵtemplate(0, MbscTreelistComponent_mbsc_input_0_Template, 2, 13, \"mbsc-input\", 0);\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.inline || ctx.showInput);\n      }\n    },\n    directives: [ɵngcc2.NgIf, MbscInput],\n    encapsulation: 2\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  return MbscTreelistComponent;\n}(MbscTreelist);\n\nvar MbscTreelistModule = function () {\n  function MbscTreelistModule() {}\n\n  MbscTreelistModule.ɵfac = function MbscTreelistModule_Factory(t) {\n    return new (t || MbscTreelistModule)();\n  };\n\n  MbscTreelistModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscTreelistModule\n  });\n  MbscTreelistModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[CommonModule, MbscScrollerBaseModule, MbscInputModule]]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscTreelistModule, {\n      declarations: function () {\n        return [MbscTreelist, MbscTreelistComponent];\n      },\n      imports: function () {\n        return [CommonModule, MbscScrollerBaseModule, MbscInputModule];\n      },\n      exports: function () {\n        return [MbscTreelist, MbscTreelistComponent];\n      }\n    });\n  })();\n\n  return MbscTreelistModule;\n}();\n\nvar directives = [MbscInput, MbscCalendar, MbscCalendarComponent, MbscCard, MbscCardComponent, MbscCardContent, MbscCardFooter, MbscCardHeader, MbscCardSubtitle, MbscCardTitle, MbscColor, MbscColorComponent, MbscDate, MbscTime, MbscDatetime, MbscDateComponent, MbscTimeComponent, MbscDatetimeComponent, MbscEventcalendar, MbscEventcalendarComponent, MbscForm, MbscRating, MbscDropdown, MbscTextarea, MbscButton, MbscCheckbox, MbscSwitch, MbscStepper, MbscProgress, MbscSlider, MbscRadio, MbscRadioGroup, MbscSegmentedGroup, MbscSegmented, MbscFormGroup, MbscFormGroupTitle, MbscFormGroupContent, MbscAccordion, MbscImage, MbscImageComponent, MbscImageItem, MbscListview, MbscListviewSublist, MbscListviewItem, MbscListviewHeader, MbscMeasurement, MbscDistance, MbscForce, MbscMass, MbscSpeed, MbscTemperature, MbscMeasurementComponent, MbscTemperatureComponent, MbscForceComponent, MbscSpeedComponent, MbscMassComponent, MbscDistanceComponent, MbscNav, MbscBottomNav, MbscHamburgerNav, MbscTabNav, MbscNavItem, MbscNumber, MbscNumberComponent, MbscNumpad, MbscNumpadDecimal, MbscNumpadDate, MbscNumpadTime, MbscNumpadTimespan, MbscNumpadComponent, MbscNumpadDateComponent, MbscNumpadDecimalComponent, MbscNumpadTimeComponent, MbscNumpadTimespanComponent, MbscOptionlist, MbscOptionItem, MbscPage, MbscNote, MbscAvatar, MbscPopup, MbscWidget, MbscRange, MbscRangeComponent, MbscRangeStartComponent, MbscRangeEndComponent, MbscScroller, MbscScrollerComponent, MbscScrollView, MbscScrollViewItem, MbscScrollViewComponent, MbscScrollViewItemComponent, MbscSelect, MbscSelectComponent, MbscTimer, MbscTimerComponent, MbscTimespan, MbscTimespanComponent, MbscTreelist, MbscTreelistComponent];\nvar modules = [MbscInputModule, MbscCalendarModule, MbscCardModule, MbscColorModule, MbscDatetimeModule, MbscEventcalendarModule, MbscFormsModule, MbscImageModule, MbscListviewModule, MbscMeasurementModule, MbscNavigationModule, MbscNumberModule, MbscNumpadModule, MbscOptionlistModule, MbscPageModule, MbscPopupModule, MbscRangeModule, MbscScrollerModule, MbscScrollViewModule, MbscSelectModule, MbscTimerModule, MbscTimespanModule, MbscTreelistModule];\n\nvar MbscModule = function () {\n  function MbscModule() {}\n\n  MbscModule_1 = MbscModule;\n\n  MbscModule.forRoot = function (config) {\n    return {\n      ngModule: MbscModule_1,\n      providers: [{\n        provide: MbscRouterToken,\n        useExisting: config.angularRouter\n      }]\n    };\n  };\n\n  var MbscModule_1;\n\n  MbscModule.ɵfac = function MbscModule_Factory(t) {\n    return new (t || MbscModule)();\n  };\n\n  MbscModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MbscModule\n  });\n  MbscModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[FormsModule, CommonModule, modules], MbscInputModule, MbscCalendarModule, MbscCardModule, MbscColorModule, MbscDatetimeModule, MbscEventcalendarModule, MbscFormsModule, MbscImageModule, MbscListviewModule, MbscMeasurementModule, MbscNavigationModule, MbscNumberModule, MbscNumpadModule, MbscOptionlistModule, MbscPageModule, MbscPopupModule, MbscRangeModule, MbscScrollerModule, MbscScrollViewModule, MbscSelectModule, MbscTimerModule, MbscTimespanModule, MbscTreelistModule]\n  });\n\n  (function () {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n  })();\n\n  (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MbscModule, {\n      imports: function () {\n        return [FormsModule, CommonModule, MbscInputModule, MbscCalendarModule, MbscCardModule, MbscColorModule, MbscDatetimeModule, MbscEventcalendarModule, MbscFormsModule, MbscImageModule, MbscListviewModule, MbscMeasurementModule, MbscNavigationModule, MbscNumberModule, MbscNumpadModule, MbscOptionlistModule, MbscPageModule, MbscPopupModule, MbscRangeModule, MbscScrollerModule, MbscScrollViewModule, MbscSelectModule, MbscTimerModule, MbscTimespanModule, MbscTreelistModule];\n      },\n      exports: function () {\n        return [MbscInput, MbscCalendar, MbscCalendarComponent, MbscCard, MbscCardComponent, MbscCardContent, MbscCardFooter, MbscCardHeader, MbscCardSubtitle, MbscCardTitle, MbscColor, MbscColorComponent, MbscDate, MbscTime, MbscDatetime, MbscDateComponent, MbscTimeComponent, MbscDatetimeComponent, MbscEventcalendar, MbscEventcalendarComponent, MbscForm, MbscRating, MbscDropdown, MbscTextarea, MbscButton, MbscCheckbox, MbscSwitch, MbscStepper, MbscProgress, MbscSlider, MbscRadio, MbscRadioGroup, MbscSegmentedGroup, MbscSegmented, MbscFormGroup, MbscFormGroupTitle, MbscFormGroupContent, MbscAccordion, MbscImage, MbscImageComponent, MbscImageItem, MbscListview, MbscListviewSublist, MbscListviewItem, MbscListviewHeader, MbscMeasurement, MbscDistance, MbscForce, MbscMass, MbscSpeed, MbscTemperature, MbscMeasurementComponent, MbscTemperatureComponent, MbscForceComponent, MbscSpeedComponent, MbscMassComponent, MbscDistanceComponent, MbscNav, MbscBottomNav, MbscHamburgerNav, MbscTabNav, MbscNavItem, MbscNumber, MbscNumberComponent, MbscNumpad, MbscNumpadDecimal, MbscNumpadDate, MbscNumpadTime, MbscNumpadTimespan, MbscNumpadComponent, MbscNumpadDateComponent, MbscNumpadDecimalComponent, MbscNumpadTimeComponent, MbscNumpadTimespanComponent, MbscOptionlist, MbscOptionItem, MbscPage, MbscNote, MbscAvatar, MbscPopup, MbscWidget, MbscRange, MbscRangeComponent, MbscRangeStartComponent, MbscRangeEndComponent, MbscScroller, MbscScrollerComponent, MbscScrollView, MbscScrollViewItem, MbscScrollViewComponent, MbscScrollViewItemComponent, MbscSelect, MbscSelectComponent, MbscTimer, MbscTimerComponent, MbscTimespan, MbscTimespanComponent, MbscTreelist, MbscTreelistComponent, MbscInputModule, MbscCalendarModule, MbscCardModule, MbscColorModule, MbscDatetimeModule, MbscEventcalendarModule, MbscFormsModule, MbscImageModule, MbscListviewModule, MbscMeasurementModule, MbscNavigationModule, MbscNumberModule, MbscNumpadModule, MbscOptionlistModule, MbscPageModule, MbscPopupModule, MbscRangeModule, MbscScrollerModule, MbscScrollViewModule, MbscSelectModule, MbscTimerModule, MbscTimespanModule, MbscTreelistModule];\n      }\n    });\n  })();\n\n  return MbscModule;\n}(); // Arabic\n\n\nfunction intPart(floatNum) {\n  if (floatNum < -0.0000001) {\n    return Math.ceil(floatNum - 0.0000001);\n  }\n\n  return Math.floor(floatNum + 0.0000001);\n}\n\nfunction hijriToGregorian(hY, hM, hD) {\n  hY = parseInt(hY);\n  hM = parseInt(hM);\n  hD = parseInt(hD);\n  var jd,\n      l,\n      j,\n      n,\n      i,\n      k,\n      gregDate = new Array(3);\n  jd = intPart((11 * hY + 3) / 30) + 354 * hY + 30 * hM - intPart((hM - 1) / 2) + hD + 1948440 - 385;\n\n  if (jd > 2299160) {\n    l = jd + 68569;\n    n = intPart(4 * l / 146097);\n    l = l - intPart((146097 * n + 3) / 4);\n    i = intPart(4000 * (l + 1) / 1461001);\n    l = l - intPart(1461 * i / 4) + 31;\n    j = intPart(80 * l / 2447);\n    hD = l - intPart(2447 * j / 80);\n    l = intPart(j / 11);\n    hM = j + 2 - 12 * l;\n    hY = 100 * (n - 49) + i + l;\n  } else {\n    j = jd + 1402;\n    k = intPart((j - 1) / 1461);\n    l = j - 1461 * k;\n    n = intPart((l - 1) / 365) - intPart(l / 1461);\n    i = l - 365 * n + 30;\n    j = intPart(80 * i / 2447);\n    hD = i - intPart(2447 * j / 80);\n    i = intPart(j / 11);\n    hM = j + 2 - 12 * i;\n    hY = 4 * k + n + i - 4716;\n  }\n\n  gregDate[2] = hD;\n  gregDate[1] = hM;\n  gregDate[0] = hY;\n  return gregDate;\n}\n\nfunction gregorianToHijri(gY, gM, gD) {\n  gY = parseInt(gY);\n  gM = parseInt(gM);\n  gD = parseInt(gD);\n  var jd,\n      l,\n      j,\n      n,\n      hijriDate = new Array(0, 0, 0);\n\n  if (gY > 1582 || gY == 1582 && gM > 10 || gY == 1582 && gM == 10 && gD > 14) {\n    jd = intPart(1461 * (gY + 4800 + intPart((gM - 14) / 12)) / 4) + intPart(367 * (gM - 2 - 12 * intPart((gM - 14) / 12)) / 12) - intPart(3 * intPart((gY + 4900 + intPart((gM - 14) / 12)) / 100) / 4) + gD - 32075;\n  } else {\n    jd = 367 * gY - intPart(7 * (gY + 5001 + intPart((gM - 9) / 7)) / 4) + intPart(275 * gM / 9) + gD + 1729777;\n  }\n\n  l = jd - 1948440 + 10632;\n  n = intPart((l - 1) / 10631);\n  l = l - 10631 * n + 354;\n  j = intPart((10985 - l) / 5316) * intPart(50 * l / 17719) + intPart(l / 5670) * intPart(43 * l / 15238);\n  l = l - intPart((30 - j) / 15) * intPart(17719 * j / 50) - intPart(j / 16) * intPart(15238 * j / 43) + 29;\n  gM = intPart(24 * l / 709);\n  gD = l - intPart(709 * gM / 24);\n  gY = 30 * n + j - 30;\n  hijriDate[2] = gD;\n  hijriDate[1] = gM;\n  hijriDate[0] = gY;\n  return hijriDate;\n}\n\ncalendars.hijri = {\n  getYear: function getYear(date) {\n    return gregorianToHijri(date.getFullYear(), date.getMonth() + 1, date.getDate())[0];\n  },\n  getMonth: function getMonth(date) {\n    return --gregorianToHijri(date.getFullYear(), date.getMonth() + 1, date.getDate())[1];\n  },\n  getDay: function getDay(date) {\n    return gregorianToHijri(date.getFullYear(), date.getMonth() + 1, date.getDate())[2];\n  },\n  getDate: function getDate(y, m, d, h, i, s, u) {\n    if (m < 0) {\n      y += Math.floor(m / 12);\n      m = m % 12 ? 12 + m % 12 : 0;\n    }\n\n    if (m > 11) {\n      y += Math.floor(m / 12);\n      m = m % 12;\n    }\n\n    var gregorianDate = hijriToGregorian(y, +m + 1, d);\n    return new Date(gregorianDate[0], gregorianDate[1] - 1, gregorianDate[2], h || 0, i || 0, s || 0, u || 0);\n  },\n  getMaxDayOfMonth: function getMaxDayOfMonth(hY, hM) {\n    if (hM < 0) {\n      hY += Math.floor(hM / 12);\n      hM = hM % 12 ? 12 + hM % 12 : 0;\n    }\n\n    if (hM > 11) {\n      hY += Math.floor(hM / 12);\n      hM = hM % 12;\n    }\n\n    var daysPerMonth = [30, 29, 30, 29, 30, 29, 30, 29, 30, 29, 30, 29],\n        leapYear = (hY * 11 + 14) % 30 < 11;\n    return daysPerMonth[hM] + (hM === 11 && leapYear ? 1 : 0);\n  }\n}; // Arabic\n\nmobiscroll.i18n.ar = {\n  // Core\n  rtl: true,\n  // Right to left mode\n  setText: 'تعيين',\n  cancelText: 'إلغاء',\n  clearText: 'مسح',\n  selectedText: '{count} المحدد',\n  // Datetime component\n  dateFormat: 'dd/mm/yy',\n  dayNames: ['الأحد', 'الاثنين', 'الثلاثاء', 'الأربعاء', 'الخميس', 'الجمعة', 'السبت'],\n  dayNamesShort: ['أحد', 'اثنين', 'ثلاثاء', 'أربعاء', 'خميس', 'جمعة', 'سبت'],\n  dayNamesMin: ['ح', 'ن', 'ث', 'ر', 'خ', 'ج', 'س'],\n  dayText: 'يوم',\n  hourText: 'ساعات',\n  minuteText: 'الدقائق',\n  monthNames: ['يناير', 'فبراير', 'مارس', 'ابريل', 'مايو', 'يونيو', 'يوليو', 'أغسطس', 'سبتمبر', 'أكتوبر', 'نوفمبر', 'ديسمبر'],\n  monthNamesShort: ['يناير', 'فبراير', 'مارس', 'ابريل', 'مايو', 'يونيو', 'يوليو', 'أغسطس', 'سبتمبر', 'أكتوبر', 'نوفمبر', 'ديسمبر'],\n  monthText: 'شهر',\n  secText: 'ثواني',\n  amText: 'ص',\n  pmText: 'م',\n  timeFormat: 'hh:ii A',\n  yearText: 'عام',\n  nowText: 'الآن',\n  // Calendar component\n  firstDay: 0,\n  dateText: 'تاريخ',\n  timeText: 'وقت',\n  closeText: 'إغلاق',\n  todayText: 'اليوم',\n  prevMonthText: 'الشهر السابق',\n  nextMonthText: 'الشهر القادم',\n  prevYearText: 'السنه السابقة',\n  nextYearText: 'العام القادم',\n  allDayText: 'اليوم كله',\n  noEventsText: 'لا توجد احداث',\n  // Event calendar\n  eventText: 'الحدث',\n  eventsText: 'أحداث',\n  moreEventsText: 'واحد آخر',\n  moreEventsPluralText: 'اثنان آخران {count}',\n  // Daterange component\n  fromText: 'يبدا',\n  toText: 'ينتهي',\n  // Measurement components\n  wholeText: 'كامل',\n  fractionText: 'جزء',\n  unitText: 'وحدة',\n  // Numpad date\n  delimiter: '/',\n  // Numpad decimal\n  decimalSeparator: '.',\n  thousandsSeparator: ',',\n  // Timer / Timespan component\n  labels: ['سنوات', 'أشهر', 'أيام', 'ساعة', 'دقائق', 'ثواني', ''],\n  labelsShort: ['سنوات', 'أشهر', 'أيام', 'ساعة', 'دقائق', 'ثواني', ''],\n  // Timer component\n  startText: 'بدء',\n  stopText: 'إيقاف',\n  resetText: 'إعادة ضبط',\n  lapText: 'الدورة',\n  hideText: 'إخفاء',\n  // Forms\n  offText: 'إيقاف',\n  onText: 'تشغيل',\n  // Listview\n  backText: 'رجوع',\n  undoText: 'تراجع'\n};\nvar themes$1 = mobiscroll.themes;\nthemes$1.frame.ios = {\n  display: 'bottom',\n  // frame\n  headerText: false,\n  // frame\n  btnWidth: false,\n  // frame\n  deleteIcon: 'ios-backspace',\n  // numpad\n  scroll3d: os != 'wp' && (os != 'android' || majorVersion > 7)\n};\nthemes$1.scroller.ios = extend$1({}, themes$1.frame.ios, {\n  rows: 5,\n  // scroller\n  height: 34,\n  // scroller\n  minWidth: 55,\n  // scroller\n  selectedLineHeight: true,\n  // scroller\n  selectedLineBorder: 1,\n  // scroller\n  showLabel: false,\n  // scroller\n  useShortLabels: true,\n  // timespan/timer\n  btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5',\n  // scroller\n  btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5',\n  // scroller\n  checkIcon: 'ion-ios7-checkmark-empty',\n  // select\n  filterClearIcon: 'ion-close-circled',\n  // select\n  dateDisplay: 'MMdyy',\n  // date\n  btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5',\n  // calendar\n  btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5' // calendar\n\n});\nthemes$1.listview.ios = {\n  leftArrowClass: 'mbsc-ic-ion-ios7-arrow-back',\n  rightArrowClass: 'mbsc-ic-ion-ios7-arrow-forward'\n};\nthemes$1.form.ios = {};\nvar themes$2 = mobiscroll.themes;\nthemes$2.frame.bootstrap = {\n  disabledClass: 'disabled',\n  selectedClass: 'btn-primary',\n  selectedTabClass: 'active',\n  tabLink: true,\n  todayClass: 'text-primary mbsc-cal-today',\n  onMarkupInserted: function onMarkupInserted(ev) {\n    var dw = $$1(ev.target),\n        calTabs = $$1('.mbsc-cal-tabs', dw);\n    $$1('.mbsc-fr-popup', dw).addClass('popover');\n    $$1('.mbsc-fr-w', dw).addClass('popover-content');\n    $$1('.mbsc-fr-hdr', dw).addClass('popover-title popover-header');\n    $$1('.mbsc-fr-arr-i', dw).addClass('popover');\n    $$1('.mbsc-fr-arr', dw).addClass('arrow');\n    $$1('.mbsc-fr-btn', dw).addClass('btn btn-default btn-secondary');\n    $$1('.mbsc-fr-btn-s .mbsc-fr-btn', dw).removeClass('btn-default btn-secondary').addClass('btn btn-primary'); // Calendar tabs\n\n    calTabs.addClass('nav nav-tabs');\n    calTabs.find('.mbsc-cal-tab').addClass('nav-item'); // 4.x\n\n    calTabs.find('a').addClass('nav-link'); // 4.x\n\n    calTabs.find('.mbsc-cal-tab.active .nav-link').addClass('active'); // 4.x\n    // Calendar year/month selector\n\n    $$1('.mbsc-cal-picker', dw).addClass('popover'); // Rangepicker start/end buttons\n\n    $$1('.mbsc-range-btn', dw).addClass('btn btn-sm btn-small btn-default'); // Numpad \n\n    $$1('.mbsc-np-btn', dw).addClass('btn btn-default'); // Select filter\n\n    $$1('.mbsc-sel-filter-cont', dw).removeClass('mbsc-input');\n    $$1('.mbsc-sel-filter-input', dw).addClass('form-control');\n  },\n  onTabChange: function onTabChange(ev, inst) {\n    $$1('.mbsc-cal-tabs .nav-link', inst._markup).removeClass('active');\n    $$1('.mbsc-cal-tab.active .nav-link', inst._markup).addClass('active');\n  },\n  onPosition: function onPosition(ev) {\n    setTimeout(function () {\n      $$1('.mbsc-fr-bubble-top, .mbsc-fr-bubble-top .mbsc-fr-arr-i', ev.target).removeClass('bottom bs-popover-bottom').addClass('top bs-popover-top');\n      $$1('.mbsc-fr-bubble-bottom, .mbsc-fr-bubble-bottom .mbsc-fr-arr-i', ev.target).removeClass('top bs-popover-top').addClass('bottom  bs-popover-bottom');\n    }, 10);\n  }\n};\nthemes$2.scroller.bootstrap = extend$1({}, themes$2.frame.bootstrap, {\n  dateDisplay: 'Mddyy',\n  btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5',\n  // calendar\n  btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5',\n  // calendar\n  btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5 btn-light',\n  // scroller\n  btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5 btn-light',\n  // scroller\n  selectedLineHeight: true,\n  onEventBubbleShow: function onEventBubbleShow(ev) {\n    var evc = $$1(ev.eventList);\n    $$1('.mbsc-cal-event-list', evc).addClass('list-group');\n    $$1('.mbsc-cal-event', evc).addClass('list-group-item');\n  }\n});\nthemes$2.navigation.bootstrap = {\n  wrapperClass: 'popover panel panel-default',\n  groupClass: 'btn-group',\n  activeClass: 'btn-primary',\n  disabledClass: 'disabled',\n  itemClass: 'btn btn-default'\n};\nthemes$2.form.bootstrap = {};\nmobiscroll.customTheme('mobiscroll-dark', 'mobiscroll');\n\nfunction _addRipple($control, ev) {\n  var x = getCoord(ev, 'X', true),\n      y = getCoord(ev, 'Y', true),\n      control = $control[0],\n      rect = $control.offset(),\n      left = x - rect.left,\n      top = y - rect.top,\n      width = Math.max(left, control.offsetWidth - left),\n      height = Math.max(top, control.offsetHeight - top),\n      size = 2 * Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));\n\n  _removeRipple($ripple);\n\n  $ripple = $$1('<span class=\"mbsc-ripple\"></span>').css({\n    backgroundColor: getComputedStyle(control).color,\n    width: size,\n    height: size,\n    top: y - rect.top - size / 2,\n    left: x - rect.left - size / 2\n  }).appendTo($control);\n  setTimeout(function () {\n    $ripple.addClass('mbsc-ripple-scaled mbsc-ripple-visible');\n  }, 10);\n}\n\nfunction _removeRipple($r) {\n  setTimeout(function () {\n    if ($r) {\n      $r.removeClass('mbsc-ripple-visible');\n      setTimeout(function () {\n        $r.remove();\n      }, 2000);\n    }\n  }, 100);\n}\n\nfunction initRipple($markup, selector, disabled, nohl) {\n  var startX,\n      startY,\n      markup = $markup[0];\n\n  function onStart(ev) {\n    var target = closest(markup, ev.target, selector);\n\n    if (target && testTouch(ev, target)) {\n      startX = getCoord(ev, 'X');\n      startY = getCoord(ev, 'Y');\n      $active$1 = $$1(target);\n\n      if (!$active$1.hasClass(disabled) && !$active$1.hasClass(nohl)) {\n        _addRipple($active$1, ev);\n      } else {\n        $active$1 = null;\n      }\n    }\n  }\n\n  function onMove(ev) {\n    if ($active$1 && Math.abs(getCoord(ev, 'X') - startX) > 9 || Math.abs(getCoord(ev, 'Y') - startY) > 9) {\n      _removeRipple($ripple);\n\n      $active$1 = null;\n    }\n  }\n\n  function onEnd() {\n    if ($active$1) {\n      setTimeout(function () {\n        _removeRipple($ripple);\n      }, 100);\n      $active$1 = null;\n    }\n  }\n\n  if (markup) {\n    if (markup.__mbscRippleOff) {\n      markup.__mbscRippleOff();\n    }\n\n    listen(markup, 'touchstart', onStart, {\n      passive: true\n    });\n    listen(markup, 'mousedown', onStart);\n    listen(markup, 'touchmove', onMove, {\n      passive: true\n    });\n    listen(markup, 'mousemove', onMove);\n    listen(markup, 'touchend', onEnd);\n    listen(markup, 'touchcancel', onEnd);\n    listen(markup, 'mouseleave', onEnd);\n    listen(markup, 'mouseup', onEnd);\n\n    markup.__mbscRippleOff = function () {\n      unlisten(markup, 'touchstart', onStart, {\n        passive: true\n      });\n      unlisten(markup, 'mousedown', onStart);\n      unlisten(markup, 'touchmove', onMove, {\n        passive: true\n      });\n      unlisten(markup, 'mousemove', onMove);\n      unlisten(markup, 'touchend', onEnd);\n      unlisten(markup, 'touchcancel', onEnd);\n      unlisten(markup, 'mouseleave', onEnd);\n      unlisten(markup, 'mouseup', onEnd);\n      delete markup.__mbscRippleOff;\n    };\n  }\n}\n\nvar $active$1,\n    $ripple,\n    themes$3 = mobiscroll.themes;\nthemes$3.frame.material = {\n  headerText: false,\n  btnWidth: false,\n  deleteIcon: 'material-backspace',\n  onMarkupReady: function onMarkupReady(ev) {\n    initRipple($$1(ev.target), '.mbsc-fr-btn-e', 'mbsc-disabled', 'mbsc-fr-btn-nhl');\n  }\n};\nthemes$3.scroller.material = extend$1({}, themes$3.frame.material, {\n  showLabel: false,\n  selectedLineBorder: 2,\n  weekDays: 'min',\n  icon: {\n    filled: 'material-star',\n    empty: 'material-star-outline'\n  },\n  checkIcon: 'material-check',\n  btnPlusClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-down',\n  btnMinusClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-up',\n  btnCalPrevClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-left',\n  btnCalNextClass: 'mbsc-ic mbsc-ic-material-keyboard-arrow-right'\n});\nthemes$3.listview.material = {\n  leftArrowClass: 'mbsc-ic-material-keyboard-arrow-left',\n  rightArrowClass: 'mbsc-ic-material-keyboard-arrow-right',\n  onItemActivate: function onItemActivate(ev) {\n    _addRipple($$1(ev.target), ev.domEvent);\n  },\n  onItemDeactivate: function onItemDeactivate() {\n    _removeRipple($ripple);\n  },\n  onSlideStart: function onSlideStart(ev) {\n    $$1('.mbsc-ripple', ev.target).remove();\n  },\n  onSortStart: function onSortStart(ev) {\n    $$1('.mbsc-ripple', ev.target).remove();\n  }\n};\nthemes$3.navigation.material = {\n  onInit: function onInit() {\n    initRipple($$1(this), '.mbsc-ms-item.mbsc-btn-e', 'mbsc-disabled', 'mbsc-btn-nhl');\n  },\n  onMarkupInit: function onMarkupInit() {\n    $$1('.mbsc-ripple', this).remove();\n  },\n  onDestroy: function onDestroy() {\n    if (this.__mbscRippleOff) {\n      this.__mbscRippleOff();\n    }\n  }\n};\nthemes$3.form.material = {\n  addRipple: function addRipple(elm, ev) {\n    _addRipple(elm, ev);\n  },\n  removeRipple: function removeRipple() {\n    _removeRipple($ripple);\n  }\n};\nmobiscroll.customTheme('material-dark', 'material');\nmobiscroll.customTheme('ios-dark', 'ios');\nvar themes$4 = mobiscroll.themes;\nthemes$4.frame.windows = {\n  headerText: false,\n  deleteIcon: 'backspace4',\n  //setIcon: 'material-check',\n  //cancelIcon: 'material-close',\n  //closeIcon: 'material-close',\n  //clearIcon: 'material-close',\n  //okIcon: 'material-check',\n  //nowIcon: 'loop2',\n  //startIcon: 'play3',\n  //stopIcon: 'pause2',\n  //resetIcon: 'stop2',\n  //lapIcon: 'loop2',\n  //btnWidth: false,\n  btnReverse: true\n};\nthemes$4.scroller.windows = extend$1({}, themes$4.frame.windows, {\n  rows: 6,\n  // scroller\n  minWidth: 88,\n  height: 44,\n  btnPlusClass: 'mbsc-ic mbsc-ic-arrow-down5',\n  btnMinusClass: 'mbsc-ic mbsc-ic-arrow-up5',\n  checkIcon: 'material-check',\n  dateDisplay: 'MMdyy',\n  // date\n  showLabel: false,\n  showScrollArrows: true,\n  btnCalPrevClass: 'mbsc-ic mbsc-ic-arrow-left5',\n  // calendar\n  btnCalNextClass: 'mbsc-ic mbsc-ic-arrow-right5',\n  // calendar\n  dayNamesShort: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],\n  useShortLabels: true // timespan/timer\n\n});\nthemes$4.form.windows = {};\nmobiscroll.customTheme('windows-dark', 'windows');\nmobiscroll.customTheme('forms2', 'ios');\nmobiscroll.customTheme('navbarmenu', 'ios');\nmobiscroll.customTheme('newtheme', 'ios');\nvar themes$5 = mobiscroll.themes;\nvar theme = 'mobiscroll';\n\nif (os == 'android') {\n  theme = 'material';\n} else if (os == 'ios') {\n  theme = 'ios';\n} else if (os == 'wp') {\n  theme = 'windows';\n}\n\n$$1.each(themes$5.frame, function (key, settings) {\n  // Stop at the first custom theme with the OS base theme\n  if (theme && settings.baseTheme == theme && key != theme + '-dark') {\n    mobiscroll.autoTheme = key;\n    return false;\n  } else if (key == theme) {\n    mobiscroll.autoTheme = key;\n  }\n});\nexport { MbscAccordion, MbscAvatar, MbscBottomNav, MbscButton, MbscCalendar, MbscCalendarComponent, MbscCalendarModule, MbscCard, MbscCardComponent, MbscCardContent, MbscCardFooter, MbscCardHeader, MbscCardModule, MbscCardSubtitle, MbscCardTitle, MbscCheckbox, MbscColor, MbscColorComponent, MbscColorModule, MbscDate, MbscDateComponent, MbscDatetime, MbscDatetimeComponent, MbscDatetimeModule, MbscDistance, MbscDistanceComponent, MbscDropdown, MbscEventcalendar, MbscEventcalendarComponent, MbscEventcalendarModule, MbscForce, MbscForceComponent, MbscForm, MbscFormGroup, MbscFormGroupContent, MbscFormGroupTitle, MbscFormsModule, MbscHamburgerNav, MbscImage, MbscImageComponent, MbscImageItem, MbscImageModule, MbscInput, MbscInputModule, MbscListview, MbscListviewHeader, MbscListviewItem, MbscListviewModule, MbscListviewSublist, MbscMass, MbscMassComponent, MbscMeasurement, MbscMeasurementComponent, MbscMeasurementModule, MbscModule, MbscNav, MbscNavItem, MbscNavigationModule, MbscNote, MbscNumber, MbscNumberComponent, MbscNumberModule, MbscNumpad, MbscNumpadComponent, MbscNumpadDate, MbscNumpadDateComponent, MbscNumpadDecimal, MbscNumpadDecimalComponent, MbscNumpadModule, MbscNumpadTime, MbscNumpadTimeComponent, MbscNumpadTimespan, MbscNumpadTimespanComponent, MbscOptionItem, MbscOptionlist, MbscOptionlistModule, MbscPage, MbscPageModule, MbscPopup, MbscPopupModule, MbscProgress, MbscRadio, MbscRadioGroup, MbscRange, MbscRangeComponent, MbscRangeEndComponent, MbscRangeModule, MbscRangeStartComponent, MbscRating, MbscRouterToken, MbscScrollView, MbscScrollViewComponent, MbscScrollViewItem, MbscScrollViewItemComponent, MbscScrollViewModule, MbscScroller, MbscScrollerComponent, MbscScrollerModule, MbscSegmented, MbscSegmentedGroup, MbscSelect, MbscSelectComponent, MbscSelectModule, MbscSlider, MbscSpeed, MbscSpeedComponent, MbscStepper, MbscSwitch, MbscTabNav, MbscTemperature, MbscTemperatureComponent, MbscTextarea, MbscTime, MbscTimeComponent, MbscTimer, MbscTimerComponent, MbscTimerModule, MbscTimespan, MbscTimespanComponent, MbscTimespanModule, MbscTreelist, MbscTreelistComponent, MbscTreelistModule, MbscWidget, mobiscroll, MbscOptionsService as ɵa, MbscInputService as ɵb, MbscCalBaseModule as ɵba, MbscDatetimeBase as ɵbb, MbscDatetimeBaseModule as ɵbc, MbscNavItemBase as ɵbd, MbscNavigationBase as ɵbe, MbscNavigationBaseModule as ɵbf, MbscNotifyItemService as ɵbg, MbscScrollItemBase as ɵbh, MbscScrollViewBase as ɵbi, MbscScrollViewBaseModule as ɵbj, MbscListService as ɵc, MbscBase as ɵd, MbscValueBase as ɵe, MbscCloneBase as ɵf, MbscControlBase as ɵg, MbscFrameBase as ɵh, MbscScrollerBase as ɵi, MbscBaseModule as ɵj, MbscFrameBaseModule as ɵk, MbscScrollerBaseModule as ɵl, INPUT_TEMPLATE as ɵm, MbscDateBase as ɵn, MbscFormBase as ɵo, MbscFormValueBase as ɵp, MbscInputBase as ɵq, MbscRadioService as ɵr, MbscRadioGroupBase as ɵs, MbscListviewService as ɵt, MbscSublistService as ɵu, MbscListitemService as ɵv, MbscMeasurementBase as ɵw, MbscMeasurementChild as ɵx, MbscNumpadBase as ɵy, MbscCalBase as ɵz }; //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9iaXNjcm9sbC5hbmd1bGFyLm1pbi5qcyIsInNvdXJjZXMiOlsibW9iaXNjcm9sbC5hbmd1bGFyLm1pbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztnREFHMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztnREFHeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztnREFHd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUVPO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBRU87QUFDUDs7Ozs7O29HQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBRU87QUFDUDs7Ozs7O29HQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBRU87QUFDUDs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBRU87QUFDUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FFTztBQUNQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7d1FBTXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O21QQU00QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs4UEFNK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFFTztBQUNQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUVPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUVPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBVU87QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7c1ZBT3dCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FFTztBQUNQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7aVFBTStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBRU87QUFDUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7dVBBTTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUtPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FNTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztvV0FPMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztnREFHNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O2dEQUcyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Z0RBRzRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FNTztBQUNQOzs7Ozs7Ozs7Ozs7OzBJQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBYU87QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQVVPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tDQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBV087QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O2tVQU8yQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBTU87QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQU9PO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBVXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBVXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBVXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBVXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBVXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7MFlBT3VCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUtPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQU1PO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozt1VkFPd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFFTztBQUNQOzs7Ozs7Ozs7Ozs7Ozs7b0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUtPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O3FFQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FNTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFLTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBTU87QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBS087QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQU1PO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7eWZBTzJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FLTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBTU87QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztzUkFPZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFPTztBQUNQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQU9PO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQU9PO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFNTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFPTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQVFPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFRTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBUU87QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Z0RBR3lCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUVPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7b0JBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBTU87QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJEQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBTU87QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQU1PO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FNTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQU9PO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQU1PO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBVU87QUFDUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dEQVUyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBVTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztnREFVc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OysyQkFPd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBS087QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQU9PO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FTTztBQUNQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7d1hBT3dCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FFTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FFTztBQUNQOzs7Ozs7OztvQkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBS087QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBTU87QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUtPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FNTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBS087QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQU1PO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFLTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBTU87QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUtPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FNTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBS087QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQU1PO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7b3lCQU84QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Z0RBRzhCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUVPO0FBQ1A7Ozs7Ozs7O29CQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FFTztBQUNQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztpUkFNaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUVPO0FBQ1A7Ozs7Ozs7Ozs7Ozs7O29CQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBRU87QUFDUDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7d1JBTWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQVdPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFRTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQVFPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQVFPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQVFPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozt3WkFPNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUtPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQU1PO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OytWQU95QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBRU87QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFLTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBTU87QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FLTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBTU87QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBS087QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBTU87QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUtPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBTU87QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUtPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQU1PO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Z3VCQU95QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQVdPO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzRHQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBUU87QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs0UEFPNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQU9PO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQVNPO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBTW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs0T0FPdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBT087QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OzswQkFRbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OzJOQU93QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUtPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBS087QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBS087QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQU1PO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O3FiQU93QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBS087QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQU1PO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O3lXQU8yQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FPTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBT087QUFDUDs7Ozs7Ozs7Ozs7Ozs0R0FBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQU9PO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FRTztBQUNQOzs7Ozs7Ozs7Ozs7Ozs7Ozs0R0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O2dYQU82QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFLTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQU1PO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OzsrVkFPeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBS087QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQU1PO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OzBWQU93QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBS087QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FNTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozt5V0FPMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUtPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBTU87QUFDUDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29CQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7eVdBTzJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Oztxc0ZBTW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBJbnB1dCBhcyBJbnB1dCQxLCBPdXRwdXQsIERpcmVjdGl2ZSwgTmdNb2R1bGUsIEV2ZW50RW1pdHRlciwgRWxlbWVudFJlZiwgTmdab25lLCBWaWV3Q29udGFpbmVyUmVmLCBWaWV3Q2hpbGQsIE9wdGlvbmFsLCBDb21wb25lbnQsIENvbnRlbnRDaGlsZHJlbiwgUXVlcnlMaXN0LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgVmlld0NoaWxkcmVuLCBDaGFuZ2VEZXRlY3RvclJlZiwgSW5qZWN0b3IsIEluamVjdCwgZm9yd2FyZFJlZiwgQ29udGVudENoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdDb250cm9sLCBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgfTtcblxuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5cbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cbiAgZnVuY3Rpb24gX18oKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gIH1cblxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG5mdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLFxuICAgICAgZDtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufVxuZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xuICAgIGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7XG4gIH07XG59XG5mdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XG59XG5cbnZhciBtb2Jpc2Nyb2xsID0gbW9iaXNjcm9sbCB8fCB7fSxcbiAgICB1dGlsID0ge30sXG4gICAgY2FsZW5kYXJzID0ge307XG5cbnZhciBvcyxcbiAgICB2ZXJzLFxuICAgIG1ham9yVmVyc2lvbixcbiAgICBtaW5vclZlcnNpb24sXG4gICAgdmVyc2lvbiA9IFtdLFxuICAgIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnLFxuICAgIGlzRGFyayA9IGlzQnJvd3NlciAmJiB3aW5kb3cubWF0Y2hNZWRpYSAmJiB3aW5kb3cubWF0Y2hNZWRpYSgnKHByZWZlcnMtY29sb3Itc2NoZW1lOmRhcmspJykubWF0Y2hlcyxcbiAgICB1c2VyQWdlbnQgPSBpc0Jyb3dzZXIgPyBuYXZpZ2F0b3IudXNlckFnZW50IDogJycsXG4gICAgcGxhdGZvcm0gPSBpc0Jyb3dzZXIgPyBuYXZpZ2F0b3IucGxhdGZvcm0gOiAnJyxcbiAgICBtYXhUb3VjaFBvaW50cyA9IGlzQnJvd3NlciA/IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA6IDAsXG4gICAgaXNTYWZhcmkgPSAvU2FmYXJpLy50ZXN0KHVzZXJBZ2VudCksXG4gICAgZGV2aWNlID0gdXNlckFnZW50Lm1hdGNoKC9BbmRyb2lkfGlQaG9uZXxpUGFkfGlQb2R8V2luZG93cyBQaG9uZXxXaW5kb3dzfE1TSUUvaSksXG4gICAgcmFmID0gaXNCcm93c2VyICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZnVuY3Rpb24gKGZ1bmMpIHtcbiAgcmV0dXJuIHNldFRpbWVvdXQoZnVuYywgMjApO1xufSxcbiAgICByYWZjID0gaXNCcm93c2VyICYmIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCBmdW5jdGlvbiAoaWQpIHtcbiAgY2xlYXJUaW1lb3V0KGlkKTtcbn07XG5cbmlmICgvQW5kcm9pZC9pLnRlc3QoZGV2aWNlKSkge1xuICBvcyA9ICdhbmRyb2lkJztcbiAgdmVycyA9IHVzZXJBZ2VudC5tYXRjaCgvQW5kcm9pZFxccysoW1xcZC5dKykvaSk7XG5cbiAgaWYgKHZlcnMpIHtcbiAgICB2ZXJzaW9uID0gdmVyc1swXS5yZXBsYWNlKCdBbmRyb2lkICcsICcnKS5zcGxpdCgnLicpO1xuICB9XG59IGVsc2UgaWYgKC9pUGhvbmV8aVBhZHxpUG9kL2kudGVzdChkZXZpY2UpIHx8IC9pUGhvbmV8aVBhZHxpUG9kL2kudGVzdChwbGF0Zm9ybSkgfHwgcGxhdGZvcm0gPT09ICdNYWNJbnRlbCcgJiYgbWF4VG91Y2hQb2ludHMgPiAxKSB7XG4gIC8vIE9uIGlQYWQgd2l0aCBpT1MgMTMgZGVza3RvcCBzaXRlIHJlcXVlc3QgaXMgYXV0b21hdGljYWxseSBlbmFibGVkIGluIFNhZmFyaSxcbiAgLy8gc28gJ2lQYWQnIGlzIG5vIGxvbmdlciBwcmVzZW50IGluIHRoZSB1c2VyIGFnZW50IHN0cmluZy5cbiAgLy8gSW4gdGhpcyBjYXNlIHdlIGNoZWNrIGBuYXZpZ2F0b3IucGxhdGZvcm1gIGFuZCBgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzYC5cbiAgLy8gbWF4VG91Y2hQb2ludHMgaXMgbmVlZGVkIHRvIGV4Y2x1ZGUgZGVza3RvcCBNYWMgT1MgWC5cbiAgb3MgPSAnaW9zJztcbiAgdmVycyA9IHVzZXJBZ2VudC5tYXRjaCgvT1NcXHMrKFtcXGRfXSspL2kpO1xuXG4gIGlmICh2ZXJzKSB7XG4gICAgdmVyc2lvbiA9IHZlcnNbMF0ucmVwbGFjZSgvXy9nLCAnLicpLnJlcGxhY2UoJ09TICcsICcnKS5zcGxpdCgnLicpO1xuICB9XG59IGVsc2UgaWYgKC9XaW5kb3dzIFBob25lL2kudGVzdChkZXZpY2UpKSB7XG4gIG9zID0gJ3dwJztcbn0gZWxzZSBpZiAoL1dpbmRvd3N8TVNJRS9pLnRlc3QoZGV2aWNlKSkge1xuICBvcyA9ICd3aW5kb3dzJztcbn1cblxubWFqb3JWZXJzaW9uID0gdmVyc2lvblswXTtcbm1pbm9yVmVyc2lvbiA9IHZlcnNpb25bMV07XG5cbmZ1bmN0aW9uIHRlc3RQcm9wcyhwcm9wcykge1xuICB2YXIgaTtcblxuICBmb3IgKGkgaW4gcHJvcHMpIHtcbiAgICBpZiAobW9kW3Byb3BzW2ldXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHRlc3RQcmVmaXgoKSB7XG4gIHZhciBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ01veicsICdPJywgJ21zJ10sXG4gICAgICBwO1xuXG4gIGZvciAocCBpbiBwcmVmaXhlcykge1xuICAgIGlmICh0ZXN0UHJvcHMoW3ByZWZpeGVzW3BdICsgJ1RyYW5zZm9ybSddKSkge1xuICAgICAgcmV0dXJuICctJyArIHByZWZpeGVzW3BdLnRvTG93ZXJDYXNlKCkgKyAnLSc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiB0ZXN0VG91Y2goZSwgZWxtKSB7XG4gIGlmIChlLnR5cGUgPT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgZWxtLl9fbWJzY1RvdWNoZWQgPSAxO1xuICB9IGVsc2UgaWYgKGVsbS5fX21ic2NUb3VjaGVkKSB7XG4gICAgZGVsZXRlIGVsbS5fX21ic2NUb3VjaGVkO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXRQb3NpdGlvbih0LCB2ZXJ0aWNhbCkge1xuICB2YXIgcHJlZml4ZXMgPSBbJ3QnLCAnd2Via2l0VCcsICdNb3pUJywgJ09UJywgJ21zVCddLFxuICAgICAgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRbMF0pLFxuICAgICAgaSA9IDAsXG4gICAgICBtYXRyaXgsXG4gICAgICBweCxcbiAgICAgIHY7XG5cbiAgd2hpbGUgKCFtYXRyaXggJiYgaSA8IHByZWZpeGVzLmxlbmd0aCkge1xuICAgIHYgPSBwcmVmaXhlc1tpXTtcblxuICAgIGlmIChzdHlsZVt2ICsgJ3JhbnNmb3JtJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgbWF0cml4ID0gc3R5bGVbdiArICdyYW5zZm9ybSddO1xuICAgIH1cblxuICAgIGkrKztcbiAgfVxuXG4gIG1hdHJpeCA9IG1hdHJpeC5zcGxpdCgnKScpWzBdLnNwbGl0KCcsICcpO1xuICBweCA9IHZlcnRpY2FsID8gbWF0cml4WzEzXSB8fCBtYXRyaXhbNV0gOiBtYXRyaXhbMTJdIHx8IG1hdHJpeFs0XTtcbiAgcmV0dXJuIHB4O1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0Q29sb3IoY29sb3IpIHtcbiAgaWYgKGNvbG9yKSB7XG4gICAgLy8gQ2FjaGUgY2FsY3VsYXRlZCB0ZXh0IGNvbG9ycywgYmVjYXVzZSBpdCBpcyBzbG93XG4gICAgaWYgKHRleHRDb2xvcnNbY29sb3JdKSB7XG4gICAgICByZXR1cm4gdGV4dENvbG9yc1tjb2xvcl07XG4gICAgfVxuXG4gICAgdmFyIGN0eCA9IGNhbnZhcyAmJiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIGlmICghY3R4KSB7XG4gICAgICByZXR1cm4gJyNmZmYnO1xuICAgIH0gLy8gVXNlIGNhbnZhcyBlbGVtZW50LCBzaW5jZSBpdCBkb2VzIG5vdCByZXF1aXJlIERPTSBhcHBlbmRcblxuXG4gICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcbiAgICB2YXIgcmdiID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhO1xuICAgIHZhciBkZWx0YSA9ICtyZ2JbMF0gKiAwLjI5OSArICtyZ2JbMV0gKiAwLjU4NyArICtyZ2JbMl0gKiAwLjExNDtcbiAgICB2YXIgdGV4dENvbG9yID0gZGVsdGEgPCAxMzAgPyAnI2ZmZicgOiAnIzAwMCc7XG4gICAgdGV4dENvbG9yc1tjb2xvcl0gPSB0ZXh0Q29sb3I7XG4gICAgcmV0dXJuIHRleHRDb2xvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY3JvbGxTdGVwKGVsLCBzdGFydFRpbWUsIGZyb20sIHRvLCBjYWxsYmFjaykge1xuICB2YXIgZWxhcHNlZCA9IE1hdGgubWluKDEsIChuZXcgRGF0ZSgpIC0gc3RhcnRUaW1lKSAvIDQ2OCksXG4gICAgICBlYXNlZCA9IDAuNSAqICgxIC0gTWF0aC5jb3MoTWF0aC5QSSAqIGVsYXBzZWQpKSxcbiAgICAgIGN1cnJlbnQgPSBmcm9tICsgKHRvIC0gZnJvbSkgKiBlYXNlZDtcbiAgZWwuc2Nyb2xsVG9wID0gY3VycmVudDtcblxuICBpZiAoY3VycmVudCAhPT0gdG8pIHtcbiAgICByYWYoZnVuY3Rpb24gKCkge1xuICAgICAgc2Nyb2xsU3RlcChlbCwgc3RhcnRUaW1lLCBmcm9tLCB0bywgY2FsbGJhY2spO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzbW9vdGhTY3JvbGwoZWwsIHRvLCBwcmV2QW5pbSwgY2FsbGJhY2spIHtcbiAgaWYgKHByZXZBbmltKSB7XG4gICAgZWwuc2Nyb2xsVG9wID0gdG87XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNjcm9sbFN0ZXAoZWwsIG5ldyBEYXRlKCksIGVsLnNjcm9sbFRvcCwgdG8sIGNhbGxiYWNrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsaXN0ZW4oZWwsIGV2ZW50LCBoYW5kbGVyLCBvcHQpIHtcbiAgaWYgKGVsKSB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bmxpc3RlbihlbCwgZXZlbnQsIGhhbmRsZXIsIG9wdCkge1xuICBpZiAoZWwpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgaWYgKCFzZWxlY3RvciB8fCAhZWxlbWVudCB8fCBlbGVtZW50Lm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIG1hdGNoZXNTZWxlY3RvciA9IGVsZW1lbnQubWF0Y2hlcyB8fCBlbGVtZW50Lm1hdGNoZXNTZWxlY3RvciB8fCBlbGVtZW50LndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBlbGVtZW50Lm1vek1hdGNoZXNTZWxlY3RvciB8fCBlbGVtZW50Lm1zTWF0Y2hlc1NlbGVjdG9yO1xuICByZXR1cm4gbWF0Y2hlc1NlbGVjdG9yLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpO1xufVxuXG5mdW5jdGlvbiBjbG9zZXN0KGVsLCB0YXJnZXQsIHNlbGVjdG9yKSB7XG4gIHdoaWxlICh0YXJnZXQpIHtcbiAgICBpZiAobWF0Y2hlcyh0YXJnZXQsIHNlbGVjdG9yKSkge1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICB0YXJnZXQgPSB0YXJnZXQgIT09IGVsID8gdGFyZ2V0LnBhcmVudE5vZGUgOiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIoZWxtLCBuYW1lLCBkYXRhKSB7XG4gIHZhciBldnQ7XG5cbiAgdHJ5IHtcbiAgICBldnQgPSBuZXcgQ3VzdG9tRXZlbnQobmFtZSwge1xuICAgICAgZGV0YWlsOiBkYXRhLFxuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2dC5pbml0RXZlbnQobmFtZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZXZ0LmRldGFpbCA9IGRhdGE7XG4gIH1cblxuICBlbG0uZGlzcGF0Y2hFdmVudChldnQpO1xufVxuXG5mdW5jdGlvbiBzZXRGb2N1c0ludmlzaWJsZSgpIHtcbiAgd2luLl9fbWJzY0ZvY3VzVmlzaWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzZXRGb2N1c1Zpc2libGUoKSB7XG4gIHdpbi5fX21ic2NGb2N1c1Zpc2libGUgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBhZGRXaW5kb3dGb2N1cygpIHtcbiAgdmFyIGZvY3VzQ291bnQgPSB3aW4uX19tYnNjRm9jdXNDb3VudCB8fCAwO1xuXG4gIGlmIChmb2N1c0NvdW50ID09PSAwKSB7XG4gICAgbGlzdGVuKHdpbiwgJ21vdXNlZG93bicsIHNldEZvY3VzSW52aXNpYmxlLCB0cnVlKTtcbiAgICBsaXN0ZW4od2luLCAna2V5ZG93bicsIHNldEZvY3VzVmlzaWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3aW4uX19tYnNjRm9jdXNDb3VudCA9ICsrZm9jdXNDb3VudDtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlV2luZG93Rm9jdXMoKSB7XG4gIHZhciBmb2N1c0NvdW50ID0gd2luLl9fbWJzY0ZvY3VzQ291bnQgfHwgMDtcbiAgd2luLl9fbWJzY0ZvY3VzQ291bnQgPSAtLWZvY3VzQ291bnQ7XG5cbiAgaWYgKHdpbi5fX21ic2NGb2N1c0NvdW50ID09PSAwKSB7XG4gICAgdW5saXN0ZW4od2luLCAnbW91c2Vkb3duJywgc2V0Rm9jdXNJbnZpc2libGUpO1xuICAgIHVubGlzdGVuKHdpbiwgJ2tleWRvd24nLCBzZXRGb2N1c1Zpc2libGUpO1xuICB9XG59XG5cbnZhciBhbmltRW5kLFxuICAgIGNhbnZhcyxcbiAgICBtb2QsXG4gICAgY3NzUHJlZml4LFxuICAgIGhhc0dob3N0Q2xpY2ssXG4gICAgaGFzVHJhbnNpdGlvbixcbiAgICBpc1dlYlZpZXcsXG4gICAgaXNXa1dlYlZpZXcsXG4gICAganNQcmVmaXgsXG4gICAgd2luLFxuICAgIHRleHRDb2xvcnMgPSB7fTtcblxuaWYgKGlzQnJvd3Nlcikge1xuICB3aW4gPSB3aW5kb3c7XG4gIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICBtb2QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdtb2Rlcm5penInKS5zdHlsZTtcbiAgY3NzUHJlZml4ID0gdGVzdFByZWZpeCgpO1xuICBqc1ByZWZpeCA9IGNzc1ByZWZpeC5yZXBsYWNlKC9eLS8sICcnKS5yZXBsYWNlKC8tJC8sICcnKS5yZXBsYWNlKCdtb3onLCAnTW96Jyk7XG4gIGFuaW1FbmQgPSBtb2QuYW5pbWF0aW9uICE9PSB1bmRlZmluZWQgPyAnYW5pbWF0aW9uZW5kJyA6ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICBoYXNUcmFuc2l0aW9uID0gbW9kLnRyYW5zaXRpb24gIT09IHVuZGVmaW5lZDsgLy8gVUlXZWJWaWV3IG9uIGlPUyBzdGlsbCBoYXMgdGhlIGdob3N0IGNsaWNrLCBcbiAgLy8gV2tXZWJWaWV3IGRvZXMgbm90IGhhdmUgYSBnaG9zdCBjbGljaywgYnV0IGl0J3MgaGFyZCB0byB0ZWxsIGlmIGl0J3MgVUlXZWJWaWV3IG9yIFdrV2ViVmlld1xuICAvLyBJbiBhZGRpdGlvbiBpbiBpT1MgMTIuMiBpZiB3ZSBlbmFibGUgdGFwIGhhbmRsaW5nLCBpdCBicmFrZXMgdGhlIGZvcm0gaW5wdXRzXG4gIC8vIChrZXlib2FyZCBhcHBlYXJzLCBidXQgdGhlIGN1cnNvciBpcyBub3QgaW4gdGhlIGlucHV0KS5cblxuICBpc1dlYlZpZXcgPSBvcyA9PT0gJ2lvcycgJiYgIWlzU2FmYXJpO1xuICBpc1drV2ViVmlldyA9IGlzV2ViVmlldyAmJiB3aW4ud2Via2l0ICYmIHdpbi53ZWJraXQubWVzc2FnZUhhbmRsZXJzO1xuICBoYXNHaG9zdENsaWNrID0gbW9kLnRvdWNoQWN0aW9uID09PSB1bmRlZmluZWQgfHwgaXNXZWJWaWV3ICYmICFpc1drV2ViVmlldztcbn1cblxudmFyIGNzc051bWJlciA9IHtcbiAgJ2NvbHVtbi1jb3VudCc6IDEsXG4gICdjb2x1bW5zJzogMSxcbiAgJ2ZvbnQtd2VpZ2h0JzogMSxcbiAgJ2xpbmUtaGVpZ2h0JzogMSxcbiAgJ29wYWNpdHknOiAxLFxuICAnei1pbmRleCc6IDEsXG4gICd6b29tJzogMVxufSxcbiAgICBwcm9wTWFwID0ge1xuICAncmVhZG9ubHknOiAncmVhZE9ubHknXG59LFxuICAgIGVtcHR5QXJyYXkgPSBbXSxcbiAgICBfc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCI7XG59XG5cbmZ1bmN0aW9uIGxpa2VBcnJheShvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoubGVuZ3RoID09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8tKyguKT8vZywgZnVuY3Rpb24gKG1hdGNoLCBjaHIpIHtcbiAgICByZXR1cm4gY2hyID8gY2hyLnRvVXBwZXJDYXNlKCkgOiAnJztcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSwgZGVlcCkge1xuICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKGRlZXAgJiYgKCQuaXNQbGFpbk9iamVjdChzb3VyY2Vba2V5XSkgfHwgJC5pc0FycmF5KHNvdXJjZVtrZXldKSkpIHtcbiAgICAgIGlmICgkLmlzUGxhaW5PYmplY3Qoc291cmNlW2tleV0pICYmICEkLmlzUGxhaW5PYmplY3QodGFyZ2V0W2tleV0pIHx8ICQuaXNBcnJheShzb3VyY2Vba2V5XSkgJiYgISQuaXNBcnJheSh0YXJnZXRba2V5XSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB7fTtcbiAgICAgIH1cblxuICAgICAgZXh0ZW5kKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSwgZGVlcCk7XG4gICAgfSBlbHNlIGlmIChzb3VyY2Vba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkYXNoZXJpemUoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvOjovZywgJy8nKS5yZXBsYWNlKC8oW0EtWl0rKShbQS1aXVthLXpdKS9nLCAnJDFfJDInKS5yZXBsYWNlKC8oW2EtelxcZF0pKFtBLVpdKS9nLCAnJDFfJDInKS5yZXBsYWNlKC9fL2csICctJykudG9Mb3dlckNhc2UoKTtcbn1cblxuZnVuY3Rpb24gbWF5YmVBZGRQeChuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgJiYgIWNzc051bWJlcltkYXNoZXJpemUobmFtZSldID8gdmFsdWUgKyBcInB4XCIgOiB2YWx1ZTtcbn1cblxudmFyIERvbSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIERvbSA9IGZ1bmN0aW9uIERvbShhcnIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICBpID0gMDsgLy8gQ3JlYXRlIGFycmF5LWxpa2Ugb2JqZWN0XG5cblxuICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIF90aGlzW2ldID0gYXJyW2ldO1xuICAgIH1cblxuICAgIF90aGlzLmxlbmd0aCA9IGFyci5sZW5ndGg7IC8vIFJldHVybiBjb2xsZWN0aW9uIHdpdGggbWV0aG9kc1xuXG4gICAgcmV0dXJuICQodGhpcyk7XG4gIH07XG5cbiAgdmFyICQgPSBmdW5jdGlvbiAkKHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIGFyciA9IFtdLFxuICAgICAgICBpID0gMDtcblxuICAgIGlmIChzZWxlY3RvciAmJiAhY29udGV4dCkge1xuICAgICAgaWYgKHNlbGVjdG9yIGluc3RhbmNlb2YgRG9tKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbihzZWxlY3RvcikpIHtcbiAgICAgIHJldHVybiAkKGRvY3VtZW50KS5yZWFkeShzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAvLyBTdHJpbmdcbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBlbHMsIHRlbXBQYXJlbnQsIGh0bWw7XG4gICAgICAgIHNlbGVjdG9yID0gaHRtbCA9IHNlbGVjdG9yLnRyaW0oKTtcblxuICAgICAgICBpZiAoaHRtbC5pbmRleE9mKCc8JykgPj0gMCAmJiBodG1sLmluZGV4T2YoJz4nKSA+PSAwKSB7XG4gICAgICAgICAgdmFyIHRvQ3JlYXRlID0gJ2Rpdic7XG5cbiAgICAgICAgICBpZiAoaHRtbC5pbmRleE9mKCc8bGknKSA9PT0gMCkge1xuICAgICAgICAgICAgdG9DcmVhdGUgPSAndWwnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChodG1sLmluZGV4T2YoJzx0cicpID09PSAwKSB7XG4gICAgICAgICAgICB0b0NyZWF0ZSA9ICd0Ym9keSc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGh0bWwuaW5kZXhPZignPHRkJykgPT09IDAgfHwgaHRtbC5pbmRleE9mKCc8dGgnKSA9PT0gMCkge1xuICAgICAgICAgICAgdG9DcmVhdGUgPSAndHInO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChodG1sLmluZGV4T2YoJzx0Ym9keScpID09PSAwKSB7XG4gICAgICAgICAgICB0b0NyZWF0ZSA9ICd0YWJsZSc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGh0bWwuaW5kZXhPZignPG9wdGlvbicpID09PSAwKSB7XG4gICAgICAgICAgICB0b0NyZWF0ZSA9ICdzZWxlY3QnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRlbXBQYXJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRvQ3JlYXRlKTtcbiAgICAgICAgICB0ZW1wUGFyZW50LmlubmVySFRNTCA9IGh0bWw7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGVtcFBhcmVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcnIucHVzaCh0ZW1wUGFyZW50LmNoaWxkTm9kZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWNvbnRleHQgJiYgc2VsZWN0b3JbMF0gPT09ICcjJyAmJiAhc2VsZWN0b3IubWF0Y2goL1sgLjw+On5dLykpIHtcbiAgICAgICAgICAgIC8vIFB1cmUgSUQgc2VsZWN0b3JcbiAgICAgICAgICAgIGVscyA9IFtkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzZWxlY3Rvci5zcGxpdCgnIycpWzFdKV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjb250ZXh0IGluc3RhbmNlb2YgRG9tKSB7XG4gICAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0WzBdO1xuICAgICAgICAgICAgfSAvLyBPdGhlciBzZWxlY3RvcnNcblxuXG4gICAgICAgICAgICBlbHMgPSAoY29udGV4dCB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGVsc1tpXSkge1xuICAgICAgICAgICAgICBhcnIucHVzaChlbHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBOb2RlL2VsZW1lbnRcbiAgICAgIGVsc2UgaWYgKHNlbGVjdG9yLm5vZGVUeXBlIHx8IHNlbGVjdG9yID09PSB3aW5kb3cgfHwgc2VsZWN0b3IgPT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgYXJyLnB1c2goc2VsZWN0b3IpO1xuICAgICAgICB9IC8vQXJyYXkgb2YgZWxlbWVudHMgb3IgaW5zdGFuY2Ugb2YgRG9tXG4gICAgICAgIGVsc2UgaWYgKHNlbGVjdG9yLmxlbmd0aCA+IDAgJiYgc2VsZWN0b3JbMF0ubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWxlY3Rvci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBhcnIucHVzaChzZWxlY3RvcltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICgkLmlzQXJyYXkoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICBhcnIgPSBzZWxlY3RvcjtcbiAgICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEb20oYXJyKTtcbiAgfTtcblxuICBEb20ucHJvdG90eXBlID0ge1xuICAgIHJlYWR5OiBmdW5jdGlvbiByZWFkeShjYWxsYmFjaykge1xuICAgICAgaWYgKGRvY3VtZW50LmF0dGFjaEV2ZW50ID8gZG9jdW1lbnQucmVhZHlTdGF0ZSA9PSAnY29tcGxldGUnIDogZG9jdW1lbnQucmVhZHlTdGF0ZSAhPSAnbG9hZGluZycpIHtcbiAgICAgICAgY2FsbGJhY2soJCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbGxiYWNrKCQpO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgY29uY2F0OiBlbXB0eUFycmF5LmNvbmNhdCxcbiAgICBlbXB0eTogZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbm5lckhUTUwgPSAnJztcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgbWFwOiBmdW5jdGlvbiBtYXAoZm4pIHtcbiAgICAgIHJldHVybiAkKCQubWFwKHRoaXMsIGZ1bmN0aW9uIChlbCwgaSkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbChlbCwgaSwgZWwpO1xuICAgICAgfSkpO1xuICAgIH0sXG4gICAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKCkge1xuICAgICAgcmV0dXJuICQoX3NsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH0sXG4gICAgLy8gQ2xhc3NlcyBhbmQgYXR0cml1dGVzXG4gICAgLy8gTk9URTogZWxlbWVudC5jbGFzc0xpc3QgYXR0cmlidXJlIGlzIG5vdCBzdXBwb3J0ZWQgb24gYW5kcm9pZCAyLjMhISFcbiAgICBhZGRDbGFzczogZnVuY3Rpb24gYWRkQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIGNsYXNzTmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBjbGFzc2VzID0gY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXNbal0uY2xhc3NMaXN0ICE9PSAndW5kZWZpbmVkJyAmJiBjbGFzc2VzW2ldICE9PSAnJykge1xuICAgICAgICAgICAgdGhpc1tqXS5jbGFzc0xpc3QuYWRkKGNsYXNzZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbiByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIGNsYXNzZXMgPSBjbGFzc05hbWUuc3BsaXQoJyAnKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpc1tqXS5jbGFzc0xpc3QgIT09ICd1bmRlZmluZWQnICYmIGNsYXNzZXNbaV0gIT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzW2pdLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3Nlc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgaGFzQ2xhc3M6IGZ1bmN0aW9uIGhhc0NsYXNzKGNsYXNzTmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXNbMF0gPyB0aGlzWzBdLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpIDogZmFsc2U7XG4gICAgfSxcbiAgICB0b2dnbGVDbGFzczogZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgICB2YXIgY2xhc3NlcyA9IGNsYXNzTmFtZS5zcGxpdCgnICcpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzW2pdLmNsYXNzTGlzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXNbal0uY2xhc3NMaXN0LnRvZ2dsZShjbGFzc2VzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBjbG9zZXN0OiBmdW5jdGlvbiBjbG9zZXN0KHNlbGVjdG9yLCBjb250ZXh0KSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXNbMF0sXG4gICAgICAgICAgY29sbGVjdGlvbiA9IGZhbHNlO1xuXG4gICAgICBpZiAoaXNPYmplY3Qoc2VsZWN0b3IpKSB7XG4gICAgICAgIGNvbGxlY3Rpb24gPSAkKHNlbGVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKG5vZGUgJiYgIShjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5pbmRleE9mKG5vZGUpID49IDAgOiBtYXRjaGVzKG5vZGUsIHNlbGVjdG9yKSkpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUgIT09IGNvbnRleHQgJiYgbm9kZS5ub2RlVHlwZSAhPT0gbm9kZS5ET0NVTUVOVF9OT0RFICYmIG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICQobm9kZSk7XG4gICAgfSxcbiAgICBhdHRyOiBmdW5jdGlvbiBhdHRyKGF0dHJzLCB2YWx1ZSkge1xuICAgICAgdmFyIGF0dHI7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhdHRycyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gR2V0IGF0dHJcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgYXR0ciA9IHRoaXNbMF0uZ2V0QXR0cmlidXRlKGF0dHJzKTtcbiAgICAgICAgICByZXR1cm4gYXR0ciB8fCBhdHRyID09PSAnJyA/IGF0dHIgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNldCBhdHRyc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgLy8gU3RyaW5nXG4gICAgICAgICAgICB0aGlzW2ldLnNldEF0dHJpYnV0ZShhdHRycywgdmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPYmplY3RcbiAgICAgICAgICAgIGZvciAodmFyIGF0dHJOYW1lIGluIGF0dHJzKSB7XG4gICAgICAgICAgICAgIHRoaXNbaV1bYXR0ck5hbWVdID0gYXR0cnNbYXR0ck5hbWVdO1xuICAgICAgICAgICAgICB0aGlzW2ldLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0cnNbYXR0ck5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZUF0dHI6IGZ1bmN0aW9uIHJlbW92ZUF0dHIoYXR0cikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXNbaV0ucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHByb3A6IGZ1bmN0aW9uIHByb3AocHJvcHMsIHZhbHVlKSB7XG4gICAgICBwcm9wcyA9IHByb3BNYXBbcHJvcHNdIHx8IHByb3BzO1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgcHJvcHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEdldCBwcm9wXG4gICAgICAgIHJldHVybiB0aGlzWzBdID8gdGhpc1swXVtwcm9wc10gOiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTZXQgcHJvcHNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpc1tpXVtwcm9wc10gPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsOiBmdW5jdGlvbiB2YWwodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCAmJiB0aGlzWzBdLm11bHRpcGxlKSB7XG4gICAgICAgICAgcmV0dXJuICQubWFwKHRoaXMuZmluZCgnb3B0aW9uOmNoZWNrZWQnKSwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB2LnZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXNbMF0gPyB0aGlzWzBdLnZhbHVlIDogdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5sZW5ndGggJiYgdGhpc1swXS5tdWx0aXBsZSkge1xuICAgICAgICAkLmVhY2godGhpc1swXS5vcHRpb25zLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHZhbHVlLmluZGV4T2YodGhpcy52YWx1ZSkgIT0gLTE7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpc1tpXS52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy9FdmVudHNcbiAgICBvbjogZnVuY3Rpb24gb24oZXZlbnROYW1lLCB0YXJnZXRTZWxlY3RvciwgbGlzdGVuZXIsIGNhcHR1cmUpIHtcbiAgICAgIHZhciBib3VuZExpc3RlbmVyLFxuICAgICAgICAgIGVsbSxcbiAgICAgICAgICBldmVudCxcbiAgICAgICAgICBldmVudHMgPSBldmVudE5hbWUuc3BsaXQoJyAnKSxcbiAgICAgICAgICBpLFxuICAgICAgICAgIGo7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUxpdmVFdmVudChlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcblxuICAgICAgICB3aGlsZSAodGFyZ2V0KSB7XG4gICAgICAgICAgaWYgKCQodGFyZ2V0KS5pcyh0YXJnZXRTZWxlY3RvcikpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGFyZ2V0LCBlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQgIT09IHRoaXMgPyB0YXJnZXQucGFyZW50Tm9kZSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaGFuZGxlTmFtZXNwYWNlcyhlbCwgbmFtZSwgbGlzdGVuZXIsIGNhcHR1cmUpIHtcbiAgICAgICAgdmFyIG5hbWVzcGFjZSA9IG5hbWUuc3BsaXQoJy4nKTtcblxuICAgICAgICBpZiAoIWVsLkRvbU5hbWVTcGFjZXMpIHtcbiAgICAgICAgICBlbC5Eb21OYW1lU3BhY2VzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBlbC5Eb21OYW1lU3BhY2VzLnB1c2goe1xuICAgICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlWzFdLFxuICAgICAgICAgIGV2ZW50OiBuYW1lc3BhY2VbMF0sXG4gICAgICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyLFxuICAgICAgICAgIGNhcHR1cmU6IGNhcHR1cmVcbiAgICAgICAgfSk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIobmFtZXNwYWNlWzBdLCBsaXN0ZW5lciwgY2FwdHVyZSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVsbSA9IHRoaXNbaV07XG5cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odGFyZ2V0U2VsZWN0b3IpIHx8IHRhcmdldFNlbGVjdG9yID09PSBmYWxzZSkge1xuICAgICAgICAgIC8vIFVzdWFsIGV2ZW50c1xuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRhcmdldFNlbGVjdG9yKSkge1xuICAgICAgICAgICAgY2FwdHVyZSA9IGxpc3RlbmVyIHx8IGZhbHNlO1xuICAgICAgICAgICAgbGlzdGVuZXIgPSB0YXJnZXRTZWxlY3RvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZXZlbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBldmVudCA9IGV2ZW50c1tqXTsgLy8gY2hlY2sgZm9yIG5hbWVzcGFjZXNcblxuICAgICAgICAgICAgaWYgKGV2ZW50LmluZGV4T2YoJy4nKSAhPSAtMSkge1xuICAgICAgICAgICAgICBoYW5kbGVOYW1lc3BhY2VzKGVsbSwgZXZlbnQsIGxpc3RlbmVyLCBjYXB0dXJlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgY2FwdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIExpdmUgZXZlbnRzXG4gICAgICAgICAgYm91bmRMaXN0ZW5lciA9IGhhbmRsZUxpdmVFdmVudC5iaW5kKGVsbSk7XG5cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZXZlbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBldmVudCA9IGV2ZW50c1tqXTtcblxuICAgICAgICAgICAgaWYgKCFlbG0uRG9tTGl2ZUxpc3RlbmVycykge1xuICAgICAgICAgICAgICBlbG0uRG9tTGl2ZUxpc3RlbmVycyA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbG0uRG9tTGl2ZUxpc3RlbmVycy5wdXNoKHtcbiAgICAgICAgICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyLFxuICAgICAgICAgICAgICBsaXZlTGlzdGVuZXI6IGJvdW5kTGlzdGVuZXJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoZXZlbnQuaW5kZXhPZignLicpICE9IC0xKSB7XG4gICAgICAgICAgICAgIGhhbmRsZU5hbWVzcGFjZXMoZWxtLCBldmVudCwgYm91bmRMaXN0ZW5lciwgY2FwdHVyZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbG0uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgYm91bmRMaXN0ZW5lciwgY2FwdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgb2ZmOiBmdW5jdGlvbiBvZmYoZXZlbnROYW1lLCB0YXJnZXRTZWxlY3RvciwgbGlzdGVuZXIsIGNhcHR1cmUpIHtcbiAgICAgIHZhciBlbG0sXG4gICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgZXZlbnRzLFxuICAgICAgICAgIGksXG4gICAgICAgICAgaixcbiAgICAgICAgICBrLFxuICAgICAgICAgIGxpdmVMaXN0ZW5lcnMsXG4gICAgICAgICAgdGhhdCA9IHRoaXM7XG5cbiAgICAgIGZ1bmN0aW9uIHJlbW92ZUV2ZW50cyhldmVudCkge1xuICAgICAgICB2YXIgZWwsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICBuYW1lU3BhY2VzLFxuICAgICAgICAgICAgcGFydHMgPSBldmVudC5zcGxpdCgnLicpLFxuICAgICAgICAgICAgbmFtZSA9IHBhcnRzWzBdLFxuICAgICAgICAgICAgbnMgPSBwYXJ0c1sxXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhhdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGVsID0gdGhhdFtpXTtcbiAgICAgICAgICBuYW1lU3BhY2VzID0gZWwuRG9tTmFtZVNwYWNlcztcblxuICAgICAgICAgIGlmIChuYW1lU3BhY2VzKSB7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbmFtZVNwYWNlcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICBpdGVtID0gbmFtZVNwYWNlc1tqXTtcblxuICAgICAgICAgICAgICBpZiAoaXRlbS5uYW1lc3BhY2UgPT0gbnMgJiYgKGl0ZW0uZXZlbnQgPT0gbmFtZSB8fCAhbmFtZSkpIHtcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGl0ZW0uZXZlbnQsIGl0ZW0ubGlzdGVuZXIsIGl0ZW0uY2FwdHVyZSk7XG4gICAgICAgICAgICAgICAgaXRlbS5yZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyByZW1vdmUgdGhlIGV2ZW50cyBmcm9tIHRoZSBEb21OYW1lU3BhY2VzIGFycmF5XG5cblxuICAgICAgICAgICAgZm9yIChqID0gbmFtZVNwYWNlcy5sZW5ndGggLSAxOyBqID49IDA7IC0taikge1xuICAgICAgICAgICAgICBpZiAobmFtZVNwYWNlc1tqXS5yZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgbmFtZVNwYWNlcy5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZXZlbnRzID0gZXZlbnROYW1lLnNwbGl0KCcgJyk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZXZlbnQgPSBldmVudHNbaV07XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBlbG0gPSB0aGlzW2pdO1xuICAgICAgICAgIGxpdmVMaXN0ZW5lcnMgPSBlbG0uRG9tTGl2ZUxpc3RlbmVycztcblxuICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRhcmdldFNlbGVjdG9yKSB8fCB0YXJnZXRTZWxlY3RvciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIFVzdWFsIGV2ZW50c1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGFyZ2V0U2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmUgPSBsaXN0ZW5lciB8fCBmYWxzZTtcbiAgICAgICAgICAgICAgbGlzdGVuZXIgPSB0YXJnZXRTZWxlY3RvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV2ZW50LmluZGV4T2YoJy4nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAvLyByZW1vdmUgbmFtZXNwYWNlIGV2ZW50c1xuICAgICAgICAgICAgICByZW1vdmVFdmVudHMoZXZlbnQuc3Vic3RyKDEpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsbS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgY2FwdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIExpdmUgZXZlbnRcbiAgICAgICAgICAgIGlmIChsaXZlTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBsaXZlTGlzdGVuZXJzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpdmVMaXN0ZW5lcnNba10ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICBlbG0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGl2ZUxpc3RlbmVyc1trXS5saXZlTGlzdGVuZXIsIGNhcHR1cmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxtLkRvbU5hbWVTcGFjZXMgJiYgZWxtLkRvbU5hbWVTcGFjZXMubGVuZ3RoICYmIGV2ZW50KSB7XG4gICAgICAgICAgICAgIHJlbW92ZUV2ZW50cyhldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlciQxKGV2ZW50TmFtZSwgZXZlbnREYXRhKSB7XG4gICAgICB2YXIgZXZlbnRzID0gZXZlbnROYW1lLnNwbGl0KCcgJyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHRyaWdnZXIodGhpc1tqXSwgZXZlbnRzW2ldLCBldmVudERhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gU2l6aW5nL1N0eWxlc1xuICAgIHdpZHRoOiBmdW5jdGlvbiB3aWR0aChkaW0pIHtcbiAgICAgIGlmIChkaW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jc3MoJ3dpZHRoJywgZGltKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNbMF0gPT09IHdpbmRvdykge1xuICAgICAgICByZXR1cm4gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICB9IGVsc2UgaWYgKHRoaXNbMF0gPT09IGRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggPiAwID8gcGFyc2VGbG9hdCh0aGlzLmNzcygnd2lkdGgnKSkgOiBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgaGVpZ2h0OiBmdW5jdGlvbiBoZWlnaHQoZGltKSB7XG4gICAgICBpZiAoZGltICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3NzKCdoZWlnaHQnLCBkaW0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpc1swXSA9PT0gd2luZG93KSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKHRoaXNbMF0gPT09IGRvY3VtZW50KSB7XG4gICAgICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keSxcbiAgICAgICAgICAgIGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChib2R5LnNjcm9sbEhlaWdodCwgYm9keS5vZmZzZXRIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5vZmZzZXRIZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID4gMCA/IHBhcnNlRmxvYXQodGhpcy5jc3MoJ2hlaWdodCcpKSA6IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBpbm5lcldpZHRoOiBmdW5jdGlvbiBpbm5lcldpZHRoKCkge1xuICAgICAgdmFyIGVsbSA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHRoaXNbMF0uaW5uZXJXaWR0aCkge1xuICAgICAgICAgIHJldHVybiB0aGlzWzBdLmlubmVyV2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNpemUgPSB0aGlzWzBdLm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgICBzaWRlcyA9IFsnbGVmdCcsICdyaWdodCddO1xuICAgICAgICAgIHNpZGVzLmZvckVhY2goZnVuY3Rpb24gKHNpZGUpIHtcbiAgICAgICAgICAgIHNpemUgLT0gcGFyc2VJbnQoZWxtLmNzcyhjYW1lbGl6ZSgnYm9yZGVyLScgKyBzaWRlICsgJy13aWR0aCcpKSB8fCAwLCAxMCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGlubmVySGVpZ2h0OiBmdW5jdGlvbiBpbm5lckhlaWdodCgpIHtcbiAgICAgIHZhciBlbG0gPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICh0aGlzWzBdLmlubmVySGVpZ2h0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXNbMF0uaW5uZXJIZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNpemUgPSB0aGlzWzBdLm9mZnNldEhlaWdodCxcbiAgICAgICAgICAgICAgc2lkZXMgPSBbJ3RvcCcsICdib3R0b20nXTtcbiAgICAgICAgICBzaWRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgICAgICAgICBzaXplIC09IHBhcnNlSW50KGVsbS5jc3MoY2FtZWxpemUoJ2JvcmRlci0nICsgc2lkZSArICctd2lkdGgnKSkgfHwgMCwgMTApO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBzaXplO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBvZmZzZXQ6IGZ1bmN0aW9uIG9mZnNldCgpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGVsID0gdGhpc1swXSxcbiAgICAgICAgICAgIGJveCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgZG9jID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvcDogYm94LnRvcCArIHdpbmRvdy5wYWdlWU9mZnNldCAtIGRvYy5jbGllbnRUb3AsXG4gICAgICAgICAgbGVmdDogYm94LmxlZnQgKyB3aW5kb3cucGFnZVhPZmZzZXQgLSBkb2MuY2xpZW50TGVmdFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgaGlkZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzW2ldLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc2hvdzogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpc1tpXS5zdHlsZS5kaXNwbGF5ID09IFwibm9uZVwiKSB7XG4gICAgICAgICAgdGhpc1tpXS5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzW2ldLCAnJykuZ2V0UHJvcGVydHlWYWx1ZShcImRpc3BsYXlcIikgPT0gXCJub25lXCIpIHtcbiAgICAgICAgICB0aGlzW2ldLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBzdHlsZXM6IGZ1bmN0aW9uIHN0eWxlcygpIHtcbiAgICAgIHJldHVybiB0aGlzWzBdID8gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpc1swXSwgbnVsbCkgOiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBjc3M6IGZ1bmN0aW9uIGNzcyhwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIGtleSxcbiAgICAgICAgICBlbGVtZW50ID0gdGhpc1swXSxcbiAgICAgICAgICBjc3MgPSAnJztcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQuc3R5bGVbcHJvcGVydHldIHx8IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgJycpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghdmFsdWUgJiYgdmFsdWUgIT09IDApIHtcbiAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShkYXNoZXJpemUocHJvcGVydHkpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjc3MgPSBkYXNoZXJpemUocHJvcGVydHkpICsgXCI6XCIgKyBtYXliZUFkZFB4KHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoa2V5IGluIHByb3BlcnR5KSB7XG4gICAgICAgICAgaWYgKCFwcm9wZXJ0eVtrZXldICYmIHByb3BlcnR5W2tleV0gIT09IDApIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHRoaXNbaV0uc3R5bGUucmVtb3ZlUHJvcGVydHkoZGFzaGVyaXplKGtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjc3MgKz0gZGFzaGVyaXplKGtleSkgKyAnOicgKyBtYXliZUFkZFB4KGtleSwgcHJvcGVydHlba2V5XSkgKyAnOyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0eWxlLmNzc1RleHQgKz0gJzsnICsgY3NzO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBlYWNoOiBmdW5jdGlvbiBlYWNoKGNhbGxiYWNrKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrLmFwcGx5KHRoaXNbaV0sIFtpLCB0aGlzW2ldXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFjaykge1xuICAgICAgdmFyIG1hdGNoZWRJdGVtcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrLmNhbGwodGhpc1tpXSwgaSwgdGhpc1tpXSkpIHtcbiAgICAgICAgICAgIG1hdGNoZWRJdGVtcy5wdXNoKHRoaXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaGVzKHRoaXNbaV0sIGNhbGxiYWNrKSkge1xuICAgICAgICAgIG1hdGNoZWRJdGVtcy5wdXNoKHRoaXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgRG9tKG1hdGNoZWRJdGVtcyk7XG4gICAgfSxcbiAgICBodG1sOiBmdW5jdGlvbiBodG1sKF9odG1sKSB7XG4gICAgICBpZiAodHlwZW9mIF9odG1sID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gdGhpc1swXSA/IHRoaXNbMF0uaW5uZXJIVE1MIDogdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbXB0eSgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXNbaV0uaW5uZXJIVE1MID0gX2h0bWw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9LFxuICAgIHRleHQ6IGZ1bmN0aW9uIHRleHQoX3RleHQpIHtcbiAgICAgIGlmICh0eXBlb2YgX3RleHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzWzBdID8gdGhpc1swXS50ZXh0Q29udGVudC50cmltKCkgOiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpc1tpXS50ZXh0Q29udGVudCA9IF90ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSxcbiAgICBpczogZnVuY3Rpb24gaXMoc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA+IDAgJiYgbWF0Y2hlcyh0aGlzWzBdLCBzZWxlY3Rvcik7XG4gICAgfSxcbiAgICBub3Q6IGZ1bmN0aW9uIG5vdChzZWxlY3Rvcikge1xuICAgICAgdmFyIG5vZGVzID0gW107XG5cbiAgICAgIGlmIChpc0Z1bmN0aW9uKHNlbGVjdG9yKSAmJiBzZWxlY3Rvci5jYWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICBpZiAoIXNlbGVjdG9yLmNhbGwodGhpcywgaWR4KSkge1xuICAgICAgICAgICAgbm9kZXMucHVzaCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGV4Y2x1ZGVzID0gdHlwZW9mIHNlbGVjdG9yID09ICdzdHJpbmcnID8gdGhpcy5maWx0ZXIoc2VsZWN0b3IpIDogbGlrZUFycmF5KHNlbGVjdG9yKSAmJiBpc0Z1bmN0aW9uKHNlbGVjdG9yLml0ZW0pID8gX3NsaWNlLmNhbGwoc2VsZWN0b3IpIDogJChzZWxlY3Rvcik7XG5cbiAgICAgICAgaWYgKGlzT2JqZWN0KGV4Y2x1ZGVzKSkge1xuICAgICAgICAgIGV4Y2x1ZGVzID0gJC5tYXAoZXhjbHVkZXMsIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChpLCBlbCkge1xuICAgICAgICAgIGlmIChleGNsdWRlcy5pbmRleE9mKGVsKSA8IDApIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2goZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAkKG5vZGVzKTtcbiAgICB9LFxuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2YoZWwpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpc1tpXSA9PT0gZWwpIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgaW5kZXg6IGZ1bmN0aW9uIGluZGV4KGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50ID8gdGhpcy5pbmRleE9mKCQoZWxlbWVudClbMF0pIDogdGhpcy5wYXJlbnQoKS5jaGlsZHJlbigpLmluZGV4T2YodGhpc1swXSk7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldChpZHgpIHtcbiAgICAgIHJldHVybiBpZHggPT09IHVuZGVmaW5lZCA/IF9zbGljZS5jYWxsKHRoaXMpIDogdGhpc1tpZHggPj0gMCA/IGlkeCA6IGlkeCArIHRoaXMubGVuZ3RoXTtcbiAgICB9LFxuICAgIGVxOiBmdW5jdGlvbiBlcShpbmRleCkge1xuICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgICByZXR1cm5JbmRleDtcblxuICAgICAgaWYgKGluZGV4ID4gbGVuZ3RoIC0gMSkge1xuICAgICAgICByZXR1cm4gbmV3IERvbShbXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgcmV0dXJuSW5kZXggPSBsZW5ndGggKyBpbmRleDtcbiAgICAgICAgcmV0dXJuIHJldHVybkluZGV4IDwgMCA/IG5ldyBEb20oW10pIDogbmV3IERvbShbdGhpc1tyZXR1cm5JbmRleF1dKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBEb20oW3RoaXNbaW5kZXhdXSk7XG4gICAgfSxcbiAgICBhcHBlbmQ6IGZ1bmN0aW9uIGFwcGVuZChuZXdDaGlsZCkge1xuICAgICAgdmFyIGksIGo7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIHRlbXBEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICB0ZW1wRGl2LmlubmVySFRNTCA9IG5ld0NoaWxkO1xuXG4gICAgICAgICAgd2hpbGUgKHRlbXBEaXYuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgdGhpc1tpXS5hcHBlbmRDaGlsZCh0ZW1wRGl2LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChuZXdDaGlsZCBpbnN0YW5jZW9mIERvbSkge1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBuZXdDaGlsZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdGhpc1tpXS5hcHBlbmRDaGlsZChuZXdDaGlsZFtqXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXNbaV0uYXBwZW5kQ2hpbGQobmV3Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgYXBwZW5kVG86IGZ1bmN0aW9uIGFwcGVuZFRvKHBhcmVudCkge1xuICAgICAgJChwYXJlbnQpLmFwcGVuZCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcHJlcGVuZDogZnVuY3Rpb24gcHJlcGVuZChuZXdDaGlsZCkge1xuICAgICAgdmFyIGksIGo7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdmFyIHRlbXBEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICB0ZW1wRGl2LmlubmVySFRNTCA9IG5ld0NoaWxkO1xuXG4gICAgICAgICAgZm9yIChqID0gdGVtcERpdi5jaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICB0aGlzW2ldLmluc2VydEJlZm9yZSh0ZW1wRGl2LmNoaWxkTm9kZXNbal0sIHRoaXNbaV0uY2hpbGROb2Rlc1swXSk7XG4gICAgICAgICAgfSAvLyB0aGlzW2ldLmluc2VydEFkamFjZW50SFRNTCgnYWZ0ZXJiZWdpbicsIG5ld0NoaWxkKTtcblxuICAgICAgICB9IGVsc2UgaWYgKG5ld0NoaWxkIGluc3RhbmNlb2YgRG9tKSB7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IG5ld0NoaWxkLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB0aGlzW2ldLmluc2VydEJlZm9yZShuZXdDaGlsZFtqXSwgdGhpc1tpXS5jaGlsZE5vZGVzWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpc1tpXS5pbnNlcnRCZWZvcmUobmV3Q2hpbGQsIHRoaXNbaV0uY2hpbGROb2Rlc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBwcmVwZW5kVG86IGZ1bmN0aW9uIHByZXBlbmRUbyhwYXJlbnQpIHtcbiAgICAgICQocGFyZW50KS5wcmVwZW5kKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uIGluc2VydEJlZm9yZShzZWxlY3Rvcikge1xuICAgICAgdmFyIGJlZm9yZSA9ICQoc2VsZWN0b3IpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGJlZm9yZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBiZWZvcmVbMF0ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpc1tpXSwgYmVmb3JlWzBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChiZWZvcmUubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYmVmb3JlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBiZWZvcmVbal0ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpc1tpXS5jbG9uZU5vZGUodHJ1ZSksIGJlZm9yZVtqXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgaW5zZXJ0QWZ0ZXI6IGZ1bmN0aW9uIGluc2VydEFmdGVyKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgYWZ0ZXIgPSAkKHNlbGVjdG9yKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhZnRlci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBhZnRlclswXS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzW2ldLCBhZnRlclswXS5uZXh0U2libGluZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoYWZ0ZXIubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYWZ0ZXIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGFmdGVyW2pdLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXNbaV0uY2xvbmVOb2RlKHRydWUpLCBhZnRlcltqXS5uZXh0U2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgbmV4dDogZnVuY3Rpb24gbmV4dChzZWxlY3Rvcikge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICBpZiAodGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmcgJiYgJCh0aGlzWzBdLm5leHRFbGVtZW50U2libGluZykuaXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERvbShbdGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmddKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEb20oW10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpc1swXS5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRG9tKFt0aGlzWzBdLm5leHRFbGVtZW50U2libGluZ10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERvbShbXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IERvbShbXSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBuZXh0QWxsOiBmdW5jdGlvbiBuZXh0QWxsKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgbmV4dEVscyA9IFtdLFxuICAgICAgICAgIGVsID0gdGhpc1swXTtcblxuICAgICAgaWYgKCFlbCkge1xuICAgICAgICByZXR1cm4gbmV3IERvbShbXSk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChlbC5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICAgICAgdmFyIG5leHQgPSBlbC5uZXh0RWxlbWVudFNpYmxpbmc7XG5cbiAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgaWYgKCQobmV4dCkuaXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICBuZXh0RWxzLnB1c2gobmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRFbHMucHVzaChuZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsID0gbmV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBEb20obmV4dEVscyk7XG4gICAgfSxcbiAgICBwcmV2OiBmdW5jdGlvbiBwcmV2KHNlbGVjdG9yKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgIGlmICh0aGlzWzBdLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgJiYgJCh0aGlzWzBdLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpLmlzKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEb20oW3RoaXNbMF0ucHJldmlvdXNFbGVtZW50U2libGluZ10pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERvbShbXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzWzBdLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRG9tKFt0aGlzWzBdLnByZXZpb3VzRWxlbWVudFNpYmxpbmddKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEb20oW10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEb20oW10pO1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJldkFsbDogZnVuY3Rpb24gcHJldkFsbChzZWxlY3Rvcikge1xuICAgICAgdmFyIHByZXZFbHMgPSBbXTtcbiAgICAgIHZhciBlbCA9IHRoaXNbMF07XG5cbiAgICAgIGlmICghZWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEb20oW10pO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoZWwucHJldmlvdXNFbGVtZW50U2libGluZykge1xuICAgICAgICB2YXIgcHJldiA9IGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG5cbiAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgaWYgKCQocHJldikuaXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICBwcmV2RWxzLnB1c2gocHJldik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZFbHMucHVzaChwcmV2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsID0gcHJldjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBEb20ocHJldkVscyk7XG4gICAgfSxcbiAgICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChzZWxlY3Rvcikge1xuICAgICAgdmFyIHBhcmVudHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzW2ldLnBhcmVudE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGlmICgkKHRoaXNbaV0ucGFyZW50Tm9kZSkuaXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgIHBhcmVudHMucHVzaCh0aGlzW2ldLnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJlbnRzLnB1c2godGhpc1tpXS5wYXJlbnROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICQoJC51bmlxdWUocGFyZW50cykpO1xuICAgIH0sXG4gICAgcGFyZW50czogZnVuY3Rpb24gcGFyZW50cyhzZWxlY3Rvcikge1xuICAgICAgdmFyIHBhcmVudHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzW2ldLnBhcmVudE5vZGU7XG5cbiAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgaWYgKCQocGFyZW50KS5pcyhzZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgcGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAkKCQudW5pcXVlKHBhcmVudHMpKTtcbiAgICB9LFxuICAgIGZpbmQ6IGZ1bmN0aW9uIGZpbmQoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBmb3VuZEVsZW1lbnRzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZm91bmQgPSB0aGlzW2ldLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZm91bmQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBmb3VuZEVsZW1lbnRzLnB1c2goZm91bmRbal0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgRG9tKGZvdW5kRWxlbWVudHMpO1xuICAgIH0sXG4gICAgY2hpbGRyZW46IGZ1bmN0aW9uIGNoaWxkcmVuKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZE5vZGVzID0gdGhpc1tpXS5jaGlsZE5vZGVzO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2hpbGROb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzW2pdLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGROb2Rlc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzW2pdLm5vZGVUeXBlID09PSAxICYmICQoY2hpbGROb2Rlc1tqXSkuaXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGROb2Rlc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgRG9tKCQudW5pcXVlKGNoaWxkcmVuKSk7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpc1tpXS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgdGhpc1tpXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgYWRkOiBmdW5jdGlvbiBhZGQoKSB7XG4gICAgICB2YXIgZG9tID0gdGhpcztcbiAgICAgIHZhciBpLCBqO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0b0FkZCA9ICQoYXJndW1lbnRzW2ldKTtcblxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgdG9BZGQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBkb21bZG9tLmxlbmd0aF0gPSB0b0FkZFtqXTtcbiAgICAgICAgICBkb20ubGVuZ3RoKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRvbTtcbiAgICB9LFxuICAgIGJlZm9yZTogZnVuY3Rpb24gYmVmb3JlKGVsbSkge1xuICAgICAgJChlbG0pLmluc2VydEJlZm9yZSh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgYWZ0ZXI6IGZ1bmN0aW9uIGFmdGVyKGVsbSkge1xuICAgICAgJChlbG0pLmluc2VydEFmdGVyKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzY3JvbGxUb3A6IGZ1bmN0aW9uIHNjcm9sbFRvcCh2YWx1ZSkge1xuICAgICAgaWYgKCF0aGlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBoYXNTY3JvbGxUb3AgPSAnc2Nyb2xsVG9wJyBpbiB0aGlzWzBdO1xuXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaGFzU2Nyb2xsVG9wID8gdGhpc1swXS5zY3JvbGxUb3AgOiB0aGlzWzBdLnBhZ2VZT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGhhc1Njcm9sbFRvcCA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxUb3AgPSB2YWx1ZTtcbiAgICAgIH0gOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG8odGhpcy5zY3JvbGxYLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNjcm9sbExlZnQ6IGZ1bmN0aW9uIHNjcm9sbExlZnQodmFsdWUpIHtcbiAgICAgIGlmICghdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFzU2Nyb2xsTGVmdCA9ICdzY3JvbGxMZWZ0JyBpbiB0aGlzWzBdO1xuXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaGFzU2Nyb2xsTGVmdCA/IHRoaXNbMF0uc2Nyb2xsTGVmdCA6IHRoaXNbMF0ucGFnZVhPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmVhY2goaGFzU2Nyb2xsTGVmdCA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxMZWZ0ID0gdmFsdWU7XG4gICAgICB9IDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNjcm9sbFRvKHZhbHVlLCB0aGlzLnNjcm9sbFkpO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBjb250ZW50czogZnVuY3Rpb24gY29udGVudHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgICAgcmV0dXJuIF9zbGljZS5jYWxsKHYuY2hpbGROb2Rlcyk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIG5leHRVbnRpbDogZnVuY3Rpb24gbmV4dFVudGlsKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgbiA9IHRoaXMsXG4gICAgICAgICAgYXJyYXkgPSBbXTtcblxuICAgICAgd2hpbGUgKG4ubGVuZ3RoICYmICFuLmZpbHRlcihzZWxlY3RvcikubGVuZ3RoKSB7XG4gICAgICAgIGFycmF5LnB1c2goblswXSk7XG4gICAgICAgIG4gPSBuLm5leHQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICQoYXJyYXkpO1xuICAgIH0sXG4gICAgcHJldlVudGlsOiBmdW5jdGlvbiBwcmV2VW50aWwoc2VsZWN0b3IpIHtcbiAgICAgIHZhciBuID0gdGhpcyxcbiAgICAgICAgICBhcnJheSA9IFtdO1xuXG4gICAgICB3aGlsZSAobi5sZW5ndGggJiYgISQobikuZmlsdGVyKHNlbGVjdG9yKS5sZW5ndGgpIHtcbiAgICAgICAgYXJyYXkucHVzaChuWzBdKTtcbiAgICAgICAgbiA9IG4ucHJldigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJChhcnJheSk7XG4gICAgfSxcbiAgICBkZXRhY2g6IGZ1bmN0aW9uIGRldGFjaCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZSgpO1xuICAgIH1cbiAgfTsgLy8gTGluayB0byBwcm90b3R5cGVcblxuICAkLmZuID0gRG9tLnByb3RvdHlwZTtcbiAgcmV0dXJuICQ7XG59KCk7IC8vIEV4cG9ydCB0byBsb2NhbCBzY29wZVxuXG5cbnZhciAkID0gRG9tOyAvLyBFeHBvcnQgdG8gbW9iaXNjcm9sbFxuXG5tb2Jpc2Nyb2xsLiQgPSBEb207IC8vIERPTSBMaWJyYXJ5IFV0aWxpdGVzXG5cbiQuaW5BcnJheSA9IGZ1bmN0aW9uIChlbGVtLCBhcnJheSwgaSkge1xuICByZXR1cm4gZW1wdHlBcnJheS5pbmRleE9mLmNhbGwoYXJyYXksIGVsZW0sIGkpO1xufTtcblxuJC5leHRlbmQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIHZhciBkZWVwLFxuICAgICAgYXJncyA9IF9zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgaWYgKHR5cGVvZiB0YXJnZXQgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgZGVlcCA9IHRhcmdldDtcbiAgICB0YXJnZXQgPSBhcmdzLnNoaWZ0KCk7XG4gIH1cblxuICB0YXJnZXQgPSB0YXJnZXQgfHwge307XG4gIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoYXJnKSB7XG4gICAgZXh0ZW5kKHRhcmdldCwgYXJnLCBkZWVwKTtcbiAgfSk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG4kLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG4kLmlzQXJyYXkgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KGFycikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG4kLmlzUGxhaW5PYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBpc09iamVjdChvYmopICYmIG9iaiAhPT0gbnVsbCAmJiBvYmogIT09IG9iai53aW5kb3cgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT0gT2JqZWN0LnByb3RvdHlwZTtcbn07XG5cbiQuZWFjaCA9IGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrKSB7XG4gIHZhciBpLCBwcm9wO1xuXG4gIGlmICghaXNPYmplY3Qob2JqKSB8fCAhY2FsbGJhY2spIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoJC5pc0FycmF5KG9iaikgfHwgb2JqIGluc3RhbmNlb2YgRG9tKSB7XG4gICAgLy8gQXJyYXlcbiAgICBmb3IgKGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoY2FsbGJhY2suY2FsbChvYmpbaV0sIGksIG9ialtpXSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBPYmplY3RcbiAgICBmb3IgKHByb3AgaW4gb2JqKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApICYmIHByb3AgIT09ICdsZW5ndGgnKSB7XG4gICAgICAgIGlmIChjYWxsYmFjay5jYWxsKG9ialtwcm9wXSwgcHJvcCwgb2JqW3Byb3BdKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuJC51bmlxdWUgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIHZhciB1bmlxdWUgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmICh1bmlxdWUuaW5kZXhPZihhcnJbaV0pID09PSAtMSkge1xuICAgICAgdW5pcXVlLnB1c2goYXJyW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5pcXVlO1xufTtcblxuJC5tYXAgPSBmdW5jdGlvbiAoZWxlbWVudHMsIGNhbGxiYWNrKSB7XG4gIHZhciB2YWx1ZSxcbiAgICAgIHZhbHVlcyA9IFtdLFxuICAgICAgaSxcbiAgICAgIGtleTtcblxuICBpZiAobGlrZUFycmF5KGVsZW1lbnRzKSkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWUgPSBjYWxsYmFjayhlbGVtZW50c1tpXSwgaSk7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoa2V5IGluIGVsZW1lbnRzKSB7XG4gICAgICB2YWx1ZSA9IGNhbGxiYWNrKGVsZW1lbnRzW2tleV0sIGtleSk7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbHVlcy5sZW5ndGggPiAwID8gJC5mbi5jb25jYXQuYXBwbHkoW10sIHZhbHVlcykgOiB2YWx1ZXM7XG59O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuZnVuY3Rpb24gb2JqZWN0VG9BcnJheShvYmopIHtcbiAgdmFyIGFyciA9IFtdLFxuICAgICAgaTtcblxuICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgYXJyLnB1c2gob2JqW2ldKTtcbiAgfVxuXG4gIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIGFycmF5VG9PYmplY3QoYXJyKSB7XG4gIHZhciBvYmogPSB7fSxcbiAgICAgIGk7XG5cbiAgaWYgKGFycikge1xuICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9ialthcnJbaV1dID0gYXJyW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGlzTnVtZXJpYyhhKSB7XG4gIHJldHVybiBhIC0gcGFyc2VGbG9hdChhKSA+PSAwO1xufVxuXG5mdW5jdGlvbiBpc1N0cmluZyhzKSB7XG4gIHJldHVybiB0eXBlb2YgcyA9PT0gJ3N0cmluZyc7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cmFpbih2YWwsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKHZhbCwgbWF4KSk7XG59XG5cbmZ1bmN0aW9uIHBhZChudW0sIHNpemUpIHtcbiAgbnVtID0gbnVtICsgJyc7XG4gIHNpemUgPSBzaXplIHx8IDI7XG5cbiAgd2hpbGUgKG51bS5sZW5ndGggPCBzaXplKSB7XG4gICAgbnVtID0gJzAnICsgbnVtO1xuICB9XG5cbiAgcmV0dXJuIG51bTtcbn1cblxuZnVuY3Rpb24gdGhyb3R0bGUoZm4sIHRocmVzaGhvbGQpIHtcbiAgdmFyIGxhc3QsIHRpbWVyO1xuICB0aHJlc2hob2xkID0gdGhyZXNoaG9sZCB8fCAxMDA7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLFxuICAgICAgICBub3cgPSArbmV3IERhdGUoKSxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcblxuICAgIGlmIChsYXN0ICYmIG5vdyA8IGxhc3QgKyB0aHJlc2hob2xkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGFzdCA9IG5vdztcbiAgICAgICAgZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICB9LCB0aHJlc2hob2xkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdCA9IG5vdztcbiAgICAgIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdmlicmF0ZSh0aW1lKSB7XG4gIGlmICgndmlicmF0ZScgaW4gbmF2aWdhdG9yKSB7XG4gICAgbmF2aWdhdG9yLnZpYnJhdGUodGltZSB8fCA1MCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UGVyY2VudCh2LCBtaW4sIG1heCkge1xuICByZXR1cm4gKHYgLSBtaW4pICogMTAwIC8gKG1heCAtIG1pbik7XG59XG5cbmZ1bmN0aW9uIGdldEJvb2xBdHRyKGF0dHIsIGRlZiwgJGVsbSkge1xuICB2YXIgdiA9ICRlbG0uYXR0cihhdHRyKTtcbiAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSAnJyA/IGRlZiA6IHYgPT09ICd0cnVlJztcbn1cblxudmFyIHRhcHBlZCA9IDA7XG52YXIgYWxsb3dRdWljaztcblxuZnVuY3Rpb24gcHJldmVudENsaWNrKCkge1xuICAvLyBQcmV2ZW50IGdob3N0IGNsaWNrXG4gIHRhcHBlZCsrO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICB0YXBwZWQtLTtcbiAgfSwgNTAwKTtcbn1cblxuZnVuY3Rpb24gdHJpZ2dlckNsaWNrKGV2LCBjb250cm9sKSB7XG4gIC8vIFByZXZlbnQgZHVwbGljYXRlIHRyaWdnZXJzIG9uIHRoZSBzYW1lIGVsZW1lbnRcbiAgLy8gZS5nLiBhIGZvcm0gY2hlY2tib3ggaW5zaWRlIGEgbGlzdHZpZXcgaXRlbVxuICBpZiAoY29udHJvbC5tYnNjQ2xpY2spIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdG91Y2ggPSAoZXYub3JpZ2luYWxFdmVudCB8fCBldikuY2hhbmdlZFRvdWNoZXNbMF0sXG4gICAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcbiAgZXZ0LmluaXRNb3VzZUV2ZW50KCdjbGljaycsIHRydWUsIHRydWUsIHdpbmRvdywgMSwgdG91Y2guc2NyZWVuWCwgdG91Y2guc2NyZWVuWSwgdG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuICBldnQuaXNNYnNjVGFwID0gdHJ1ZTsgLy8gUHJldmVudCBpb25pYyB0byBidXN0IG91ciBjbGlja1xuICAvLyBUaGlzIHdvcmtzIGZvciBJb25pYyAxIC0gMywgbm90IHN1cmUgYWJvdXQgNFxuXG4gIGV2dC5pc0lvbmljVGFwID0gdHJ1ZTsgLy8gVGhpcyB3aWxsIGFsbG93IGEgY2xpY2sgZmlyZWQgdG9nZXRoZXIgd2l0aCB0aGlzIGNsaWNrXG4gIC8vIFdlIG5lZWQgdGhpcywgYmVjYXVzZSBjbGlja2luZyBvbiBhIGxhYmVsIHdpbGwgdHJpZ2dlciBhIGNsaWNrXG4gIC8vIG9uIHRoZSBhc3NvY2lhdGVkIGlucHV0IGFzIHdlbGwsIHdoaWNoIHNob3VsZCBub3QgYmUgYnVzdGVkXG5cbiAgYWxsb3dRdWljayA9IHRydWU7XG4gIGNvbnRyb2wubWJzY0NoYW5nZSA9IHRydWU7XG4gIGNvbnRyb2wubWJzY0NsaWNrID0gdHJ1ZTtcbiAgY29udHJvbC5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gIGFsbG93UXVpY2sgPSBmYWxzZTsgLy8gUHJldmVudCBnaG9zdCBjbGlja1xuXG4gIHByZXZlbnRDbGljaygpO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBkZWxldGUgY29udHJvbC5tYnNjQ2xpY2s7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRDb29yZChlLCBjLCBwYWdlKSB7XG4gIHZhciBldiA9IGUub3JpZ2luYWxFdmVudCB8fCBlLFxuICAgICAgcHJvcCA9IChwYWdlID8gJ3BhZ2UnIDogJ2NsaWVudCcpICsgYzsgLy8gTXVsdGkgdG91Y2ggc3VwcG9ydFxuXG4gIGlmIChldi50YXJnZXRUb3VjaGVzICYmIGV2LnRhcmdldFRvdWNoZXNbMF0pIHtcbiAgICByZXR1cm4gZXYudGFyZ2V0VG91Y2hlc1swXVtwcm9wXTtcbiAgfVxuXG4gIGlmIChldi5jaGFuZ2VkVG91Y2hlcyAmJiBldi5jaGFuZ2VkVG91Y2hlc1swXSkge1xuICAgIHJldHVybiBldi5jaGFuZ2VkVG91Y2hlc1swXVtwcm9wXTtcbiAgfVxuXG4gIHJldHVybiBlW3Byb3BdO1xufVxuXG5mdW5jdGlvbiBnZXRDb250cm9sVHlwZSgkZWxtKSB7XG4gIHZhciBhdHRycyA9IFsnc3dpdGNoJywgJ3JhbmdlJywgJ3JhdGluZycsICdzZWdtZW50ZWQnLCAnc3RlcHBlciddO1xuICB2YXIgZWxtID0gJGVsbVswXTtcbiAgdmFyIHJvbGUgPSAkZWxtLmF0dHIoJ2RhdGEtcm9sZScpO1xuICB2YXIgdHlwZSA9ICRlbG0uYXR0cigndHlwZScpIHx8IGVsbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmICgvKHN3aXRjaHxyYW5nZXxyYXRpbmd8c2VnbWVudGVkfHN0ZXBwZXJ8c2VsZWN0KS8udGVzdChyb2xlKSkge1xuICAgIHR5cGUgPSByb2xlO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICgkZWxtLmlzKCdbbWJzYy0nICsgYXR0cnNbaV0gKyAnXScpKSB7XG4gICAgICAgIHR5cGUgPSBhdHRyc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHlwZTtcbn1cblxuZnVuY3Rpb24gYWN0aXZhdGVDb250cm9sKGNvbnRyb2wsIHR5cGUsIGV2KSB7XG4gIGNvbnRyb2wuZm9jdXMoKTtcblxuICBpZiAoLyhidXR0b258c3VibWl0fGNoZWNrYm94fHN3aXRjaHxyYWRpbykvLnRlc3QodHlwZSkpIHtcbiAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgaWYgKCEvc2VsZWN0Ly50ZXN0KHR5cGUpKSB7XG4gICAgdHJpZ2dlckNsaWNrKGV2LCBjb250cm9sKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0YXAodGhhdCwgZWwsIGhhbmRsZXIsIHByZXZlbnQsIHRvbGVyYW5jZSwgdGltZSkge1xuICB2YXIgc3RhcnRYLFxuICAgICAgc3RhcnRZLFxuICAgICAgdGFyZ2V0LFxuICAgICAgbW92ZWQsXG4gICAgICBzdGFydFRpbWUsXG4gICAgICAkID0gbW9iaXNjcm9sbC4kLFxuICAgICAgJGVsbSA9ICQoZWwpO1xuICB0b2xlcmFuY2UgPSB0b2xlcmFuY2UgfHwgOTtcblxuICBmdW5jdGlvbiBvblN0YXJ0KGV2KSB7XG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIC8vIENhbid0IGFsd2F5cyBjYWxsIHByZXZlbnREZWZhdWx0IGhlcmUsIGl0IGtpbGxzIHBhZ2Ugc2Nyb2xsXG4gICAgICAvLyBpZiAocHJldmVudCkge1xuICAgICAgLy8gICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAvLyB9XG4gICAgICB0YXJnZXQgPSB0aGlzO1xuICAgICAgc3RhcnRYID0gZ2V0Q29vcmQoZXYsICdYJyk7XG4gICAgICBzdGFydFkgPSBnZXRDb29yZChldiwgJ1knKTtcbiAgICAgIG1vdmVkID0gZmFsc2U7XG4gICAgICBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uTW92ZShldikge1xuICAgIC8vIElmIG1vdmVtZW50IGlzIG1vcmUgdGhhbiAyMHB4LCBkb24ndCBmaXJlIHRoZSBjbGljayBldmVudCBoYW5kbGVyXG4gICAgaWYgKHRhcmdldCAmJiAhbW92ZWQgJiYgKE1hdGguYWJzKGdldENvb3JkKGV2LCAnWCcpIC0gc3RhcnRYKSA+IHRvbGVyYW5jZSB8fCBNYXRoLmFicyhnZXRDb29yZChldiwgJ1knKSAtIHN0YXJ0WSkgPiB0b2xlcmFuY2UpKSB7XG4gICAgICBtb3ZlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25FbmQoZXYpIHtcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICBpZiAodGltZSAmJiBuZXcgRGF0ZSgpIC0gc3RhcnRUaW1lIDwgMTAwIHx8ICFtb3ZlZCkge1xuICAgICAgICAvLyBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAvLyBoYW5kbGVyLmNhbGwodGFyZ2V0LCBldiwgdGhhdCk7XG4gICAgICAgIHRyaWdnZXJDbGljayhldiwgZXYudGFyZ2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXZlbnRDbGljaygpO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkNsaWNrKGV2KSB7XG4gICAgaWYgKHByZXZlbnQpIHtcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSAvLyBJZiBoYW5kbGVyIHdhcyBub3QgY2FsbGVkIG9uIHRvdWNoZW5kLCBjYWxsIGl0IG9uIGNsaWNrO1xuXG5cbiAgICBoYW5kbGVyLmNhbGwodGhpcywgZXYsIHRoYXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25DYW5jZWwoKSB7XG4gICAgdGFyZ2V0ID0gZmFsc2U7XG4gIH1cblxuICAkZWxtLmVhY2goZnVuY3Rpb24gKGksIGVsbSkge1xuICAgIGlmICh0aGF0LnNldHRpbmdzLnRhcCkge1xuICAgICAgbGlzdGVuKGVsbSwgJ3RvdWNoc3RhcnQnLCBvblN0YXJ0LCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgbGlzdGVuKGVsbSwgJ3RvdWNoY2FuY2VsJywgb25DYW5jZWwpO1xuICAgICAgbGlzdGVuKGVsbSwgJ3RvdWNobW92ZScsIG9uTW92ZSwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGxpc3RlbihlbG0sICd0b3VjaGVuZCcsIG9uRW5kKTtcbiAgICB9XG5cbiAgICBsaXN0ZW4oZWxtLCAnY2xpY2snLCBvbkNsaWNrKTtcblxuICAgIGVsbS5fX21ic2NPZmYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB1bmxpc3RlbihlbG0sICd0b3VjaHN0YXJ0Jywgb25TdGFydCwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHVubGlzdGVuKGVsbSwgJ3RvdWNoY2FuY2VsJywgb25DYW5jZWwpO1xuICAgICAgdW5saXN0ZW4oZWxtLCAndG91Y2htb3ZlJywgb25Nb3ZlLCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdW5saXN0ZW4oZWxtLCAndG91Y2hlbmQnLCBvbkVuZCk7XG4gICAgICB1bmxpc3RlbihlbG0sICdjbGljaycsIG9uQ2xpY2spO1xuICAgICAgZGVsZXRlIGVsbS5fX21ic2NPZmY7XG4gICAgfTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHRhcE9mZigkZWxtKSB7XG4gIGlmICgkZWxtICYmICRlbG1bMF0gJiYgJGVsbVswXS5fX21ic2NPZmYpIHtcbiAgICAkZWxtWzBdLl9fbWJzY09mZigpO1xuICB9XG59IC8vIFByZXZlbnQgc3RhbmRhcmQgYmVoYXZpb3VyIG9uIGJvZHkgY2xpY2tcblxuXG5mdW5jdGlvbiBidXN0Q2xpY2soZXYpIHtcbiAgLy8gVGV4dGFyZWEgbmVlZHMgdGhlIG1vdXNlZG93biBldmVudFxuICBpZiAodGFwcGVkICYmICFhbGxvd1F1aWNrICYmICFldi5pc01ic2NUYXAgJiYgIShldi50YXJnZXQubm9kZU5hbWUgPT0gJ1RFWFRBUkVBJyAmJiBldi50eXBlID09ICdtb3VzZWRvd24nKSkge1xuICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmlmIChpc0Jyb3dzZXIpIHtcbiAgWydtb3VzZW92ZXInLCAnbW91c2Vkb3duJywgJ21vdXNldXAnLCAnY2xpY2snXS5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXYsIGJ1c3RDbGljaywgdHJ1ZSk7XG4gIH0pO1xuXG4gIGlmIChvcyA9PSAnYW5kcm9pZCcgJiYgbWFqb3JWZXJzaW9uIDwgNSkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgaWYgKHRhcHBlZCAmJiBldi50YXJnZXQudHlwZSA9PSAnY2hlY2tib3gnICYmICFldi50YXJnZXQubWJzY0NoYW5nZSkge1xuICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIGV2LnRhcmdldC5tYnNjQ2hhbmdlO1xuICAgIH0sIHRydWUpO1xuICB9XG59XG5cbi8qIVxyXG4gKiBNb2Jpc2Nyb2xsIHY0LjEwLjZcclxuICogaHR0cDovL21vYmlzY3JvbGwuY29tXHJcbiAqXHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDEwLTIwMTgsIEFjaWQgTWVkaWFcclxuICpcclxuICovXG5tb2Jpc2Nyb2xsLnVpZCA9IFwiYjFlYWQ2NDJcIjtcblxuZnVuY3Rpb24gZ2V0V2lkdGgoZWwpIHtcbiAgcmV0dXJuIGVsWzBdLmlubmVyV2lkdGggfHwgZWwuaW5uZXJXaWR0aCgpO1xufVxuXG5mdW5jdGlvbiBnZXRUaGVtZU5hbWUocykge1xuICB2YXIgdGhlbWVOYW1lID0gcy50aGVtZSxcbiAgICAgIHRoZW1lVmFyaWFudCA9IHMudGhlbWVWYXJpYW50O1xuXG4gIGlmICh0aGVtZU5hbWUgPT0gJ2F1dG8nIHx8ICF0aGVtZU5hbWUpIHtcbiAgICB0aGVtZU5hbWUgPSBtcy5hdXRvVGhlbWU7XG4gIH1cblxuICBpZiAodGhlbWVOYW1lID09ICdkZWZhdWx0Jykge1xuICAgIHRoZW1lTmFtZSA9ICdtb2Jpc2Nyb2xsJztcbiAgfVxuXG4gIGlmICgodGhlbWVWYXJpYW50ID09PSAnZGFyaycgfHwgaXNEYXJrICYmIHRoZW1lVmFyaWFudCA9PT0gJ2F1dG8nKSAmJiBtcy50aGVtZXMuZm9ybVt0aGVtZU5hbWUgKyAnLWRhcmsnXSkge1xuICAgIHRoZW1lTmFtZSA9IHRoZW1lTmFtZSArICctZGFyayc7XG4gIH0gZWxzZSBpZiAodGhlbWVWYXJpYW50ID09PSAnbGlnaHQnICYmIC8uKy1kYXJrJC8udGVzdCh0aGVtZU5hbWUpKSB7XG4gICAgdGhlbWVOYW1lID0gdGhlbWVOYW1lLnJlcGxhY2UoLy1kYXJrJC8sICcnKTtcbiAgfVxuXG4gIHJldHVybiB0aGVtZU5hbWU7XG59XG5cbmZ1bmN0aW9uIGF1dG9Jbml0KHNlbGVjdG9yLCBDb21wb25lbnQsIGhhc1JlZnJlc2gpIHtcbiAgaWYgKGlzQnJvd3Nlcikge1xuICAgICQkMShmdW5jdGlvbiAoKSB7XG4gICAgICAkJDEoc2VsZWN0b3IpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBuZXcgQ29tcG9uZW50KHRoaXMsIHt9KTtcbiAgICAgIH0pO1xuICAgICAgJCQxKGRvY3VtZW50KS5vbignbWJzYy1lbmhhbmNlJywgZnVuY3Rpb24gKGV2LCBzZXR0aW5ncykge1xuICAgICAgICBpZiAoJCQxKGV2LnRhcmdldCkuaXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgbmV3IENvbXBvbmVudChldi50YXJnZXQsIHNldHRpbmdzIHx8IHt9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkJDEoc2VsZWN0b3IsIGV2LnRhcmdldCkuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBuZXcgQ29tcG9uZW50KHRoaXMsIHNldHRpbmdzIHx8IHt9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChoYXNSZWZyZXNoKSB7XG4gICAgICAgICQkMShkb2N1bWVudCkub24oJ21ic2MtcmVmcmVzaCcsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgIHZhciBpbnN0O1xuXG4gICAgICAgICAgaWYgKCQkMShldi50YXJnZXQpLmlzKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgaW5zdCA9IGluc3RhbmNlc1tldi50YXJnZXQuaWRdO1xuXG4gICAgICAgICAgICBpZiAoaW5zdCkge1xuICAgICAgICAgICAgICBpbnN0LnJlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJCQxKHNlbGVjdG9yLCBldi50YXJnZXQpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpbnN0ID0gaW5zdGFuY2VzW3RoaXMuaWRdO1xuXG4gICAgICAgICAgICAgIGlmIChpbnN0KSB7XG4gICAgICAgICAgICAgICAgaW5zdC5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxudmFyIG1zLFxuICAgICQkMSA9IG1vYmlzY3JvbGwuJCxcbiAgICBpZCA9ICtuZXcgRGF0ZSgpLFxuICAgIGluc3RhbmNlcyA9IHt9LFxuICAgIGNsYXNzZXMgPSB7fSxcbiAgICBlbXB0eSA9IHt9LFxuICAgIGJyZWFrcG9pbnRzID0ge1xuICB4c21hbGw6IDAsXG4gIHNtYWxsOiA1NzYsXG4gIG1lZGl1bTogNzY4LFxuICBsYXJnZTogOTkyLFxuICB4bGFyZ2U6IDEyMDBcbn0sXG4gICAgZXh0ZW5kJDEgPSAkJDEuZXh0ZW5kO1xuZXh0ZW5kJDEodXRpbCwge1xuICBnZXRDb29yZDogZ2V0Q29vcmQsXG4gIHByZXZlbnRDbGljazogcHJldmVudENsaWNrLFxuICB2aWJyYXRlOiB2aWJyYXRlXG59KTtcbm1zID0gZXh0ZW5kJDEobW9iaXNjcm9sbCwge1xuICAkOiAkJDEsXG4gIHZlcnNpb246ICc0LjEwLjYnLFxuICBhdXRvVGhlbWU6ICdtb2Jpc2Nyb2xsJyxcbiAgdGhlbWVzOiB7XG4gICAgZm9ybToge30sXG4gICAgcGFnZToge30sXG4gICAgZnJhbWU6IHt9LFxuICAgIHNjcm9sbGVyOiB7fSxcbiAgICBsaXN0dmlldzoge30sXG4gICAgbmF2aWdhdGlvbjoge30sXG4gICAgcHJvZ3Jlc3M6IHt9LFxuICAgIGNhcmQ6IHt9XG4gIH0sXG4gIHBsYXRmb3JtOiB7XG4gICAgbmFtZTogb3MsXG4gICAgbWFqb3JWZXJzaW9uOiBtYWpvclZlcnNpb24sXG4gICAgbWlub3JWZXJzaW9uOiBtaW5vclZlcnNpb25cbiAgfSxcbiAgaTE4bjoge30sXG4gIGluc3RhbmNlczogaW5zdGFuY2VzLFxuICBjbGFzc2VzOiBjbGFzc2VzLFxuICB1dGlsOiB1dGlsLFxuICBzZXR0aW5nczoge30sXG4gIHNldERlZmF1bHRzOiBmdW5jdGlvbiBzZXREZWZhdWx0cyhvKSB7XG4gICAgZXh0ZW5kJDEodGhpcy5zZXR0aW5ncywgbyk7XG4gIH0sXG4gIGN1c3RvbVRoZW1lOiBmdW5jdGlvbiBjdXN0b21UaGVtZShuYW1lLCBiYXNlVGhlbWUpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgdGhlbWVzID0gbW9iaXNjcm9sbC50aGVtZXMsXG4gICAgICAgIGNvbXBzID0gWydmcmFtZScsICdzY3JvbGxlcicsICdsaXN0dmlldycsICduYXZpZ2F0aW9uJywgJ2Zvcm0nLCAncGFnZScsICdwcm9ncmVzcycsICdjYXJkJ107XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY29tcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoZW1lc1tjb21wc1tpXV1bbmFtZV0gPSBleHRlbmQkMSh7fSwgdGhlbWVzW2NvbXBzW2ldXVtiYXNlVGhlbWVdLCB7XG4gICAgICAgIGJhc2VUaGVtZTogYmFzZVRoZW1lXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0pO1xuXG52YXIgQmFzZSA9IGZ1bmN0aW9uIEJhc2UoZWwsIHNldHRpbmdzKSB7XG4gIHZhciBjdHgsXG4gICAgICBsYW5nLFxuICAgICAgcHJlc2V0LFxuICAgICAgcmVzcCxcbiAgICAgIHMsXG4gICAgICB0aGVtZSxcbiAgICAgIHRoZW1lTmFtZSxcbiAgICAgIHRyaWdnZXIsXG4gICAgICBkZWZhdWx0cyxcbiAgICAgIHRoYXQgPSB0aGlzO1xuICB0aGF0LnNldHRpbmdzID0ge307XG4gIHRoYXQuZWxlbWVudCA9IGVsO1xuICB0aGF0Ll9pbml0ID0gbm9vcDtcbiAgdGhhdC5fZGVzdHJveSA9IG5vb3A7XG4gIHRoYXQuX3Byb2Nlc3NTZXR0aW5ncyA9IG5vb3A7XG5cbiAgdGhhdC5fY2hlY2tSZXNwID0gZnVuY3Rpb24gKHdpZHRoKSB7XG4gICAgaWYgKHRoYXQgJiYgdGhhdC5fcmVzcG9uc2l2ZSkge1xuICAgICAgdmFyIG5ld1Jlc3AgPSBnZXRSZXNwb25zaXZlU2V0dGluZ3Mod2lkdGgpO1xuXG4gICAgICBpZiAocmVzcCAhPT0gbmV3UmVzcCkge1xuICAgICAgICByZXNwID0gbmV3UmVzcDtcbiAgICAgICAgdGhhdC5pbml0KHt9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHRoYXQuX2dldFJlc3BDb250ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAkJDEocy5jb250ZXh0ID09ICdib2R5JyA/IHdpbmRvdyA6IHMuY29udGV4dCk7XG4gIH07XG5cbiAgdGhhdC5pbml0ID0gZnVuY3Rpb24gKG5ld1NldHRpbmdzLCBuZXdWYWx1ZSkge1xuICAgIHZhciBrZXksIHZhbHVlOyAvLyBJbiBjYXNlIG9mIHNldHRpbmdzIHVwZGF0ZSBzYXZlIHRoZSBvbGQgdmFsdWVcblxuICAgIGlmIChuZXdTZXR0aW5ncyAmJiB0aGF0LmdldFZhbCkge1xuICAgICAgdmFsdWUgPSB0aGF0LmdldFZhbCgpO1xuICAgIH0gLy8gUmVzZXQgc2V0dGluZ3Mgb2JqZWN0XG5cblxuICAgIGZvciAoa2V5IGluIHRoYXQuc2V0dGluZ3MpIHtcbiAgICAgIGRlbGV0ZSB0aGF0LnNldHRpbmdzW2tleV07XG4gICAgfVxuXG4gICAgcyA9IHRoYXQuc2V0dGluZ3M7IC8vIFVwZGF0ZSBvcmlnaW5hbCB1c2VyIHNldHRpbmdzXG5cbiAgICBleHRlbmQkMShzZXR0aW5ncywgbmV3U2V0dGluZ3MpOyAvLyBMb2FkIHVzZXIgZGVmYXVsdHNcblxuICAgIGlmICh0aGF0Ll9oYXNEZWYpIHtcbiAgICAgIGRlZmF1bHRzID0gbXMuc2V0dGluZ3M7XG4gICAgfSAvLyBDcmVhdGUgc2V0dGluZ3Mgb2JqZWN0XG5cblxuICAgIGV4dGVuZCQxKHMsIHRoYXQuX2RlZmF1bHRzLCBkZWZhdWx0cywgc2V0dGluZ3MpOyAvLyBHZXQgdGhlbWUgZGVmYXVsdHNcblxuICAgIGlmICh0aGF0Ll9oYXNUaGVtZSkge1xuICAgICAgdGhlbWVOYW1lID0gZ2V0VGhlbWVOYW1lKHMpO1xuICAgICAgc2V0dGluZ3MudGhlbWUgPSB0aGVtZU5hbWU7XG4gICAgICB0aGVtZSA9IG1zLnRoZW1lc1t0aGF0Ll9jbGFzc10gPyBtcy50aGVtZXNbdGhhdC5fY2xhc3NdW3RoZW1lTmFtZV0gOiB7fTtcbiAgICB9IC8vIEdldCBsYW5ndWFnZSBkZWZhdWx0c1xuXG5cbiAgICBpZiAodGhhdC5faGFzTGFuZykge1xuICAgICAgbGFuZyA9IG1zLmkxOG5bcy5sYW5nXTtcbiAgICB9IC8vIFVwZGF0ZSBzZXR0aW5ncyBvYmplY3RcblxuXG4gICAgZXh0ZW5kJDEocywgdGhlbWUsIGxhbmcsIGRlZmF1bHRzLCBzZXR0aW5ncyk7XG4gICAgY3R4ID0gdGhhdC5fZ2V0UmVzcENvbnQoKTtcblxuICAgIGlmICh0aGF0Ll9yZXNwb25zaXZlKSB7XG4gICAgICBpZiAoIXJlc3ApIHtcbiAgICAgICAgcmVzcCA9IGdldFJlc3BvbnNpdmVTZXR0aW5ncygpO1xuICAgICAgfVxuXG4gICAgICBleHRlbmQkMShzLCByZXNwKTtcbiAgICB9XG5cbiAgICB0aGF0Ll9wcm9jZXNzU2V0dGluZ3MocmVzcCB8fCB7fSk7IC8vIExvYWQgcHJlc2V0IHNldHRpbmdzXG5cblxuICAgIGlmICh0aGF0Ll9wcmVzZXRzKSB7XG4gICAgICBwcmVzZXQgPSB0aGF0Ll9wcmVzZXRzW3MucHJlc2V0XTtcblxuICAgICAgaWYgKHByZXNldCkge1xuICAgICAgICBwcmVzZXQgPSBwcmVzZXQuY2FsbChlbCwgdGhhdCwgc2V0dGluZ3MpO1xuICAgICAgICBleHRlbmQkMShzLCBwcmVzZXQsIHNldHRpbmdzLCByZXNwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGF0Ll9pbml0KG5ld1NldHRpbmdzKTsgLy8gSW4gY2FzZSBvZiBzZXR0aW5ncyB1cGRhdGUgcmVzZXQgdGhlIHZhbHVlLlxuICAgIC8vIFRoaXMgaXMgbmVlZGVkIHRvIGFkYXB0IHRoZSB2YWx1ZSBmb3IgdGhlIHVwZGF0ZWQgc2V0dGluZ3NcbiAgICAvLyBFLmcuIG1pbi9tYXgsIGRhdGUgZm9ybWF0LCBldGMuXG5cblxuICAgIGlmIChuZXdTZXR0aW5ncyAmJiB0aGF0LnNldFZhbCkge1xuICAgICAgdGhhdC5zZXRWYWwobmV3VmFsdWUgPT09IHVuZGVmaW5lZCA/IHZhbHVlIDogbmV3VmFsdWUsIHRydWUpO1xuICAgIH1cblxuICAgIHRyaWdnZXIoJ29uSW5pdCcpO1xuICB9O1xuXG4gIHRoYXQuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhhdCkge1xuICAgICAgdGhhdC5fZGVzdHJveSgpO1xuXG4gICAgICB0cmlnZ2VyKCdvbkRlc3Ryb3knKTsgLy8gRGVsZXRlIHNjcm9sbGVyIGluc3RhbmNlXG5cbiAgICAgIGRlbGV0ZSBpbnN0YW5jZXNbZWwuaWRdO1xuICAgICAgdGhhdCA9IG51bGw7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBBdHRhY2ggdGFwIGV2ZW50IHRvIHRoZSBnaXZlbiBlbGVtZW50LlxyXG4gICAqL1xuXG5cbiAgdGhhdC50YXAgPSBmdW5jdGlvbiAoZWwsIGhhbmRsZXIsIHByZXZlbnQsIHRvbGVyYW5jZSwgdGltZSkge1xuICAgIHRhcCh0aGF0LCBlbCwgaGFuZGxlciwgcHJldmVudCwgdG9sZXJhbmNlLCB0aW1lKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogVHJpZ2dlcnMgYW4gZXZlbnRcclxuICAgKi9cblxuXG4gIHRoYXQudHJpZ2dlciA9IGZ1bmN0aW9uIChuYW1lLCBldikge1xuICAgIHZhciByZXQsXG4gICAgICAgIGksXG4gICAgICAgIHYsXG4gICAgICAgIHMgPSBbZGVmYXVsdHMsIHRoZW1lLCBwcmVzZXQsIHNldHRpbmdzXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIHYgPSBzW2ldO1xuXG4gICAgICBpZiAodiAmJiB2W25hbWVdKSB7XG4gICAgICAgIHJldCA9IHZbbmFtZV0uY2FsbChlbCwgZXYgfHwge30sIHRoYXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH07XG4gIC8qKlxyXG4gICAqIFNldHMgb25lIG9yZSBtb3JlIG9wdGlvbnMuXHJcbiAgICovXG5cblxuICB0aGF0Lm9wdGlvbiA9IGZ1bmN0aW9uIChvcHQsIHZhbHVlLCBuZXdWYWx1ZSkge1xuICAgIHZhciBvYmogPSB7fSxcbiAgICAgICAgLy8gcHJlc2VydmUgc2V0dGluZ3MgdGhhdCBhcmUgcG9zc2libGUgdG8gY2hhbmdlIHJ1bnRpbWVcbiAgICBkeW5hbWljID0gWydkYXRhJywgJ2ludmFsaWQnLCAndmFsaWQnLCAncmVhZG9ubHknXTtcblxuICAgIGlmICgvY2FsZW5kYXJ8ZXZlbnRjYWxlbmRhcnxyYW5nZS8udGVzdChzLnByZXNldCkpIHtcbiAgICAgIGR5bmFtaWMucHVzaCgnbWFya2VkJywgJ2xhYmVscycsICdjb2xvcnMnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG9iaiA9IG9wdDtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW29wdF0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBkeW5hbWljLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgIHNldHRpbmdzW3ZdID0gc1t2XTtcbiAgICB9KTtcbiAgICB0aGF0LmluaXQob2JqLCBuZXdWYWx1ZSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIG1vYmlzY3JvbGwgaW5zdGFuY2UuXHJcbiAgICovXG5cblxuICB0aGF0LmdldEluc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoYXQ7XG4gIH07XG5cbiAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcbiAgdHJpZ2dlciA9IHRoYXQudHJpZ2dlcjtcblxuICBmdW5jdGlvbiBnZXRSZXNwb25zaXZlU2V0dGluZ3Modykge1xuICAgIHZhciByZXN1bHQgPSBlbXB0eSxcbiAgICAgICAgd2lkdGg7XG5cbiAgICBpZiAocy5yZXNwb25zaXZlKSB7XG4gICAgICB3aWR0aCA9IHcgfHwgZ2V0V2lkdGgoY3R4KTtcbiAgICAgICQkMS5lYWNoKHMucmVzcG9uc2l2ZSwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHdpZHRoID49ICh2YWx1ZS5icmVha3BvaW50IHx8IGJyZWFrcG9pbnRzW2tleV0pKSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdHJ1Y3QoKSB7XG4gICAgJCQxKGVsKS5hZGRDbGFzcygnbWJzYy1jb21wJyk7IC8vIEF1dG9nZW5lcmF0ZSBpZFxuXG4gICAgaWYgKCFlbC5pZCkge1xuICAgICAgZWwuaWQgPSAnbW9iaXNjcm9sbCcgKyArK2lkO1xuICAgIH0gZWxzZSBpZiAoaW5zdGFuY2VzW2VsLmlkXSkge1xuICAgICAgaW5zdGFuY2VzW2VsLmlkXS5kZXN0cm95KCk7XG4gICAgfSAvLyBTYXZlIGluc3RhbmNlXG5cblxuICAgIGluc3RhbmNlc1tlbC5pZF0gPSB0aGF0O1xuICAgIHRoYXQuX19yZWFkeSA9IHRydWU7XG4gIH1cblxuICBpZiAoIXRoYXQuX19yZWFkeSkge1xuICAgIGNvbnN0cnVjdCgpO1xuICB9XG59O1xuXG52YXIgT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT2JzZXJ2YWJsZSgpIHtcbiAgICB0aGlzLmtleUNvdW50ID0gMDtcbiAgICB0aGlzLnN1YnNjcmliZXJzID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICB2YXIga2V5ID0gdGhpcy5rZXlDb3VudCsrO1xuICAgIHRoaXMuc3Vic2NyaWJlcnMuc2V0KGtleSwgaGFuZGxlcik7XG4gICAgcmV0dXJuIGtleTtcbiAgfTtcblxuICBPYnNlcnZhYmxlLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5zdWJzY3JpYmVycy5kZWxldGUoaGFuZGxlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmb3VuZEtleV8xID0gbnVsbDtcbiAgICAgIHRoaXMuc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoZm4sIGtleSkge1xuICAgICAgICBpZiAoZm4gPT09IGhhbmRsZXIpIHtcbiAgICAgICAgICBmb3VuZEtleV8xID0ga2V5O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc3Vic2NyaWJlcnMuZGVsZXRlKGZvdW5kS2V5XzEpO1xuICAgIH1cbiAgfTtcblxuICBPYnNlcnZhYmxlLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5zdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVyKHZhbHVlKTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gT2JzZXJ2YWJsZTtcbn0oKTtcblxudmFyIE1ic2NSb3V0ZXJUb2tlbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNYnNjUm91dGVyVG9rZW4oKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTWJzY1JvdXRlclRva2VuO1xyXG59KCkpO1xyXG52YXIgTWJzY09wdGlvbnNTZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1ic2NPcHRpb25zU2VydmljZSgpIHtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjT3B0aW9uc1NlcnZpY2UucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG87XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBNYnNjT3B0aW9uc1NlcnZpY2UgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbmplY3RhYmxlKClcclxuICAgIF0sIE1ic2NPcHRpb25zU2VydmljZSk7XHJcbiAgICByZXR1cm4gTWJzY09wdGlvbnNTZXJ2aWNlO1xyXG59KCkpO1xyXG52YXIgTWJzY0lucHV0U2VydmljZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNYnNjSW5wdXRTZXJ2aWNlKCkge1xyXG4gICAgICAgIHRoaXMuX2NvbnRyb2xTZXQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9jb21wb25lbnRSZWYgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY0lucHV0U2VydmljZS5wcm90b3R5cGUsIFwiaXNDb250cm9sU2V0XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRyb2xTZXQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbnRyb2xTZXQgPSB2O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NJbnB1dFNlcnZpY2UucHJvdG90eXBlLCBcImlucHV0XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudFJlZjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50UmVmID0gdjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE1ic2NJbnB1dFNlcnZpY2UgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbmplY3RhYmxlKClcclxuICAgIF0sIE1ic2NJbnB1dFNlcnZpY2UpO1xyXG4gICAgcmV0dXJuIE1ic2NJbnB1dFNlcnZpY2U7XHJcbn0oKSk7XHJcbnZhciBNYnNjTGlzdFNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWJzY0xpc3RTZXJ2aWNlKCkge1xyXG4gICAgICAgIHRoaXMuYWRkUmVtb3ZlT2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKCk7XHJcbiAgICB9XHJcbiAgICBNYnNjTGlzdFNlcnZpY2UucHJvdG90eXBlLm5vdGlmeUFkZFJlbW92ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgdGhpcy5hZGRSZW1vdmVPYnNlcnZhYmxlLm5leHQoaXRlbSk7XHJcbiAgICB9O1xyXG4gICAgTWJzY0xpc3RTZXJ2aWNlLnByb3RvdHlwZS5vbkFkZFJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hZGRSZW1vdmVPYnNlcnZhYmxlO1xyXG4gICAgfTtcclxuICAgIE1ic2NMaXN0U2VydmljZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIEluamVjdGFibGUoKVxyXG4gICAgXSwgTWJzY0xpc3RTZXJ2aWNlKTtcclxuICAgIHJldHVybiBNYnNjTGlzdFNlcnZpY2U7XHJcbn0oKSk7XHJcbnZhciBNYnNjQmFzZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNYnNjQmFzZShpbml0aWFsRWxlbSwgem9uZSkge1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbEVsZW0gPSBpbml0aWFsRWxlbTtcclxuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIHRoaXMub25Jbml0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMub25EZXN0cm95ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHRoaXMuaW5saW5lT3B0aW9uc09iaiA9IHt9O1xyXG4gICAgICAgIHRoaXMucGVuZGluZ1ZhbHVlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMudGhlbWVDbGFzc2VzU2V0ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmlubGluZU9wdGlvbnNPYmouem9uZSA9IHpvbmU7XHJcbiAgICB9XHJcbiAgICBNYnNjQmFzZS5wcm90b3R5cGUuZ2V0SW5saW5lRXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAocHJvcCkge1xyXG4gICAgICAgICAgICBpZiAodGhpc18xW3Byb3BdIGluc3RhbmNlb2YgKEV2ZW50RW1pdHRlcikgJiYgKCF0aGlzXzEub3B0aW9ucyB8fCAhKHRoaXNfMS5vcHRpb25zW3Byb3BdKSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXNfMS5pbmxpbmVPcHRpb25zT2JqW3Byb3BdID0gZnVuY3Rpb24gKGV2ZW50LCBpbnN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuaW5zdCA9IGluc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXNbcHJvcF0uZW1pdChldmVudCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcclxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIHRoaXMpIHtcclxuICAgICAgICAgICAgX2xvb3BfMShwcm9wKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTWJzY0Jhc2UucHJvdG90eXBlLnNldFRoZW1lQ2xhc3NlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAkJDEodGhpcy5pbml0aWFsRWxlbS5uYXRpdmVFbGVtZW50KS5hZGRDbGFzcyh0aGlzLmdldFRoZW1lQ2xhc3NlcygpKTtcclxuICAgICAgICB0aGlzLnRoZW1lQ2xhc3Nlc1NldCA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgTWJzY0Jhc2UucHJvdG90eXBlLmNsZWFyVGhlbWVDbGFzc2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICQkMSh0aGlzLmluaXRpYWxFbGVtLm5hdGl2ZUVsZW1lbnQpLnJlbW92ZUNsYXNzKHRoaXMuZ2V0VGhlbWVDbGFzc2VzKCkpO1xyXG4gICAgfTtcclxuICAgIE1ic2NCYXNlLnByb3RvdHlwZS5nZXRUaGVtZUNsYXNzZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHMgPSB0aGlzLmluc3RhbmNlLnNldHRpbmdzO1xyXG4gICAgICAgIHJldHVybiAnbWJzYy1jb250cm9sLW5nIG1ic2MtJyArIHMudGhlbWUgKyAocy5iYXNlVGhlbWUgPyAnIG1ic2MtJyArIHMuYmFzZVRoZW1lIDogJycpO1xyXG4gICAgfTtcclxuICAgIE1ic2NCYXNlLnByb3RvdHlwZS5zZXRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IHRoaXMuaW5pdGlhbEVsZW0ubmF0aXZlRWxlbWVudDtcclxuICAgICAgICB2YXIgY29udGVudElucHV0ID0gJCQxKCdpbnB1dCcsIHRoaXMuaW5pdGlhbEVsZW0ubmF0aXZlRWxlbWVudCk7XHJcbiAgICAgICAgaWYgKGNvbnRlbnRJbnB1dC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gY29udGVudElucHV0WzBdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNYnNjQmFzZS5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc2V0RWxlbWVudCgpO1xyXG4gICAgICAgIHRoaXMuc3RhcnRJbml0KCk7XHJcbiAgICB9O1xyXG4gICAgTWJzY0Jhc2UucHJvdG90eXBlLnN0YXJ0SW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuZ2V0SW5saW5lRXZlbnRzKCk7XHJcbiAgICAgICAgdmFyIGlvbklucHV0ID0gdGhpcy5nZXRJb25JbnB1dCgpO1xyXG4gICAgICAgIGlmIChpb25JbnB1dCAmJiAoaW9uSW5wdXQuZ2V0SW5wdXRFbGVtZW50IHx8IGlvbklucHV0LnRoZW4pICYmIHRoaXMuZWxlbWVudC5ub2RlTmFtZSAhPT0gXCJJTlBVVFwiKSB7XHJcbiAgICAgICAgICAgIGlmIChpb25JbnB1dC5nZXRJbnB1dEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGlvbklucHV0LmdldElucHV0RWxlbWVudCgpLnRoZW4oZnVuY3Rpb24gKGlucCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbml0Q29udHJvbCgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpb25JbnB1dC50aGVuKGZ1bmN0aW9uIChpb25JbnBDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpb25JbnBDb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldElucHV0RWxlbWVudCgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChpbnApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0RWxlbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pbml0Q29udHJvbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5pbml0Q29udHJvbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNYnNjQmFzZS5wcm90b3R5cGUuZ2V0SW9uSW5wdXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHYgPSB0aGlzLl92aWV3O1xyXG4gICAgICAgIHZhciBuYXRpdmUgPSB0aGlzLmluaXRpYWxFbGVtLm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICAgICAgdmFyIGlvbklucHV0Tm9kZSA9IG5hdGl2ZS5ub2RlTmFtZSA9PT0gXCJJT04tSU5QVVRcIjtcclxuICAgICAgICB2YXIgaW5wMSA9IGlvbklucHV0Tm9kZSAmJiB2ICYmIHYuX2RhdGEgJiYgdi5fZGF0YS5jb21wb25lbnRWaWV3ICYmIHYuX2RhdGEuY29tcG9uZW50Vmlldy5jb21wb25lbnQ7XHJcbiAgICAgICAgdmFyIGlucDIgPSBpb25JbnB1dE5vZGUgJiYgbmF0aXZlLmNvbXBvbmVudE9uUmVhZHkgJiYgbmF0aXZlLmNvbXBvbmVudE9uUmVhZHkoKTtcclxuICAgICAgICByZXR1cm4gaW5wMSB8fCBpbnAyO1xyXG4gICAgfTtcclxuICAgIE1ic2NCYXNlLnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIE1ic2NCYXNlLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTWJzY0Jhc2UucHJvdG90eXBlLnVwZGF0ZU9wdGlvbnMgPSBmdW5jdGlvbiAobmV3T3B0aW9ucywgb3B0aW9uQ2hhbmdlZCwgaW52YWxpZENoYW5nZWQsIGRhdGFDaGFuZ2VkKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAob3B0aW9uQ2hhbmdlZCB8fCBpbnZhbGlkQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdPcHRpb25zLnRoZW1lICYmIF90aGlzLnRoZW1lQ2xhc3Nlc1NldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNsZWFyVGhlbWVDbGFzc2VzKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5pbnN0YW5jZS5vcHRpb24obmV3T3B0aW9ucywgdW5kZWZpbmVkLCBfdGhpcy5wZW5kaW5nVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld09wdGlvbnMudGhlbWUgJiYgX3RoaXMudGhlbWVDbGFzc2VzU2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0VGhlbWVDbGFzc2VzKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkYXRhQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hEYXRhKHRoaXMuZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaW5zdGFuY2UucmVkcmF3KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UucmVkcmF3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1ic2NCYXNlLnByb3RvdHlwZS5uZ09uQ2hhbmdlcyA9IGZ1bmN0aW9uIChjaGFuZ2VzKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbkNoYW5nZSA9IGZhbHNlLCBjbG9uZUNoYW5nZSA9IGZhbHNlLCBpbnZhbGlkQ2hhbmdlID0gZmFsc2UsIGRhdGFDaGFuZ2UgPSBmYWxzZSwgbmV3T3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gY2hhbmdlcykge1xyXG4gICAgICAgICAgICBpZiAoIWNoYW5nZXNbcHJvcF0uZmlyc3RDaGFuZ2UgJiYgcHJvcCAhPT0gJ29wdGlvbnMnICYmIHByb3AgIT09ICd2YWx1ZScpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsb25lRGljdGlvbmFyeSAmJiB0aGlzLmNsb25lRGljdGlvbmFyeVtwcm9wXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFrZUNsb25lKHByb3AsIGNoYW5nZXNbcHJvcF0uY3VycmVudFZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNldHRpbmdzW3Byb3BdID0gY2hhbmdlc1twcm9wXS5jdXJyZW50VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wID09ICdpbnZhbGlkJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkQ2hhbmdlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3AgPT0gJ2RhdGEnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFDaGFuZ2UgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjbG9uZUNoYW5nZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdPcHRpb25zW3Byb3BdID0gY2hhbmdlc1twcm9wXS5jdXJyZW50VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uQ2hhbmdlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghY2hhbmdlc1twcm9wXS5maXJzdENoYW5nZSAmJiBwcm9wICE9PSAndmFsdWUnKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdPcHRpb25zID0gZXh0ZW5kJDEoY2hhbmdlc1twcm9wXS5jdXJyZW50VmFsdWUsIG5ld09wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uQ2hhbmdlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGFuZ2VzW3Byb3BdLmZpcnN0Q2hhbmdlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcCAhPT0gJ29wdGlvbnMnICYmIHByb3AgIT09ICd2YWx1ZScpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlubGluZU9wdGlvbnNPYmpbcHJvcF0gPSBjaGFuZ2VzW3Byb3BdLmN1cnJlbnRWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2xvbmVDaGFuZ2UpIHtcclxuICAgICAgICAgICAgZXh0ZW5kJDEobmV3T3B0aW9ucywgdGhpcy5jbG9uZURpY3Rpb25hcnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9uQ2hhbmdlIHx8IGNsb25lQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlT3B0aW9ucyhuZXdPcHRpb25zLCBvcHRpb25DaGFuZ2UsIGludmFsaWRDaGFuZ2UsIGRhdGFDaGFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdtYnNjLW9wdGlvbnMnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY0Jhc2UucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0Jhc2UucHJvdG90eXBlLCBcImNzc0NsYXNzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NCYXNlLnByb3RvdHlwZSwgXCJ0aGVtZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjQmFzZS5wcm90b3R5cGUsIFwidGhlbWVWYXJpYW50XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NCYXNlLnByb3RvdHlwZSwgXCJsYW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjQmFzZS5wcm90b3R5cGUsIFwicnRsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NCYXNlLnByb3RvdHlwZSwgXCJyZXNwb25zaXZlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY0Jhc2UucHJvdG90eXBlLCBcIm9uSW5pdFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NCYXNlLnByb3RvdHlwZSwgXCJvbkRlc3Ryb3lcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NCYXNlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbWJzYy1iXScgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBOZ1pvbmVdKVxyXG4gICAgXSwgTWJzY0Jhc2UpO1xyXG4gICAgcmV0dXJuIE1ic2NCYXNlO1xyXG59KCkpO1xyXG52YXIgTWJzY1ZhbHVlQmFzZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY1ZhbHVlQmFzZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NWYWx1ZUJhc2UoaW5pdGlhbEVsZW0sIHpvbmUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5pbml0aWFsVmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgTWJzY1ZhbHVlQmFzZS5wcm90b3R5cGUuc2V0TmV3VmFsdWUgPSBmdW5jdGlvbiAodikgeyB9O1xyXG4gICAgTWJzY1ZhbHVlQmFzZS5wcm90b3R5cGUuc2V0TmV3VmFsdWVQcm94eSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gdjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXROZXdWYWx1ZSh2KTtcclxuICAgIH07XHJcbiAgICBNYnNjVmFsdWVCYXNlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbWJzYy12LWJdJyB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZV0pXHJcbiAgICBdLCBNYnNjVmFsdWVCYXNlKTtcclxuICAgIHJldHVybiBNYnNjVmFsdWVCYXNlO1xyXG59KE1ic2NCYXNlKSk7XHJcbnZhciBNYnNjQ2xvbmVCYXNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjQ2xvbmVCYXNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY0Nsb25lQmFzZShpbml0RWxlbSwgem9uZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRFbGVtLCB6b25lKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmNsb25lRGljdGlvbmFyeSA9IHt9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE1ic2NDbG9uZUJhc2UucHJvdG90eXBlLm1ha2VDbG9uZSA9IGZ1bmN0aW9uIChzZXR0aW5nLCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmNsb25lRGljdGlvbmFyeVtzZXR0aW5nXSA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNsb25lRGljdGlvbmFyeVtzZXR0aW5nXS5wdXNoKHZhbHVlW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jbG9uZURpY3Rpb25hcnlbc2V0dGluZ10gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTWJzY0Nsb25lQmFzZS5wcm90b3R5cGUubmdEb0NoZWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2UsIGRhdGEgPSBmYWxzZSwgaW52YWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNsb25lRGljdGlvbmFyeSkge1xyXG4gICAgICAgICAgICBpZiAodGhpc1trZXldICE9PSB1bmRlZmluZWQgJiYgIWRlZXBFcXVhbHNBcnJheSh0aGlzW2tleV0sIHRoaXMuY2xvbmVEaWN0aW9uYXJ5W2tleV0pKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1ha2VDbG9uZShrZXksIHRoaXNba2V5XSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNldHRpbmdzW2tleV0gPSB0aGlzW2tleV07XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gJ2ludmFsaWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09ICdkYXRhJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VkICYmIHRoaXMuaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVPcHRpb25zKHRoaXMuY2xvbmVEaWN0aW9uYXJ5LCBmYWxzZSwgaW52YWxpZCwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1ic2NDbG9uZUJhc2UucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmNsb25lRGljdGlvbmFyeSkge1xyXG4gICAgICAgICAgICB0aGlzLm1ha2VDbG9uZShrZXksIHRoaXNba2V5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1ic2NDbG9uZUJhc2UgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1ttYnNjLWMtYl0nIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lXSlcclxuICAgIF0sIE1ic2NDbG9uZUJhc2UpO1xyXG4gICAgcmV0dXJuIE1ic2NDbG9uZUJhc2U7XHJcbn0oTWJzY1ZhbHVlQmFzZSkpO1xyXG52YXIgTWJzY0NvbnRyb2xCYXNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjQ29udHJvbEJhc2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjQ29udHJvbEJhc2UoaW5pdGlhbEVsZW1lbnQsIHpvbmUsIGNvbnRyb2wsIF9pbnB1dFNlcnZpY2UsIF92aWV3KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW1lbnQsIHpvbmUpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuY29udHJvbCA9IGNvbnRyb2w7XHJcbiAgICAgICAgX3RoaXMuX2lucHV0U2VydmljZSA9IF9pbnB1dFNlcnZpY2U7XHJcbiAgICAgICAgX3RoaXMuX3ZpZXcgPSBfdmlldztcclxuICAgICAgICBfdGhpcy5fbmVlZHNUaW1lb3V0ID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgICAgICBfdGhpcy5vblRvdWNoID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5vbGRBY2Nlc3NvciA9IG51bGw7XHJcbiAgICAgICAgX3RoaXMub3ZlcndyaXRlQWNjZXNzb3IoKTtcclxuICAgICAgICBpZiAoX2lucHV0U2VydmljZSkge1xyXG4gICAgICAgICAgICBfaW5wdXRTZXJ2aWNlLmlzQ29udHJvbFNldCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjQ29udHJvbEJhc2UucHJvdG90eXBlLCBcIm9wdGlvbkV4dGVuc2lvbnNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgZXh0ZXJuYWxPbkNsb3NlID0gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5vbkNsb3NlO1xyXG4gICAgICAgICAgICB2YXIgZXh0ZXJuYWxPbkZpbGwgPSB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm9uRmlsbDtcclxuICAgICAgICAgICAgdmFyIG9uQ2xvc2VFbWl0dGVyID0gdGhpcy5vbkNsb3NlO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgb25GaWxsOiBmdW5jdGlvbiAoZXZlbnQsIGluc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMub2xkQWNjZXNzb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub2xkQWNjZXNzb3Iud3JpdGVWYWx1ZShldmVudC52YWx1ZVRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlvbklucHV0ID0gX3RoaXMuZ2V0SW9uSW5wdXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlvbklucHV0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpb25JbnB1dC52YWx1ZSA9IGV2ZW50LnZhbHVlVGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ZXJuYWxPbkZpbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZXJuYWxPbkZpbGwoZXZlbnQsIGluc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBvbkNsb3NlOiBmdW5jdGlvbiAoZXZlbnQsIGluc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vblRvdWNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVybmFsT25DbG9zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlcm5hbE9uQ2xvc2UoZXZlbnQsIGluc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob25DbG9zZUVtaXR0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuaW5zdCA9IGluc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xvc2VFbWl0dGVyLmVtaXQoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjQ29udHJvbEJhc2UucHJvdG90eXBlLCBcImVuYWJsZU1hbnVhbEVkaXRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbnNmID0gdGhpcy5zaG93T25Gb2N1cyA9PT0gZmFsc2UgfHwgdGhpcy5vcHRpb25zLnNob3dPbkZvY3VzID09PSBmYWxzZSwgbnN0ID0gdGhpcy5zaG93T25UYXAgPT09IGZhbHNlIHx8IHRoaXMub3B0aW9ucy5zaG93T25UYXAgPT09IGZhbHNlO1xyXG4gICAgICAgICAgICByZXR1cm4gbnNmICYmIG5zdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE1ic2NDb250cm9sQmFzZS5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICAgICAgJCQxKGVsZW1lbnQgfHwgdGhpcy5lbGVtZW50KS5vbignY2hhbmdlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGF0LnpvbmUucnVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGF0LmVsZW1lbnQudmFsdWUgIT09IHRoYXQuaW5zdGFuY2UuX3ZhbHVlICYmIHRoYXQuZW5hYmxlTWFudWFsRWRpdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuaW5zdGFuY2Uuc2V0VmFsKHRoYXQuZWxlbWVudC52YWx1ZSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGF0Lmluc3RhbmNlLmdldFZhbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LmNvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZUVxdWFscyh2YWx1ZSwgdGhhdC5jb250cm9sLm1vZGVsKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5vbkNoYW5nZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbnRyb2wuY29udHJvbC5wYXRjaFZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5vbkNoYW5nZUVtaXR0ZXIuZW1pdCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBmdW5jdGlvbiB2YWx1ZUVxdWFscyh2MSwgdjIpIHtcclxuICAgICAgICAgICAgaWYgKHYxID09PSB2Mikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHYxIGluc3RhbmNlb2YgRGF0ZSAmJiB2MiBpbnN0YW5jZW9mIERhdGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoK3YxKSA9PT0gKCt2Mik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNYnNjQ29udHJvbEJhc2UucHJvdG90eXBlLm92ZXJ3cml0ZUFjY2Vzc29yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnRyb2wpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbC52YWx1ZUFjY2Vzc29yICE9PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9sZEFjY2Vzc29yID0gdGhpcy5jb250cm9sLnZhbHVlQWNjZXNzb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb250cm9sLnZhbHVlQWNjZXNzb3IgPSB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNYnNjQ29udHJvbEJhc2UucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlQ2hhbmdlKCk7XHJcbiAgICAgICAgdGhpcy5vdmVyd3JpdGVBY2Nlc3NvcigpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnRyb2wgJiYgdGhpcy5jb250cm9sLl9zZXRVcENvbnRyb2wpIHtcclxuICAgICAgICAgICAgdGhpcy5jb250cm9sLl9zZXRVcENvbnRyb2woKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTWJzY0NvbnRyb2xCYXNlLnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xyXG4gICAgfTtcclxuICAgIE1ic2NDb250cm9sQmFzZS5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICB0aGlzLm9uVG91Y2ggPSBmbjtcclxuICAgIH07XHJcbiAgICBNYnNjQ29udHJvbEJhc2UucHJvdG90eXBlLnNldERpc2FibGVkU3RhdGUgPSBmdW5jdGlvbiAoaXNEaXNhYmxlZCkge1xyXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xyXG4gICAgICAgIGlmICh0aGlzLm9sZEFjY2Vzc29yICYmIHRoaXMub2xkQWNjZXNzb3Iuc2V0RGlzYWJsZWRTdGF0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9sZEFjY2Vzc29yLnNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlICYmIHRoaXMuaW5zdGFuY2UuZGlzYWJsZSAmJiB0aGlzLmluc3RhbmNlLmVuYWJsZSkge1xyXG4gICAgICAgICAgICBpZiAoaXNEaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5kaXNhYmxlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlLmVuYWJsZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1ic2NDb250cm9sQmFzZS5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5fbmVlZHNUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1ZhbHVlID0gdjtcclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5wZW5kaW5nVmFsdWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXROZXdWYWx1ZVByb3h5KHYpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnbGFiZWwtc3R5bGUnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0NvbnRyb2xCYXNlLnByb3RvdHlwZSwgXCJsYWJlbFN0eWxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdpbnB1dC1zdHlsZScpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjQ29udHJvbEJhc2UucHJvdG90eXBlLCBcImlucHV0U3R5bGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NDb250cm9sQmFzZS5wcm90b3R5cGUsIFwic2hvd09uRm9jdXNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NDb250cm9sQmFzZS5wcm90b3R5cGUsIFwic2hvd09uVGFwXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjQ29udHJvbEJhc2UucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjQ29udHJvbEJhc2UgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1ttYnNjLWNjLWJdJyB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZSwgTmdDb250cm9sLCBNYnNjSW5wdXRTZXJ2aWNlLCBWaWV3Q29udGFpbmVyUmVmXSlcclxuICAgIF0sIE1ic2NDb250cm9sQmFzZSk7XHJcbiAgICByZXR1cm4gTWJzY0NvbnRyb2xCYXNlO1xyXG59KE1ic2NDbG9uZUJhc2UpKTtcclxudmFyIE1ic2NGcmFtZUJhc2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NGcmFtZUJhc2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjRnJhbWVCYXNlKGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBfaW5wdXRTZXJ2aWNlLCB2aWV3KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIF9pbnB1dFNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMub25CZWZvcmVDbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5vbkJlZm9yZVNob3cgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMub25DYW5jZWwgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMub25DbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5vbkZpbGwgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMub25NYXJrdXBSZWFkeSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5vblBvc2l0aW9uID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm9uU2hvdyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY0ZyYW1lQmFzZS5wcm90b3R5cGUsIFwiaW5saW5lXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmRpc3BsYXkgfHwgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuZGlzcGxheSkpID09PSAnaW5saW5lJztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE1ic2NGcmFtZUJhc2UucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2xvbmVEaWN0aW9uYXJ5LmludmFsaWQgPSBbXTtcclxuICAgICAgICB0aGlzLmNsb25lRGljdGlvbmFyeS52YWxpZCA9IFtdO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdPbkluaXQuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NGcmFtZUJhc2UucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NGcmFtZUJhc2UucHJvdG90eXBlLCBcImRyb3Bkb3duXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NGcmFtZUJhc2UucHJvdG90eXBlLCBcImFuY2hvclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjRnJhbWVCYXNlLnByb3RvdHlwZSwgXCJhbmltYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgTWJzY0ZyYW1lQmFzZS5wcm90b3R5cGUsIFwiYnV0dG9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY0ZyYW1lQmFzZS5wcm90b3R5cGUsIFwiY2xvc2VPbk92ZXJsYXlUYXBcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY0ZyYW1lQmFzZS5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjRnJhbWVCYXNlLnByb3RvdHlwZSwgXCJkaXNwbGF5XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjRnJhbWVCYXNlLnByb3RvdHlwZSwgXCJzaG93SW5wdXRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY0ZyYW1lQmFzZS5wcm90b3R5cGUsIFwiZm9jdXNPbkNsb3NlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjRnJhbWVCYXNlLnByb3RvdHlwZSwgXCJmb2N1c1RyYXBcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY0ZyYW1lQmFzZS5wcm90b3R5cGUsIFwiaGVhZGVyVGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY0ZyYW1lQmFzZS5wcm90b3R5cGUsIFwic2Nyb2xsTG9ja1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY0ZyYW1lQmFzZS5wcm90b3R5cGUsIFwidG91Y2hVaVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NGcmFtZUJhc2UucHJvdG90eXBlLCBcIm9uQmVmb3JlQ2xvc2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjRnJhbWVCYXNlLnByb3RvdHlwZSwgXCJvbkJlZm9yZVNob3dcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjRnJhbWVCYXNlLnByb3RvdHlwZSwgXCJvbkNhbmNlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NGcmFtZUJhc2UucHJvdG90eXBlLCBcIm9uQ2xvc2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjRnJhbWVCYXNlLnByb3RvdHlwZSwgXCJvbkZpbGxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjRnJhbWVCYXNlLnByb3RvdHlwZSwgXCJvbk1hcmt1cFJlYWR5XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY0ZyYW1lQmFzZS5wcm90b3R5cGUsIFwib25Qb3NpdGlvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NGcmFtZUJhc2UucHJvdG90eXBlLCBcIm9uU2hvd1wiLCB2b2lkIDApO1xyXG4gICAgTWJzY0ZyYW1lQmFzZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW21ic2MtZnItYl0nIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLCBOZ0NvbnRyb2wsIE1ic2NJbnB1dFNlcnZpY2UsIFZpZXdDb250YWluZXJSZWZdKVxyXG4gICAgXSwgTWJzY0ZyYW1lQmFzZSk7XHJcbiAgICByZXR1cm4gTWJzY0ZyYW1lQmFzZTtcclxufShNYnNjQ29udHJvbEJhc2UpKTtcclxudmFyIE1ic2NTY3JvbGxlckJhc2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NTY3JvbGxlckJhc2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjU2Nyb2xsZXJCYXNlKGluaXRpYWxFbGVtZW50LCB6b25lLCBjb250cm9sLCBfaW5wdXRTZXJ2aWNlLCB2aWV3KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW1lbnQsIHpvbmUsIGNvbnRyb2wsIF9pbnB1dFNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMub25XaGVlbENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5vblNldCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5vbkl0ZW1UYXAgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMub25DbGVhciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NTY3JvbGxlckJhc2UucHJvdG90eXBlLCBcImNpcmN1bGFyXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIE1ic2NTY3JvbGxlckJhc2UucHJvdG90eXBlLCBcImhlaWdodFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjU2Nyb2xsZXJCYXNlLnByb3RvdHlwZSwgXCJsYXlvdXRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY1Njcm9sbGVyQmFzZS5wcm90b3R5cGUsIFwibWF4V2lkdGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY1Njcm9sbGVyQmFzZS5wcm90b3R5cGUsIFwibWluV2lkdGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgTWJzY1Njcm9sbGVyQmFzZS5wcm90b3R5cGUsIFwibXVsdGlsaW5lXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NTY3JvbGxlckJhc2UucHJvdG90eXBlLCBcInJlYWRvbmx5XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIE1ic2NTY3JvbGxlckJhc2UucHJvdG90eXBlLCBcInJvd3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NTY3JvbGxlckJhc2UucHJvdG90eXBlLCBcInNob3dMYWJlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY1Njcm9sbGVyQmFzZS5wcm90b3R5cGUsIFwic2hvd1Njcm9sbEFycm93c1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIE1ic2NTY3JvbGxlckJhc2UucHJvdG90eXBlLCBcIndoZWVsc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjU2Nyb2xsZXJCYXNlLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcclxuICAgIF0sIE1ic2NTY3JvbGxlckJhc2UucHJvdG90eXBlLCBcInZhbGlkYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NTY3JvbGxlckJhc2UucHJvdG90eXBlLCBcImNhbmNlbFRleHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1Njcm9sbGVyQmFzZS5wcm90b3R5cGUsIFwiY2xlYXJUZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NTY3JvbGxlckJhc2UucHJvdG90eXBlLCBcInNlbGVjdGVkVGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjU2Nyb2xsZXJCYXNlLnByb3RvdHlwZSwgXCJzZXRUZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxyXG4gICAgXSwgTWJzY1Njcm9sbGVyQmFzZS5wcm90b3R5cGUsIFwiZm9ybWF0VmFsdWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXHJcbiAgICBdLCBNYnNjU2Nyb2xsZXJCYXNlLnByb3RvdHlwZSwgXCJwYXJzZVZhbHVlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoJ29uQ2hhbmdlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NTY3JvbGxlckJhc2UucHJvdG90eXBlLCBcIm9uV2hlZWxDaGFuZ2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjU2Nyb2xsZXJCYXNlLnByb3RvdHlwZSwgXCJvblNldFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NTY3JvbGxlckJhc2UucHJvdG90eXBlLCBcIm9uSXRlbVRhcFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NTY3JvbGxlckJhc2UucHJvdG90eXBlLCBcIm9uQ2xlYXJcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NTY3JvbGxlckJhc2UgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1ttYnNjLXMtYl0nIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLCBOZ0NvbnRyb2wsIE1ic2NJbnB1dFNlcnZpY2UsIFZpZXdDb250YWluZXJSZWZdKVxyXG4gICAgXSwgTWJzY1Njcm9sbGVyQmFzZSk7XHJcbiAgICByZXR1cm4gTWJzY1Njcm9sbGVyQmFzZTtcclxufShNYnNjRnJhbWVCYXNlKSk7XHJcbnZhciBNYnNjQmFzZU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNYnNjQmFzZU1vZHVsZSgpIHtcclxuICAgIH1cclxuICAgIE1ic2NCYXNlTW9kdWxlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgTmdNb2R1bGUoe1xyXG4gICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSxcclxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWJzY0Jhc2UsIE1ic2NWYWx1ZUJhc2UsIE1ic2NDbG9uZUJhc2UsIE1ic2NDb250cm9sQmFzZV0sXHJcbiAgICAgICAgfSlcclxuICAgIF0sIE1ic2NCYXNlTW9kdWxlKTtcclxuICAgIHJldHVybiBNYnNjQmFzZU1vZHVsZTtcclxufSgpKTtcclxudmFyIE1ic2NGcmFtZUJhc2VNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWJzY0ZyYW1lQmFzZU1vZHVsZSgpIHtcclxuICAgIH1cclxuICAgIE1ic2NGcmFtZUJhc2VNb2R1bGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBOZ01vZHVsZSh7XHJcbiAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIE1ic2NCYXNlTW9kdWxlXSxcclxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWJzY0ZyYW1lQmFzZV0sXHJcbiAgICAgICAgfSlcclxuICAgIF0sIE1ic2NGcmFtZUJhc2VNb2R1bGUpO1xyXG4gICAgcmV0dXJuIE1ic2NGcmFtZUJhc2VNb2R1bGU7XHJcbn0oKSk7XHJcbnZhciBNYnNjU2Nyb2xsZXJCYXNlTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1ic2NTY3JvbGxlckJhc2VNb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBNYnNjU2Nyb2xsZXJCYXNlTW9kdWxlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgTmdNb2R1bGUoe1xyXG4gICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBNYnNjRnJhbWVCYXNlTW9kdWxlXSxcclxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWJzY1Njcm9sbGVyQmFzZV0sXHJcbiAgICAgICAgfSlcclxuICAgIF0sIE1ic2NTY3JvbGxlckJhc2VNb2R1bGUpO1xyXG4gICAgcmV0dXJuIE1ic2NTY3JvbGxlckJhc2VNb2R1bGU7XHJcbn0oKSk7XHJcbmZ1bmN0aW9uIGRlZXBFcXVhbHNBcnJheShhMSwgYTIpIHtcclxuICAgIGlmIChhMSA9PT0gYTIpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFhMSB8fCAhYTIgfHwgYTEubGVuZ3RoICE9PSBhMi5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGExLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChhMVtpXSAhPT0gYTJbaV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBpc0RhdGVFcXVhbChkMSwgZDIpIHtcclxuICAgIGlmICgoZDEgJiYgIWQyKSB8fCAoZDIgJiYgIWQxKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKCFkMSAmJiAhZDIpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBkMSAmJiBkMiAmJiBkMS50b1N0cmluZygpID09PSBkMi50b1N0cmluZygpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGVtcHR5T3JUcnVlKHZhbCkge1xyXG4gICAgcmV0dXJuICh0eXBlb2YgKHZhbCkgPT09ICdzdHJpbmcnICYmICh2YWwgPT09ICd0cnVlJyB8fCB2YWwgPT09ICcnKSkgfHwgISF2YWw7XHJcbn1cclxudmFyIElOUFVUX1RFTVBMQVRFID0gXCI8bWJzYy1pbnB1dCAqbmdJZj1cXFwiIWlubGluZSB8fCBzaG93SW5wdXRcXFwiXFxuICAgIFtjb250cm9sTmddPVxcXCJmYWxzZVxcXCIgW25hbWVdPVxcXCJuYW1lXFxcIiBbdGhlbWVdPVxcXCJ0aGVtZVxcXCIgW3RoZW1lVmFyaWFudF09XFxcInRoZW1lVmFyaWFudFxcXCIgW2xhYmVsLXN0eWxlXT1cXFwibGFiZWxTdHlsZVxcXCIgW2lucHV0LXN0eWxlXT1cXFwiaW5wdXRTdHlsZVxcXCIgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiIFtkcm9wZG93bl09XFxcImRyb3Bkb3duXFxcIiBbcGxhY2Vob2xkZXJdPVxcXCJwbGFjZWhvbGRlclxcXCJcXG4gICAgW2Vycm9yXT1cXFwiZXJyb3JcXFwiIFtlcnJvck1lc3NhZ2VdPVxcXCJlcnJvck1lc3NhZ2VcXFwiXFxuICAgIFtpY29uXT1cXFwiaW5wdXRJY29uXFxcIiBbaWNvbi1hbGlnbl09XFxcImljb25BbGlnblxcXCI+XFxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cXG48L21ic2MtaW5wdXQ+XCI7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxudmFyIHdyYXBDbGFzcyA9ICdtYnNjLWlucHV0LXdyYXAnO1xudmFyIGV2ZW50cyA9IFsndG91Y2hlbmQnLCAndG91Y2hjYW5jZWwnLCAnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdtb3VzZXVwJywgJ21vdXNlbGVhdmUnXTtcbnZhciBkZWZhdWx0cyA9IHtcbiAgdGFwOiBoYXNHaG9zdENsaWNrXG59O1xudmFyICRhY3RpdmU7XG5cbmZ1bmN0aW9uIGFkZEljb24oJGNvbnRyb2wsIGljKSB7XG4gIHZhciBpY29ucyA9IHt9LFxuICAgICAgY29udHJvbCA9ICRjb250cm9sWzBdLFxuICAgICAgJHBhcmVudCA9ICRjb250cm9sLnBhcmVudCgpLFxuICAgICAgZXJyb3JNc2cgPSAkcGFyZW50LmZpbmQoJy5tYnNjLWVyci1tc2cnKSxcbiAgICAgIGFsaWduID0gJGNvbnRyb2wuYXR0cignZGF0YS1pY29uLWFsaWduJykgfHwgJ2xlZnQnLFxuICAgICAgaWNvbiA9ICRjb250cm9sLmF0dHIoJ2RhdGEtaWNvbicpO1xuXG4gIGlmICgkcGFyZW50Lmhhc0NsYXNzKHdyYXBDbGFzcykpIHtcbiAgICAkcGFyZW50ID0gJHBhcmVudC5wYXJlbnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXcmFwIGlucHV0XG4gICAgJCQxKCc8c3BhbiBjbGFzcz1cIicgKyB3cmFwQ2xhc3MgKyAnXCI+PC9zcGFuPicpLmluc2VydEFmdGVyKCRjb250cm9sKS5hcHBlbmQoJGNvbnRyb2wpO1xuICB9XG5cbiAgaWYgKGVycm9yTXNnKSB7XG4gICAgJHBhcmVudC5maW5kKCcuJyArIHdyYXBDbGFzcykuYXBwZW5kKGVycm9yTXNnKTtcbiAgfVxuXG4gIGlmIChpY29uKSB7XG4gICAgaWYgKGljb24uaW5kZXhPZigneycpICE9PSAtMSkge1xuICAgICAgaWNvbnMgPSBKU09OLnBhcnNlKGljb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpY29uc1thbGlnbl0gPSBpY29uO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb250cm9sLnR5cGUgPT0gJ2ZpbGUnKSB7XG4gICAgLy8gU2V0IGljb25cbiAgICBpY29ucy5yaWdodCA9ICRjb250cm9sLmF0dHIoJ2RhdGEtaWNvbi11cGxvYWQnKSB8fCAndXBsb2FkJztcbiAgfVxuXG4gIGlmIChpY29uIHx8IGljKSB7XG4gICAgZXh0ZW5kJDEoaWNvbnMsIGljKTtcbiAgICAkcGFyZW50LmFkZENsYXNzKChpY29ucy5yaWdodCA/ICdtYnNjLWljLXJpZ2h0ICcgOiAnJykgKyAoaWNvbnMubGVmdCA/ICcgbWJzYy1pYy1sZWZ0JyA6ICcnKSkuZmluZCgnLicgKyB3cmFwQ2xhc3MpLmFwcGVuZCgnPHNwYW4gY2xhc3M9XCJtYnNjLWlucHV0LWZpbGxcIj48L3NwYW4+JykuYXBwZW5kKGljb25zLmxlZnQgPyAnPHNwYW4gY2xhc3M9XCJtYnNjLWlucHV0LWljIG1ic2MtbGVmdC1pYyBtYnNjLWljIG1ic2MtaWMtJyArIGljb25zLmxlZnQgKyAnXCI+PC9zcGFuPicgOiAnJykuYXBwZW5kKGljb25zLnJpZ2h0ID8gJzxzcGFuIGNsYXNzPVwibWJzYy1pbnB1dC1pYyBtYnNjLXJpZ2h0LWljIG1ic2MtaWMgbWJzYy1pYy0nICsgaWNvbnMucmlnaHQgKyAnXCI+PC9zcGFuPicgOiAnJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkSWNvblRvZ2dsZSh0aGF0LCAkcGFyZW50LCAkY29udHJvbCkge1xuICB2YXIgaWNvbnMgPSB7fSxcbiAgICAgIGNvbnRyb2wgPSAkY29udHJvbFswXSxcbiAgICAgIHRvZ2dsZSA9ICRjb250cm9sLmF0dHIoJ2RhdGEtcGFzc3dvcmQtdG9nZ2xlJyksXG4gICAgICBpY29uU2hvdyA9ICRjb250cm9sLmF0dHIoJ2RhdGEtaWNvbi1zaG93JykgfHwgJ2V5ZScsXG4gICAgICBpY29uSGlkZSA9ICRjb250cm9sLmF0dHIoJ2RhdGEtaWNvbi1oaWRlJykgfHwgJ2V5ZS1ibG9ja2VkJztcblxuICBpZiAodG9nZ2xlKSB7XG4gICAgaWNvbnMucmlnaHQgPSBjb250cm9sLnR5cGUgPT0gJ3Bhc3N3b3JkJyA/IGljb25TaG93IDogaWNvbkhpZGU7XG4gIH1cblxuICBhZGRJY29uKCRjb250cm9sLCBpY29ucyk7XG5cbiAgaWYgKHRvZ2dsZSkge1xuICAgIHRhcCh0aGF0LCAkcGFyZW50LmZpbmQoJy5tYnNjLXJpZ2h0LWljJykuYWRkQ2xhc3MoJ21ic2MtaW5wdXQtdG9nZ2xlJyksIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChjb250cm9sLnR5cGUgPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgY29udHJvbC50eXBlID0gXCJwYXNzd29yZFwiO1xuICAgICAgICAkJDEodGhpcykuYWRkQ2xhc3MoJ21ic2MtaWMtJyArIGljb25TaG93KS5yZW1vdmVDbGFzcygnbWJzYy1pYy0nICsgaWNvbkhpZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udHJvbC50eXBlID0gXCJ0ZXh0XCI7XG4gICAgICAgICQkMSh0aGlzKS5yZW1vdmVDbGFzcygnbWJzYy1pYy0nICsgaWNvblNob3cpLmFkZENsYXNzKCdtYnNjLWljLScgKyBpY29uSGlkZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd3JhcExhYmVsKCRwYXJlbnQsIHR5cGUsIGlucHV0U3R5bGUsIGxhYmVsU3R5bGUsIGVsbSkge1xuICAvLyBXcmFwIG5vbi1lbXB0eSB0ZXh0IG5vZGVzIGluIHNwYW4gd2l0aCBtYnNjLWxhYmVsIGNsYXNzXG4gIGlmICh0eXBlID09ICdzZWdtZW50ZWQnKSB7XG4gICAgJHBhcmVudC5jbG9zZXN0KCcubWJzYy1zZWdtZW50ZWQnKS5hZGRDbGFzcyhpbnB1dFN0eWxlID09ICdib3gnID8gJ21ic2MtaW5wdXQtYm94JyA6ICcnKS5hZGRDbGFzcyhpbnB1dFN0eWxlID09ICdvdXRsaW5lJyA/ICdtYnNjLWlucHV0LW91dGxpbmUnIDogJycpO1xuICB9IGVsc2UgaWYgKHR5cGUgIT0gJ2J1dHRvbicgJiYgdHlwZSAhPSAnc3VibWl0Jykge1xuICAgICRwYXJlbnQuYWRkQ2xhc3MoJ21ic2MtY29udHJvbC13JykuYWRkQ2xhc3MoaW5wdXRTdHlsZSA9PSAnYm94JyA/ICdtYnNjLWlucHV0LWJveCcgOiAnJykuYWRkQ2xhc3MoaW5wdXRTdHlsZSA9PSAnb3V0bGluZScgPyAnbWJzYy1pbnB1dC1vdXRsaW5lJyA6ICcnKS5hZGRDbGFzcyhsYWJlbFN0eWxlID09ICdpbmxpbmUnID8gJ21ic2MtbGFiZWwtaW5saW5lJyA6ICcnKS5hZGRDbGFzcyhsYWJlbFN0eWxlID09ICdzdGFja2VkJyA/ICdtYnNjLWxhYmVsLXN0YWNrZWQnIDogJycpLmFkZENsYXNzKGxhYmVsU3R5bGUgPT0gJ2Zsb2F0aW5nJyA/ICdtYnNjLWxhYmVsLWZsb2F0aW5nJyA6ICcnKS5hZGRDbGFzcyhsYWJlbFN0eWxlID09ICdmbG9hdGluZycgJiYgZWxtLnZhbHVlID8gJ21ic2MtbGFiZWwtZmxvYXRpbmctYWN0aXZlJyA6ICcnKS5maW5kKCdsYWJlbCcpLmFkZENsYXNzKCdtYnNjLWxhYmVsJykuZWFjaChmdW5jdGlvbiAoaSwgdikge1xuICAgICAgJCQxKHYpLmF0dHIoJ3RpdGxlJywgJCQxKHYpLnRleHQoKSk7XG4gICAgfSk7XG4gICAgJHBhcmVudC5jb250ZW50cygpLmZpbHRlcihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlVHlwZSA9PSAzICYmIHRoaXMubm9kZVZhbHVlICYmIC9cXFMvLnRlc3QodGhpcy5ub2RlVmFsdWUpO1xuICAgIH0pLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgJCQxKCc8c3BhbiBjbGFzcz1cIm1ic2MtbGFiZWxcIiB0aXRsZT1cIicgKyB0aGlzLnRleHRDb250ZW50LnRyaW0oKSArICdcIj48L3NwYW4+JykuaW5zZXJ0QWZ0ZXIodGhpcykuYXBwZW5kKHRoaXMpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJpcHBsZSh0aGVtZSkge1xuICB2YXIgcmlwcGxlID0gbW9iaXNjcm9sbC50aGVtZXMuZm9ybVt0aGVtZV07XG4gIHJldHVybiByaXBwbGUgJiYgcmlwcGxlLmFkZFJpcHBsZSA/IHJpcHBsZSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEF0dHIoJGVsbSwgYXR0ciwgZGVmKSB7XG4gIHZhciB2ID0gJGVsbS5hdHRyKGF0dHIpO1xuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09ICcnID8gZGVmIDogdjtcbn1cblxuZnVuY3Rpb24gZ2V0Q3NzQ2xhc3Mocykge1xuICB2YXIgdGhlbWUgPSBnZXRUaGVtZU5hbWUocyk7XG4gIHZhciBiYXNlVGhlbWUgPSBtb2Jpc2Nyb2xsLnRoZW1lcy5mb3JtW3RoZW1lXS5iYXNlVGhlbWU7XG4gIHJldHVybiAnbWJzYy0nICsgdGhlbWUgKyAoYmFzZVRoZW1lID8gJyBtYnNjLScgKyBiYXNlVGhlbWUgOiAnJykgKyAocy5ydGwgPyAnIG1ic2MtcnRsJyA6ICcgbWJzYy1sdHInKTtcbn1cblxudmFyIEZvcm1Db250cm9sID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRm9ybUNvbnRyb2woZWxtLCBzZXR0aW5ncykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgcyA9IGV4dGVuZCQxKHt9LCBkZWZhdWx0cywgbW9iaXNjcm9sbC5zZXR0aW5ncywgc2V0dGluZ3MpO1xuICAgIHZhciAkZWxtID0gJCQxKGVsbSk7XG4gICAgdmFyICRwID0gJGVsbS5wYXJlbnQoKTtcbiAgICB2YXIgJHBhcmVudCA9ICRwLmhhc0NsYXNzKCdtYnNjLWlucHV0LXdyYXAnKSA/ICRwLnBhcmVudCgpIDogJHA7IC8vIENoZWNrIGZvciBpbmxpbmUgbW9iaXNjcm9sbCBjb21wb25lbnRzXG5cbiAgICB2YXIgJGZyYW1lID0gJGVsbS5uZXh0KCkuaGFzQ2xhc3MoJ21ic2MtZnInKSA/ICRlbG0ubmV4dCgpIDogbnVsbDtcbiAgICB2YXIgdHlwZSA9IGdldENvbnRyb2xUeXBlKCRlbG0pO1xuICAgIHZhciBpbnB1dFN0eWxlID0gZ2V0QXR0cigkZWxtLCAnZGF0YS1pbnB1dC1zdHlsZScsIHMuaW5wdXRTdHlsZSk7XG4gICAgdmFyIGxhYmVsU3R5bGUgPSBnZXRBdHRyKCRlbG0sICdkYXRhLWxhYmVsLXN0eWxlJywgcy5sYWJlbFN0eWxlKTtcblxuICAgIGlmIChlbG0ubWJzY0luc3QpIHtcbiAgICAgIGVsbS5tYnNjSW5zdC5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgaWYgKCRmcmFtZSkge1xuICAgICAgJGZyYW1lLmluc2VydEFmdGVyKCRwYXJlbnQpO1xuICAgIH1cblxuICAgIHMudGhlbWUgPSBnZXRUaGVtZU5hbWUocyk7XG5cbiAgICBpZiAocy5ydGwgPT09IHVuZGVmaW5lZCAmJiBzLmxhbmcgJiYgbW9iaXNjcm9sbC5pMThuW3MubGFuZ10pIHtcbiAgICAgIHMucnRsID0gbW9iaXNjcm9sbC5pMThuW3MubGFuZ10ucnRsO1xuICAgIH1cblxuICAgIHdyYXBMYWJlbCgkcGFyZW50LCB0eXBlLCBpbnB1dFN0eWxlLCBsYWJlbFN0eWxlLCBlbG0pO1xuICAgICRlbG0uYWRkQ2xhc3MoJ21ic2MtY29udHJvbCcpOyAvLyBBdHRhY2ggZXZlbnRzXG5cbiAgICB0aGlzLl9oYW5kbGUgPSB0aGlzLl9oYW5kbGUuYmluZCh0aGlzKTsgLy8gUHJldmVudCAzMDBtcyBjbGljayBsYXRlbmN5XG5cbiAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICRlbG0ub24oZXYsIF90aGlzLl9oYW5kbGUpO1xuICAgIH0pOyAvLyBUb3VjaCBldmVudHMgYXJlIGFkZGVkIHNlcGFyYXRlbHksIG5lZWRzIHRvIGJlIHBhc3NpdmUgbGlzdGVuZXJcblxuICAgIGxpc3RlbihlbG0sICd0b3VjaHN0YXJ0JywgdGhpcy5faGFuZGxlLCB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG4gICAgbGlzdGVuKGVsbSwgJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZSwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzO1xuICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuICAgIHRoaXMuX2VsbSA9IGVsbTtcbiAgICB0aGlzLl8kZWxtID0gJGVsbTtcbiAgICB0aGlzLl8kcGFyZW50ID0gJHBhcmVudDtcbiAgICB0aGlzLl8kZnJhbWUgPSAkZnJhbWU7XG4gICAgdGhpcy5fcmlwcGxlID0gZ2V0UmlwcGxlKHMudGhlbWUpO1xuICAgIHRoaXMuX2lzRmxvYXRpbmcgPSBsYWJlbFN0eWxlID09ICdmbG9hdGluZycgfHwgJHBhcmVudC5oYXNDbGFzcygnbWJzYy1sYWJlbC1mbG9hdGluZycpO1xuICAgIHRoaXMuY3NzQ2xhc3MgPSBnZXRDc3NDbGFzcyhzKTtcbiAgICB0aGlzLmdldENsYXNzRWxtKCkuYWRkQ2xhc3ModGhpcy5jc3NDbGFzcyk7XG4gICAgZWxtLm1ic2NJbnN0ID0gdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBGb3JtQ29udHJvbC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldENsYXNzRWxtID0gZnVuY3Rpb24gZ2V0Q2xhc3NFbG0oKSB7XG4gICAgcmV0dXJuIHRoaXMuXyRwYXJlbnQ7XG4gIH07XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyICRlbG0gPSB0aGlzLl8kZWxtO1xuICAgIHZhciBlbG0gPSB0aGlzLl9lbG07XG4gICAgJGVsbS5yZW1vdmVDbGFzcygnbWJzYy1jb250cm9sJyk7XG4gICAgdGhpcy5nZXRDbGFzc0VsbSgpLnJlbW92ZUNsYXNzKHRoaXMuY3NzQ2xhc3MpO1xuICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xuICAgICAgJGVsbS5vZmYoZXYsIF90aGlzMi5faGFuZGxlKTtcbiAgICB9KTtcbiAgICB1bmxpc3RlbihlbG0sICd0b3VjaHN0YXJ0JywgdGhpcy5faGFuZGxlLCB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG4gICAgdW5saXN0ZW4oZWxtLCAndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlLCB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG4gICAgZGVsZXRlIGVsbS5tYnNjSW5zdDtcbiAgfTtcblxuICBfcHJvdG8ub3B0aW9uID0gZnVuY3Rpb24gb3B0aW9uKHMpIHtcbiAgICBleHRlbmQkMSh0aGlzLnNldHRpbmdzLCBzKTtcbiAgICB2YXIgY2xhc3NFbG0gPSB0aGlzLmdldENsYXNzRWxtKCk7XG5cbiAgICBpZiAodGhpcy5jc3NDbGFzcykge1xuICAgICAgY2xhc3NFbG0ucmVtb3ZlQ2xhc3ModGhpcy5jc3NDbGFzcyk7XG4gICAgfVxuXG4gICAgdGhpcy5jc3NDbGFzcyA9IGdldENzc0NsYXNzKHRoaXMuc2V0dGluZ3MpO1xuICAgIGNsYXNzRWxtLmFkZENsYXNzKHRoaXMuY3NzQ2xhc3MpO1xuICAgIHRoaXMuX3JpcHBsZSA9IGdldFJpcHBsZSh0aGlzLnNldHRpbmdzLnRoZW1lKTtcbiAgfTtcblxuICBfcHJvdG8uX2hhbmRsZSA9IGZ1bmN0aW9uIF9oYW5kbGUoZXYpIHtcbiAgICBzd2l0Y2ggKGV2LnR5cGUpIHtcbiAgICAgIGNhc2UgJ3RvdWNoc3RhcnQnOlxuICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgdGhpcy5fb25TdGFydChldik7XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3RvdWNobW92ZSc6XG4gICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgICB0aGlzLl9vbk1vdmUoZXYpO1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd0b3VjaGVuZCc6XG4gICAgICBjYXNlICd0b3VjaGNhbmNlbCc6XG4gICAgICBjYXNlICdtb3VzZXVwJzpcbiAgICAgIGNhc2UgJ21vdXNlbGVhdmUnOlxuICAgICAgICB0aGlzLl9vbkVuZChldik7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fYWRkUmlwcGxlID0gZnVuY3Rpb24gX2FkZFJpcHBsZShldikge1xuICAgIGlmICh0aGlzLl9yaXBwbGUgJiYgdGhpcy5fJHJpcHBsZUVsbSkge1xuICAgICAgdGhpcy5fcmlwcGxlLmFkZFJpcHBsZSh0aGlzLl8kcmlwcGxlRWxtLCBldik7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fcmVtb3ZlUmlwcGxlID0gZnVuY3Rpb24gX3JlbW92ZVJpcHBsZSgpIHtcbiAgICBpZiAodGhpcy5fcmlwcGxlICYmIHRoaXMuXyRyaXBwbGVFbG0pIHtcbiAgICAgIHRoaXMuX3JpcHBsZS5yZW1vdmVSaXBwbGUoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9vblN0YXJ0ID0gZnVuY3Rpb24gX29uU3RhcnQoZXYpIHtcbiAgICB2YXIgZWxtID0gdGhpcy5fZWxtO1xuXG4gICAgaWYgKHRlc3RUb3VjaChldiwgZWxtKSkge1xuICAgICAgdGhpcy5fc3RhcnRYID0gZ2V0Q29vcmQoZXYsICdYJyk7XG4gICAgICB0aGlzLl9zdGFydFkgPSBnZXRDb29yZChldiwgJ1knKTtcblxuICAgICAgaWYgKCRhY3RpdmUpIHtcbiAgICAgICAgJGFjdGl2ZS5yZW1vdmVDbGFzcygnbWJzYy1hY3RpdmUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFlbG0uZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5faXNBY3RpdmUgPSB0cnVlO1xuICAgICAgICAkYWN0aXZlID0gdGhpcy5fJGVsbTtcbiAgICAgICAgJGFjdGl2ZS5hZGRDbGFzcygnbWJzYy1hY3RpdmUnKTtcblxuICAgICAgICB0aGlzLl9hZGRSaXBwbGUoZXYpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChldi50eXBlID09ICd0b3VjaHN0YXJ0Jykge1xuICAgICAgdGhpcy5fJGVsbS5jbG9zZXN0KCcubWJzYy1uby10b3VjaCcpLnJlbW92ZUNsYXNzKCdtYnNjLW5vLXRvdWNoJyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fb25Nb3ZlID0gZnVuY3Rpb24gX29uTW92ZShldikge1xuICAgIC8vIElmIG1vdmVtZW50IGlzIG1vcmUgdGhhbiA5cHgsIGRvbid0IGZpcmUgdGhlIGNsaWNrIGV2ZW50IGhhbmRsZXJcbiAgICBpZiAodGhpcy5faXNBY3RpdmUgJiYgTWF0aC5hYnMoZ2V0Q29vcmQoZXYsICdYJykgLSB0aGlzLl9zdGFydFgpID4gOSB8fCBNYXRoLmFicyhnZXRDb29yZChldiwgJ1knKSAtIHRoaXMuX3N0YXJ0WSkgPiA5KSB7XG4gICAgICB0aGlzLl8kZWxtLnJlbW92ZUNsYXNzKCdtYnNjLWFjdGl2ZScpO1xuXG4gICAgICB0aGlzLl9yZW1vdmVSaXBwbGUoKTtcblxuICAgICAgdGhpcy5faXNBY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9vbkVuZCA9IGZ1bmN0aW9uIF9vbkVuZChldikge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgdmFyIGNvbnRyb2wgPSB0aGlzLl9lbG07XG4gICAgdmFyIHR5cGUgPSB0aGlzLl90eXBlO1xuXG4gICAgaWYgKHRoaXMuX2lzQWN0aXZlICYmIHRoaXMuc2V0dGluZ3MudGFwICYmIGV2LnR5cGUgPT0gJ3RvdWNoZW5kJyAmJiAhY29udHJvbC5yZWFkT25seSkge1xuICAgICAgYWN0aXZhdGVDb250cm9sKGNvbnRyb2wsIHR5cGUsIGV2KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faXNBY3RpdmUpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMuXyRlbG0ucmVtb3ZlQ2xhc3MoJ21ic2MtYWN0aXZlJyk7XG5cbiAgICAgICAgX3RoaXMzLl9yZW1vdmVSaXBwbGUoKTtcbiAgICAgIH0sIDEwMCk7XG4gICAgfVxuXG4gICAgdGhpcy5faXNBY3RpdmUgPSBmYWxzZTtcbiAgICAkYWN0aXZlID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gRm9ybUNvbnRyb2w7XG59KCk7XG5tb2Jpc2Nyb2xsLnRoZW1lcy5mb3JtLm1vYmlzY3JvbGwgPSB7fTtcblxudmFyIGV2ZW50cyQxID0gWydmb2N1cycsICdjaGFuZ2UnLCAnYmx1cicsICdhbmltYXRpb25zdGFydCddO1xudmFyIElucHV0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRm9ybUNvbnRyb2wpIHtcbiAgX2luaGVyaXRzTG9vc2UoSW5wdXQsIF9Gb3JtQ29udHJvbCk7XG5cbiAgZnVuY3Rpb24gSW5wdXQoZWxtLCBzZXR0aW5ncykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Zvcm1Db250cm9sLmNhbGwodGhpcywgZWxtLCBzZXR0aW5ncykgfHwgdGhpcztcbiAgICB2YXIgJGVsbSA9IF90aGlzLl8kZWxtO1xuICAgIHZhciAkcGFyZW50ID0gX3RoaXMuXyRwYXJlbnQ7XG4gICAgdmFyICRkdW1teSA9ICRwYXJlbnQuZmluZCgnLm1ic2Mtc2VsZWN0LWlucHV0LCAubWJzYy1jb2xvci1pbnB1dCcpO1xuICAgIGFkZEljb25Ub2dnbGUoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksICRwYXJlbnQsICRlbG0pO1xuICAgIF90aGlzLl9jaGVja0xhYmVsID0gX3RoaXMuX2NoZWNrTGFiZWwuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMuX21vdXNlRG93biA9IF90aGlzLl9tb3VzZURvd24uYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMuX3NldFRleHQgPSBfdGhpcy5fc2V0VGV4dC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIGlmIChlbG0udHlwZSA9PSAnZmlsZScpIHtcbiAgICAgIC8vIENvcHkgYXR0cmlidXRlcyBhbmQgY3JlYXRlIGR1bW15IGlucHV0XG4gICAgICB2YXIgJGV4aXN0aW5nID0gJHBhcmVudC5maW5kKCcubWJzYy1maWxlLWlucHV0Jyk7XG4gICAgICBfdGhpcy5fJGlucHV0ID0gJGV4aXN0aW5nLmxlbmd0aCA/ICRleGlzdGluZyA6ICQkMSgnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCInICsgKCRlbG0uYXR0cignY2xhc3MnKSB8fCAnJykgKyAnIG1ic2MtZmlsZS1pbnB1dFwiIHBsYWNlaG9sZGVyPVwiJyArICgkZWxtLmF0dHIoJ3BsYWNlaG9sZGVyJykgfHwgJycpICsgJ1wiLz4nKS5pbnNlcnRBZnRlcigkZWxtKTsgLy8gQ29weSB2YWx1ZSBvbiBmaWxlIHVwbG9hZFxuXG4gICAgICAkZWxtLm9uKCdjaGFuZ2UnLCBfdGhpcy5fc2V0VGV4dCk7XG4gICAgfVxuXG4gICAgJHBhcmVudC5hZGRDbGFzcygnbWJzYy1pbnB1dCcpLm9uKCdtb3VzZWRvd24nLCBfdGhpcy5fbW91c2VEb3duKTsgLy8gQXR0YWNoIGV2ZW50c1xuXG4gICAgZXZlbnRzJDEuZm9yRWFjaChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICRlbG0ub24oZXYsIF90aGlzLl9jaGVja0xhYmVsKTtcbiAgICB9KTsgLy8gTW92ZSB0aGUgZHVtbXkgaW5wdXQgYWZ0ZXIgdGhlIGVsZW1lbnQgZm9yIGNvcnJlY3Qgc3R5bGluZ1xuXG4gICAgaWYgKCRkdW1teS5sZW5ndGgpIHtcbiAgICAgICRlbG0uYWZ0ZXIoJGR1bW15KTtcblxuICAgICAgaWYgKCRkdW1teS5oYXNDbGFzcygnbWJzYy1zZWxlY3QtaW5wdXQnKSkge1xuICAgICAgICBfdGhpcy5fZGVsbSA9ICRkdW1teVswXTtcblxuICAgICAgICBfdGhpcy5yZWZyZXNoKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IElucHV0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uX3NldFRleHQgPSBmdW5jdGlvbiBfc2V0VGV4dChldikge1xuICAgIHZhciBmaWxlcyA9IGV2LnRhcmdldC5maWxlcztcbiAgICB2YXIgbmFtZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIG5hbWVzLnB1c2goZmlsZXNbaV0ubmFtZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fJGlucHV0LnZhbChuYW1lcyk7XG4gIH07XG5cbiAgX3Byb3RvLl9jaGVja0xhYmVsID0gZnVuY3Rpb24gX2NoZWNrTGFiZWwoZXYpIHtcbiAgICBpZiAodGhpcy5faXNGbG9hdGluZykge1xuICAgICAgLy8gSW4gY2FzZSBvZiBzZWxlY3Qgd2UgbmVlZCB0byBjaGVjayB0aGUgZHVtbXkgZWxlbWVudFxuICAgICAgdmFyIGVsbSA9IHRoaXMuX2RlbG0gfHwgdGhpcy5fZWxtOyAvLyBJbiBjYXNlIG9mIGF1dG9maWxsIGluIHdlYmtpdCBicm93c2VycyB0aGUgYW5pbWF0aW9uc3RhcnQgZXZlbnQgd2lsbCBmaXJlIFxuICAgICAgLy8gZHVlIHRvIHRoZSBlbXB0eSBhbmltYXRpb24gYWRkZWQgaW4gdGhlIGNzcyxcbiAgICAgIC8vIGJlY2F1c2UgdGhlcmUncyBubyBvdGhlciBldmVudCBpbiBjYXNlIG9mIHRoZSBpbml0aWFsIGF1dG9maWxsXG5cbiAgICAgIGlmIChlbG0udmFsdWUgfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZWxtIHx8IGV2ICYmIChldi50eXBlID09ICdmb2N1cycgfHwgZXYudHlwZSA9PSAnYW5pbWF0aW9uc3RhcnQnICYmIHRoaXMuXyRlbG0uaXMoJyo6LXdlYmtpdC1hdXRvZmlsbCcpKSkge1xuICAgICAgICB0aGlzLl8kcGFyZW50LmFkZENsYXNzKCdtYnNjLWxhYmVsLWZsb2F0aW5nLWFjdGl2ZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fJHBhcmVudC5yZW1vdmVDbGFzcygnbWJzYy1sYWJlbC1mbG9hdGluZy1hY3RpdmUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9tb3VzZURvd24gPSBmdW5jdGlvbiBfbW91c2VEb3duKGV2KSB7XG4gICAgLy8gV2lsbCBwcmV2ZW50IGZsb2F0aW5nIGxhYmVsIGFuaW1hdGlvbiB3aGVuIGxvb3NpbmcgZm9jdXMgb25seSBmb3IgYSBicmllZiBtb21lbnRcbiAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy5fZWxtICYmIGV2LnRhcmdldCAhPT0gdGhpcy5fZWxtKSB7XG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVmcmVzaCA9IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgdGhpcy5fY2hlY2tMYWJlbCgpO1xuICB9O1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIF9Gb3JtQ29udHJvbC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5fJHBhcmVudC5vZmYoJ21vdXNlZG93bicsIHRoaXMuX21vdXNlRG93bikucmVtb3ZlQ2xhc3MoJ21ic2MtaWMtbGVmdCBtYnNjLWljLXJpZ2h0JykuZmluZCgnLm1ic2MtaW5wdXQtaWMnKS5yZW1vdmUoKTtcblxuICAgIHRoaXMuXyRwYXJlbnQuZmluZCgnLm1ic2MtaW5wdXQtZmlsbCcpLnJlbW92ZSgpO1xuXG4gICAgZXZlbnRzJDEuZm9yRWFjaChmdW5jdGlvbiAoZXYpIHtcbiAgICAgIF90aGlzMi5fJGVsbS5vZmYoZXYsIF90aGlzMi5fY2hlY2tMYWJlbCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl8kZWxtLm9mZignY2hhbmdlJywgdGhpcy5fc2V0VGV4dCk7XG4gIH07XG5cbiAgcmV0dXJuIElucHV0O1xufShGb3JtQ29udHJvbCk7IC8vIEluaXQgbWJzYy1pbnB1dCBlbGVtZW50cyBvbiBwYWdlIGxvYWRcblxuYXV0b0luaXQoJ1ttYnNjLWlucHV0XScsIElucHV0KTtcblxudmFyIE1ic2NGb3JtQmFzZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY0Zvcm1CYXNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY0Zvcm1CYXNlKGhvc3RFbGVtLCBfZm9ybVNlcnZpY2UsIHpvbmUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBob3N0RWxlbSwgem9uZSkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5fZm9ybVNlcnZpY2UgPSBfZm9ybVNlcnZpY2U7XHJcbiAgICAgICAgX3RoaXMuZGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBNYnNjRm9ybUJhc2UucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX2luaGVyaXRlZE9wdGlvbnMgPSB0aGlzLl9mb3JtU2VydmljZSA/IHRoaXMuX2Zvcm1TZXJ2aWNlLm9wdGlvbnMgOiB7fTtcclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NGb3JtQmFzZS5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY0Zvcm1CYXNlLnByb3RvdHlwZSwgXCJvcHRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjRm9ybUJhc2UucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NGb3JtQmFzZS5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgVmlld0NoaWxkKCdpbml0RWxlbWVudCcsIHsgc3RhdGljOiBmYWxzZSB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcclxuICAgIF0sIE1ic2NGb3JtQmFzZS5wcm90b3R5cGUsIFwiX2luaXRFbGVtXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjRm9ybUJhc2UgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1ttYnNjLWYtYl0nIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTWJzY09wdGlvbnNTZXJ2aWNlLCBOZ1pvbmVdKVxyXG4gICAgXSwgTWJzY0Zvcm1CYXNlKTtcclxuICAgIHJldHVybiBNYnNjRm9ybUJhc2U7XHJcbn0oTWJzY0Jhc2UpKTtcclxudmFyIE1ic2NGb3JtVmFsdWVCYXNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjRm9ybVZhbHVlQmFzZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NGb3JtVmFsdWVCYXNlKGhvc3RFbGVtLCBfZm9ybVNlcnZpY2UsIF9pbnB1dFNlcnZpY2UsIF9jb250cm9sLCB6b25lKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaG9zdEVsZW0sIF9mb3JtU2VydmljZSwgem9uZSkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5fY29udHJvbCA9IF9jb250cm9sO1xyXG4gICAgICAgIF90aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgICAgIF90aGlzLm9uVG91Y2ggPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICAgICAgX3RoaXMuZXJyb3JNZXNzYWdlID0gJyc7XHJcbiAgICAgICAgX3RoaXMudmFsdWVDaGFuZ2VFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIGlmIChfY29udHJvbCAmJiAoIV9pbnB1dFNlcnZpY2UgfHwgIV9pbnB1dFNlcnZpY2UuaXNDb250cm9sU2V0KSkge1xyXG4gICAgICAgICAgICBpZiAoX2NvbnRyb2wudmFsdWVBY2Nlc3NvciAmJiBfY29udHJvbC52YWx1ZUFjY2Vzc29yLm9sZEFjY2Vzc29yICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIF9jb250cm9sLnZhbHVlQWNjZXNzb3Iub2xkQWNjZXNzb3IgPSBfdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF9jb250cm9sLnZhbHVlQWNjZXNzb3IgPSBfdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY0Zvcm1WYWx1ZUJhc2UucHJvdG90eXBlLCBcInJlYWRvbmx5XCIsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVhZG9ubHkgPSBlbXB0eU9yVHJ1ZSh2YWwpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NGb3JtVmFsdWVCYXNlLnByb3RvdHlwZSwgXCJpbm5lclZhbHVlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHY7XHJcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2Uodik7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWVDaGFuZ2VFbWl0dGVyLmVtaXQodik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY0Zvcm1WYWx1ZUJhc2UucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdjtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBNYnNjRm9ybVZhbHVlQmFzZS5wcm90b3R5cGUucmVnaXN0ZXJPbkNoYW5nZSA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcclxuICAgIH07XHJcbiAgICBNYnNjRm9ybVZhbHVlQmFzZS5wcm90b3R5cGUucmVnaXN0ZXJPblRvdWNoZWQgPSBmdW5jdGlvbiAoZm4pIHtcclxuICAgICAgICB0aGlzLm9uVG91Y2ggPSBmbjtcclxuICAgIH07XHJcbiAgICBNYnNjRm9ybVZhbHVlQmFzZS5wcm90b3R5cGUuc2V0RGlzYWJsZWRTdGF0ZSA9IGZ1bmN0aW9uIChpc0Rpc2FibGVkKSB7XHJcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XHJcbiAgICB9O1xyXG4gICAgTWJzY0Zvcm1WYWx1ZUJhc2UucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdjtcclxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcclxuICAgIH07XHJcbiAgICBNYnNjRm9ybVZhbHVlQmFzZS5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlICYmIHRoaXMuaW5zdGFuY2UucmVmcmVzaCkge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmluc3RhbmNlLnJlZnJlc2goKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXHJcbiAgICBdLCBNYnNjRm9ybVZhbHVlQmFzZS5wcm90b3R5cGUsIFwicmVhZG9ubHlcIiwgbnVsbCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxyXG4gICAgXSwgTWJzY0Zvcm1WYWx1ZUJhc2UucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY0Zvcm1WYWx1ZUJhc2UucHJvdG90eXBlLCBcImVycm9yXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NGb3JtVmFsdWVCYXNlLnByb3RvdHlwZSwgXCJlcnJvck1lc3NhZ2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgndmFsdWVDaGFuZ2UnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY0Zvcm1WYWx1ZUJhc2UucHJvdG90eXBlLCBcInZhbHVlQ2hhbmdlRW1pdHRlclwiLCB2b2lkIDApO1xyXG4gICAgTWJzY0Zvcm1WYWx1ZUJhc2UgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1ttYnNjLWZ2LWJdJyB9KSxcclxuICAgICAgICBfX3BhcmFtKDEsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDIsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTWJzY09wdGlvbnNTZXJ2aWNlLCBNYnNjSW5wdXRTZXJ2aWNlLCBOZ0NvbnRyb2wsIE5nWm9uZV0pXHJcbiAgICBdLCBNYnNjRm9ybVZhbHVlQmFzZSk7XHJcbiAgICByZXR1cm4gTWJzY0Zvcm1WYWx1ZUJhc2U7XHJcbn0oTWJzY0Zvcm1CYXNlKSk7XHJcbnZhciBNYnNjSW5wdXRCYXNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjSW5wdXRCYXNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY0lucHV0QmFzZShpbml0aWFsRWxlbSwgX2Zvcm1TZXJ2aWNlLCBfaW5wdXRTZXJ2aWNlLCBfY29udHJvbCwgem9uZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCBfZm9ybVNlcnZpY2UsIF9pbnB1dFNlcnZpY2UsIF9jb250cm9sLCB6b25lKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnR5cGUgPSAndGV4dCc7XHJcbiAgICAgICAgX3RoaXMucGxhY2Vob2xkZXIgPSAnJztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NJbnB1dEJhc2UucHJvdG90eXBlLCBcImF1dG9jb21wbGV0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjSW5wdXRCYXNlLnByb3RvdHlwZSwgXCJhdXRvY2FwaXRhbGl6ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjSW5wdXRCYXNlLnByb3RvdHlwZSwgXCJhdXRvY29ycmVjdFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjSW5wdXRCYXNlLnByb3RvdHlwZSwgXCJzcGVsbGNoZWNrXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NJbnB1dEJhc2UucHJvdG90eXBlLCBcImF1dG9mb2N1c1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBNYnNjSW5wdXRCYXNlLnByb3RvdHlwZSwgXCJtaW5sZW5ndGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgTWJzY0lucHV0QmFzZS5wcm90b3R5cGUsIFwibWF4bGVuZ3RoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NJbnB1dEJhc2UucHJvdG90eXBlLCBcInJlcXVpcmVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NJbnB1dEJhc2UucHJvdG90eXBlLCBcImljb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ2ljb24tYWxpZ24nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0lucHV0QmFzZS5wcm90b3R5cGUsIFwiaWNvbkFsaWduXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NJbnB1dEJhc2UucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ3Bhc3N3b3JkLXRvZ2dsZScpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY0lucHV0QmFzZS5wcm90b3R5cGUsIFwicGFzc3dvcmRUb2dnbGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ2ljb24tc2hvdycpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjSW5wdXRCYXNlLnByb3RvdHlwZSwgXCJpY29uU2hvd1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnaWNvbi1oaWRlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NJbnB1dEJhc2UucHJvdG90eXBlLCBcImljb25IaWRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdpY29uLXVwbG9hZCcpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY0lucHV0QmFzZS5wcm90b3R5cGUsIFwiaWNvblVwbG9hZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnaW5wdXQtc3R5bGUnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0lucHV0QmFzZS5wcm90b3R5cGUsIFwiaW5wdXRTdHlsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnbGFiZWwtc3R5bGUnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0lucHV0QmFzZS5wcm90b3R5cGUsIFwibGFiZWxTdHlsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjSW5wdXRCYXNlLnByb3RvdHlwZSwgXCJwbGFjZWhvbGRlclwiLCB2b2lkIDApO1xyXG4gICAgTWJzY0lucHV0QmFzZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW21ic2MtaS1iXScgfSksXHJcbiAgICAgICAgX19wYXJhbSgxLCBPcHRpb25hbCgpKSwgX19wYXJhbSgyLCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE1ic2NPcHRpb25zU2VydmljZSwgTWJzY0lucHV0U2VydmljZSwgTmdDb250cm9sLCBOZ1pvbmVdKVxyXG4gICAgXSwgTWJzY0lucHV0QmFzZSk7XHJcbiAgICByZXR1cm4gTWJzY0lucHV0QmFzZTtcclxufShNYnNjRm9ybVZhbHVlQmFzZSkpO1xyXG52YXIgTWJzY0lucHV0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjSW5wdXQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjSW5wdXQoaW5pdGlhbEVsZW0sIF9mb3JtU2VydmljZSwgX2lucHV0U2VydmljZSwgX2NvbnRyb2wsIHpvbmUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgX2Zvcm1TZXJ2aWNlLCBfaW5wdXRTZXJ2aWNlLCBfY29udHJvbCwgem9uZSkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5faW5wdXRTZXJ2aWNlID0gX2lucHV0U2VydmljZTtcclxuICAgICAgICBfdGhpcy5jb250cm9sTmcgPSB0cnVlO1xyXG4gICAgICAgIF90aGlzLmRyb3Bkb3duID0gZmFsc2U7XHJcbiAgICAgICAgX2lucHV0U2VydmljZS5pbnB1dCA9IF90aGlzO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE1ic2NJbnB1dC5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHt9LCB0aGlzLl9pbmhlcml0ZWRPcHRpb25zLCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaik7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBJbnB1dCh0aGlzLl9pbml0RWxlbS5uYXRpdmVFbGVtZW50LCBvcHRpb25zKTtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMuaW5zdGFuY2UucmVmcmVzaCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgTWJzY0lucHV0LnByb3RvdHlwZSwgXCJtaW5cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgTWJzY0lucHV0LnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgTWJzY0lucHV0LnByb3RvdHlwZSwgXCJzdGVwXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NJbnB1dC5wcm90b3R5cGUsIFwicGF0dGVyblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjSW5wdXQucHJvdG90eXBlLCBcImFjY2VwdFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjSW5wdXQucHJvdG90eXBlLCBcIm11bHRpcGxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjSW5wdXQucHJvdG90eXBlLCBcImNvbnRyb2xOZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY0lucHV0LnByb3RvdHlwZSwgXCJkcm9wZG93blwiLCB2b2lkIDApO1xyXG4gICAgTWJzY0lucHV0ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLWlucHV0JyxcclxuICAgICAgICAgICAgaG9zdDoge1xyXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYnNjLWNvbnRyb2wtbmddJzogJ2NvbnRyb2xOZycsXHJcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1ic2MtZXJyXSc6ICdlcnJvcidcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICA8bGFiZWxcXG4gICAgICAgICAgICBbY2xhc3MubWJzYy1lcnJdPVxcXCJlcnJvclxcXCIgW2NsYXNzLm1ic2Mtc2VsZWN0XT1cXFwiZHJvcGRvd25cXFwiXFxuICAgICAgICAgICAgW2NsYXNzLm1ic2MtaW5wdXQtYm94XT1cXFwiaW5wdXRTdHlsZSA9PSAnYm94J1xcXCJcXG4gICAgICAgICAgICBbY2xhc3MubWJzYy1pbnB1dC1vdXRsaW5lXT1cXFwiaW5wdXRTdHlsZSA9PSAnb3V0bGluZSdcXFwiXFxuICAgICAgICAgICAgW2NsYXNzLm1ic2MtbGFiZWwtc3RhY2tlZF09XFxcImxhYmVsU3R5bGUgPT0gJ3N0YWNrZWQnXFxcIlxcbiAgICAgICAgICAgIFtjbGFzcy5tYnNjLWxhYmVsLWlubGluZV09XFxcImxhYmVsU3R5bGUgPT0gJ2lubGluZSdcXFwiXFxuICAgICAgICAgICAgW2NsYXNzLm1ic2MtbGFiZWwtZmxvYXRpbmddPVxcXCJsYWJlbFN0eWxlID09ICdmbG9hdGluZydcXFwiXFxuICAgICAgICA+XFxuICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJtYnNjLWlucHV0LXdyYXBcXFwiPlxcbiAgICAgICAgICAgICAgICA8aW5wdXQgI2luaXRFbGVtZW50IFt0eXBlXT1cXFwidHlwZVxcXCIgW3BsYWNlaG9sZGVyXT1cXFwicGxhY2Vob2xkZXJcXFwiIFsobmdNb2RlbCldPVxcXCJpbm5lclZhbHVlXFxcIiAoYmx1cik9XFxcIm9uVG91Y2goJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLm5hbWVdPVxcXCJuYW1lXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuZGF0YS1pY29uXT1cXFwiaWNvbiA/IGljb24gOiBudWxsXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuZGF0YS1pY29uLWFsaWduXT1cXFwiaWNvbkFsaWduID8gaWNvbkFsaWduIDogbnVsbFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtcGFzc3dvcmQtdG9nZ2xlXT1cXFwicGFzc3dvcmRUb2dnbGUgPyAndHJ1ZSc6IG51bGxcXFwiXFxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLWljb24tc2hvd109XFxcImljb25TaG93ID8gaWNvblNob3cgOiBudWxsXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuZGF0YS1pY29uLWhpZGVdPVxcXCJpY29uSGlkZSA/IGljb25IaWRlIDogbnVsbFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtaWNvbi11cGxvYWRdPVxcXCJpY29uVXBsb2FkID8gaWNvblVwbG9hZCA6IG51bGxcXFwiXFxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5taW5dPVxcXCJtaW5cXFwiXFxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5tYXhdPVxcXCJtYXhcXFwiXFxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5taW5sZW5ndGhdPVxcXCJtaW5sZW5ndGhcXFwiXFxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5tYXhsZW5ndGhdPVxcXCJtYXhsZW5ndGhcXFwiXFxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hdXRvY29tcGxldGVdPVxcXCJhdXRvY29tcGxldGVcXFwiXFxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hdXRvY2FwaXRhbGl6ZV09XFxcImF1dG9jYXBpdGFsaXplXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXV0b2NvcnJlY3RdPVxcXCJhdXRvY29ycmVjdFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLnNwZWxsY2hlY2tdPVxcXCJzcGVsbGNoZWNrXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXV0b2ZvY3VzXT1cXFwiYXV0b2ZvY3VzXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuc3RlcF09XFxcInN0ZXBcXFwiXFxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5wYXR0ZXJuXT1cXFwicGF0dGVyblxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLnJlcXVpcmVkXT1cXFwicmVxdWlyZWRcXFwiXFxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hY2NlcHRdPVxcXCJhY2NlcHRcXFwiXFxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5tdWx0aXBsZV09XFxcIm11bHRpcGxlXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgICAgICAgICBbcmVhZG9ubHldPVxcXCJfcmVhZG9ubHlcXFwiIC8+XFxuICAgICAgICAgICAgICAgIDxzcGFuICpuZ0lmPVxcXCJkcm9wZG93blxcXCIgY2xhc3M9XFxcIm1ic2Mtc2VsZWN0LWljIG1ic2MtaWMgbWJzYy1pYy1hcnJvdy1kb3duNVxcXCI+PC9zcGFuPlxcbiAgICAgICAgICAgICAgICA8c3BhbiAqbmdJZj1cXFwiZXJyb3IgJiYgZXJyb3JNZXNzYWdlXFxcIiBjbGFzcz1cXFwibWJzYy1lcnItbXNnXFxcIj57e2Vycm9yTWVzc2FnZX19PC9zcGFuPlxcbiAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgIDwvbGFiZWw+XFxuICAgIFwiLFxyXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtNYnNjSW5wdXRTZXJ2aWNlXVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMSwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBNYnNjT3B0aW9uc1NlcnZpY2UsIE1ic2NJbnB1dFNlcnZpY2UsIE5nQ29udHJvbCwgTmdab25lXSlcclxuICAgIF0sIE1ic2NJbnB1dCk7XHJcbiAgICByZXR1cm4gTWJzY0lucHV0O1xyXG59KE1ic2NJbnB1dEJhc2UpKTtcclxudmFyIE1ic2NJbnB1dE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNYnNjSW5wdXRNb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBNYnNjSW5wdXRNb2R1bGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBOZ01vZHVsZSh7XHJcbiAgICAgICAgICAgIGltcG9ydHM6IFtGb3Jtc01vZHVsZSwgQ29tbW9uTW9kdWxlLCBNYnNjQmFzZU1vZHVsZV0sXHJcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01ic2NJbnB1dCwgTWJzY0lucHV0QmFzZSwgTWJzY0Zvcm1CYXNlLCBNYnNjRm9ybVZhbHVlQmFzZV0sXHJcbiAgICAgICAgICAgIGV4cG9ydHM6IFtNYnNjSW5wdXRdXHJcbiAgICAgICAgfSlcclxuICAgIF0sIE1ic2NJbnB1dE1vZHVsZSk7XHJcbiAgICByZXR1cm4gTWJzY0lucHV0TW9kdWxlO1xyXG59KCkpO1xuXG5mdW5jdGlvbiBhZGp1c3RlZERhdGUoeSwgbSwgZCwgaCwgaSwgcywgdSkge1xuICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQsIGggfHwgMCwgaSB8fCAwLCBzIHx8IDAsIHUgfHwgMCk7XG5cbiAgaWYgKGRhdGUuZ2V0SG91cnMoKSA9PSAyMyAmJiAoaCB8fCAwKSA9PT0gMCkge1xuICAgIGRhdGUuc2V0SG91cnMoZGF0ZS5nZXRIb3VycygpICsgMik7XG4gIH1cblxuICByZXR1cm4gZGF0ZTtcbn1cbi8qKlxyXG4gKiBGb3JtYXQgYSBkYXRlIGludG8gYSBzdHJpbmcgdmFsdWUgd2l0aCBhIHNwZWNpZmllZCBmb3JtYXQuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXQgT3V0cHV0IGZvcm1hdC5cclxuICogQHBhcmFtIHtEYXRlfSBkYXRlIERhdGUgdG8gZm9ybWF0LlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW3NldHRpbmdzPXt9XSBTZXR0aW5ncy5cclxuICogQHJldHVybiB7U3RyaW5nfSBSZXR1cm5zIHRoZSBmb3JtYXR0ZWQgZGF0ZSBzdHJpbmcuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGZvcm1hdERhdGUoZm9ybWF0LCBkYXRlLCBzZXR0aW5ncykge1xuICBpZiAoIWRhdGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBzID0gZXh0ZW5kJDEoe30sIGRhdGVUaW1lRGVmYXVsdHMsIHNldHRpbmdzKSxcbiAgICAgIGxvb2sgPSBmdW5jdGlvbiBsb29rKG0pIHtcbiAgICAvLyBDaGVjayB3aGV0aGVyIGEgZm9ybWF0IGNoYXJhY3RlciBpcyBkb3VibGVkXG4gICAgdmFyIG4gPSAwO1xuXG4gICAgd2hpbGUgKGkgKyAxIDwgZm9ybWF0Lmxlbmd0aCAmJiBmb3JtYXQuY2hhckF0KGkgKyAxKSA9PSBtKSB7XG4gICAgICBuKys7XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIG47XG4gIH0sXG4gICAgICBmMSA9IGZ1bmN0aW9uIGYxKG0sIHZhbCwgbGVuKSB7XG4gICAgLy8gRm9ybWF0IGEgbnVtYmVyLCB3aXRoIGxlYWRpbmcgemVybyBpZiBuZWNlc3NhcnlcbiAgICB2YXIgbiA9ICcnICsgdmFsO1xuXG4gICAgaWYgKGxvb2sobSkpIHtcbiAgICAgIHdoaWxlIChuLmxlbmd0aCA8IGxlbikge1xuICAgICAgICBuID0gJzAnICsgbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbjtcbiAgfSxcbiAgICAgIGYyID0gZnVuY3Rpb24gZjIobSwgdmFsLCBzLCBsKSB7XG4gICAgLy8gRm9ybWF0IGEgbmFtZSwgc2hvcnQgb3IgbG9uZyBhcyByZXF1ZXN0ZWRcbiAgICByZXR1cm4gbG9vayhtKSA/IGxbdmFsXSA6IHNbdmFsXTtcbiAgfSxcbiAgICAgIGksXG4gICAgICB5ZWFyLFxuICAgICAgb3V0cHV0ID0gJycsXG4gICAgICBsaXRlcmFsID0gZmFsc2U7XG5cbiAgZm9yIChpID0gMDsgaSA8IGZvcm1hdC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsaXRlcmFsKSB7XG4gICAgICBpZiAoZm9ybWF0LmNoYXJBdChpKSA9PSBcIidcIiAmJiAhbG9vayhcIidcIikpIHtcbiAgICAgICAgbGl0ZXJhbCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ICs9IGZvcm1hdC5jaGFyQXQoaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoZm9ybWF0LmNoYXJBdChpKSkge1xuICAgICAgICBjYXNlICdkJzpcbiAgICAgICAgICBvdXRwdXQgKz0gZjEoJ2QnLCBzLmdldERheShkYXRlKSwgMik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnRCc6XG4gICAgICAgICAgb3V0cHV0ICs9IGYyKCdEJywgZGF0ZS5nZXREYXkoKSwgcy5kYXlOYW1lc1Nob3J0LCBzLmRheU5hbWVzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdvJzpcbiAgICAgICAgICBvdXRwdXQgKz0gZjEoJ28nLCAoZGF0ZS5nZXRUaW1lKCkgLSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDAsIDApLmdldFRpbWUoKSkgLyA4NjQwMDAwMCwgMyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgb3V0cHV0ICs9IGYxKCdtJywgcy5nZXRNb250aChkYXRlKSArIDEsIDIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgIG91dHB1dCArPSBmMignTScsIHMuZ2V0TW9udGgoZGF0ZSksIHMubW9udGhOYW1lc1Nob3J0LCBzLm1vbnRoTmFtZXMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgIHllYXIgPSBzLmdldFllYXIoZGF0ZSk7XG4gICAgICAgICAgb3V0cHV0ICs9IGxvb2soJ3knKSA/IHllYXIgOiAoeWVhciAlIDEwMCA8IDEwID8gJzAnIDogJycpICsgeWVhciAlIDEwMDsgLy9vdXRwdXQgKz0gKGxvb2soJ3knKSA/IGRhdGUuZ2V0RnVsbFllYXIoKSA6IChkYXRlLmdldFllYXIoKSAlIDEwMCA8IDEwID8gJzAnIDogJycpICsgZGF0ZS5nZXRZZWFyKCkgJSAxMDApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgdmFyIGggPSBkYXRlLmdldEhvdXJzKCk7XG4gICAgICAgICAgb3V0cHV0ICs9IGYxKCdoJywgaCA+IDEyID8gaCAtIDEyIDogaCA9PT0gMCA/IDEyIDogaCwgMik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgb3V0cHV0ICs9IGYxKCdIJywgZGF0ZS5nZXRIb3VycygpLCAyKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdpJzpcbiAgICAgICAgICBvdXRwdXQgKz0gZjEoJ2knLCBkYXRlLmdldE1pbnV0ZXMoKSwgMik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgb3V0cHV0ICs9IGYxKCdzJywgZGF0ZS5nZXRTZWNvbmRzKCksIDIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgIG91dHB1dCArPSBkYXRlLmdldEhvdXJzKCkgPiAxMSA/IHMucG1UZXh0IDogcy5hbVRleHQ7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgb3V0cHV0ICs9IGRhdGUuZ2V0SG91cnMoKSA+IDExID8gcy5wbVRleHQudG9VcHBlckNhc2UoKSA6IHMuYW1UZXh0LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICBpZiAobG9vayhcIidcIikpIHtcbiAgICAgICAgICAgIG91dHB1dCArPSBcIidcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGl0ZXJhbCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBvdXRwdXQgKz0gZm9ybWF0LmNoYXJBdChpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufSAvLyAtLS0gVFJJQUwgU0VSVkVSIENPREUgRU5EIC0tLVxuXG4vKipcclxuICogRXh0cmFjdCBhIGRhdGUgZnJvbSBhIHN0cmluZyB2YWx1ZSB3aXRoIGEgc3BlY2lmaWVkIGZvcm1hdC5cclxuICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdCBJbnB1dCBmb3JtYXQuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBTdHJpbmcgdG8gcGFyc2UuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2V0dGluZ3M9e31dIFNldHRpbmdzLlxyXG4gKiBAcmV0dXJuIHtEYXRlfSBSZXR1cm5zIHRoZSBleHRyYWN0ZWQgZGF0ZS5cclxuICovXG5cblxuZnVuY3Rpb24gcGFyc2VEYXRlKGZvcm1hdCwgdmFsdWUsIHNldHRpbmdzKSB7XG4gIHZhciBzID0gZXh0ZW5kJDEoe30sIGRhdGVUaW1lRGVmYXVsdHMsIHNldHRpbmdzKSxcbiAgICAgIGRlZiA9IG1ha2VEYXRlKHMuZGVmYXVsdFZhbHVlIHx8IG5ldyBEYXRlKCkpO1xuXG4gIGlmICghZm9ybWF0IHx8ICF2YWx1ZSkge1xuICAgIHJldHVybiBkZWY7XG4gIH0gLy8gSWYgYWxyZWFkeSBhIGRhdGUgb2JqZWN0XG5cblxuICBpZiAodmFsdWUuZ2V0VGltZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHZhbHVlID0gdHlwZW9mIHZhbHVlID09ICdvYmplY3QnID8gdmFsdWUudG9TdHJpbmcoKSA6IHZhbHVlICsgJyc7XG5cbiAgdmFyIHNob3J0WWVhckN1dG9mZiA9IHMuc2hvcnRZZWFyQ3V0b2ZmLFxuICAgICAgeWVhciA9IHMuZ2V0WWVhcihkZWYpLFxuICAgICAgbW9udGggPSBzLmdldE1vbnRoKGRlZikgKyAxLFxuICAgICAgZGF5ID0gcy5nZXREYXkoZGVmKSxcbiAgICAgIGRveSA9IC0xLFxuICAgICAgaG91cnMgPSBkZWYuZ2V0SG91cnMoKSxcbiAgICAgIG1pbnV0ZXMgPSBkZWYuZ2V0TWludXRlcygpLFxuICAgICAgc2Vjb25kcyA9IDAsXG4gICAgICAvL2RlZi5nZXRTZWNvbmRzKCksXG4gIGFtcG0gPSAtMSxcbiAgICAgIGxpdGVyYWwgPSBmYWxzZSxcbiAgICAgIC8vIENoZWNrIHdoZXRoZXIgYSBmb3JtYXQgY2hhcmFjdGVyIGlzIGRvdWJsZWRcbiAgbG9va0FoZWFkID0gZnVuY3Rpb24gbG9va0FoZWFkKG1hdGNoKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBpRm9ybWF0ICsgMSA8IGZvcm1hdC5sZW5ndGggJiYgZm9ybWF0LmNoYXJBdChpRm9ybWF0ICsgMSkgPT0gbWF0Y2g7XG5cbiAgICBpZiAobWF0Y2hlcykge1xuICAgICAgaUZvcm1hdCsrO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaGVzO1xuICB9LFxuICAgICAgZ2V0TnVtYmVyID0gZnVuY3Rpb24gZ2V0TnVtYmVyKG1hdGNoKSB7XG4gICAgLy8gRXh0cmFjdCBhIG51bWJlciBmcm9tIHRoZSBzdHJpbmcgdmFsdWVcbiAgICBsb29rQWhlYWQobWF0Y2gpO1xuICAgIHZhciBzaXplID0gbWF0Y2ggPT0gJ0AnID8gMTQgOiBtYXRjaCA9PSAnIScgPyAyMCA6IG1hdGNoID09ICd5JyA/IDQgOiBtYXRjaCA9PSAnbycgPyAzIDogMixcbiAgICAgICAgZGlnaXRzID0gbmV3IFJlZ0V4cCgnXlxcXFxkezEsJyArIHNpemUgKyAnfScpLFxuICAgICAgICBudW0gPSB2YWx1ZS5zdWJzdHIoaVZhbHVlKS5tYXRjaChkaWdpdHMpO1xuXG4gICAgaWYgKCFudW0pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlWYWx1ZSArPSBudW1bMF0ubGVuZ3RoO1xuICAgIHJldHVybiBwYXJzZUludChudW1bMF0sIDEwKTtcbiAgfSxcbiAgICAgIGdldE5hbWUgPSBmdW5jdGlvbiBnZXROYW1lKG1hdGNoLCBzLCBsKSB7XG4gICAgLy8gRXh0cmFjdCBhIG5hbWUgZnJvbSB0aGUgc3RyaW5nIHZhbHVlIGFuZCBjb252ZXJ0IHRvIGFuIGluZGV4XG4gICAgdmFyIG5hbWVzID0gbG9va0FoZWFkKG1hdGNoKSA/IGwgOiBzLFxuICAgICAgICBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWUuc3Vic3RyKGlWYWx1ZSwgbmFtZXNbaV0ubGVuZ3RoKS50b0xvd2VyQ2FzZSgpID09IG5hbWVzW2ldLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgaVZhbHVlICs9IG5hbWVzW2ldLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGkgKyAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9LFxuICAgICAgY2hlY2tMaXRlcmFsID0gZnVuY3Rpb24gY2hlY2tMaXRlcmFsKCkge1xuICAgIGlWYWx1ZSsrO1xuICB9LFxuICAgICAgaVZhbHVlID0gMCxcbiAgICAgIGlGb3JtYXQ7XG5cbiAgZm9yIChpRm9ybWF0ID0gMDsgaUZvcm1hdCA8IGZvcm1hdC5sZW5ndGg7IGlGb3JtYXQrKykge1xuICAgIGlmIChsaXRlcmFsKSB7XG4gICAgICBpZiAoZm9ybWF0LmNoYXJBdChpRm9ybWF0KSA9PSBcIidcIiAmJiAhbG9va0FoZWFkKFwiJ1wiKSkge1xuICAgICAgICBsaXRlcmFsID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGVja0xpdGVyYWwoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChmb3JtYXQuY2hhckF0KGlGb3JtYXQpKSB7XG4gICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgIGRheSA9IGdldE51bWJlcignZCcpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgIGdldE5hbWUoJ0QnLCBzLmRheU5hbWVzU2hvcnQsIHMuZGF5TmFtZXMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ28nOlxuICAgICAgICAgIGRveSA9IGdldE51bWJlcignbycpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgIG1vbnRoID0gZ2V0TnVtYmVyKCdtJyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgbW9udGggPSBnZXROYW1lKCdNJywgcy5tb250aE5hbWVzU2hvcnQsIHMubW9udGhOYW1lcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAneSc6XG4gICAgICAgICAgeWVhciA9IGdldE51bWJlcigneScpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgIGhvdXJzID0gZ2V0TnVtYmVyKCdIJyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgaG91cnMgPSBnZXROdW1iZXIoJ2gnKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdpJzpcbiAgICAgICAgICBtaW51dGVzID0gZ2V0TnVtYmVyKCdpJyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgc2Vjb25kcyA9IGdldE51bWJlcigncycpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAgIGFtcG0gPSBnZXROYW1lKCdhJywgW3MuYW1UZXh0LCBzLnBtVGV4dF0sIFtzLmFtVGV4dCwgcy5wbVRleHRdKSAtIDE7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgYW1wbSA9IGdldE5hbWUoJ0EnLCBbcy5hbVRleHQsIHMucG1UZXh0XSwgW3MuYW1UZXh0LCBzLnBtVGV4dF0pIC0gMTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgIGlmIChsb29rQWhlYWQoXCInXCIpKSB7XG4gICAgICAgICAgICBjaGVja0xpdGVyYWwoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGl0ZXJhbCA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjaGVja0xpdGVyYWwoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoeWVhciA8IDEwMCkge1xuICAgIHllYXIgKz0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpIC0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpICUgMTAwICsgKHllYXIgPD0gKHR5cGVvZiBzaG9ydFllYXJDdXRvZmYgIT0gJ3N0cmluZycgPyBzaG9ydFllYXJDdXRvZmYgOiBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkgJSAxMDAgKyBwYXJzZUludChzaG9ydFllYXJDdXRvZmYsIDEwKSkgPyAwIDogLTEwMCk7XG4gIH1cblxuICBpZiAoZG95ID4gLTEpIHtcbiAgICBtb250aCA9IDE7XG4gICAgZGF5ID0gZG95O1xuXG4gICAgZG8ge1xuICAgICAgdmFyIGRpbSA9IDMyIC0gbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCAzMiwgMTIpLmdldERhdGUoKTtcblxuICAgICAgaWYgKGRheSA+IGRpbSkge1xuICAgICAgICBtb250aCsrO1xuICAgICAgICBkYXkgLT0gZGltO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGRheSA+IGRpbSk7XG4gIH1cblxuICBob3VycyA9IGFtcG0gPT0gLTEgPyBob3VycyA6IGFtcG0gJiYgaG91cnMgPCAxMiA/IGhvdXJzICsgMTIgOiAhYW1wbSAmJiBob3VycyA9PSAxMiA/IDAgOiBob3VycztcbiAgdmFyIGRhdGUgPSBzLmdldERhdGUoeWVhciwgbW9udGggLSAxLCBkYXksIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzKTtcblxuICBpZiAocy5nZXRZZWFyKGRhdGUpICE9IHllYXIgfHwgcy5nZXRNb250aChkYXRlKSArIDEgIT0gbW9udGggfHwgcy5nZXREYXkoZGF0ZSkgIT0gZGF5KSB7XG4gICAgcmV0dXJuIGRlZjsgLy8gSW52YWxpZCBkYXRlXG4gIH1cblxuICByZXR1cm4gZGF0ZTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF5RGlmZihkMSwgZDIpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQoKGQyIC0gZDEpIC8gKDI0ICogNjAgKiA2MCAqIDEwMDApKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0ZU9ubHkoZCkge1xuICByZXR1cm4gYWRqdXN0ZWREYXRlKGQuZ2V0RnVsbFllYXIoKSwgZC5nZXRNb250aCgpLCBkLmdldERhdGUoKSk7XG59XG5cbmZ1bmN0aW9uIGdldERhdGVTdHIoZCkge1xuICByZXR1cm4gZC5nZXRGdWxsWWVhcigpICsgJy0nICsgKGQuZ2V0TW9udGgoKSArIDEpICsgJy0nICsgZC5nZXREYXRlKCk7XG59XG5cbmZ1bmN0aW9uIGdldElTT1N0cmluZyhkLCBwYXJ0cykge1xuICB2YXIgcmV0ID0gJycsXG4gICAgICB0aW1lID0gJyc7XG5cbiAgaWYgKGQpIHtcbiAgICBpZiAocGFydHMuaCkge1xuICAgICAgdGltZSArPSBwYWQoZC5nZXRIb3VycygpKSArICc6JyArIHBhZChkLmdldE1pbnV0ZXMoKSk7XG5cbiAgICAgIGlmIChwYXJ0cy5zKSB7XG4gICAgICAgIHRpbWUgKz0gJzonICsgcGFkKGQuZ2V0U2Vjb25kcygpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcnRzLnUpIHtcbiAgICAgICAgdGltZSArPSAnLicgKyBwYWQoZC5nZXRNaWxsaXNlY29uZHMoKSwgMyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJ0cy50eikge1xuICAgICAgICB0aW1lICs9IHBhcnRzLnR6OyAvLyBKdXN0IHB1dCB3aGF0IHdlIGdvdFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwYXJ0cy55KSB7XG4gICAgICByZXQgKz0gZC5nZXRGdWxsWWVhcigpO1xuXG4gICAgICBpZiAocGFydHMubSkge1xuICAgICAgICByZXQgKz0gJy0nICsgcGFkKGQuZ2V0TW9udGgoKSArIDEpO1xuXG4gICAgICAgIGlmIChwYXJ0cy5kKSB7XG4gICAgICAgICAgcmV0ICs9ICctJyArIHBhZChkLmdldERhdGUoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFydHMuaCkge1xuICAgICAgICAgIHJldCArPSAnVCcgKyB0aW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwYXJ0cy5oKSB7XG4gICAgICByZXQgPSB0aW1lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHNldElTT1BhcnRzKHBhcnNlZCwgb2Zmc2V0LCBwYXJ0cykge1xuICB2YXIgcGFydCxcbiAgICAgIHYsXG4gICAgICBwID0ge1xuICAgIHk6IDEsXG4gICAgbTogMixcbiAgICBkOiAzLFxuICAgIGg6IDQsXG4gICAgaTogNSxcbiAgICBzOiA2LFxuICAgIHU6IDcsXG4gICAgdHo6IDhcbiAgfTtcblxuICBpZiAocGFydHMpIHtcbiAgICBmb3IgKHBhcnQgaW4gcCkge1xuICAgICAgdiA9IHBhcnNlZFtwW3BhcnRdIC0gb2Zmc2V0XTtcblxuICAgICAgaWYgKHYpIHtcbiAgICAgICAgcGFydHNbcGFydF0gPSBwYXJ0ID09ICd0eicgPyB2IDogMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV0dXJuRGF0ZShkLCBzLCBkaXNwbGF5Rm9ybWF0KSB7XG4gIHZhciBtb21lbnQgPSB3aW5kb3cubW9tZW50IHx8IHMubW9tZW50LFxuICAgICAgZm9ybWF0ID0gcy5yZXR1cm5Gb3JtYXQ7XG5cbiAgaWYgKGQpIHtcbiAgICBpZiAoZm9ybWF0ID09ICdtb21lbnQnICYmIG1vbWVudCkge1xuICAgICAgcmV0dXJuIG1vbWVudChkKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0ID09ICdsb2NhbGUnKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RGF0ZShkaXNwbGF5Rm9ybWF0LCBkLCBzKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0ID09ICdpc284NjAxJykge1xuICAgICAgcmV0dXJuIGdldElTT1N0cmluZyhkLCBzLmlzb1BhcnRzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZDtcbn1cblxuZnVuY3Rpb24gbWFrZURhdGUoZCwgZm9ybWF0LCBzLCBwYXJ0cykge1xuICB2YXIgcGFyc2U7XG5cbiAgaWYgKCFkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gSWYgYWxyZWFkeSBkYXRlIG9iamVjdFxuXG5cbiAgaWYgKGQuZ2V0VGltZSkge1xuICAgIHJldHVybiBkO1xuICB9IC8vIE1vbWVudCBvYmplY3RcblxuXG4gIGlmIChkLnRvRGF0ZSkge1xuICAgIHJldHVybiBkLnRvRGF0ZSgpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBkID09ICdzdHJpbmcnKSB7XG4gICAgZCA9IGQudHJpbSgpO1xuICB9XG5cbiAgcGFyc2UgPSBJU09fODYwMV9USU1FLmV4ZWMoZCk7IC8vIElmIElTTyA4NjAxIHRpbWUgc3RyaW5nXG5cbiAgaWYgKHBhcnNlKSB7XG4gICAgc2V0SVNPUGFydHMocGFyc2UsIDIsIHBhcnRzKTtcbiAgICByZXR1cm4gbmV3IERhdGUoMTk3MCwgMCwgMSwgcGFyc2VbMl0gPyArcGFyc2VbMl0gOiAwLCBwYXJzZVszXSA/ICtwYXJzZVszXSA6IDAsIHBhcnNlWzRdID8gK3BhcnNlWzRdIDogMCwgcGFyc2VbNV0gPyArcGFyc2VbNV0gOiAwKTtcbiAgfVxuXG4gIGlmICghcGFyc2UpIHtcbiAgICBwYXJzZSA9IElTT184NjAxX0ZVTEwuZXhlYyhkKTtcbiAgfSAvLyBJZiBJU08gODYwMSBkYXRlIHN0cmluZ1xuXG5cbiAgaWYgKHBhcnNlKSB7XG4gICAgc2V0SVNPUGFydHMocGFyc2UsIDAsIHBhcnRzKTtcbiAgICByZXR1cm4gbmV3IERhdGUocGFyc2VbMV0gPyArcGFyc2VbMV0gOiAxOTcwLCBwYXJzZVsyXSA/IHBhcnNlWzJdIC0gMSA6IDAsIHBhcnNlWzNdID8gK3BhcnNlWzNdIDogMSwgcGFyc2VbNF0gPyArcGFyc2VbNF0gOiAwLCBwYXJzZVs1XSA/ICtwYXJzZVs1XSA6IDAsIHBhcnNlWzZdID8gK3BhcnNlWzZdIDogMCwgcGFyc2VbN10gPyArcGFyc2VbN10gOiAwKTtcbiAgfSAvLyBQYXJzZSBkYXRlIGJhc2VkIG9uIGZvcm1hdFxuXG5cbiAgcmV0dXJuIHBhcnNlRGF0ZShmb3JtYXQsIGQsIHMpO1xufVxuXG5mdW5jdGlvbiBpc1NhbWVEYXkoZDEsIGQyKSB7XG4gIHJldHVybiBkMS5nZXRGdWxsWWVhcigpID09IGQyLmdldEZ1bGxZZWFyKCkgJiYgZDEuZ2V0TW9udGgoKSA9PSBkMi5nZXRNb250aCgpICYmIGQxLmdldERhdGUoKSA9PSBkMi5nZXREYXRlKCk7XG59XG5cbnZhciBJU09fODYwMV9GVUxMID0gL14oXFxkezR9fFsrLV1cXGR7Nn0pKD86LShcXGR7Mn0pKD86LShcXGR7Mn0pKT8pPyg/OlQoXFxkezJ9KTooXFxkezJ9KSg/OjooXFxkezJ9KSg/OlxcLihcXGR7M30pKT8pPygoWil8KFsrLV0pKFxcZHsyfSkoPzo6KFxcZHsyfSkpPyk/KT8kLztcbnZhciBJU09fODYwMV9USU1FID0gL14oKFxcZHsyfSk6KFxcZHsyfSkoPzo6KFxcZHsyfSkoPzpcXC4oXFxkezN9KSk/KT8oPzooWil8KFsrLV0pKFxcZHsyfSkoPzo6KFxcZHsyfSkpPyk/KT8kLztcbnZhciBEQVlfT0ZfTU9OVEggPSAvXlxcZHsxLDJ9KFxcL1xcZHsxLDJ9KT8kLztcbnZhciBEQVlfT0ZfV0VFSyA9IC9ed1xcZCQvaTtcbnZhciBkYXRlVGltZURlZmF1bHRzID0ge1xuICBzaG9ydFllYXJDdXRvZmY6ICcrMTAnLFxuICBtb250aE5hbWVzOiBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXSxcbiAgbW9udGhOYW1lc1Nob3J0OiBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJ10sXG4gIGRheU5hbWVzOiBbJ1N1bmRheScsICdNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JywgJ1NhdHVyZGF5J10sXG4gIGRheU5hbWVzU2hvcnQ6IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J10sXG4gIGRheU5hbWVzTWluOiBbJ1MnLCAnTScsICdUJywgJ1cnLCAnVCcsICdGJywgJ1MnXSxcbiAgYW1UZXh0OiAnYW0nLFxuICBwbVRleHQ6ICdwbScsXG4gIGdldFllYXI6IGZ1bmN0aW9uIGdldFllYXIoZCkge1xuICAgIHJldHVybiBkLmdldEZ1bGxZZWFyKCk7XG4gIH0sXG4gIGdldE1vbnRoOiBmdW5jdGlvbiBnZXRNb250aChkKSB7XG4gICAgcmV0dXJuIGQuZ2V0TW9udGgoKTtcbiAgfSxcbiAgZ2V0RGF5OiBmdW5jdGlvbiBnZXREYXkoZCkge1xuICAgIHJldHVybiBkLmdldERhdGUoKTtcbiAgfSxcbiAgZ2V0RGF0ZTogYWRqdXN0ZWREYXRlLFxuICBnZXRNYXhEYXlPZk1vbnRoOiBmdW5jdGlvbiBnZXRNYXhEYXlPZk1vbnRoKHksIG0pIHtcbiAgICByZXR1cm4gMzIgLSBuZXcgRGF0ZSh5LCBtLCAzMiwgMTIpLmdldERhdGUoKTtcbiAgfSxcbiAgZ2V0V2Vla051bWJlcjogZnVuY3Rpb24gZ2V0V2Vla051bWJlcihkKSB7XG4gICAgLy8gQ29weSBkYXRlIHNvIGRvbid0IG1vZGlmeSBvcmlnaW5hbFxuICAgIGQgPSBuZXcgRGF0ZShkKTtcbiAgICBkLnNldEhvdXJzKDAsIDAsIDApOyAvLyBTZXQgdG8gbmVhcmVzdCBUaHVyc2RheTogY3VycmVudCBkYXRlICsgNCAtIGN1cnJlbnQgZGF5IG51bWJlclxuICAgIC8vIE1ha2UgU3VuZGF5J3MgZGF5IG51bWJlciA3XG5cbiAgICBkLnNldERhdGUoZC5nZXREYXRlKCkgKyA0IC0gKGQuZ2V0RGF5KCkgfHwgNykpOyAvLyBHZXQgZmlyc3QgZGF5IG9mIHllYXJcblxuICAgIHZhciB5ZWFyU3RhcnQgPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIDAsIDEpOyAvLyBDYWxjdWxhdGUgZnVsbCB3ZWVrcyB0byBuZWFyZXN0IFRodXJzZGF5XG5cbiAgICByZXR1cm4gTWF0aC5jZWlsKCgoZCAtIHllYXJTdGFydCkgLyA4NjQwMDAwMCArIDEpIC8gNyk7XG4gIH1cbn07XG51dGlsLmRhdGV0aW1lID0ge1xuICBmb3JtYXREYXRlOiBmb3JtYXREYXRlLFxuICBwYXJzZURhdGU6IHBhcnNlRGF0ZVxufTtcblxuZnVuY3Rpb24gY3JlYXRlU3RlcHBlcigkZWxtLCBhY3Rpb24sIGRlbGF5LCBpc1JlYWRPbmx5LCBzdG9wUHJvcCwgcmlwcGxlKSB7XG4gIHZhciAkYnRuLFxuICAgICAgY2hhbmdlZCxcbiAgICAgIGluZGV4LFxuICAgICAgcnVubmluZyxcbiAgICAgIHNvdXJjZSxcbiAgICAgIHN0YXJ0WCxcbiAgICAgIHN0YXJ0WSxcbiAgICAgIHN0ZXAsXG4gICAgICB0aW1lcixcbiAgICAgIGNoZWNrID0gaXNSZWFkT25seSB8fCBub29wO1xuXG4gIGZ1bmN0aW9uIG9uQnRuU3RhcnQoZXYpIHtcbiAgICB2YXIgcHJvY2VlZDtcbiAgICAkYnRuID0gJCQxKHRoaXMpO1xuICAgIHN0ZXAgPSArJGJ0bi5hdHRyKCdkYXRhLXN0ZXAnKTtcbiAgICBpbmRleCA9ICskYnRuLmF0dHIoJ2RhdGEtaW5kZXgnKTtcbiAgICBjaGFuZ2VkID0gdHJ1ZTtcblxuICAgIGlmIChzdG9wUHJvcCkge1xuICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgaWYgKGV2LnR5cGUgPT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAkYnRuLmNsb3Nlc3QoJy5tYnNjLW5vLXRvdWNoJykucmVtb3ZlQ2xhc3MoJ21ic2Mtbm8tdG91Y2gnKTtcbiAgICB9XG5cbiAgICBpZiAoZXYudHlwZSA9PSAnbW91c2Vkb3duJykge1xuICAgICAgLy8gUHJldmVudCBmb2N1c1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBpZiAoZXYudHlwZSAhPSAna2V5ZG93bicpIHtcbiAgICAgIC8vZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgc3RhcnRYID0gZ2V0Q29vcmQoZXYsICdYJyk7XG4gICAgICBzdGFydFkgPSBnZXRDb29yZChldiwgJ1knKTtcbiAgICAgIHByb2NlZWQgPSB0ZXN0VG91Y2goZXYsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9jZWVkID0gZXYua2V5Q29kZSA9PT0gMzI7XG4gICAgfVxuXG4gICAgaWYgKCFydW5uaW5nICYmIHByb2NlZWQgJiYgISRidG4uaGFzQ2xhc3MoJ21ic2MtZGlzYWJsZWQnKSkge1xuICAgICAgaWYgKHN0YXJ0KGluZGV4LCBzdGVwLCBldikpIHtcbiAgICAgICAgJGJ0bi5hZGRDbGFzcygnbWJzYy1hY3RpdmUnKTtcblxuICAgICAgICBpZiAocmlwcGxlKSB7XG4gICAgICAgICAgcmlwcGxlLmFkZFJpcHBsZSgkYnRuLmZpbmQoJy5tYnNjLXNlZ21lbnRlZC1jb250ZW50JyksIGV2KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZXYudHlwZSA9PSAnbW91c2Vkb3duJykge1xuICAgICAgICAkJDEoZG9jdW1lbnQpLm9uKCdtb3VzZW1vdmUnLCBvbkJ0bk1vdmUpLm9uKCdtb3VzZXVwJywgb25CdG5FbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQnRuTW92ZShldikge1xuICAgIGlmIChNYXRoLmFicyhzdGFydFggLSBnZXRDb29yZChldiwgJ1gnKSkgPiA3IHx8IE1hdGguYWJzKHN0YXJ0WSAtIGdldENvb3JkKGV2LCAnWScpKSA+IDcpIHtcbiAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgc3RvcCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQnRuRW5kKGV2KSB7XG4gICAgaWYgKGV2LnR5cGUgPT0gJ3RvdWNoZW5kJykge1xuICAgICAgLy8gUHJldmVudHMgaU9TIHNjcm9sbCBvbiBkb3VibGUgdGFwXG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHN0b3AoKTtcblxuICAgIGlmIChldi50eXBlID09ICdtb3VzZXVwJykge1xuICAgICAgJCQxKGRvY3VtZW50KS5vZmYoJ21vdXNlbW92ZScsIG9uQnRuTW92ZSkub2ZmKCdtb3VzZXVwJywgb25CdG5FbmQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgcnVubmluZyA9IGZhbHNlO1xuICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xuXG4gICAgaWYgKCRidG4pIHtcbiAgICAgICRidG4ucmVtb3ZlQ2xhc3MoJ21ic2MtYWN0aXZlJyk7XG5cbiAgICAgIGlmIChyaXBwbGUpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmlwcGxlLnJlbW92ZVJpcHBsZSgpO1xuICAgICAgICB9LCAxMDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0KGksIHN0LCBldikge1xuICAgIGlmICghcnVubmluZyAmJiAhY2hlY2soaSkpIHtcbiAgICAgIGluZGV4ID0gaTtcbiAgICAgIHN0ZXAgPSBzdDtcbiAgICAgIHNvdXJjZSA9IGV2O1xuICAgICAgcnVubmluZyA9IHRydWU7XG4gICAgICBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICBzZXRUaW1lb3V0KHRpY2ssIDEwMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ1bm5pbmc7XG4gIH1cblxuICBmdW5jdGlvbiB0aWNrKCkge1xuICAgIGlmICgkYnRuICYmICRidG4uaGFzQ2xhc3MoJ21ic2MtZGlzYWJsZWQnKSkge1xuICAgICAgc3RvcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChydW5uaW5nIHx8ICFjaGFuZ2VkKSB7XG4gICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIGFjdGlvbihpbmRleCwgc3RlcCwgc291cmNlLCB0aWNrKTtcbiAgICB9XG5cbiAgICBpZiAocnVubmluZyAmJiBkZWxheSkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICB0aW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWN0aW9uKGluZGV4LCBzdGVwLCBzb3VyY2UpO1xuICAgICAgfSwgZGVsYXkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgJGVsbS5lYWNoKGZ1bmN0aW9uIChpLCBlbCkge1xuICAgICAgdW5saXN0ZW4oZWwsICd0b3VjaHN0YXJ0Jywgb25CdG5TdGFydCwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHVubGlzdGVuKGVsLCAnbW91c2Vkb3duJywgb25CdG5TdGFydCk7XG4gICAgICB1bmxpc3RlbihlbCwgJ2tleWRvd24nLCBvbkJ0blN0YXJ0KTtcbiAgICAgIHVubGlzdGVuKGVsLCAndG91Y2htb3ZlJywgb25CdG5Nb3ZlLCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdW5saXN0ZW4oZWwsICd0b3VjaGVuZCcsIG9uQnRuRW5kKTtcbiAgICAgIHVubGlzdGVuKGVsLCAndG91Y2hjYW5jZWwnLCBvbkJ0bkVuZCk7XG4gICAgICB1bmxpc3RlbihlbCwgJ2tleXVwJywgb25CdG5FbmQpO1xuICAgIH0pO1xuICB9XG5cbiAgJGVsbS5lYWNoKGZ1bmN0aW9uIChpLCBlbCkge1xuICAgIGxpc3RlbihlbCwgJ3RvdWNoc3RhcnQnLCBvbkJ0blN0YXJ0LCB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG4gICAgbGlzdGVuKGVsLCAnbW91c2Vkb3duJywgb25CdG5TdGFydCk7XG4gICAgbGlzdGVuKGVsLCAna2V5ZG93bicsIG9uQnRuU3RhcnQpO1xuICAgIGxpc3RlbihlbCwgJ3RvdWNobW92ZScsIG9uQnRuTW92ZSwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGxpc3RlbihlbCwgJ3RvdWNoZW5kJywgb25CdG5FbmQpO1xuICAgIGxpc3RlbihlbCwgJ3RvdWNoY2FuY2VsJywgb25CdG5FbmQpO1xuICAgIGxpc3RlbihlbCwgJ2tleXVwJywgb25CdG5FbmQpO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQsXG4gICAgc3RvcDogc3RvcCxcbiAgICBkZXN0cm95OiBkZXN0cm95XG4gIH07XG59XG5cbnZhciBpbm5lclN0eWxlID0gJ3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6MDsnO1xudmFyIHN0eWxlID0gaW5uZXJTdHlsZSArICdyaWdodDowO2JvdHRvbTowO292ZXJmbG93OmhpZGRlbjt6LWluZGV4Oi0xOyc7XG52YXIgbWFya3VwID0gJzxkaXYgc3R5bGU9XCInICsgc3R5bGUgKyAnXCI+PGRpdiBzdHlsZT1cIicgKyBpbm5lclN0eWxlICsgJ1wiPjwvZGl2PjwvZGl2PicgKyAnPGRpdiBzdHlsZT1cIicgKyBzdHlsZSArICdcIj48ZGl2IHN0eWxlPVwiJyArIGlubmVyU3R5bGUgKyAnd2lkdGg6MjAwJTtoZWlnaHQ6MjAwJTtcIj48L2Rpdj48L2Rpdj4nO1xudmFyIG9ic2VydmVyO1xudmFyIGNvdW50ID0gMDtcbmZ1bmN0aW9uIHJlc2l6ZU9ic2VydmVyKGVsLCBjYWxsYmFjaywgem9uZSkge1xuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBleHBhbmRDaGlsZC5zdHlsZS53aWR0aCA9ICcxMDAwMDBweCc7XG4gICAgZXhwYW5kQ2hpbGQuc3R5bGUuaGVpZ2h0ID0gJzEwMDAwMHB4JztcbiAgICBleHBhbmQuc2Nyb2xsTGVmdCA9IDEwMDAwMDtcbiAgICBleHBhbmQuc2Nyb2xsVG9wID0gMTAwMDAwO1xuICAgIHNocmluay5zY3JvbGxMZWZ0ID0gMTAwMDAwO1xuICAgIHNocmluay5zY3JvbGxUb3AgPSAxMDAwMDA7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0hpZGRlbigpIHtcbiAgICB2YXIgbm93ID0gbmV3IERhdGUoKTtcbiAgICBoaWRkZW5SYWZJZCA9IDA7XG5cbiAgICBpZiAoIXN0b3BDaGVjaykge1xuICAgICAgaWYgKG5vdyAtIGxhc3RDaGVjayA+IDIwMCAmJiAhZXhwYW5kLnNjcm9sbFRvcCAmJiAhZXhwYW5kLnNjcm9sbExlZnQpIHtcbiAgICAgICAgbGFzdENoZWNrID0gbm93O1xuICAgICAgICByZXNldCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWhpZGRlblJhZklkKSB7XG4gICAgICAgIGhpZGRlblJhZklkID0gcmFmKGNoZWNrSGlkZGVuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblNjcm9sbCgpIHtcbiAgICBpZiAoIXJhZklkKSB7XG4gICAgICByYWZJZCA9IHJhZihvblJlc2l6ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25SZXNpemUoKSB7XG4gICAgcmFmSWQgPSAwO1xuICAgIHJlc2V0KCk7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxuXG4gIHZhciBleHBhbmQ7XG4gIHZhciBleHBhbmRDaGlsZDtcbiAgdmFyIGhlbHBlcjtcbiAgdmFyIGhpZGRlblJhZklkO1xuICB2YXIgcmFmSWQ7XG4gIHZhciBzaHJpbms7XG4gIHZhciBzdG9wQ2hlY2s7XG4gIHZhciBsYXN0Q2hlY2sgPSAwOyAvL2xldCBpc0hpZGRlbiA9IHRydWU7XG5cbiAgaWYgKHdpbmRvdy5SZXNpemVPYnNlcnZlcikge1xuICAgIGlmICghb2JzZXJ2ZXIpIHtcbiAgICAgIG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGZ1bmN0aW9uIChlbnRyaWVzKSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGVudHJpZXMsIF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheShfaXRlcmF0b3IpLCBfaSA9IDAsIF9pdGVyYXRvciA9IF9pc0FycmF5ID8gX2l0ZXJhdG9yIDogX2l0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0oKTs7KSB7XG4gICAgICAgICAgdmFyIF9yZWY7XG5cbiAgICAgICAgICBpZiAoX2lzQXJyYXkpIHtcbiAgICAgICAgICAgIGlmIChfaSA+PSBfaXRlcmF0b3IubGVuZ3RoKSBicmVhaztcbiAgICAgICAgICAgIF9yZWYgPSBfaXRlcmF0b3JbX2krK107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9pID0gX2l0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChfaS5kb25lKSBicmVhaztcbiAgICAgICAgICAgIF9yZWYgPSBfaS52YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZW50cnkgPSBfcmVmO1xuXG4gICAgICAgICAgZW50cnkudGFyZ2V0Ll9fbWJzY1Jlc2l6ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb3VudCsrO1xuICAgIGVsLl9fbWJzY1Jlc2l6ZSA9IGNhbGxiYWNrO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZWwpO1xuICB9IGVsc2Uge1xuICAgIGhlbHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGhlbHBlci5pbm5lckhUTUwgPSBtYXJrdXA7XG4gICAgaGVscGVyLmRpciA9ICdsdHInOyAvLyBOZWVkIHRoaXMgdG8gd29yayBpbiBydGwgYXMgd2VsbDtcblxuICAgIHNocmluayA9IGhlbHBlci5jaGlsZE5vZGVzWzFdO1xuICAgIGV4cGFuZCA9IGhlbHBlci5jaGlsZE5vZGVzWzBdO1xuICAgIGV4cGFuZENoaWxkID0gZXhwYW5kLmNoaWxkTm9kZXNbMF07XG4gICAgZWwuYXBwZW5kQ2hpbGQoaGVscGVyKTtcbiAgICBleHBhbmQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgb25TY3JvbGwpO1xuICAgIHNocmluay5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbCk7XG5cbiAgICBpZiAoem9uZSkge1xuICAgICAgem9uZS5ydW5PdXRzaWRlQW5ndWxhcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJhZihjaGVja0hpZGRlbik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFmKGNoZWNrSGlkZGVuKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRldGFjaDogZnVuY3Rpb24gZGV0YWNoKCkge1xuICAgICAgaWYgKG9ic2VydmVyKSB7XG4gICAgICAgIGNvdW50LS07XG4gICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbCk7XG5cbiAgICAgICAgaWYgKCFjb3VudCkge1xuICAgICAgICAgIG9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwucmVtb3ZlQ2hpbGQoaGVscGVyKTtcbiAgICAgICAgc3RvcENoZWNrID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciAkYWN0aXZlRWxtLFxuICAgIHByZXZlbnRTaG93LFxuICAgIHRoZW1lcyA9IG1vYmlzY3JvbGwudGhlbWVzLFxuICAgIG5lZWRzRml4ZWQgPSAvKGlwaG9uZXxpcG9kKS9pLnRlc3QodXNlckFnZW50KSAmJiBtYWpvclZlcnNpb24gPj0gNyxcbiAgICBpc0FuZHJvaWQgPSBvcyA9PSAnYW5kcm9pZCcsXG4gICAgaXNJT1MgPSBvcyA9PSAnaW9zJyxcbiAgICBpc0lPUzggPSBpc0lPUyAmJiBtYWpvclZlcnNpb24gPT0gOCxcbiAgICBoYWxmQm9yZGVyID0gaXNJT1MgJiYgbWFqb3JWZXJzaW9uID4gNyxcbiAgICBwcmV2ZGVmID0gZnVuY3Rpb24gcHJldmRlZihldikge1xuICBldi5wcmV2ZW50RGVmYXVsdCgpO1xufTtcblxudmFyIEVESVRBQkxFID0gJ2lucHV0LHNlbGVjdCx0ZXh0YXJlYSxidXR0b24nO1xudmFyIEFMTE9XX0VOVEVSID0gJ3RleHRhcmVhLGJ1dHRvbixpbnB1dFt0eXBlPVwiYnV0dG9uXCJdLGlucHV0W3R5cGU9XCJzdWJtaXRcIl0nO1xudmFyIEZPQ1VTQUJMRSA9IEVESVRBQkxFICsgJyxbdGFiaW5kZXg9XCIwXCJdJztcbnZhciBGcmFtZSA9IGZ1bmN0aW9uIEZyYW1lKGVsLCBzZXR0aW5ncywgaW5oZXJpdCkge1xuICB2YXIgLy8kYXJpYURpdixcbiAgJGN0eCxcbiAgICAgICRoZWFkZXIsXG4gICAgICAkbG9jayxcbiAgICAgICRtYXJrdXAsXG4gICAgICAkb3ZlcmxheSxcbiAgICAgICRwZXJzcCxcbiAgICAgICRwb3B1cCxcbiAgICAgICR3bmQsXG4gICAgICAkd3JhcHBlcixcbiAgICAgIGJ1dHRvbnMsXG4gICAgICBidG4sXG4gICAgICBjdHgsXG4gICAgICBkb0FuaW0sXG4gICAgICBoYXNDb250ZXh0LFxuICAgICAgaXNNb2RhbCxcbiAgICAgIGlzSW5zZXJ0ZWQsXG4gICAgICBpc1BvaW50ZXIsXG4gICAgICBtYXJrdXAsXG4gICAgICBtb2RhbFdpZHRoLFxuICAgICAgbW9kYWxIZWlnaHQsXG4gICAgICBuZWVkc0RpbWVuc2lvbnMsXG4gICAgICBuZWVkc0xvY2ssXG4gICAgICBvYnNlcnZlcixcbiAgICAgIG92ZXJsYXksXG4gICAgICBwb3B1cCxcbiAgICAgIHBvc0RlYm91bmNlLFxuICAgICAgcHJldkluc3QsXG4gICAgICBzLFxuICAgICAgc2Nyb2xsTG9jayxcbiAgICAgIHRvdWNoZWQsXG4gICAgICB0cmlnZ2VyLFxuICAgICAgd25kV2lkdGgsXG4gICAgICB3bmRIZWlnaHQsXG4gICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICRlbG0gPSAkJDEoZWwpLFxuICAgICAgZWxtTGlzdCA9IFtdLFxuICAgICAgbGFzdEZvY3VzID0gbmV3IERhdGUoKTtcblxuICBmdW5jdGlvbiBvbkJ0blN0YXJ0KGV2KSB7XG4gICAgLy8gTmVlZCB0aGlzIHRvIHByZXZlbnQgb3BlbmluZyBvZiBzaWRlbWVudXMgb3Igc2ltaWxhclxuICAgIGlmIChzLnN0b3BQcm9wKSB7XG4gICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICB2YXIgYiA9IGNsb3Nlc3QodGhpcywgZXYudGFyZ2V0LCAnLm1ic2MtZnItYnRuLWUnKTtcblxuICAgIGlmICghYikge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ2FuJ3QgY2FsbCBwcmV2ZW50RGVmYXVsdCBoZXJlLCBpdCBraWxscyBwYWdlIHNjcm9sbFxuXG5cbiAgICBpZiAoYnRuKSB7XG4gICAgICBidG4ucmVtb3ZlQ2xhc3MoJ21ic2MtYWN0aXZlJyk7XG4gICAgfVxuXG4gICAgYnRuID0gJCQxKGIpOyAvLyBBY3RpdmUgYnV0dG9uXG5cbiAgICBpZiAoIWJ0bi5oYXNDbGFzcygnbWJzYy1kaXNhYmxlZCcpICYmICFidG4uaGFzQ2xhc3MoJ21ic2MtZnItYnRuLW5obCcpKSB7XG4gICAgICBidG4uYWRkQ2xhc3MoJ21ic2MtYWN0aXZlJyk7XG4gICAgfVxuXG4gICAgaWYgKGV2LnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICAkJDEoZG9jdW1lbnQpLm9uKCdtb3VzZXVwJywgb25CdG5FbmQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQnRuRW5kKGV2KSB7XG4gICAgaWYgKGJ0bikge1xuICAgICAgYnRuLnJlbW92ZUNsYXNzKCdtYnNjLWFjdGl2ZScpO1xuICAgICAgYnRuID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoZXYudHlwZSA9PT0gJ21vdXNldXAnKSB7XG4gICAgICAkJDEoZG9jdW1lbnQpLm9mZignbW91c2V1cCcsIG9uQnRuRW5kKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblNjcm9sbChldikge1xuICAgIGlmIChzY3JvbGxMb2NrICYmIG1hcmt1cC5jb250YWlucyhldi50YXJnZXQpKSB7XG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uV25kS2V5RG93bihldikge1xuICAgIGlmIChtb2Jpc2Nyb2xsLmFjdGl2ZUluc3RhbmNlID09IHRoYXQpIHtcbiAgICAgIGlmIChldi5rZXlDb2RlID09IDEzICYmICghJCQxKGV2LnRhcmdldCkuaXMoQUxMT1dfRU5URVIpIHx8IGV2LnNoaWZ0S2V5KSkge1xuICAgICAgICB0aGF0LnNlbGVjdCgpO1xuICAgICAgfSBlbHNlIGlmIChldi5rZXlDb2RlID09IDI3KSB7XG4gICAgICAgIHRoYXQuY2FuY2VsKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25TaG93KHByZXZGb2N1cykge1xuICAgIGlmICghcHJldkZvY3VzICYmICFpc0FuZHJvaWQgJiYgdGhhdC5fYWN0aXZlRWxtKSB7XG4gICAgICAvL292ZXJsYXkuZm9jdXMoKTtcbiAgICAgIGxhc3RGb2N1cyA9IG5ldyBEYXRlKCk7XG5cbiAgICAgIHRoYXQuX2FjdGl2ZUVsbS5mb2N1cygpO1xuICAgIH0gLy90aGF0LmFyaWFNZXNzYWdlKHMuYXJpYU1lc3NhZ2UpO1xuXG4gIH1cblxuICBmdW5jdGlvbiBvbkhpZGUocHJldkFuaW0pIHtcbiAgICB2YXIgJGFjdGl2ZUVsID0gJGFjdGl2ZUVsbSxcbiAgICAgICAgZm9jdXMgPSBzLmZvY3VzT25DbG9zZTtcblxuICAgIHRoYXQuX21hcmt1cFJlbW92ZSgpO1xuXG4gICAgJG1hcmt1cC5yZW1vdmUoKTtcblxuICAgIGlmIChpc01vZGFsKSB7XG4gICAgICBjdHgubWJzY01vZGFscy0tO1xuXG4gICAgICBpZiAocy5zY3JvbGxMb2NrKSB7XG4gICAgICAgIGN0eC5tYnNjTG9jay0tO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWN0eC5tYnNjTG9jaykge1xuICAgICAgICAkbG9jay5yZW1vdmVDbGFzcygnbWJzYy1mci1sb2NrJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZWVkc0xvY2spIHtcbiAgICAgICAgY3R4Lm1ic2NJT1NMb2NrLS07XG5cbiAgICAgICAgaWYgKCFjdHgubWJzY0lPU0xvY2spIHtcbiAgICAgICAgICAkbG9jay5yZW1vdmVDbGFzcygnbWJzYy1mci1sb2NrLWlvcycpO1xuICAgICAgICAgICRjdHguY3NzKHtcbiAgICAgICAgICAgIHRvcDogJycsXG4gICAgICAgICAgICBsZWZ0OiAnJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgICR3bmQuc2Nyb2xsTGVmdChjdHgubWJzY1Njcm9sbExlZnQpO1xuICAgICAgICAgICR3bmQuc2Nyb2xsVG9wKGN0eC5tYnNjU2Nyb2xsVG9wKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBUaGUgZm9sbHdpbmcgc2hvdWxkIGJlIGRvbmUgb25seSBpZiBubyBvdGhlclxuICAgICAgLy8gaW5zdGFuY2Ugd2FzIG9wZW5lZCBkdXJpbmcgdGhlIGhpZGUgYW5pbWF0aW9uXG5cblxuICAgICAgaWYgKCFjdHgubWJzY01vZGFscykge1xuICAgICAgICAkbG9jay5yZW1vdmVDbGFzcygnbWJzYy1mci1sb2NrLWN0eCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWN0eC5tYnNjTW9kYWxzIHx8IHByZXZJbnN0KSB7XG4gICAgICAgIC8vIFB1dCBmb2N1cyBiYWNrIHRvIHRoZSBsYXN0IGFjdGl2ZSBlbGVtZW50XG4gICAgICAgIGlmICghcHJldkFuaW0pIHtcbiAgICAgICAgICBpZiAoISRhY3RpdmVFbCkge1xuICAgICAgICAgICAgJGFjdGl2ZUVsID0gJGVsbTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChmb2N1cyA9PT0gdW5kZWZpbmVkIHx8IGZvY3VzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHByZXZlbnRTaG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgJGFjdGl2ZUVsWzBdLmZvY3VzKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvY3VzKSB7XG4gICAgICAgICAgICAgICQkMShmb2N1cylbMF0uZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAyMDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJldkluc3QgPSB1bmRlZmluZWQ7XG4gICAgaXNJbnNlcnRlZCA9IGZhbHNlO1xuICAgIHRyaWdnZXIoJ29uSGlkZScpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Qb3NpdGlvbigpIHtcbiAgICBjbGVhclRpbWVvdXQocG9zRGVib3VuY2UpO1xuICAgIHBvc0RlYm91bmNlID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhhdC5wb3NpdGlvbih0cnVlKSkge1xuICAgICAgICAvLyBUcmlnZ2VyIHJlZmxvdywgbmVlZGVkIG9uIGlPUyBzYWZhcmksIHdoZW4gb3JpZW50YXRpb24gaXMgY2hhbmdlZFxuICAgICAgICBwb3B1cC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIHBvcHVwLm9mZnNldEhlaWdodDtcbiAgICAgICAgcG9wdXAuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xuICAgICAgfVxuICAgIH0sIDIwMCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkZvY3VzKGV2KSB7XG4gICAgaWYgKG1vYmlzY3JvbGwuYWN0aXZlSW5zdGFuY2UgPT0gdGhhdCAmJiBldi50YXJnZXQubm9kZVR5cGUgJiYgIW92ZXJsYXkuY29udGFpbnMoZXYudGFyZ2V0KSAmJiBuZXcgRGF0ZSgpIC0gbGFzdEZvY3VzID4gMTAwKSB7XG4gICAgICBsYXN0Rm9jdXMgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICB0aGF0Ll9hY3RpdmVFbG0uZm9jdXMoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnRNYXJrdXAocHJldkFuaW0sIHByZXZGb2N1cykge1xuICAgIGZ1bmN0aW9uIG9uQW5pbUVuZCgpIHtcbiAgICAgICRtYXJrdXAub2ZmKGFuaW1FbmQsIG9uQW5pbUVuZCkucmVtb3ZlQ2xhc3MoJ21ic2MtYW5pbS1pbiBtYnNjLWFuaW0tdHJhbnMgbWJzYy1hbmltLXRyYW5zLScgKyBkb0FuaW0pLmZpbmQoJy5tYnNjLWZyLXBvcHVwJykucmVtb3ZlQ2xhc3MoJ21ic2MtYW5pbS0nICsgZG9BbmltKTtcbiAgICAgIG9uU2hvdyhwcmV2Rm9jdXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uT3ZlcmxheVN0YXJ0KGV2KSB7XG4gICAgICBpZiAoIXRhcmdldCAmJiBldi50YXJnZXQgPT0gb3ZlcmxheSkge1xuICAgICAgICB0YXJnZXQgPSB0cnVlO1xuICAgICAgICBtb3ZlZCA9IGZhbHNlO1xuICAgICAgICBzdGFydFggPSBnZXRDb29yZChldiwgJ1gnKTtcbiAgICAgICAgc3RhcnRZID0gZ2V0Q29vcmQoZXYsICdZJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25PdmVybGF5TW92ZShldikge1xuICAgICAgaWYgKHRhcmdldCAmJiAhbW92ZWQgJiYgKE1hdGguYWJzKGdldENvb3JkKGV2LCAnWCcpIC0gc3RhcnRYKSA+IDkgfHwgTWF0aC5hYnMoZ2V0Q29vcmQoZXYsICdZJykgLSBzdGFydFkpID4gOSkpIHtcbiAgICAgICAgbW92ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gLy8gTWlnaHQgYmUgbm90IHZpc2libGUgaWYgaW1tZWRpYXRlbHkgaGlkZGVuXG5cblxuICAgIGlmICghdGhhdC5faXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBTaG93XG5cblxuICAgIGlmIChpc01vZGFsKSB7XG4gICAgICAkbWFya3VwLmFwcGVuZFRvKCRjdHgpO1xuICAgIH0gZWxzZSBpZiAoJGVsbS5pcygnZGl2JykgJiYgIXRoYXQuX2hhc0NvbnRlbnQpIHtcbiAgICAgIC8vIEluc2VydCBpbnNpZGUgdGhlIGVsZW1lbnQgb24gd2hpY2ggd2FzIGluaXRpYWxpemVkXG4gICAgICAkZWxtLmVtcHR5KCkuYXBwZW5kKCRtYXJrdXApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbnNlcnQgYWZ0ZXIgdGhlIGVsZW1lbnRcbiAgICAgIGlmICgkZWxtLmhhc0NsYXNzKCdtYnNjLWNvbnRyb2wnKSkge1xuICAgICAgICB2YXIgJHdyYXAgPSAkZWxtLmNsb3Nlc3QoJy5tYnNjLWNvbnRyb2wtdycpO1xuICAgICAgICAkbWFya3VwLmluc2VydEFmdGVyKCR3cmFwKTtcblxuICAgICAgICBpZiAoJHdyYXAuaGFzQ2xhc3MoJ21ic2Mtc2VsZWN0JykpIHtcbiAgICAgICAgICAkd3JhcC5hZGRDbGFzcygnbWJzYy1zZWxlY3QtaW5saW5lJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRtYXJrdXAuaW5zZXJ0QWZ0ZXIoJGVsbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaXNJbnNlcnRlZCA9IHRydWU7XG5cbiAgICB0aGF0Ll9tYXJrdXBJbnNlcnRlZCgkbWFya3VwKTtcblxuICAgIHRyaWdnZXIoJ29uTWFya3VwSW5zZXJ0ZWQnLCB7XG4gICAgICB0YXJnZXQ6IG1hcmt1cFxuICAgIH0pO1xuXG4gICAgaWYgKGlzTW9kYWwgJiYgcy5jbG9zZU9uT3ZlcmxheVRhcCkge1xuICAgICAgdmFyIG1vdmVkLCB0YXJnZXQsIHN0YXJ0WCwgc3RhcnRZO1xuICAgICAgbGlzdGVuKG92ZXJsYXksICd0b3VjaHN0YXJ0Jywgb25PdmVybGF5U3RhcnQsIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBsaXN0ZW4ob3ZlcmxheSwgJ3RvdWNobW92ZScsIG9uT3ZlcmxheU1vdmUsIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICAkb3ZlcmxheS5vbignbW91c2Vkb3duJywgb25PdmVybGF5U3RhcnQpLm9uKCdtb3VzZW1vdmUnLCBvbk92ZXJsYXlNb3ZlKS5vbigndG91Y2hjYW5jZWwnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRhcmdldCA9IGZhbHNlO1xuICAgICAgfSkub24oJ3RvdWNoZW5kIGNsaWNrJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgIGlmICh0YXJnZXQgJiYgIW1vdmVkKSB7XG4gICAgICAgICAgdGhhdC5jYW5jZWwoKTtcblxuICAgICAgICAgIGlmIChldi50eXBlID09ICd0b3VjaGVuZCcpIHtcbiAgICAgICAgICAgIHByZXZlbnRDbGljaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRhcmdldCA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgJG1hcmt1cC5vbignbW91c2Vkb3duJywgJy5tYnNjLWJ0bi1lLC5tYnNjLWZyLWJ0bi1lJywgcHJldmRlZikub24oJ2tleWRvd24nLCAnLm1ic2MtZnItYnRuLWUnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIGlmIChldi5rZXlDb2RlID09IDMyKSB7XG4gICAgICAgIC8vIFNwYWNlXG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB0aGlzLmNsaWNrKCk7XG4gICAgICB9XG4gICAgfSkub24oJ2tleWRvd24nLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIC8vIFRyYXAgZm9jdXMgaW5zaWRlIG1vZGFsXG4gICAgICBpZiAoZXYua2V5Q29kZSA9PSAzMiAmJiAhJCQxKGV2LnRhcmdldCkuaXMoRURJVEFCTEUpKSB7XG4gICAgICAgIC8vIFByZXZlbnQgcGFnZSBzY3JvbGwgb24gc3BhY2UgcHJlc3NcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0gZWxzZSBpZiAoZXYua2V5Q29kZSA9PSA5ICYmIGlzTW9kYWwgJiYgcy5mb2N1c1RyYXApIHtcbiAgICAgICAgLy8gVGFiXG4gICAgICAgIHZhciAkZm9jdXNhYmxlID0gJG1hcmt1cC5maW5kKEZPQ1VTQUJMRSkuZmlsdGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXRXaWR0aCA+IDAgfHwgdGhpcy5vZmZzZXRIZWlnaHQgPiAwO1xuICAgICAgICB9KSxcbiAgICAgICAgICAgIGluZGV4ID0gJGZvY3VzYWJsZS5pbmRleCgkJDEoJzpmb2N1cycsICRtYXJrdXApKSxcbiAgICAgICAgICAgIGkgPSAkZm9jdXNhYmxlLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICB0YXJnZXQgPSAwO1xuXG4gICAgICAgIGlmIChldi5zaGlmdEtleSkge1xuICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgIHRhcmdldCA9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4ID09PSBpKSB7XG4gICAgICAgICAgJGZvY3VzYWJsZS5lcSh0YXJnZXQpWzBdLmZvY3VzKCk7XG4gICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLm9uKCd0b3VjaGVuZCcsICcubWJzYy1mci1idG4tZScsIG9uQnRuRW5kKTtcbiAgICBsaXN0ZW4obWFya3VwLCAndG91Y2hzdGFydCcsIG9uQnRuU3RhcnQsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICBsaXN0ZW4obWFya3VwLCAnbW91c2Vkb3duJywgb25CdG5TdGFydCk7IC8vIE5lZWQgZXZlbnQgY2FwdHVyZSBmb3IgdGhpc1xuXG4gICAgbGlzdGVuKG1hcmt1cCwgJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXRvdWNoZWQpIHtcbiAgICAgICAgdG91Y2hlZCA9IHRydWU7XG4gICAgICAgICRjdHguZmluZCgnLm1ic2Mtbm8tdG91Y2gnKS5yZW1vdmVDbGFzcygnbWJzYy1uby10b3VjaCcpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfSk7IC8vIEluaXQgYnV0dG9uc1xuXG4gICAgJCQxLmVhY2goYnV0dG9ucywgZnVuY3Rpb24gKGksIGIpIHtcbiAgICAgIHRoYXQudGFwKCQkMSgnLm1ic2MtZnItYnRuJyArIGksICRtYXJrdXApLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgYiA9IGlzU3RyaW5nKGIpID8gdGhhdC5idXR0b25zW2JdIDogYjtcbiAgICAgICAgKGlzU3RyaW5nKGIuaGFuZGxlcikgPyB0aGF0LmhhbmRsZXJzW2IuaGFuZGxlcl0gOiBiLmhhbmRsZXIpLmNhbGwodGhpcywgZXYsIHRoYXQpO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgfSk7XG5cbiAgICB0aGF0Ll9hdHRhY2hFdmVudHMoJG1hcmt1cCk7IC8vIFNldCBwb3NpdGlvblxuXG5cbiAgICBpZiAodGhhdC5wb3NpdGlvbigpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc01vZGFsIHx8IHRoYXQuX2NoZWNrU2l6ZSkge1xuICAgICAgb2JzZXJ2ZXIgPSByZXNpemVPYnNlcnZlcihtYXJrdXAsIG9uUG9zaXRpb24sIHMuem9uZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzTW9kYWwpIHtcbiAgICAgICRtYXJrdXAucmVtb3ZlQ2xhc3MoJ21ic2MtZnItcG9zJyk7XG5cbiAgICAgIGlmIChkb0FuaW0gJiYgIXByZXZBbmltKSB7XG4gICAgICAgICRtYXJrdXAuYWRkQ2xhc3MoJ21ic2MtYW5pbS1pbiBtYnNjLWFuaW0tdHJhbnMgbWJzYy1hbmltLXRyYW5zLScgKyBkb0FuaW0pLm9uKGFuaW1FbmQsIG9uQW5pbUVuZCkuZmluZCgnLm1ic2MtZnItcG9wdXAnKS5hZGRDbGFzcygnbWJzYy1hbmltLScgKyBkb0FuaW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25TaG93KHByZXZGb2N1cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJpZ2dlcignb25TaG93Jywge1xuICAgICAgdGFyZ2V0OiBtYXJrdXAsXG4gICAgICB2YWx1ZVRleHQ6IHRoYXQuX3RlbXBWYWx1ZVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdyhiZWZvcmVTaG93LCAkZWxtKSB7XG4gICAgaWYgKHRoYXQuX2lzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChiZWZvcmVTaG93KSB7XG4gICAgICBiZWZvcmVTaG93KCk7XG4gICAgfVxuXG4gICAgaWYgKHRoYXQuc2hvdygpICE9PSBmYWxzZSkge1xuICAgICAgJGFjdGl2ZUVsbSA9ICRlbG07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0KCkge1xuICAgIHRoYXQuX2ZpbGxWYWx1ZSgpO1xuXG4gICAgdHJpZ2dlcignb25TZXQnLCB7XG4gICAgICB2YWx1ZVRleHQ6IHRoYXQuX3ZhbHVlXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgdHJpZ2dlcignb25DYW5jZWwnLCB7XG4gICAgICB2YWx1ZVRleHQ6IHRoYXQuX3ZhbHVlXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGF0LnNldFZhbChudWxsLCB0cnVlKTtcbiAgfSAvLyBDYWxsIHRoZSBwYXJlbnQgY29uc3RydWN0b3JcblxuXG4gIEJhc2UuY2FsbCh0aGlzLCBlbCwgc2V0dGluZ3MsIHRydWUpO1xuICAvKipcclxuICAgKiBQb3NpdGlvbnMgdGhlIHNjcm9sbGVyIG9uIHRoZSBzY3JlZW4uXHJcbiAgICovXG5cbiAgdGhhdC5wb3NpdGlvbiA9IGZ1bmN0aW9uIChjaGVjaykge1xuICAgIHZhciBhbmNob3IsXG4gICAgICAgIGFuY2hvcldpZHRoLFxuICAgICAgICBhbmNob3JIZWlnaHQsXG4gICAgICAgIGFuY2hvclBvcyxcbiAgICAgICAgYW5jaG9yVG9wLFxuICAgICAgICBhbmNob3JMZWZ0LFxuICAgICAgICBhcnJvdyxcbiAgICAgICAgYXJyb3dXaWR0aCxcbiAgICAgICAgYXJyb3dIZWlnaHQsXG4gICAgICAgIGRvY0hlaWdodCxcbiAgICAgICAgZG9jV2lkdGgsXG4gICAgICAgIGlzV3JhcHBlZCxcbiAgICAgICAgbmV3SGVpZ2h0LFxuICAgICAgICBuZXdXaWR0aCxcbiAgICAgICAgb2xkSGVpZ2h0LFxuICAgICAgICBvbGRXaWR0aCxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIHRvcCxcbiAgICAgICAgbGVmdCxcbiAgICAgICAgY3NzID0ge30sXG4gICAgICAgIHNjcm9sbExlZnQgPSAwLFxuICAgICAgICBzY3JvbGxUb3AgPSAwLFxuICAgICAgICBtaW5XaWR0aCA9IDAsXG4gICAgICAgIHRvdGFsV2lkdGggPSAwO1xuXG4gICAgaWYgKCFpc0luc2VydGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgb2xkV2lkdGggPSB3bmRXaWR0aDtcbiAgICBvbGRIZWlnaHQgPSB3bmRIZWlnaHQ7XG4gICAgbmV3SGVpZ2h0ID0gTWF0aC5taW4obWFya3VwLm9mZnNldEhlaWdodCwgaGFzQ29udGV4dCA/IEluZmluaXR5IDogd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICBuZXdXaWR0aCA9IE1hdGgubWluKG1hcmt1cC5vZmZzZXRXaWR0aCwgaGFzQ29udGV4dCA/IEluZmluaXR5IDogd2luZG93LmlubmVyV2lkdGgpO1xuXG4gICAgaWYgKCFuZXdXaWR0aCB8fCAhbmV3SGVpZ2h0IHx8IHduZFdpZHRoID09PSBuZXdXaWR0aCAmJiB3bmRIZWlnaHQgPT09IG5ld0hlaWdodCAmJiBjaGVjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGF0Ll9jaGVja1Jlc3AobmV3V2lkdGgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgd25kV2lkdGggPSBuZXdXaWR0aDtcbiAgICB3bmRIZWlnaHQgPSBuZXdIZWlnaHQ7XG5cbiAgICBpZiAodGhhdC5faXNGdWxsU2NyZWVuIHx8IC90b3B8Ym90dG9tLy50ZXN0KHMuZGlzcGxheSkpIHtcbiAgICAgIC8vIFNldCB3aWR0aCwgaWYgZG9jdW1lbnQgaXMgbGFyZ2VyIHRoYW4gdmlld3BvcnQsIG5lZWRzIHRvIGJlIHNldCBiZWZvcmUgb25Qb3NpdGlvbiAoZm9yIGNhbGVuZGFyKVxuICAgICAgJHBvcHVwLndpZHRoKG5ld1dpZHRoKTtcbiAgICB9IGVsc2UgaWYgKGlzTW9kYWwpIHtcbiAgICAgIC8vIFJlc2V0IHdpZHRoXG4gICAgICAkd3JhcHBlci53aWR0aCgnJyk7XG4gICAgfVxuXG4gICAgdGhhdC5fcG9zaXRpb24oJG1hcmt1cCk7IC8vIENhbGwgcG9zaXRpb24gZm9yIG5lc3RlZCBtb2Jpc2Nyb2xsIGNvbXBvbmVudHNcbiAgICAvLyAkKCcubWJzYy1jb21wJywgJG1hcmt1cCkuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgLy8gICAgIHZhciBpbnN0ID0gaW5zdGFuY2VzW3RoaXMuaWRdO1xuICAgIC8vICAgICBpZiAoaW5zdCAmJiBpbnN0ICE9PSB0aGF0ICYmIGluc3QucG9zaXRpb24pIHtcbiAgICAvLyAgICAgICAgIGluc3QucG9zaXRpb24oKTtcbiAgICAvLyAgICAgfVxuICAgIC8vIH0pO1xuXG5cbiAgICBpZiAoIXRoYXQuX2lzRnVsbFNjcmVlbiAmJiAvY2VudGVyfGJ1YmJsZS8udGVzdChzLmRpc3BsYXkpKSB7XG4gICAgICAkJDEoJy5tYnNjLXctcCcsICRtYXJrdXApLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBOZWVkIGZyYWN0aW9uYWwgdmFsdWVzIGhlcmUsIHNvIG9mZnNldFdpZHRoIGlzIG5vdCBva1xuICAgICAgICB3aWR0aCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgIHRvdGFsV2lkdGggKz0gd2lkdGg7XG4gICAgICAgIG1pbldpZHRoID0gd2lkdGggPiBtaW5XaWR0aCA/IHdpZHRoIDogbWluV2lkdGg7XG4gICAgICB9KTtcbiAgICAgIGlzV3JhcHBlZCA9IHRvdGFsV2lkdGggPiBuZXdXaWR0aCAtIDE2IHx8IHMudGFicyA9PT0gdHJ1ZTtcbiAgICAgICR3cmFwcGVyLmNzcyh7XG4gICAgICAgICd3aWR0aCc6IHRoYXQuX2lzTGlxdWlkID8gTWF0aC5taW4ocy5tYXhQb3B1cFdpZHRoLCBuZXdXaWR0aCAtIDE2KSA6IE1hdGguY2VpbChpc1dyYXBwZWQgPyBtaW5XaWR0aCA6IHRvdGFsV2lkdGgpLFxuICAgICAgICAnd2hpdGUtc3BhY2UnOiBpc1dyYXBwZWQgPyAnJyA6ICdub3dyYXAnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodHJpZ2dlcignb25Qb3NpdGlvbicsIHtcbiAgICAgIHRhcmdldDogbWFya3VwLFxuICAgICAgcG9wdXA6IHBvcHVwLFxuICAgICAgaGFzVGFiczogaXNXcmFwcGVkLFxuICAgICAgb2xkV2lkdGg6IG9sZFdpZHRoLFxuICAgICAgb2xkSGVpZ2h0OiBvbGRIZWlnaHQsXG4gICAgICB3aW5kb3dXaWR0aDogbmV3V2lkdGgsXG4gICAgICB3aW5kb3dIZWlnaHQ6IG5ld0hlaWdodFxuICAgIH0pID09PSBmYWxzZSB8fCAhaXNNb2RhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChuZWVkc0RpbWVuc2lvbnMpIHtcbiAgICAgIHNjcm9sbExlZnQgPSAkd25kLnNjcm9sbExlZnQoKTtcbiAgICAgIHNjcm9sbFRvcCA9ICR3bmQuc2Nyb2xsVG9wKCk7XG5cbiAgICAgIGlmICh3bmRXaWR0aCkge1xuICAgICAgICAkcGVyc3AuY3NzKHtcbiAgICAgICAgICB3aWR0aDogJycsXG4gICAgICAgICAgaGVpZ2h0OiAnJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtb2RhbFdpZHRoID0gcG9wdXAub2Zmc2V0V2lkdGg7XG4gICAgbW9kYWxIZWlnaHQgPSBwb3B1cC5vZmZzZXRIZWlnaHQ7XG4gICAgc2Nyb2xsTG9jayA9IG1vZGFsSGVpZ2h0IDw9IG5ld0hlaWdodCAmJiBtb2RhbFdpZHRoIDw9IG5ld1dpZHRoO1xuXG4gICAgaWYgKHMuZGlzcGxheSA9PSAnY2VudGVyJykge1xuICAgICAgbGVmdCA9IE1hdGgubWF4KDAsIHNjcm9sbExlZnQgKyAobmV3V2lkdGggLSBtb2RhbFdpZHRoKSAvIDIpO1xuICAgICAgdG9wID0gTWF0aC5tYXgoMCwgc2Nyb2xsVG9wICsgKG5ld0hlaWdodCAtIG1vZGFsSGVpZ2h0KSAvIDIpO1xuICAgIH0gZWxzZSBpZiAocy5kaXNwbGF5ID09ICdidWJibGUnKSB7XG4gICAgICBhbmNob3IgPSBzLmFuY2hvciA9PT0gdW5kZWZpbmVkID8gJGVsbSA6ICQkMShzLmFuY2hvcik7XG4gICAgICBhcnJvdyA9ICQkMSgnLm1ic2MtZnItYXJyLWknLCAkbWFya3VwKVswXTtcbiAgICAgIGFuY2hvclBvcyA9IGFuY2hvci5vZmZzZXQoKTtcbiAgICAgIGFuY2hvclRvcCA9IGFuY2hvclBvcy50b3AgKyAoaGFzQ29udGV4dCA/IHNjcm9sbFRvcCAtICRjdHgub2Zmc2V0KCkudG9wIDogMCk7XG4gICAgICBhbmNob3JMZWZ0ID0gYW5jaG9yUG9zLmxlZnQgKyAoaGFzQ29udGV4dCA/IHNjcm9sbExlZnQgLSAkY3R4Lm9mZnNldCgpLmxlZnQgOiAwKTtcbiAgICAgIGFuY2hvcldpZHRoID0gYW5jaG9yWzBdLm9mZnNldFdpZHRoO1xuICAgICAgYW5jaG9ySGVpZ2h0ID0gYW5jaG9yWzBdLm9mZnNldEhlaWdodDtcbiAgICAgIGFycm93V2lkdGggPSBhcnJvdy5vZmZzZXRXaWR0aDtcbiAgICAgIGFycm93SGVpZ2h0ID0gYXJyb3cub2Zmc2V0SGVpZ2h0OyAvLyBIb3Jpem9udGFsIHBvc2l0aW9uaW5nXG5cbiAgICAgIGxlZnQgPSBjb25zdHJhaW4oYW5jaG9yTGVmdCAtIChtb2RhbFdpZHRoIC0gYW5jaG9yV2lkdGgpIC8gMiwgc2Nyb2xsTGVmdCArIDMsIHNjcm9sbExlZnQgKyBuZXdXaWR0aCAtIG1vZGFsV2lkdGggLSAzKTsgLy8gVmVydGljYWwgcG9zaXRpb25pbmdcbiAgICAgIC8vIEJlbG93IHRoZSBpbnB1dFxuXG4gICAgICB0b3AgPSBhbmNob3JUb3AgKyBhbmNob3JIZWlnaHQgKyBhcnJvd0hlaWdodCAvIDI7XG5cbiAgICAgIGlmICh0b3AgKyBtb2RhbEhlaWdodCArIDggPiBzY3JvbGxUb3AgKyBuZXdIZWlnaHQgJiYgYW5jaG9yVG9wIC0gbW9kYWxIZWlnaHQgLSBhcnJvd0hlaWdodCAvIDIgPiBzY3JvbGxUb3ApIHtcbiAgICAgICAgJHBvcHVwLnJlbW92ZUNsYXNzKCdtYnNjLWZyLWJ1YmJsZS1ib3R0b20nKS5hZGRDbGFzcygnbWJzYy1mci1idWJibGUtdG9wJyk7IC8vIEFib3ZlIHRoZSBpbnB1dFxuXG4gICAgICAgIHRvcCA9IGFuY2hvclRvcCAtIG1vZGFsSGVpZ2h0IC0gYXJyb3dIZWlnaHQgLyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHBvcHVwLnJlbW92ZUNsYXNzKCdtYnNjLWZyLWJ1YmJsZS10b3AnKS5hZGRDbGFzcygnbWJzYy1mci1idWJibGUtYm90dG9tJyk7XG4gICAgICB9IC8vIFNldCBhcnJvdyBwb3NpdGlvblxuXG5cbiAgICAgICQkMSgnLm1ic2MtZnItYXJyJywgJG1hcmt1cCkuY3NzKHtcbiAgICAgICAgbGVmdDogY29uc3RyYWluKGFuY2hvckxlZnQgKyBhbmNob3JXaWR0aCAvIDIgLSAobGVmdCArIChtb2RhbFdpZHRoIC0gYXJyb3dXaWR0aCkgLyAyKSwgMCwgYXJyb3dXaWR0aClcbiAgICAgIH0pOyAvLyBMb2NrIHNjcm9sbCBvbmx5IGlmIHBvcHVwIGlzIGVudGlyZWx5IGluIHRoZSB2aWV3cG9ydFxuXG4gICAgICBzY3JvbGxMb2NrID0gdG9wID4gc2Nyb2xsVG9wICYmIGxlZnQgPiBzY3JvbGxMZWZ0ICYmIHRvcCArIG1vZGFsSGVpZ2h0IDw9IHNjcm9sbFRvcCArIG5ld0hlaWdodCAmJiBsZWZ0ICsgbW9kYWxXaWR0aCA8PSBzY3JvbGxMZWZ0ICsgbmV3V2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSBzY3JvbGxMZWZ0O1xuICAgICAgdG9wID0gcy5kaXNwbGF5ID09ICd0b3AnID8gc2Nyb2xsVG9wIDogTWF0aC5tYXgoMCwgc2Nyb2xsVG9wICsgbmV3SGVpZ2h0IC0gbW9kYWxIZWlnaHQpO1xuICAgIH1cblxuICAgIGlmIChuZWVkc0RpbWVuc2lvbnMpIHtcbiAgICAgIC8vIElmIHRvcCArIG1vZGFsIGhlaWdodCA+IGRvYyBoZWlnaHQsIGluY3JlYXNlIGRvYyBoZWlnaHRcbiAgICAgIGRvY0hlaWdodCA9IE1hdGgubWF4KHRvcCArIG1vZGFsSGVpZ2h0LCBoYXNDb250ZXh0ID8gY3R4LnNjcm9sbEhlaWdodCA6ICQkMShkb2N1bWVudCkuaGVpZ2h0KCkpO1xuICAgICAgZG9jV2lkdGggPSBNYXRoLm1heChsZWZ0ICsgbW9kYWxXaWR0aCwgaGFzQ29udGV4dCA/IGN0eC5zY3JvbGxXaWR0aCA6ICQkMShkb2N1bWVudCkud2lkdGgoKSk7XG4gICAgICAkcGVyc3AuY3NzKHtcbiAgICAgICAgd2lkdGg6IGRvY1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IGRvY0hlaWdodFxuICAgICAgfSk7IC8vIENoZWNrIGlmIHNjcm9sbCBuZWVkZWRcblxuICAgICAgaWYgKHMuc2Nyb2xsICYmIHMuZGlzcGxheSA9PSAnYnViYmxlJyAmJiAodG9wICsgbW9kYWxIZWlnaHQgKyA4ID4gc2Nyb2xsVG9wICsgbmV3SGVpZ2h0IHx8IGFuY2hvclRvcCA+IHNjcm9sbFRvcCArIG5ld0hlaWdodCB8fCBhbmNob3JUb3AgKyBhbmNob3JIZWlnaHQgPCBzY3JvbGxUb3ApKSB7XG4gICAgICAgICR3bmQuc2Nyb2xsVG9wKE1hdGgubWluKGFuY2hvclRvcCwgdG9wICsgbW9kYWxIZWlnaHQgLSBuZXdIZWlnaHQgKyA4LCBkb2NIZWlnaHQgLSBuZXdIZWlnaHQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjc3MudG9wID0gTWF0aC5mbG9vcih0b3ApO1xuICAgIGNzcy5sZWZ0ID0gTWF0aC5mbG9vcihsZWZ0KTtcbiAgICAkcG9wdXAuY3NzKGNzcyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIC8qKlxyXG4gICAqIFNob3cgbW9iaXNjcm9sbCBvbiBmb2N1cyBhbmQgY2xpY2sgZXZlbnQgb2YgdGhlIHBhcmFtZXRlci5cclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbG0gLSBFdmVudHMgd2lsbCBiZSBhdHRhY2hlZCB0byB0aGlzIGVsZW1lbnQuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2JlZm9yZVNob3c9dW5kZWZpbmVkXSAtIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgYmVmb3JlIHNob3dpbmcgbW9iaXNjcm9sbC5cclxuICAgKi9cblxuXG4gIHRoYXQuYXR0YWNoU2hvdyA9IGZ1bmN0aW9uIChlbG0sIGJlZm9yZVNob3cpIHtcbiAgICB2YXIgJGxhYmVsLFxuICAgICAgICAkZWxtID0gJCQxKGVsbSkub2ZmKCcubWJzYycpLFxuICAgICAgICByZWFkT25seSA9ICRlbG0ucHJvcCgncmVhZG9ubHknKTtcbiAgICB0YXBPZmYoJGVsbSk7XG5cbiAgICBpZiAocy5kaXNwbGF5ICE9PSAnaW5saW5lJykge1xuICAgICAgaWYgKChzLnNob3dPbkZvY3VzIHx8IHMuc2hvd09uVGFwKSAmJiAkZWxtLmlzKCdpbnB1dCxzZWxlY3QnKSkge1xuICAgICAgICAkZWxtLnByb3AoJ3JlYWRvbmx5JywgdHJ1ZSkub24oJ21vdXNlZG93bi5tYnNjJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgLy8gUHJldmVudCBpbnB1dCB0byBnZXQgZm9jdXMgb24gdGFwICh2aXJ0dWFsIGtleWJvYXJkIHBvcHMgdXAgb24gc29tZSBkZXZpY2VzKVxuICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0pLm9uKCdmb2N1cy5tYnNjJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0aGF0Ll9pc1Zpc2libGUpIHtcbiAgICAgICAgICAgIC8vIERvbid0IGFsbG93IGlucHV0IGZvY3VzIGlmIG1vYmlzY3JvbGwgaXMgYmVpbmcgb3BlbmVkXG4gICAgICAgICAgICB0aGlzLmJsdXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAkbGFiZWwgPSAkJDEoJ2xhYmVsW2Zvcj1cIicgKyAkZWxtLmF0dHIoJ2lkJykgKyAnXCJdJyk7XG5cbiAgICAgICAgaWYgKCEkbGFiZWwubGVuZ3RoKSB7XG4gICAgICAgICAgJGxhYmVsID0gJGVsbS5jbG9zZXN0KCdsYWJlbCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghJGVsbS5pcygnc2VsZWN0JykpIHtcbiAgICAgICAgaWYgKHMuc2hvd09uRm9jdXMpIHtcbiAgICAgICAgICAkZWxtLm9uKCdmb2N1cy5tYnNjJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFwcmV2ZW50U2hvdykge1xuICAgICAgICAgICAgICBzaG93KGJlZm9yZVNob3csICRlbG0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcHJldmVudFNob3cgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzLnNob3dPblRhcCkge1xuICAgICAgICAgICRlbG0ub24oJ2tleWRvd24ubWJzYycsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKGV2LmtleUNvZGUgPT0gMzIgfHwgZXYua2V5Q29kZSA9PSAxMykge1xuICAgICAgICAgICAgICAvLyBTcGFjZSBvciBFbnRlclxuICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgc2hvdyhiZWZvcmVTaG93LCAkZWxtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGF0LnRhcCgkZWxtLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmIChldi5pc01ic2NUYXApIHtcbiAgICAgICAgICAgICAgdG91Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNob3coYmVmb3JlU2hvdywgJGVsbSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoJGxhYmVsICYmICRsYWJlbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoYXQudGFwKCRsYWJlbCwgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgaWYgKGV2LnRhcmdldCAhPT0gJGVsbVswXSkge1xuICAgICAgICAgICAgICAgIHNob3coYmVmb3JlU2hvdywgJGVsbSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbG1MaXN0LnB1c2goe1xuICAgICAgICByZWFkT25seTogcmVhZE9ubHksXG4gICAgICAgIGVsOiAkZWxtLFxuICAgICAgICBsYmw6ICRsYWJlbFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBTZXQgYnV0dG9uIGhhbmRsZXIuXHJcbiAgICovXG5cblxuICB0aGF0LnNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaXNNb2RhbCkge1xuICAgICAgdGhhdC5oaWRlKGZhbHNlLCAnc2V0JywgZmFsc2UsIHNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldCgpO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogQ2FuY2VsIGFuZCBoaWRlIHRoZSBzY3JvbGxlciBpbnN0YW5jZS5cclxuICAgKi9cblxuXG4gIHRoYXQuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChpc01vZGFsKSB7XG4gICAgICB0aGF0LmhpZGUoZmFsc2UsICdjYW5jZWwnLCBmYWxzZSwgY2FuY2VsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FuY2VsKCk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBDbGVhciBidXR0b24gaGFuZGxlci5cclxuICAgKi9cblxuXG4gIHRoYXQuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhhdC5fY2xlYXJWYWx1ZSgpO1xuXG4gICAgdHJpZ2dlcignb25DbGVhcicpO1xuXG4gICAgaWYgKGlzTW9kYWwgJiYgdGhhdC5faXNWaXNpYmxlICYmICF0aGF0LmxpdmUpIHtcbiAgICAgIHRoYXQuaGlkZShmYWxzZSwgJ2NsZWFyJywgZmFsc2UsIGNsZWFyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYXIoKTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIEVuYWJsZXMgdGhlIHNjcm9sbGVyIGFuZCB0aGUgYXNzb2NpYXRlZCBpbnB1dC5cclxuICAgKi9cblxuXG4gIHRoYXQuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAkJDEuZWFjaChlbG1MaXN0LCBmdW5jdGlvbiAoaSwgdikge1xuICAgICAgaWYgKHYuZWwuaXMoJ2lucHV0LHNlbGVjdCcpKSB7XG4gICAgICAgIHYuZWxbMF0uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogRGlzYWJsZXMgdGhlIHNjcm9sbGVyIGFuZCB0aGUgYXNzb2NpYXRlZCBpbnB1dC5cclxuICAgKi9cblxuXG4gIHRoYXQuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBzLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAkJDEuZWFjaChlbG1MaXN0LCBmdW5jdGlvbiAoaSwgdikge1xuICAgICAgaWYgKHYuZWwuaXMoJ2lucHV0LHNlbGVjdCcpKSB7XG4gICAgICAgIHYuZWxbMF0uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICAvKipcclxuICAgKiBTaG93cyB0aGUgc2Nyb2xsZXIgaW5zdGFuY2UuXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBwcmV2QW5pbSAtIFByZXZlbnQgYW5pbWF0aW9uIGlmIHRydWVcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHByZXZGb2N1cyAtIFByZXZlbnQgZm9jdXNpbmcgaWYgdHJ1ZVxyXG4gICAqL1xuXG5cbiAgdGhhdC5zaG93ID0gZnVuY3Rpb24gKHByZXZBbmltLCBwcmV2Rm9jdXMpIHtcbiAgICB2YXIgaGFzQnV0dG9ucywgaHRtbCwgc2Nyb2xsTGVmdCwgc2Nyb2xsVG9wO1xuXG4gICAgaWYgKHMuZGlzYWJsZWQgfHwgdGhhdC5faXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBQYXJzZSB2YWx1ZSBmcm9tIGlucHV0XG5cblxuICAgIHRoYXQuX3JlYWRWYWx1ZSgpO1xuXG4gICAgaWYgKHRyaWdnZXIoJ29uQmVmb3JlU2hvdycpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgICRhY3RpdmVFbG0gPSBudWxsO1xuICAgIGRvQW5pbSA9IHMuYW5pbWF0ZTtcbiAgICBidXR0b25zID0gcy5idXR0b25zIHx8IFtdO1xuICAgIG5lZWRzRGltZW5zaW9ucyA9IGhhc0NvbnRleHQgfHwgcy5kaXNwbGF5ID09ICdidWJibGUnO1xuICAgIG5lZWRzTG9jayA9IG5lZWRzRml4ZWQgJiYgIW5lZWRzRGltZW5zaW9ucyAmJiBzLnNjcm9sbExvY2s7XG4gICAgaGFzQnV0dG9ucyA9IGJ1dHRvbnMubGVuZ3RoID4gMDsgLy90b3VjaGVkID0gZmFsc2U7XG5cbiAgICBpZiAoZG9BbmltICE9PSBmYWxzZSkge1xuICAgICAgaWYgKHMuZGlzcGxheSA9PSAndG9wJykge1xuICAgICAgICBkb0FuaW0gPSBkb0FuaW0gfHwgJ3NsaWRlZG93bic7XG4gICAgICB9IGVsc2UgaWYgKHMuZGlzcGxheSA9PSAnYm90dG9tJykge1xuICAgICAgICBkb0FuaW0gPSBkb0FuaW0gfHwgJ3NsaWRldXAnO1xuICAgICAgfSBlbHNlIGlmIChzLmRpc3BsYXkgPT0gJ2NlbnRlcicgfHwgcy5kaXNwbGF5ID09ICdidWJibGUnKSB7XG4gICAgICAgIGRvQW5pbSA9IGRvQW5pbSB8fCAncG9wJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNNb2RhbCkge1xuICAgICAgd25kV2lkdGggPSAwO1xuICAgICAgd25kSGVpZ2h0ID0gMDtcblxuICAgICAgaWYgKG5lZWRzTG9jayAmJiAhJGxvY2suaGFzQ2xhc3MoJ21ic2MtZnItbG9jay1pb3MnKSkge1xuICAgICAgICAvLyRsb2NrLnNjcm9sbFRvcCgwKTtcbiAgICAgICAgY3R4Lm1ic2NTY3JvbGxUb3AgPSBzY3JvbGxUb3AgPSBNYXRoLm1heCgwLCAkd25kLnNjcm9sbFRvcCgpKTtcbiAgICAgICAgY3R4Lm1ic2NTY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdCA9IE1hdGgubWF4KDAsICR3bmQuc2Nyb2xsTGVmdCgpKTtcbiAgICAgICAgJGN0eC5jc3Moe1xuICAgICAgICAgIHRvcDogLXNjcm9sbFRvcCArICdweCcsXG4gICAgICAgICAgbGVmdDogLXNjcm9sbExlZnQgKyAncHgnXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAkbG9jay5hZGRDbGFzcygocy5zY3JvbGxMb2NrID8gJ21ic2MtZnItbG9jaycgOiAnJykgKyAobmVlZHNMb2NrID8gJyBtYnNjLWZyLWxvY2staW9zJyA6ICcnKSArIChoYXNDb250ZXh0ID8gJyBtYnNjLWZyLWxvY2stY3R4JyA6ICcnKSk7IC8vIEhpZGUgdmlydHVhbCBrZXlib2FyZFxuXG4gICAgICBpZiAoJCQxKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmlzKCdpbnB1dCx0ZXh0YXJlYScpKSB7XG4gICAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgfSAvLyBTYXZlIGFjdGl2ZSBpbnN0YW5jZSB0byBwcmV2aW91c1xuXG5cbiAgICAgIHByZXZJbnN0ID0gbW9iaXNjcm9sbC5hY3RpdmVJbnN0YW5jZTsgLy8gU2V0IGFjdGl2ZSBpbnN0YW5jZVxuXG4gICAgICBtb2Jpc2Nyb2xsLmFjdGl2ZUluc3RhbmNlID0gdGhhdDsgLy8gS2VlcCB0cmFjayBvZiBtb2RhbHMgb3BlbmVkIHBlciBjb250ZXh0XG5cbiAgICAgIGN0eC5tYnNjTW9kYWxzID0gKGN0eC5tYnNjTW9kYWxzIHx8IDApICsgMTtcblxuICAgICAgaWYgKG5lZWRzTG9jaykge1xuICAgICAgICBjdHgubWJzY0lPU0xvY2sgPSAoY3R4Lm1ic2NJT1NMb2NrIHx8IDApICsgMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMuc2Nyb2xsTG9jaykge1xuICAgICAgICBjdHgubWJzY0xvY2sgPSAoY3R4Lm1ic2NMb2NrIHx8IDApICsgMTtcbiAgICAgIH1cbiAgICB9IC8vIENyZWF0ZSB3aGVlbHMgY29udGFpbmVyc1xuXG5cbiAgICBodG1sID0gJzxkaXYgbGFuZz1cIicgKyBzLmxhbmcgKyAnXCIgY2xhc3M9XCJtYnNjLWZyIG1ic2MtJyArIHMudGhlbWUgKyAocy5iYXNlVGhlbWUgPyAnIG1ic2MtJyArIHMuYmFzZVRoZW1lIDogJycpICsgJyBtYnNjLWZyLScgKyBzLmRpc3BsYXkgKyAnICcgKyAocy5jc3NDbGFzcyB8fCAnJykgKyAnICcgKyAocy5jb21wQ2xhc3MgfHwgJycpICsgKHRoYXQuX2lzTGlxdWlkID8gJyBtYnNjLWZyLWxpcScgOiAnJykgKyAoaXNNb2RhbCA/ICcgbWJzYy1mci1wb3MnICsgKHMuc2hvd092ZXJsYXkgPyAnJyA6ICcgbWJzYy1mci1uby1vdmVybGF5JykgOiAnJykgKyAoaXNQb2ludGVyID8gJyBtYnNjLWZyLXBvaW50ZXInIDogJycpICsgKGhhbGZCb3JkZXIgPyAnIG1ic2MtZnItaGInIDogJycpICsgKHRvdWNoZWQgPyAnJyA6ICcgbWJzYy1uby10b3VjaCcpICsgKG5lZWRzTG9jayA/ICcgbWJzYy1wbGF0Zm9ybS1pb3MnIDogJycpICsgKGhhc0J1dHRvbnMgPyBidXR0b25zLmxlbmd0aCA+PSAzID8gJyBtYnNjLWZyLWJ0bi1ibG9jayAnIDogJycgOiAnIG1ic2MtZnItbm9idG4nKSArICdcIj4nICsgKGlzTW9kYWwgPyAnPGRpdiBjbGFzcz1cIm1ic2MtZnItcGVyc3BcIj4nICsgKHMuc2hvd092ZXJsYXkgPyAnPGRpdiBjbGFzcz1cIm1ic2MtZnItb3ZlcmxheVwiPjwvZGl2PicgOiAnJykgKyAvLyBPdmVybGF5XG4gICAgJzxkaXYgcm9sZT1cImRpYWxvZ1wiIGNsYXNzPVwibWJzYy1mci1zY3JvbGxcIj4nIDogJycpICsgJzxkaXYgY2xhc3M9XCJtYnNjLWZyLXBvcHVwJyArIChzLnJ0bCA/ICcgbWJzYy1ydGwnIDogJyBtYnNjLWx0cicpICsgKHMuaGVhZGVyVGV4dCA/ICcgbWJzYy1mci1oYXMtaGRyJyA6ICcnKSArICdcIj4nICsgKCAvLyBQb3B1cFxuICAgIHMuZGlzcGxheSA9PT0gJ2J1YmJsZScgPyAnPGRpdiBjbGFzcz1cIm1ic2MtZnItYXJyLXdcIj48ZGl2IGNsYXNzPVwibWJzYy1mci1hcnItaVwiPjxkaXYgY2xhc3M9XCJtYnNjLWZyLWFyclwiPjwvZGl2PjwvZGl2PjwvZGl2PicgOiAnJykgKyAoIC8vIEJ1YmJsZSBhcnJvd1xuICAgIGlzTW9kYWwgPyAnPGRpdiBjbGFzcz1cIm1ic2MtZnItZm9jdXNcIiB0YWJpbmRleD1cIi0xXCI+PC9kaXY+JyA6ICcnKSArICc8ZGl2IGNsYXNzPVwibWJzYy1mci13XCI+JyArICggLy8gUG9wdXAgY29udGVudFxuICAgIC8vJzxkaXYgYXJpYS1saXZlPVwiYXNzZXJ0aXZlXCIgY2xhc3M9XCJtYnNjLWZyLWFyaWEgbWJzYy1mci1oZG5cIj48L2Rpdj4nICtcbiAgICBzLmhlYWRlclRleHQgPyAnPGRpdiBjbGFzcz1cIm1ic2MtZnItaGRyXCI+JyArIChpc1N0cmluZyhzLmhlYWRlclRleHQpID8gcy5oZWFkZXJUZXh0IDogJycpICsgJzwvZGl2PicgOiAnJykgKyAvLyBIZWFkZXJcbiAgICAnPGRpdiBjbGFzcz1cIm1ic2MtZnItY1wiPic7IC8vIFdoZWVsIGdyb3VwIGNvbnRhaW5lclxuXG4gICAgaHRtbCArPSB0aGF0Ll9nZW5lcmF0ZUNvbnRlbnQoKTtcbiAgICBodG1sICs9ICc8L2Rpdj4nO1xuXG4gICAgaWYgKGhhc0J1dHRvbnMpIHtcbiAgICAgIHZhciBiLFxuICAgICAgICAgIGksXG4gICAgICAgICAgaixcbiAgICAgICAgICBsID0gYnV0dG9ucy5sZW5ndGg7XG4gICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwibWJzYy1mci1idG4tY29udFwiPic7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBidXR0b25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGogPSBzLmJ0blJldmVyc2UgPyBsIC0gaSAtIDEgOiBpO1xuICAgICAgICBiID0gYnV0dG9uc1tqXTtcbiAgICAgICAgYiA9IGlzU3RyaW5nKGIpID8gdGhhdC5idXR0b25zW2JdIDogYjtcblxuICAgICAgICBpZiAoYi5oYW5kbGVyID09PSAnc2V0Jykge1xuICAgICAgICAgIGIucGFyZW50Q2xhc3MgPSAnbWJzYy1mci1idG4tcyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYi5oYW5kbGVyID09PSAnY2FuY2VsJykge1xuICAgICAgICAgIGIucGFyZW50Q2xhc3MgPSAnbWJzYy1mci1idG4tYyc7XG4gICAgICAgIH1cblxuICAgICAgICBodG1sICs9ICc8ZGl2JyArIChzLmJ0bldpZHRoID8gJyBzdHlsZT1cIndpZHRoOicgKyAxMDAgLyBidXR0b25zLmxlbmd0aCArICclXCInIDogJycpICsgJyBjbGFzcz1cIm1ic2MtZnItYnRuLXcgJyArIChiLnBhcmVudENsYXNzIHx8ICcnKSArICdcIj4nICsgJzxkaXYgdGFiaW5kZXg9XCIwXCIgcm9sZT1cImJ1dHRvblwiIGNsYXNzPVwibWJzYy1mci1idG4nICsgaiArICcgbWJzYy1mci1idG4tZSAnICsgKGIuY3NzQ2xhc3MgPT09IHVuZGVmaW5lZCA/IHMuYnRuQ2xhc3MgOiBiLmNzc0NsYXNzKSArIChiLmljb24gPyAnIG1ic2MtaWMgbWJzYy1pYy0nICsgYi5pY29uIDogJycpICsgJ1wiPicgKyAoYi50ZXh0IHx8ICcnKSArICc8L2Rpdj48L2Rpdj4nO1xuICAgICAgfVxuXG4gICAgICBodG1sICs9ICc8L2Rpdj4nO1xuICAgIH1cblxuICAgIGh0bWwgKz0gJzwvZGl2PjwvZGl2PjwvZGl2PjwvZGl2PicgKyAoaXNNb2RhbCA/ICc8L2Rpdj48L2Rpdj4nIDogJycpO1xuICAgICRtYXJrdXAgPSAkJDEoaHRtbCk7XG4gICAgJHBlcnNwID0gJCQxKCcubWJzYy1mci1wZXJzcCcsICRtYXJrdXApO1xuICAgICRvdmVybGF5ID0gJCQxKCcubWJzYy1mci1zY3JvbGwnLCAkbWFya3VwKTtcbiAgICAkd3JhcHBlciA9ICQkMSgnLm1ic2MtZnItdycsICRtYXJrdXApO1xuICAgICRwb3B1cCA9ICQkMSgnLm1ic2MtZnItcG9wdXAnLCAkbWFya3VwKTtcbiAgICAkaGVhZGVyID0gJCQxKCcubWJzYy1mci1oZHInLCAkbWFya3VwKTsgLy8kYXJpYURpdiA9ICQoJy5tYnNjLWZyLWFyaWEnLCAkbWFya3VwKTtcblxuICAgIG1hcmt1cCA9ICRtYXJrdXBbMF07XG4gICAgb3ZlcmxheSA9ICRvdmVybGF5WzBdO1xuICAgIHBvcHVwID0gJHBvcHVwWzBdO1xuICAgIHRoYXQuX2FjdGl2ZUVsbSA9ICQkMSgnLm1ic2MtZnItZm9jdXMnLCAkbWFya3VwKVswXTtcbiAgICB0aGF0Ll9tYXJrdXAgPSAkbWFya3VwO1xuICAgIHRoYXQuX2lzVmlzaWJsZSA9IHRydWU7XG4gICAgdGhhdC5tYXJrdXAgPSBtYXJrdXA7XG5cbiAgICB0aGF0Ll9tYXJrdXBSZWFkeSgkbWFya3VwKTtcblxuICAgIHRyaWdnZXIoJ29uTWFya3VwUmVhZHknLCB7XG4gICAgICB0YXJnZXQ6IG1hcmt1cFxuICAgIH0pOyAvLyBBdHRhY2ggZXZlbnRzXG5cbiAgICBpZiAoaXNNb2RhbCkge1xuICAgICAgLy8gRW50ZXIgLyBFU0NcbiAgICAgICQkMSh3aW5kb3cpLm9uKCdrZXlkb3duJywgb25XbmRLZXlEb3duKTsgLy8gUHJldmVudCBzY3JvbGwgaWYgbm90IHNwZWNpZmllZCBvdGhlcndpc2VcblxuICAgICAgaWYgKHMuc2Nyb2xsTG9jaykge1xuICAgICAgICBsaXN0ZW4oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCBvblNjcm9sbCwge1xuICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBsaXN0ZW4oZG9jdW1lbnQsICdtb3VzZXdoZWVsJywgb25TY3JvbGwsIHtcbiAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgbGlzdGVuKGRvY3VtZW50LCAnd2hlZWwnLCBvblNjcm9sbCwge1xuICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocy5mb2N1c1RyYXApIHtcbiAgICAgICAgJHduZC5vbignZm9jdXNpbicsIG9uRm9jdXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc01vZGFsKSB7XG4gICAgICAvLyBXYWl0IGZvciB0aGUgdG9vbGJhciBhbmQgYWRkcmVzc2JhciB0byBhcHBlYXIgb24gaU9TXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5zZXJ0TWFya3VwKHByZXZBbmltLCBwcmV2Rm9jdXMpO1xuICAgICAgfSwgbmVlZHNMb2NrID8gMTAwIDogMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc2VydE1hcmt1cChwcmV2QW5pbSwgcHJldkZvY3VzKTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIEhpZGVzIHRoZSBzY3JvbGxlciBpbnN0YW5jZS5cclxuICAgKi9cblxuXG4gIHRoYXQuaGlkZSA9IGZ1bmN0aW9uIChwcmV2QW5pbSwgYnRuLCBmb3JjZSwgY2FsbGJhY2spIHtcbiAgICBmdW5jdGlvbiBvbkFuaW1FbmQoKSB7XG4gICAgICAkbWFya3VwLm9mZihhbmltRW5kLCBvbkFuaW1FbmQpO1xuICAgICAgb25IaWRlKHByZXZBbmltKTtcbiAgICB9IC8vIElmIG9uQ2xvc2UgaGFuZGxlciByZXR1cm5zIGZhbHNlLCBwcmV2ZW50IGhpZGVcblxuXG4gICAgaWYgKCF0aGF0Ll9pc1Zpc2libGUgfHwgIWZvcmNlICYmICF0aGF0Ll9pc1ZhbGlkICYmIGJ0biA9PSAnc2V0JyB8fCAhZm9yY2UgJiYgdHJpZ2dlcignb25CZWZvcmVDbG9zZScsIHtcbiAgICAgIHZhbHVlVGV4dDogdGhhdC5fdGVtcFZhbHVlLFxuICAgICAgYnV0dG9uOiBidG5cbiAgICB9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGF0Ll9pc1Zpc2libGUgPSBmYWxzZTtcblxuICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgb2JzZXJ2ZXIuZGV0YWNoKCk7XG4gICAgICBvYnNlcnZlciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGlzTW9kYWwpIHtcbiAgICAgIGlmICgkJDEoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkuaXMoJ2lucHV0LHRleHRhcmVhJykgJiYgcG9wdXAuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2Jpc2Nyb2xsLmFjdGl2ZUluc3RhbmNlID09IHRoYXQpIHtcbiAgICAgICAgbW9iaXNjcm9sbC5hY3RpdmVJbnN0YW5jZSA9IHByZXZJbnN0O1xuICAgICAgfVxuXG4gICAgICAkJDEod2luZG93KS5vZmYoJ2tleWRvd24nLCBvblduZEtleURvd24pO1xuICAgICAgJHduZC5vZmYoJ2ZvY3VzaW4nLCBvbkZvY3VzKTtcbiAgICAgIHVubGlzdGVuKGRvY3VtZW50LCAndG91Y2htb3ZlJywgb25TY3JvbGwsIHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgdW5saXN0ZW4oZG9jdW1lbnQsICdtb3VzZXdoZWVsJywgb25TY3JvbGwsIHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgdW5saXN0ZW4oZG9jdW1lbnQsICd3aGVlbCcsIG9uU2Nyb2xsLCB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IC8vIEhpZGUgd2hlZWxzIGFuZCBvdmVybGF5XG5cblxuICAgIGlmICgkbWFya3VwKSB7XG4gICAgICBpZiAoaXNNb2RhbCAmJiBkb0FuaW0gJiYgIXByZXZBbmltKSB7XG4gICAgICAgICRtYXJrdXAuYWRkQ2xhc3MoJ21ic2MtYW5pbS1vdXQgbWJzYy1hbmltLXRyYW5zIG1ic2MtYW5pbS10cmFucy0nICsgZG9BbmltKS5vbihhbmltRW5kLCBvbkFuaW1FbmQpLmZpbmQoJy5tYnNjLWZyLXBvcHVwJykuYWRkQ2xhc3MoJ21ic2MtYW5pbS0nICsgZG9BbmltKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uSGlkZShwcmV2QW5pbSk7XG4gICAgICB9XG5cbiAgICAgIHRoYXQuX2RldGFjaEV2ZW50cygkbWFya3VwKTtcbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSAvLyBGb3IgdmFsaWRhdGlvblxuXG5cbiAgICAkZWxtLnRyaWdnZXIoJ2JsdXInKTtcbiAgICB0cmlnZ2VyKCdvbkNsb3NlJywge1xuICAgICAgdmFsdWVUZXh0OiB0aGF0Ll92YWx1ZVxuICAgIH0pO1xuICB9OyAvLyB0aGF0LmFyaWFNZXNzYWdlID0gZnVuY3Rpb24gKHR4dCkge1xuICAvLyAgICAgJGFyaWFEaXYuaHRtbCgnJyk7XG4gIC8vICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgLy8gICAgICAgICAkYXJpYURpdi5odG1sKHR4dCk7XG4gIC8vICAgICB9LCAxMDApO1xuICAvLyB9O1xuXG4gIC8qKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSBzY3JvbGxlciBpcyBjdXJyZW50bHkgdmlzaWJsZS5cclxuICAgKi9cblxuXG4gIHRoYXQuaXNWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGF0Ll9pc1Zpc2libGU7XG4gIH07IC8vIFByb3RlY3RlZCBmdW5jdGlvbnMgdG8gb3ZlcnJpZGVcblxuXG4gIHRoYXQuc2V0VmFsID0gbm9vcDtcbiAgdGhhdC5nZXRWYWwgPSBub29wO1xuICB0aGF0Ll9nZW5lcmF0ZUNvbnRlbnQgPSBub29wO1xuICB0aGF0Ll9hdHRhY2hFdmVudHMgPSBub29wO1xuICB0aGF0Ll9kZXRhY2hFdmVudHMgPSBub29wO1xuICB0aGF0Ll9yZWFkVmFsdWUgPSBub29wO1xuICB0aGF0Ll9jbGVhclZhbHVlID0gbm9vcDtcbiAgdGhhdC5fZmlsbFZhbHVlID0gbm9vcDtcbiAgdGhhdC5fbWFya3VwUmVhZHkgPSBub29wO1xuICB0aGF0Ll9tYXJrdXBJbnNlcnRlZCA9IG5vb3A7XG4gIHRoYXQuX21hcmt1cFJlbW92ZSA9IG5vb3A7XG4gIHRoYXQuX3Bvc2l0aW9uID0gbm9vcDtcbiAgdGhhdC5fX3Byb2Nlc3NTZXR0aW5ncyA9IG5vb3A7XG4gIHRoYXQuX19pbml0ID0gbm9vcDtcbiAgdGhhdC5fX2Rlc3Ryb3kgPSBub29wOyAvLyBHZW5lcmljIGZyYW1lIGZ1bmN0aW9uc1xuXG4gIC8qKlxyXG4gICAqIERlc3Ryb3lzIHRoZSBtb2Jpc2Nyb2xsIGluc3RhbmNlLlxyXG4gICAqL1xuXG4gIHRoYXQuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gRm9yY2UgaGlkZSB3aXRob3V0IGFuaW1hdGlvblxuICAgIHRoYXQuaGlkZSh0cnVlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgJGVsbS5vZmYoJy5tYnNjJyk7XG4gICAgdGFwT2ZmKCRlbG0pOyAvLyBSZW1vdmUgYWxsIGV2ZW50cyBmcm9tIGVsZW1lbnRzXG5cbiAgICAkJDEuZWFjaChlbG1MaXN0LCBmdW5jdGlvbiAoaSwgdikge1xuICAgICAgdi5lbC5vZmYoJy5tYnNjJykucHJvcCgncmVhZG9ubHknLCB2LnJlYWRPbmx5KTtcbiAgICAgIHRhcE9mZih2LmVsKTtcblxuICAgICAgaWYgKHYubGJsKSB7XG4gICAgICAgIHYubGJsLm9mZignLm1ic2MnKTtcbiAgICAgICAgdGFwT2ZmKHYubGJsKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoYXQuX19kZXN0cm95KCk7XG4gIH07XG5cbiAgdGhhdC5fdXBkYXRlSGVhZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ID0gcy5oZWFkZXJUZXh0LFxuICAgICAgICB0eHQgPSB0ID8gdHlwZW9mIHQgPT09ICdmdW5jdGlvbicgPyB0LmNhbGwoZWwsIHRoYXQuX3RlbXBWYWx1ZSkgOiB0LnJlcGxhY2UoL1xce3ZhbHVlXFx9L2ksIHRoYXQuX3RlbXBWYWx1ZSkgOiAnJztcbiAgICAkaGVhZGVyLmh0bWwodHh0IHx8ICcmbmJzcDsnKTtcbiAgfTtcblxuICB0aGF0Ll9nZXRSZXNwQ29udCA9IGZ1bmN0aW9uICgpIHtcbiAgICBoYXNDb250ZXh0ID0gcy5jb250ZXh0ICE9ICdib2R5JztcbiAgICAkd25kID0gJCQxKGhhc0NvbnRleHQgPyBzLmNvbnRleHQgOiB3aW5kb3cpO1xuICAgIHJldHVybiBzLmRpc3BsYXkgPT0gJ2lubGluZScgPyAkZWxtLmlzKCdkaXYnKSA/ICRlbG0gOiAkZWxtLnBhcmVudCgpIDogJHduZDtcbiAgfTtcblxuICB0aGF0Ll9wcm9jZXNzU2V0dGluZ3MgPSBmdW5jdGlvbiAocmVzcCkge1xuICAgIHZhciBiLCBpO1xuXG4gICAgdGhhdC5fX3Byb2Nlc3NTZXR0aW5ncyhyZXNwKTtcblxuICAgIGlzUG9pbnRlciA9ICFzLnRvdWNoVWk7XG5cbiAgICBpZiAoaXNQb2ludGVyKSB7XG4gICAgICBzLmRpc3BsYXkgPSByZXNwLmRpc3BsYXkgfHwgc2V0dGluZ3MuZGlzcGxheSB8fCAnYnViYmxlJztcbiAgICAgIHMuYnV0dG9ucyA9IHJlc3AuYnV0dG9ucyB8fCBzZXR0aW5ncy5idXR0b25zIHx8IFtdO1xuICAgICAgcy5zaG93T3ZlcmxheSA9IHJlc3Auc2hvd092ZXJsYXkgfHwgc2V0dGluZ3Muc2hvd092ZXJsYXkgfHwgZmFsc2U7XG4gICAgfSAvLyBBZGQgZGVmYXVsdCBidXR0b25zXG5cblxuICAgIHMuYnV0dG9ucyA9IHMuYnV0dG9ucyB8fCAocy5kaXNwbGF5ICE9PSAnaW5saW5lJyA/IFsnY2FuY2VsJywgJ3NldCddIDogW10pOyAvLyBIaWRlIGhlYWRlciB0ZXh0IGluIGlubGluZSBtb2RlIGJ5IGRlZmF1bHRcblxuICAgIHMuaGVhZGVyVGV4dCA9IHMuaGVhZGVyVGV4dCA9PT0gdW5kZWZpbmVkID8gcy5kaXNwbGF5ICE9PSAnaW5saW5lJyA/ICd7dmFsdWV9JyA6IGZhbHNlIDogcy5oZWFkZXJUZXh0O1xuICAgIGJ1dHRvbnMgPSBzLmJ1dHRvbnMgfHwgW107XG4gICAgaXNNb2RhbCA9IHMuZGlzcGxheSAhPT0gJ2lubGluZSc7XG4gICAgJGN0eCA9ICQkMShzLmNvbnRleHQpO1xuICAgICRsb2NrID0gaGFzQ29udGV4dCA/ICRjdHggOiAkJDEoJ2JvZHksaHRtbCcpO1xuICAgIGN0eCA9ICRjdHhbMF07XG4gICAgdGhhdC5saXZlID0gdHJ1ZTsgLy8gSWYgbm8gc2V0IGJ1dHRvbiBpcyBmb3VuZCwgbGl2ZSBtb2RlIGlzIGFjdGl2YXRlZFxuXG4gICAgZm9yIChpID0gMDsgaSA8IGJ1dHRvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGIgPSBidXR0b25zW2ldO1xuXG4gICAgICBpZiAoYiA9PSAnb2snIHx8IGIgPT0gJ3NldCcgfHwgYi5oYW5kbGVyID09ICdzZXQnKSB7XG4gICAgICAgIHRoYXQubGl2ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoYXQuYnV0dG9ucy5zZXQgPSB7XG4gICAgICB0ZXh0OiBzLnNldFRleHQsXG4gICAgICBpY29uOiBzLnNldEljb24sXG4gICAgICBoYW5kbGVyOiAnc2V0J1xuICAgIH07XG4gICAgdGhhdC5idXR0b25zLmNhbmNlbCA9IHtcbiAgICAgIHRleHQ6IHMuY2FuY2VsVGV4dCxcbiAgICAgIGljb246IHMuY2FuY2VsSWNvbixcbiAgICAgIGhhbmRsZXI6ICdjYW5jZWwnXG4gICAgfTtcbiAgICB0aGF0LmJ1dHRvbnMuY2xvc2UgPSB7XG4gICAgICB0ZXh0OiBzLmNsb3NlVGV4dCxcbiAgICAgIGljb246IHMuY2xvc2VJY29uLFxuICAgICAgaGFuZGxlcjogJ2NhbmNlbCdcbiAgICB9O1xuICAgIHRoYXQuYnV0dG9ucy5jbGVhciA9IHtcbiAgICAgIHRleHQ6IHMuY2xlYXJUZXh0LFxuICAgICAgaWNvbjogcy5jbGVhckljb24sXG4gICAgICBoYW5kbGVyOiAnY2xlYXInXG4gICAgfTtcbiAgICB0aGF0Ll9pc0lucHV0ID0gJGVsbS5pcygnaW5wdXQnKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogU2Nyb2xsZXIgaW5pdGlhbGl6YXRpb24uXHJcbiAgICovXG5cblxuICB0aGF0Ll9pbml0ID0gZnVuY3Rpb24gKG5ld1NldHRpbmdzKSB7XG4gICAgdmFyIHdhc1Zpc2libGUgPSB0aGF0Ll9pc1Zpc2libGUsXG4gICAgICAgIHdhc1JlYWR5ID0gd2FzVmlzaWJsZSAmJiAhJG1hcmt1cC5oYXNDbGFzcygnbWJzYy1mci1wb3MnKTtcblxuICAgIGlmICh3YXNWaXNpYmxlKSB7XG4gICAgICB0aGF0LmhpZGUodHJ1ZSwgZmFsc2UsIHRydWUpO1xuICAgIH0gLy8gVW5iaW5kIGFsbCBldmVudHMgKGlmIHJlLWluaXQpXG5cblxuICAgICRlbG0ub2ZmKCcubWJzYycpO1xuICAgIHRhcE9mZigkZWxtKTtcblxuICAgIHRoYXQuX19pbml0KG5ld1NldHRpbmdzKTtcblxuICAgIHRoYXQuX2lzTGlxdWlkID0gcy5sYXlvdXQgPT0gJ2xpcXVpZCc7XG5cbiAgICBpZiAoaXNNb2RhbCkge1xuICAgICAgdGhhdC5fcmVhZFZhbHVlKCk7XG5cbiAgICAgIGlmICghdGhhdC5faGFzQ29udGVudCAmJiAhcy5za2lwU2hvdykge1xuICAgICAgICB0aGF0LmF0dGFjaFNob3coJGVsbSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3YXNWaXNpYmxlKSB7XG4gICAgICAgIHRoYXQuc2hvdyh3YXNSZWFkeSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuc2hvdygpO1xuICAgIH1cblxuICAgICRlbG0ucmVtb3ZlQ2xhc3MoJ21ic2MtY2xvYWsnKS5maWx0ZXIoJ2lucHV0LCBzZWxlY3QsIHRleHRhcmVhJykub24oJ2NoYW5nZS5tYnNjJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGF0Ll9wcmV2ZW50Q2hhbmdlKSB7XG4gICAgICAgIHRoYXQuc2V0VmFsKCRlbG0udmFsKCksIHRydWUsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgdGhhdC5fcHJldmVudENoYW5nZSA9IGZhbHNlO1xuICAgIH0pO1xuICB9O1xuXG4gIHRoYXQuYnV0dG9ucyA9IHt9O1xuICB0aGF0LmhhbmRsZXJzID0ge1xuICAgIHNldDogdGhhdC5zZWxlY3QsXG4gICAgY2FuY2VsOiB0aGF0LmNhbmNlbCxcbiAgICBjbGVhcjogdGhhdC5jbGVhclxuICB9O1xuICB0aGF0Ll92YWx1ZSA9IG51bGw7XG4gIHRoYXQuX2lzVmFsaWQgPSB0cnVlO1xuICB0aGF0Ll9pc1Zpc2libGUgPSBmYWxzZTsgLy8gQ29uc3RydWN0b3JcblxuICBzID0gdGhhdC5zZXR0aW5ncztcbiAgdHJpZ2dlciA9IHRoYXQudHJpZ2dlcjtcblxuICBpZiAoIWluaGVyaXQpIHtcbiAgICB0aGF0LmluaXQoKTtcbiAgfVxufTtcbkZyYW1lLnByb3RvdHlwZS5fZGVmYXVsdHMgPSB7XG4gIC8vIExvY2FsaXphdGlvblxuICBsYW5nOiAnZW4nLFxuICBzZXRUZXh0OiAnU2V0JyxcbiAgc2VsZWN0ZWRUZXh0OiAne2NvdW50fSBzZWxlY3RlZCcsXG4gIGNsb3NlVGV4dDogJ0Nsb3NlJyxcbiAgY2FuY2VsVGV4dDogJ0NhbmNlbCcsXG4gIGNsZWFyVGV4dDogJ0NsZWFyJyxcbiAgLy8gT3B0aW9uc1xuICBjb250ZXh0OiAnYm9keScsXG4gIG1heFBvcHVwV2lkdGg6IDYwMCxcbiAgZGlzYWJsZWQ6IGZhbHNlLFxuICBjbG9zZU9uT3ZlcmxheVRhcDogdHJ1ZSxcbiAgc2hvd09uRm9jdXM6IGlzQW5kcm9pZCB8fCBpc0lPUyxcbiAgLy8gTmVlZGVkIGZvciBpb24taW5wdXRcbiAgc2hvd09uVGFwOiB0cnVlLFxuICBkaXNwbGF5OiAnY2VudGVyJyxcbiAgc2Nyb2xsOiB0cnVlLFxuICBzY3JvbGxMb2NrOiB0cnVlLFxuICBzaG93T3ZlcmxheTogdHJ1ZSxcbiAgdGFwOiB0cnVlLFxuICB0b3VjaFVpOiB0cnVlLFxuICBidG5DbGFzczogJ21ic2MtZnItYnRuJyxcbiAgYnRuV2lkdGg6IHRydWUsXG4gIGZvY3VzVHJhcDogdHJ1ZSxcbiAgZm9jdXNPbkNsb3NlOiAhaXNJT1M4IC8vIFRlbXBvcmFyeSBmb3IgaU9TOFxuXG59O1xuY2xhc3Nlcy5GcmFtZSA9IEZyYW1lO1xudGhlbWVzLmZyYW1lLm1vYmlzY3JvbGwgPSB7XG4gIGhlYWRlclRleHQ6IGZhbHNlLFxuICBidG5XaWR0aDogZmFsc2Vcbn07XG50aGVtZXMuc2Nyb2xsZXIubW9iaXNjcm9sbCA9IGV4dGVuZCQxKHt9LCB0aGVtZXMuZnJhbWUubW9iaXNjcm9sbCwge1xuICByb3dzOiA1LFxuICBzaG93TGFiZWw6IGZhbHNlLFxuICBzZWxlY3RlZExpbmVCb3JkZXI6IDEsXG4gIHdlZWtEYXlzOiAnbWluJyxcbiAgY2hlY2tJY29uOiAnaW9uLWlvczctY2hlY2ttYXJrLWVtcHR5JyxcbiAgYnRuUGx1c0NsYXNzOiAnbWJzYy1pYyBtYnNjLWljLWFycm93LWRvd241JyxcbiAgYnRuTWludXNDbGFzczogJ21ic2MtaWMgbWJzYy1pYy1hcnJvdy11cDUnLFxuICBidG5DYWxQcmV2Q2xhc3M6ICdtYnNjLWljIG1ic2MtaWMtYXJyb3ctbGVmdDUnLFxuICBidG5DYWxOZXh0Q2xhc3M6ICdtYnNjLWljIG1ic2MtaWMtYXJyb3ctcmlnaHQ1J1xufSk7XG5cbmlmIChpc0Jyb3dzZXIpIHtcbiAgLy8gUHJldmVudCByZS1zaG93IG9uIHdpbmRvdyBmb2N1c1xuICAkJDEod2luZG93KS5vbignZm9jdXMnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCRhY3RpdmVFbG0pIHtcbiAgICAgIHByZXZlbnRTaG93ID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbnZhciBpc0lPUyQxID0gb3MgPT0gJ2lvcyc7XG52YXIgU2Nyb2xsVmlld0Jhc2UgPSBmdW5jdGlvbiBTY3JvbGxWaWV3QmFzZShlbCwgc2V0dGluZ3MsIGluaGVyaXQpIHtcbiAgdmFyICRidG4sXG4gICAgICAkc2Nyb2xsYmFyLFxuICAgICAgJHNjcm9sbGJhclRyYWNrLFxuICAgICAgYnRuVGltZXIsXG4gICAgICBjb250U2l6ZSxcbiAgICAgIGRpZmZYLFxuICAgICAgZGlmZlksXG4gICAgICBkaWZmLFxuICAgICAgZGlyLFxuICAgICAgZWFzaW5nLFxuICAgICAgZWxhc3RpYyxcbiAgICAgIGVuZFgsXG4gICAgICBlbmRZLFxuICAgICAgZXZlbnRPYmosXG4gICAgICBpc0J0bixcbiAgICAgIGlzSW5maW5pdGUsXG4gICAgICBtYXhTY3JvbGwsXG4gICAgICBtYXhTbmFwU2Nyb2xsLFxuICAgICAgbWluU2Nyb2xsLFxuICAgICAgbW92ZSxcbiAgICAgIG1vdmluZyxcbiAgICAgIG5hdGl2ZVNjcm9sbCxcbiAgICAgIHJhZklELFxuICAgICAgLy9yYWZNb3ZlSUQsXG4gIHJhZlJ1bm5pbmcsXG4gICAgICBzY3JvbGxiYXIsXG4gICAgICBzY3JvbGxiYXJIZWlnaHQsXG4gICAgICBzY3JvbGxiYXJPZmZzZXQsXG4gICAgICBzY3JvbGxiYXJUcmFjayxcbiAgICAgIHNjcm9sbGVkLFxuICAgICAgc2Nyb2xsRGVib3VuY2UsXG4gICAgICBzY3JvbGxTbmFwLFxuICAgICAgc2Nyb2xsVGltZXIsXG4gICAgICBzbmFwLFxuICAgICAgc25hcFBvaW50cyxcbiAgICAgIHN0YXJ0UG9zLFxuICAgICAgc3RhcnRUaW1lLFxuICAgICAgc3RhcnRYLFxuICAgICAgc3RhcnRZLFxuICAgICAgc3R5bGUsXG4gICAgICB0YXJnZXQsXG4gICAgICB0cmFuc1RpbWVyLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgdHJpZ2dlcixcbiAgICAgIHZlcnRpY2FsLFxuICAgICAgdGhhdCA9IHRoaXMsXG4gICAgICBjdXJyUG9zLFxuICAgICAgY3VyclNuYXAgPSAwLFxuICAgICAgY3VyclNuYXBEaXIgPSAxLFxuICAgICAgcyA9IHNldHRpbmdzLFxuICAgICAgJGVsbSA9ICQkMShlbCk7XG5cbiAgZnVuY3Rpb24gb25TdGFydChldikge1xuICAgIHRyaWdnZXIoJ29uU3RhcnQnLCB7XG4gICAgICBkb21FdmVudDogZXZcbiAgICB9KTsgLy8gQmV0dGVyIHBlcmZvcm1hbmNlIGlmIHRoZXJlIGFyZSB0YXAgZXZlbnRzIG9uIGRvY3VtZW50XG5cbiAgICBpZiAocy5zdG9wUHJvcCkge1xuICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSAvL2lmIChzLnByZXZEZWYgfHwgZXYudHlwZSA9PSAnbW91c2Vkb3duJykge1xuXG5cbiAgICBpZiAocy5wcmV2RGVmICYmIGV2LnR5cGUgPT0gJ21vdXNlZG93bicpIHtcbiAgICAgIC8vIFByZXZlbnQgdG91Y2ggaGlnaGxpZ2h0IGFuZCBmb2N1c1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBpZiAocy5yZWFkb25seSB8fCBzLmxvY2sgJiYgbW92aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRlc3RUb3VjaChldiwgdGhpcykgJiYgIW1vdmUpIHtcbiAgICAgIGlmICgkYnRuKSB7XG4gICAgICAgICRidG4ucmVtb3ZlQ2xhc3MoJ21ic2MtYWN0aXZlJyk7XG4gICAgICB9IC8vIEhpZ2hsaWdodCBidXR0b25cblxuXG4gICAgICBpc0J0biA9IGZhbHNlO1xuXG4gICAgICBpZiAoIW1vdmluZykge1xuICAgICAgICAkYnRuID0gJCQxKGV2LnRhcmdldCkuY2xvc2VzdCgnLm1ic2MtYnRuLWUnLCB0aGlzKTtcblxuICAgICAgICBpZiAoJGJ0bi5sZW5ndGggJiYgISRidG4uaGFzQ2xhc3MoJ21ic2MtZGlzYWJsZWQnKSkge1xuICAgICAgICAgIGlzQnRuID0gdHJ1ZTtcbiAgICAgICAgICBidG5UaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJGJ0bi5hZGRDbGFzcygnbWJzYy1hY3RpdmUnKTtcbiAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1vdmUgPSB0cnVlO1xuICAgICAgc2Nyb2xsZWQgPSBmYWxzZTtcbiAgICAgIG5hdGl2ZVNjcm9sbCA9IGZhbHNlO1xuICAgICAgdGhhdC5zY3JvbGxlZCA9IG1vdmluZztcbiAgICAgIHN0YXJ0WCA9IGdldENvb3JkKGV2LCAnWCcpO1xuICAgICAgc3RhcnRZID0gZ2V0Q29vcmQoZXYsICdZJyk7XG4gICAgICBlbmRYID0gc3RhcnRYO1xuICAgICAgZGlmZlggPSAwO1xuICAgICAgZGlmZlkgPSAwO1xuICAgICAgZGlmZiA9IDA7XG4gICAgICBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgc3RhcnRQb3MgPSArZ2V0UG9zaXRpb24odGFyZ2V0LCB2ZXJ0aWNhbCkgfHwgMDsgLy8gU3RvcCBzY3JvbGxpbmcgYW5pbWF0aW9uLCAxbXMgaXMgbmVlZGVkIGZvciBBbmRyb2lkIDQuMFxuXG4gICAgICBpZiAobW92aW5nKSB7XG4gICAgICAgIHNjcm9sbChzdGFydFBvcywgaXNJT1MkMSA/IDAgOiAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2LnR5cGUgPT09ICdtb3VzZWRvd24nKSB7XG4gICAgICAgICQkMShkb2N1bWVudCkub24oJ21vdXNlbW92ZScsIG9uTW92ZSkub24oJ21vdXNldXAnLCBvbkVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Nb3ZlKGV2KSB7XG4gICAgaWYgKG1vdmUpIHtcbiAgICAgIGlmIChzLnN0b3BQcm9wKSB7XG4gICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuXG4gICAgICBlbmRYID0gZ2V0Q29vcmQoZXYsICdYJyk7XG4gICAgICBlbmRZID0gZ2V0Q29vcmQoZXYsICdZJyk7XG4gICAgICBkaWZmWCA9IGVuZFggLSBzdGFydFg7XG4gICAgICBkaWZmWSA9IGVuZFkgLSBzdGFydFk7XG4gICAgICBkaWZmID0gdmVydGljYWwgPyBkaWZmWSA6IGRpZmZYO1xuXG4gICAgICBpZiAoaXNCdG4gJiYgKE1hdGguYWJzKGRpZmZZKSA+IHMudGhyZXNob2xkWSB8fCBNYXRoLmFicyhkaWZmWCkgPiBzLnRocmVzaG9sZFgpKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChidG5UaW1lcik7XG4gICAgICAgICRidG4ucmVtb3ZlQ2xhc3MoJ21ic2MtYWN0aXZlJyk7XG4gICAgICAgIGlzQnRuID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGF0LnNjcm9sbGVkIHx8ICFuYXRpdmVTY3JvbGwgJiYgTWF0aC5hYnMoZGlmZikgPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgaWYgKCFzY3JvbGxlZCkge1xuICAgICAgICAgIHRyaWdnZXIoJ29uR2VzdHVyZVN0YXJ0JywgZXZlbnRPYmopO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdC5zY3JvbGxlZCA9IHNjcm9sbGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIXJhZlJ1bm5pbmcpIHtcbiAgICAgICAgICByYWZSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICByYWZJRCA9IHJhZihvbk1vdmluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHZlcnRpY2FsIHx8IHMuc2Nyb2xsTG9jaykge1xuICAgICAgICAvLyBBbHdheXMgcHJldmVudCBuYXRpdmUgc2Nyb2xsLCBpZiB2ZXJ0aWNhbFxuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoYXQuc2Nyb2xsZWQpIHtcbiAgICAgICAgICAvLyBQcmV2ZW50IG5hdGl2ZSBzY3JvbGxcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGRpZmZZKSA+IDcpIHtcbiAgICAgICAgICBuYXRpdmVTY3JvbGwgPSB0cnVlO1xuICAgICAgICAgIHRoYXQuc2Nyb2xsZWQgPSB0cnVlO1xuICAgICAgICAgIG9uRW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbk1vdmluZygpIHtcbiAgICAvL3ZhciB0aW1lID0gbmV3IERhdGUoKTtcbiAgICBpZiAobWF4U25hcFNjcm9sbCkge1xuICAgICAgZGlmZiA9IGNvbnN0cmFpbihkaWZmLCAtc25hcCAqIG1heFNuYXBTY3JvbGwsIHNuYXAgKiBtYXhTbmFwU2Nyb2xsKTtcbiAgICB9XG5cbiAgICBzY3JvbGwoY29uc3RyYWluKHN0YXJ0UG9zICsgZGlmZiwgbWluU2Nyb2xsIC0gZWxhc3RpYywgbWF4U2Nyb2xsICsgZWxhc3RpYykpOyAvL2lmIChzLm1vbWVudHVtKSB7XG4gICAgLy8gICAgc3RhcnRUaW1lID0gdGltZTtcbiAgICAvLyAgICBsYXN0WCA9IGVuZFg7XG4gICAgLy99XG5cbiAgICByYWZSdW5uaW5nID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBvbkVuZChldikge1xuICAgIGlmIChtb3ZlKSB7XG4gICAgICB2YXIgc3BlZWQsXG4gICAgICAgICAgdGltZSA9IG5ldyBEYXRlKCkgLSBzdGFydFRpbWU7IC8vIEJldHRlciBwZXJmb3JtYW5jZSBpZiB0aGVyZSBhcmUgdGFwIGV2ZW50cyBvbiBkb2N1bWVudFxuXG4gICAgICBpZiAocy5zdG9wUHJvcCAmJiBldikge1xuICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cblxuICAgICAgcmFmYyhyYWZJRCk7XG4gICAgICByYWZSdW5uaW5nID0gZmFsc2U7XG5cbiAgICAgIGlmICghbmF0aXZlU2Nyb2xsICYmIHRoYXQuc2Nyb2xsZWQpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIG1vbWVudHVtIGRpc3RhbmNlXG4gICAgICAgIGlmIChzLm1vbWVudHVtICYmIHRpbWUgPCAzMDApIHtcbiAgICAgICAgICBzcGVlZCA9IGRpZmYgLyB0aW1lOyAvL3NwZWVkID0gTWF0aC5hYnMobGFzdFggLSBlbmRYKSAvIHRpbWU7XG5cbiAgICAgICAgICBkaWZmID0gTWF0aC5tYXgoTWF0aC5hYnMoZGlmZiksIHNwZWVkICogc3BlZWQgLyBzLnNwZWVkVW5pdCkgKiAoZGlmZiA8IDAgPyAtMSA6IDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmluYWxpemUoZGlmZik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0J0bikge1xuICAgICAgICBjbGVhclRpbWVvdXQoYnRuVGltZXIpO1xuICAgICAgICAkYnRuLmFkZENsYXNzKCdtYnNjLWFjdGl2ZScpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAkYnRuLnJlbW92ZUNsYXNzKCdtYnNjLWFjdGl2ZScpO1xuICAgICAgICB9LCAxMDApO1xuXG4gICAgICAgIGlmICghbmF0aXZlU2Nyb2xsICYmICF0aGF0LnNjcm9sbGVkKSB7XG4gICAgICAgICAgdHJpZ2dlcignb25CdG5UYXAnLCB7XG4gICAgICAgICAgICB0YXJnZXQ6ICRidG5bMF0sXG4gICAgICAgICAgICBkb21FdmVudDogZXZcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBEZXRhY2ggZG9jdW1lbnQgZXZlbnRzXG5cblxuICAgICAgaWYgKGV2ICYmIGV2LnR5cGUgPT0gJ21vdXNldXAnKSB7XG4gICAgICAgICQkMShkb2N1bWVudCkub2ZmKCdtb3VzZW1vdmUnLCBvbk1vdmUpLm9mZignbW91c2V1cCcsIG9uRW5kKTtcbiAgICAgIH1cblxuICAgICAgbW92ZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2xpY2soZXYpIHtcbiAgICBpZiAodGhhdC5zY3JvbGxlZCkge1xuICAgICAgdGhhdC5zY3JvbGxlZCA9IGZhbHNlO1xuICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uU2Nyb2xsKGV2KSB7XG4gICAgaWYgKCFlbC5jb250YWlucyhldi50YXJnZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXYgPSBldi5vcmlnaW5hbEV2ZW50IHx8IGV2O1xuICAgIGRpZmYgPSB2ZXJ0aWNhbCA/IGV2LmRlbHRhWSA9PSB1bmRlZmluZWQgPyBldi53aGVlbERlbHRhIHx8IGV2LmRldGFpbCA6IGV2LmRlbHRhWSA6IGV2LmRlbHRhWDtcbiAgICB0cmlnZ2VyKCdvblN0YXJ0Jywge1xuICAgICAgZG9tRXZlbnQ6IGV2XG4gICAgfSk7XG5cbiAgICBpZiAocy5zdG9wUHJvcCkge1xuICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgaWYgKGRpZmYpIHtcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IC8vZGlmZiA9IGRpZmYgPCAwID8gMjAgOiAtMjA7XG5cbiAgICAgIGlmIChldi5kZWx0YU1vZGUgJiYgZXYuZGVsdGFNb2RlID09IDEpIHtcbiAgICAgICAgZGlmZiAqPSAxNTtcbiAgICAgIH1cblxuICAgICAgZGlmZiA9IGNvbnN0cmFpbigtZGlmZiwgLXNjcm9sbFNuYXAsIHNjcm9sbFNuYXApO1xuICAgICAgc3RhcnRQb3MgPSBjdXJyUG9zO1xuXG4gICAgICBpZiAocy5yZWFkb25seSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghc2Nyb2xsZWQpIHtcbiAgICAgICAgZ2VzdHVyZVN0YXJ0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFydFBvcyArIGRpZmYgPCBtaW5TY3JvbGwpIHtcbiAgICAgICAgc3RhcnRQb3MgPSBtaW5TY3JvbGw7XG4gICAgICAgIGRpZmYgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnRQb3MgKyBkaWZmID4gbWF4U2Nyb2xsKSB7XG4gICAgICAgIHN0YXJ0UG9zID0gbWF4U2Nyb2xsO1xuICAgICAgICBkaWZmID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyYWZSdW5uaW5nKSB7XG4gICAgICAgIHJhZlJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICByYWZJRCA9IHJhZihvbk1vdmluZyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZGlmZiAmJiBzY3JvbGxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHNjcm9sbGVkID0gdHJ1ZTtcbiAgICAgIGNsZWFyVGltZW91dChzY3JvbGxEZWJvdW5jZSk7XG4gICAgICBzY3JvbGxEZWJvdW5jZSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByYWZjKHJhZklEKTtcbiAgICAgICAgcmFmUnVubmluZyA9IGZhbHNlO1xuICAgICAgICBzY3JvbGxlZCA9IGZhbHNlO1xuICAgICAgICBmaW5hbGl6ZShkaWZmKTtcbiAgICAgIH0sIDIwMCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25TY3JvbGxCYXJTdGFydChldikge1xuICAgIHRyaWdnZXIoJ29uU3RhcnQnLCB7XG4gICAgICBkb21FdmVudDogZXZcbiAgICB9KTtcblxuICAgIGlmIChzLnJlYWRvbmx5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgc3RhcnRQb3MgPSBjdXJyUG9zO1xuICAgIHNjcm9sbGVkID0gZmFsc2U7XG5cbiAgICBpZiAoZXYudGFyZ2V0ID09IHNjcm9sbGJhcikge1xuICAgICAgc3RhcnRZID0gZ2V0Q29vcmQoZXYsICdZJywgdHJ1ZSk7XG4gICAgICAkJDEoZG9jdW1lbnQpLm9uKCdtb3VzZW1vdmUnLCBvblNjcm9sbEJhck1vdmUpLm9uKCdtb3VzZXVwJywgb25TY3JvbGxCYXJFbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFkgPSAkc2Nyb2xsYmFyLm9mZnNldCgpLnRvcDtcbiAgICAgIG9uU2Nyb2xsQmFyTW92ZShldik7XG4gICAgICBvblNjcm9sbEJhckVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uU2Nyb2xsQmFyTW92ZShldikge1xuICAgIHZhciBwZXJjZW50ID0gKGdldENvb3JkKGV2LCAnWScsIHRydWUpIC0gc3RhcnRZKSAvIGNvbnRTaXplO1xuXG4gICAgaWYgKGlzSW5maW5pdGUpIHtcbiAgICAgIGRpZmYgPSAtKG1heFNuYXBTY3JvbGwgKiBzbmFwICogMiArIGNvbnRTaXplKSAqIHBlcmNlbnQ7XG4gICAgICBkaWZmID0gY29uc3RyYWluKGRpZmYsIC1zbmFwICogbWF4U25hcFNjcm9sbCwgc25hcCAqIG1heFNuYXBTY3JvbGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWZmID0gKG1pblNjcm9sbCAtIG1heFNjcm9sbCAtIGNvbnRTaXplKSAqIHBlcmNlbnQ7XG4gICAgfVxuXG4gICAgaWYgKCFzY3JvbGxlZCkge1xuICAgICAgZ2VzdHVyZVN0YXJ0KCk7XG4gICAgfVxuXG4gICAgc2Nyb2xsZWQgPSB0cnVlO1xuICAgIHNjcm9sbChjb25zdHJhaW4oc3RhcnRQb3MgKyBkaWZmLCBtaW5TY3JvbGwgLSBlbGFzdGljLCBtYXhTY3JvbGwgKyBlbGFzdGljKSk7XG4gIH1cblxuICBmdW5jdGlvbiBvblNjcm9sbEJhckVuZCgpIHtcbiAgICBzdGFydFBvcyA9IGN1cnJQb3M7XG4gICAgZmluYWxpemUoMCk7XG4gICAgJCQxKGRvY3VtZW50KS5vZmYoJ21vdXNlbW92ZScsIG9uU2Nyb2xsQmFyTW92ZSkub2ZmKCdtb3VzZXVwJywgb25TY3JvbGxCYXJFbmQpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25TY3JvbGxCYXJDbGljayhldikge1xuICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VzdHVyZVN0YXJ0KCkge1xuICAgIGV2ZW50T2JqID0ge1xuICAgICAgcG9zWDogdmVydGljYWwgPyAwIDogY3VyclBvcyxcbiAgICAgIHBvc1k6IHZlcnRpY2FsID8gY3VyclBvcyA6IDAsXG4gICAgICBvcmlnaW5YOiB2ZXJ0aWNhbCA/IDAgOiBzdGFydFBvcyxcbiAgICAgIG9yaWdpblk6IHZlcnRpY2FsID8gc3RhcnRQb3MgOiAwLFxuICAgICAgZGlyZWN0aW9uOiBkaWZmID4gMCA/IHZlcnRpY2FsID8gMjcwIDogMzYwIDogdmVydGljYWwgPyA5MCA6IDE4MFxuICAgIH07XG4gICAgdHJpZ2dlcignb25HZXN0dXJlU3RhcnQnLCBldmVudE9iaik7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5hbGl6ZShkaWZmKSB7XG4gICAgdmFyIGksIHRpbWUsIG5ld1BvczsgLy8gTGltaXQgc2Nyb2xsIHRvIHNuYXAgc2l6ZVxuXG4gICAgaWYgKG1heFNuYXBTY3JvbGwpIHtcbiAgICAgIGRpZmYgPSBjb25zdHJhaW4oZGlmZiwgLXNuYXAgKiBtYXhTbmFwU2Nyb2xsLCBzbmFwICogbWF4U25hcFNjcm9sbCk7XG4gICAgfSAvLyBDYWxjdWxhdGUgc25hcCBhbmQgbGltaXQgYmV0d2VlbiBtaW4gYW5kIG1heFxuXG5cbiAgICBuZXdQb3MgPSBjb25zdHJhaW4oTWF0aC5yb3VuZCgoc3RhcnRQb3MgKyBkaWZmKSAvIHNuYXApICogc25hcCwgbWluU2Nyb2xsLCBtYXhTY3JvbGwpOyAvLyBTbmFwIHRvIG5lYXJlc3QgZWxlbWVudFxuXG4gICAgaWYgKHNuYXBQb2ludHMpIHtcbiAgICAgIGlmIChkaWZmIDwgMCkge1xuICAgICAgICBmb3IgKGkgPSBzbmFwUG9pbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKE1hdGguYWJzKG5ld1BvcykgKyBjb250U2l6ZSA+PSBzbmFwUG9pbnRzW2ldLmJyZWFrcG9pbnQpIHtcbiAgICAgICAgICAgIGN1cnJTbmFwID0gaTtcbiAgICAgICAgICAgIGN1cnJTbmFwRGlyID0gMjtcbiAgICAgICAgICAgIG5ld1BvcyA9IHNuYXBQb2ludHNbaV0uc25hcDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGlmZiA+PSAwKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzbmFwUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKE1hdGguYWJzKG5ld1BvcykgPD0gc25hcFBvaW50c1tpXS5icmVha3BvaW50KSB7XG4gICAgICAgICAgICBjdXJyU25hcCA9IGk7XG4gICAgICAgICAgICBjdXJyU25hcERpciA9IDE7XG4gICAgICAgICAgICBuZXdQb3MgPSBzbmFwUG9pbnRzW2ldLnNuYXAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5ld1BvcyA9IGNvbnN0cmFpbihuZXdQb3MsIG1pblNjcm9sbCwgbWF4U2Nyb2xsKTtcbiAgICB9XG5cbiAgICB0aW1lID0gcy50aW1lIHx8IChjdXJyUG9zIDwgbWluU2Nyb2xsIHx8IGN1cnJQb3MgPiBtYXhTY3JvbGwgPyAxMDAwIDogTWF0aC5tYXgoMTAwMCwgTWF0aC5hYnMobmV3UG9zIC0gY3VyclBvcykgKiBzLnRpbWVVbml0KSk7XG4gICAgZXZlbnRPYmouZGVzdGluYXRpb25YID0gdmVydGljYWwgPyAwIDogbmV3UG9zO1xuICAgIGV2ZW50T2JqLmRlc3RpbmF0aW9uWSA9IHZlcnRpY2FsID8gbmV3UG9zIDogMDtcbiAgICBldmVudE9iai5kdXJhdGlvbiA9IHRpbWU7XG4gICAgZXZlbnRPYmoudHJhbnNpdGlvblRpbWluZyA9IGVhc2luZztcbiAgICB0cmlnZ2VyKCdvbkdlc3R1cmVFbmQnLCBldmVudE9iaik7IC8vIFNjcm9sbCB0byB0aGUgY2FsY3VsYXRlZCBwb3NpdGlvblxuXG4gICAgdGhhdC5zY3JvbGwobmV3UG9zLCB0aW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcm9sbChwb3MsIHRpbWUsIHRhcCwgY2FsbGJhY2spIHtcbiAgICB2YXIgcGVyY2VudCxcbiAgICAgICAgY2hhbmdlZCA9IHBvcyAhPSBjdXJyUG9zLFxuICAgICAgICBhbmltID0gdGltZSA+IDEsXG4gICAgICAgIHRpbWluZyA9IHRpbWUgPyBjc3NQcmVmaXggKyAndHJhbnNmb3JtICcgKyBNYXRoLnJvdW5kKHRpbWUpICsgJ21zICcgKyBlYXNpbmcgOiAnJyxcbiAgICAgICAgZG9uZSA9IGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICBjbGVhckludGVydmFsKHNjcm9sbFRpbWVyKTtcbiAgICAgIGNsZWFyVGltZW91dCh0cmFuc1RpbWVyKTsgLy9yYWZjKHJhZk1vdmVJRCk7XG5cbiAgICAgIG1vdmluZyA9IGZhbHNlO1xuICAgICAgY3VyclBvcyA9IHBvcztcbiAgICAgIGV2ZW50T2JqLnBvc1ggPSB2ZXJ0aWNhbCA/IDAgOiBwb3M7XG4gICAgICBldmVudE9iai5wb3NZID0gdmVydGljYWwgPyBwb3MgOiAwO1xuXG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICB0cmlnZ2VyKCdvbk1vdmUnLCBldmVudE9iaik7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbmltKSB7XG4gICAgICAgIC8vdGhhdC5zY3JvbGxlZCA9IGZhbHNlO1xuICAgICAgICB0cmlnZ2VyKCdvbkFuaW1hdGlvbkVuZCcsIGV2ZW50T2JqKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGV2ZW50T2JqID0ge1xuICAgICAgcG9zWDogdmVydGljYWwgPyAwIDogY3VyclBvcyxcbiAgICAgIHBvc1k6IHZlcnRpY2FsID8gY3VyclBvcyA6IDAsXG4gICAgICBvcmlnaW5YOiB2ZXJ0aWNhbCA/IDAgOiBzdGFydFBvcyxcbiAgICAgIG9yaWdpblk6IHZlcnRpY2FsID8gc3RhcnRQb3MgOiAwLFxuICAgICAgZGlyZWN0aW9uOiBwb3MgLSBjdXJyUG9zID4gMCA/IHZlcnRpY2FsID8gMjcwIDogMzYwIDogdmVydGljYWwgPyA5MCA6IDE4MFxuICAgIH07XG4gICAgY3VyclBvcyA9IHBvcztcblxuICAgIGlmIChhbmltKSB7XG4gICAgICBldmVudE9iai5kZXN0aW5hdGlvblggPSB2ZXJ0aWNhbCA/IDAgOiBwb3M7XG4gICAgICBldmVudE9iai5kZXN0aW5hdGlvblkgPSB2ZXJ0aWNhbCA/IHBvcyA6IDA7XG4gICAgICBldmVudE9iai5kdXJhdGlvbiA9IHRpbWU7XG4gICAgICBldmVudE9iai50cmFuc2l0aW9uVGltaW5nID0gZWFzaW5nO1xuICAgICAgdHJpZ2dlcignb25BbmltYXRpb25TdGFydCcsIGV2ZW50T2JqKTtcbiAgICB9XG5cbiAgICBzdHlsZVtqc1ByZWZpeCArICdUcmFuc2l0aW9uJ10gPSB0aW1pbmc7XG4gICAgc3R5bGVbanNQcmVmaXggKyAnVHJhbnNmb3JtJ10gPSAndHJhbnNsYXRlM2QoJyArICh2ZXJ0aWNhbCA/ICcwLCcgKyBwb3MgKyAncHgsJyA6IHBvcyArICdweCwnICsgJzAsJykgKyAnMCknO1xuXG4gICAgaWYgKHNjcm9sbGJhciAmJiBzY3JvbGxiYXJIZWlnaHQpIHtcbiAgICAgIHBlcmNlbnQgPSBpc0luZmluaXRlID8gKHNjcm9sbGJhck9mZnNldCAtIHBvcykgLyAobWF4U25hcFNjcm9sbCAqIHNuYXAgKiAyKSA6IChwb3MgLSBtYXhTY3JvbGwpIC8gKG1pblNjcm9sbCAtIG1heFNjcm9sbCk7XG4gICAgICBzY3JvbGxiYXIuc3R5bGVbanNQcmVmaXggKyAnVHJhbnNpdGlvbiddID0gdGltaW5nO1xuICAgICAgc2Nyb2xsYmFyLnN0eWxlW2pzUHJlZml4ICsgJ1RyYW5zZm9ybSddID0gJ3RyYW5zbGF0ZTNkKDAsJyArIE1hdGgubWF4KDAsIE1hdGgubWluKChjb250U2l6ZSAtIHNjcm9sbGJhckhlaWdodCkgKiBwZXJjZW50LCBjb250U2l6ZSAtIHNjcm9sbGJhckhlaWdodCkpICsgJ3B4LDApJztcbiAgICB9XG5cbiAgICBpZiAoIWNoYW5nZWQgJiYgIW1vdmluZyB8fCAhdGltZSB8fCB0aW1lIDw9IDEpIHtcbiAgICAgIGRvbmUoKTtcbiAgICB9IGVsc2UgaWYgKHRpbWUpIHtcbiAgICAgIG1vdmluZyA9ICF0YXA7XG4gICAgICBjbGVhckludGVydmFsKHNjcm9sbFRpbWVyKTtcbiAgICAgIHNjcm9sbFRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAvL3JhZk1vdmVJRCA9IHJhZihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwID0gK2dldFBvc2l0aW9uKHRhcmdldCwgdmVydGljYWwpIHx8IDA7XG4gICAgICAgIGV2ZW50T2JqLnBvc1ggPSB2ZXJ0aWNhbCA/IDAgOiBwO1xuICAgICAgICBldmVudE9iai5wb3NZID0gdmVydGljYWwgPyBwIDogMDtcbiAgICAgICAgdHJpZ2dlcignb25Nb3ZlJywgZXZlbnRPYmopOyAvLyBUcmlnZ2VyIGRvbmUgaWYgY2xvc2UgdG8gdGhlIGVuZFxuXG4gICAgICAgIGlmIChNYXRoLmFicyhwIC0gcG9zKSA8IDIpIHtcbiAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH0gLy99KTtcblxuICAgICAgfSwgMTAwKTtcbiAgICAgIGNsZWFyVGltZW91dCh0cmFuc1RpbWVyKTtcbiAgICAgIHRyYW5zVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9uZSgpOyAvL3N0eWxlW3ByICsgJ1RyYW5zaXRpb24nXSA9ICcnO1xuICAgICAgfSwgdGltZSk7IC8vIHRhcmdldC5vZmYodHJhbnNFbmQpLm9uKHRyYW5zRW5kLCBmdW5jdGlvbiAoZSkge1xuICAgICAgLy8gICAgIGlmIChlLnRhcmdldCA9PT0gdGFyZ2V0WzBdKSB7XG4gICAgICAvLyAgICAgICAgIHRhcmdldC5vZmYodHJhbnNFbmQpO1xuICAgICAgLy8gICAgICAgICBzdHlsZVtwciArICdUcmFuc2l0aW9uJ10gPSAnJztcbiAgICAgIC8vICAgICAgICAgZG9uZSgpO1xuICAgICAgLy8gICAgIH1cbiAgICAgIC8vIH0pO1xuICAgIH1cblxuICAgIGlmIChzLnN5bmMpIHtcbiAgICAgIHMuc3luYyhwb3MsIHRpbWUsIGVhc2luZyk7XG4gICAgfVxuICB9IC8vIENhbGwgdGhlIHBhcmVudCBjb25zdHJ1Y3RvclxuXG5cbiAgQmFzZS5jYWxsKHRoaXMsIGVsLCBzZXR0aW5ncywgdHJ1ZSk7XG4gIHRoYXQuc2Nyb2xsZWQgPSBmYWxzZTtcbiAgLyoqXHJcbiAgICogU2Nyb2xsIHRvIHRoZSBnaXZlbiBwb3NpdGlvbiBvciBlbGVtZW50XHJcbiAgICovXG5cbiAgdGhhdC5zY3JvbGwgPSBmdW5jdGlvbiAocG9zLCB0aW1lLCB0YXAsIGNhbGxiYWNrKSB7XG4gICAgLy8gSWYgcG9zaXRpb24gaXMgbm90IG51bWVyaWMsIHNjcm9sbCB0byBlbGVtZW50XG4gICAgaWYgKCFpc051bWVyaWMocG9zKSkge1xuICAgICAgcG9zID0gTWF0aC5jZWlsKCgkJDEocG9zLCBlbCkubGVuZ3RoID8gTWF0aC5yb3VuZCh0YXJnZXQub2Zmc2V0KClbZGlyXSAtICQkMShwb3MsIGVsKS5vZmZzZXQoKVtkaXJdKSA6IGN1cnJQb3MpIC8gc25hcCkgKiBzbmFwO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3MgPSBNYXRoLnJvdW5kKHBvcyAvIHNuYXApICogc25hcDtcbiAgICB9XG5cbiAgICBwb3MgPSBjb25zdHJhaW4ocG9zLCBtaW5TY3JvbGwsIG1heFNjcm9sbCk7XG4gICAgY3VyclNuYXAgPSBNYXRoLnJvdW5kKHBvcyAvIHNuYXApO1xuICAgIHN0YXJ0UG9zID0gY3VyclBvcztcbiAgICBzY3JvbGxiYXJPZmZzZXQgPSBtYXhTbmFwU2Nyb2xsICogc25hcCArIHBvcztcbiAgICBzY3JvbGwocG9zLCB0aW1lLCB0YXAsIGNhbGxiYWNrKTtcbiAgfTtcblxuICB0aGF0LnJlZnJlc2ggPSBmdW5jdGlvbiAobm9TY3JvbGwpIHtcbiAgICB2YXIgdGVtcFNjcm9sbDtcbiAgICBjb250U2l6ZSA9IChzLmNvbnRTaXplID09PSB1bmRlZmluZWQgPyB2ZXJ0aWNhbCA/ICRlbG0uaGVpZ2h0KCkgOiAkZWxtLndpZHRoKCkgOiBzLmNvbnRTaXplKSB8fCAwO1xuICAgIG1heFNjcm9sbCA9IChzLm1heFNjcm9sbCA9PT0gdW5kZWZpbmVkID8gMCA6IHMubWF4U2Nyb2xsKSB8fCAwO1xuICAgIG1pblNjcm9sbCA9IE1hdGgubWluKG1heFNjcm9sbCwgcy5taW5TY3JvbGwgPT09IHVuZGVmaW5lZCA/IE1hdGgubWluKDAsIHZlcnRpY2FsID8gY29udFNpemUgLSB0YXJnZXQuaGVpZ2h0KCkgOiBjb250U2l6ZSAtIHRhcmdldC53aWR0aCgpKSA6IHMubWluU2Nyb2xsKSB8fCAwO1xuICAgIHNuYXBQb2ludHMgPSBudWxsO1xuXG4gICAgaWYgKCF2ZXJ0aWNhbCAmJiBzLnJ0bCkge1xuICAgICAgdGVtcFNjcm9sbCA9IG1heFNjcm9sbDtcbiAgICAgIG1heFNjcm9sbCA9IC1taW5TY3JvbGw7XG4gICAgICBtaW5TY3JvbGwgPSAtdGVtcFNjcm9sbDtcbiAgICB9XG5cbiAgICBpZiAoaXNTdHJpbmcocy5zbmFwKSkge1xuICAgICAgc25hcFBvaW50cyA9IFtdO1xuICAgICAgdGFyZ2V0LmZpbmQocy5zbmFwKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHZlcnRpY2FsID8gdGhpcy5vZmZzZXRUb3AgOiB0aGlzLm9mZnNldExlZnQsXG4gICAgICAgICAgICBzaXplID0gdmVydGljYWwgPyB0aGlzLm9mZnNldEhlaWdodCA6IHRoaXMub2Zmc2V0V2lkdGg7XG4gICAgICAgIHNuYXBQb2ludHMucHVzaCh7XG4gICAgICAgICAgYnJlYWtwb2ludDogb2Zmc2V0ICsgc2l6ZSAvIDIsXG4gICAgICAgICAgc25hcDE6IC1vZmZzZXQsXG4gICAgICAgICAgc25hcDI6IGNvbnRTaXplIC0gb2Zmc2V0IC0gc2l6ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHNuYXAgPSBpc051bWVyaWMocy5zbmFwKSA/IHMuc25hcCA6IDE7XG4gICAgbWF4U25hcFNjcm9sbCA9IHMuc25hcCA/IHMubWF4U25hcFNjcm9sbCA6IDA7XG4gICAgZWFzaW5nID0gcy5lYXNpbmc7XG4gICAgZWxhc3RpYyA9IHMuZWxhc3RpYyA/IGlzTnVtZXJpYyhzLnNuYXApID8gc25hcCA6IGlzTnVtZXJpYyhzLmVsYXN0aWMpID8gcy5lbGFzdGljIDogMCA6IDA7IC8vICYmIHMuc25hcCA/IHNuYXAgOiAwO1xuXG4gICAgc2Nyb2xsU25hcCA9IHNuYXA7XG5cbiAgICB3aGlsZSAoc2Nyb2xsU25hcCA+IDQ0KSB7XG4gICAgICBzY3JvbGxTbmFwIC89IDI7XG4gICAgfVxuXG4gICAgc2Nyb2xsU25hcCA9IE1hdGgucm91bmQoNDQgLyBzY3JvbGxTbmFwKSAqIHNjcm9sbFNuYXA7XG5cbiAgICBpZiAoc2Nyb2xsYmFyKSB7XG4gICAgICBpc0luZmluaXRlID0gbWluU2Nyb2xsID09IC1JbmZpbml0eSB8fCBtYXhTY3JvbGwgPT0gSW5maW5pdHk7XG4gICAgICBzY3JvbGxiYXJIZWlnaHQgPSBtaW5TY3JvbGwgPCBtYXhTY3JvbGwgPyBNYXRoLm1heCgyMCwgY29udFNpemUgKiBjb250U2l6ZSAvIChtYXhTY3JvbGwgLSBtaW5TY3JvbGwgKyBjb250U2l6ZSkpIDogMDtcbiAgICAgIHNjcm9sbGJhci5zdHlsZS5oZWlnaHQgPSBzY3JvbGxiYXJIZWlnaHQgKyAncHgnO1xuICAgICAgc2Nyb2xsYmFyVHJhY2suc3R5bGUuaGVpZ2h0ID0gc2Nyb2xsYmFySGVpZ2h0ID8gJycgOiAwO1xuICAgIH1cblxuICAgIGlmIChjdXJyUG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGN1cnJQb3MgPSBzLmluaXRpYWxQb3M7XG4gICAgICBjdXJyU25hcCA9IE1hdGgucm91bmQoY3VyclBvcyAvIHNuYXApO1xuICAgIH1cblxuICAgIGlmICghbm9TY3JvbGwpIHtcbiAgICAgIHRoYXQuc2Nyb2xsKHMuc25hcCA/IHNuYXBQb2ludHMgJiYgc25hcFBvaW50c1tjdXJyU25hcF0gPyBzbmFwUG9pbnRzW2N1cnJTbmFwXVsnc25hcCcgKyBjdXJyU25hcERpcl0gOiBjdXJyU25hcCAqIHNuYXAgOiBjdXJyUG9zKTtcbiAgICB9XG4gIH07XG5cbiAgdGhhdC5fcHJvY2Vzc1NldHRpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIHZlcnRpY2FsID0gcy5heGlzID09ICdZJztcbiAgICBkaXIgPSB2ZXJ0aWNhbCA/ICd0b3AnIDogJ2xlZnQnO1xuICAgIHRhcmdldCA9IHMubW92ZUVsZW1lbnQgfHwgJGVsbS5jaGlsZHJlbigpLmVxKDApO1xuICAgIHN0eWxlID0gdGFyZ2V0WzBdLnN0eWxlO1xuICAgIHRocmVzaG9sZCA9IHZlcnRpY2FsID8gcy50aHJlc2hvbGRZIDogcy50aHJlc2hvbGRYO1xuXG4gICAgaWYgKHMuc2Nyb2xsYmFyKSB7XG4gICAgICAkc2Nyb2xsYmFyVHJhY2sgPSBzLnNjcm9sbGJhcjtcbiAgICAgICRzY3JvbGxiYXIgPSAkc2Nyb2xsYmFyVHJhY2suZmluZCgnLm1ic2Mtc2MtYmFyJyk7XG4gICAgICBzY3JvbGxiYXIgPSAkc2Nyb2xsYmFyWzBdO1xuICAgICAgc2Nyb2xsYmFyVHJhY2sgPSAkc2Nyb2xsYmFyVHJhY2tbMF07XG4gICAgfVxuICB9O1xuXG4gIHRoYXQuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhhdC5yZWZyZXNoKCk7XG4gICAgbGlzdGVuKGVsLCAnbW91c2Vkb3duJywgb25TdGFydCk7XG4gICAgbGlzdGVuKGVsLCAndG91Y2hzdGFydCcsIG9uU3RhcnQsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICBsaXN0ZW4oZWwsICd0b3VjaGVuZCcsIG9uRW5kKTtcbiAgICBsaXN0ZW4oZWwsICd0b3VjaGNhbmNlbCcsIG9uRW5kKTtcbiAgICBsaXN0ZW4oZWwsICdjbGljaycsIG9uQ2xpY2ssIHRydWUpO1xuICAgIGxpc3Rlbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIG9uTW92ZSwge1xuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcblxuICAgIGlmIChzLm1vdXNld2hlZWwpIHtcbiAgICAgIGxpc3Rlbihkb2N1bWVudCwgJ3doZWVsJywgb25TY3JvbGwsIHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgbGlzdGVuKGRvY3VtZW50LCAnbW91c2V3aGVlbCcsIG9uU2Nyb2xsLCB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoc2Nyb2xsYmFyKSB7XG4gICAgICAkc2Nyb2xsYmFyVHJhY2sub24oJ21vdXNlZG93bicsIG9uU2Nyb2xsQmFyU3RhcnQpLm9uKCdjbGljaycsIG9uU2Nyb2xsQmFyQ2xpY2spO1xuICAgIH0gLy9lbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGZ1bmN0aW9uIChldikge1xuICAgIC8vICAgIGlmIChzY3JvbGxlZCkge1xuICAgIC8vICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAvLyAgICB9XG4gICAgLy99LCB0cnVlKTtcblxuICB9O1xuICAvKipcclxuICAgKiBEZXN0cm95XHJcbiAgICovXG5cblxuICB0aGF0Ll9kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGNsZWFySW50ZXJ2YWwoc2Nyb2xsVGltZXIpO1xuICAgIHVubGlzdGVuKGVsLCAnbW91c2Vkb3duJywgb25TdGFydCk7XG4gICAgdW5saXN0ZW4oZWwsICd0b3VjaHN0YXJ0Jywgb25TdGFydCwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuICAgIHVubGlzdGVuKGVsLCAndG91Y2hlbmQnLCBvbkVuZCk7XG4gICAgdW5saXN0ZW4oZWwsICd0b3VjaGNhbmNlbCcsIG9uRW5kKTtcbiAgICB1bmxpc3RlbihlbCwgJ2NsaWNrJywgb25DbGljaywgdHJ1ZSk7XG4gICAgdW5saXN0ZW4oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCBvbk1vdmUsIHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gICAgdW5saXN0ZW4oZG9jdW1lbnQsICd3aGVlbCcsIG9uU2Nyb2xsLCB7XG4gICAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9KTtcbiAgICB1bmxpc3Rlbihkb2N1bWVudCwgJ21vdXNld2hlZWwnLCBvblNjcm9sbCwge1xuICAgICAgcGFzc2l2ZTogZmFsc2UsXG4gICAgICBjYXB0dXJlOiB0cnVlXG4gICAgfSk7XG5cbiAgICBpZiAoc2Nyb2xsYmFyKSB7XG4gICAgICAkc2Nyb2xsYmFyVHJhY2sub2ZmKCdtb3VzZWRvd24nLCBvblNjcm9sbEJhclN0YXJ0KS5vZmYoJ2NsaWNrJywgb25TY3JvbGxCYXJDbGljayk7XG4gICAgfVxuICB9OyAvLyBDb25zdHJ1Y3RvclxuXG5cbiAgcyA9IHRoYXQuc2V0dGluZ3M7XG4gIHRyaWdnZXIgPSB0aGF0LnRyaWdnZXI7XG5cbiAgaWYgKCFpbmhlcml0KSB7XG4gICAgdGhhdC5pbml0KCk7XG4gIH1cbn07XG5TY3JvbGxWaWV3QmFzZS5wcm90b3R5cGUgPSB7XG4gIF9kZWZhdWx0czoge1xuICAgIHNwZWVkVW5pdDogMC4wMDIyLFxuICAgIC8vdGltZVVuaXQ6IDAuOCxcbiAgICB0aW1lVW5pdDogMyxcbiAgICBpbml0aWFsUG9zOiAwLFxuICAgIGF4aXM6ICdZJyxcbiAgICB0aHJlc2hvbGRYOiAxMCxcbiAgICB0aHJlc2hvbGRZOiA1LFxuICAgIC8vZWFzaW5nOiAnZWFzZS1vdXQnLFxuICAgIGVhc2luZzogJ2N1YmljLWJlemllcigwLjE5MCwgMS4wMDAsIDAuMjIwLCAxLjAwMCknLFxuICAgIHN0b3BQcm9wOiB0cnVlLFxuICAgIG1vbWVudHVtOiB0cnVlLFxuICAgIG1vdXNld2hlZWw6IHRydWUsXG4gICAgZWxhc3RpYzogdHJ1ZVxuICB9XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbnZhciBwcmVzZXRzID0ge30sXG4gICAgY3NzID0gaXNCcm93c2VyID8gd2luZG93LkNTUyA6IG51bGwsXG4gICAgaGFzM2QgPSBjc3MgJiYgY3NzLnN1cHBvcnRzICYmIGNzcy5zdXBwb3J0cyhcIih0cmFuc2Zvcm0tc3R5bGU6IHByZXNlcnZlLTNkKVwiKTtcblxuZnVuY3Rpb24gc2FuaXRpemUoc3RyKSB7XG4gIHJldHVybiAoc3RyICsgJycpLnJlcGxhY2UoJ1wiJywgJ19fXycpO1xufVxudmFyIFNjcm9sbGVyID0gZnVuY3Rpb24gU2Nyb2xsZXIoZWwsIHNldHRpbmdzLCBpbmhlcml0KSB7XG4gIHZhciAkbWFya3VwLFxuICAgICAgYmF0Y2hTaXplM2QsXG4gICAgICBiYXRjaFNpemUgPSA0MCxcbiAgICAgIGFuaW1UaW1lID0gMTAwMCxcbiAgICAgIHNjcm9sbDNkQW5nbGUsXG4gICAgICBzY3JvbGwzZCxcbiAgICAgIHNlbGVjdGVkQ2xhc3MsXG4gICAgICBzaG93U2Nyb2xsQXJyb3dzLFxuICAgICAgc3RlcHBlcixcbiAgICAgIHRlbXBXaGVlbEFycmF5LFxuICAgICAgaXRlbUhlaWdodCxcbiAgICAgIGl0ZW1IZWlnaHQzZCxcbiAgICAgIGlzUG9pbnRlcixcbiAgICAgIGlzVmFsaWRhdGluZyxcbiAgICAgIHMsXG4gICAgICB0cmlnZ2VyLFxuICAgICAgbGluZXMsXG4gICAgICB3aGVlbHMsXG4gICAgICB3aGVlbHNNYXAsXG4gICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICRlbG0gPSAkJDEoZWwpOyAvLyBFdmVudCBoYW5kbGVyc1xuXG4gIGZ1bmN0aW9uIG9uS2V5RG93bihldikge1xuICAgIHZhciBpID0gKyQkMSh0aGlzKS5hdHRyKCdkYXRhLWluZGV4JyksXG4gICAgICAgIGhhbmRsZSxcbiAgICAgICAgZGlyZWN0aW9uO1xuXG4gICAgaWYgKGV2LmtleUNvZGUgPT0gMzgpIHtcbiAgICAgIC8vIFVwXG4gICAgICBoYW5kbGUgPSB0cnVlO1xuICAgICAgZGlyZWN0aW9uID0gLTE7XG4gICAgfSBlbHNlIGlmIChldi5rZXlDb2RlID09IDQwKSB7XG4gICAgICAvLyBEb3duXG4gICAgICBoYW5kbGUgPSB0cnVlO1xuICAgICAgZGlyZWN0aW9uID0gMTtcbiAgICB9IGVsc2UgaWYgKGV2LmtleUNvZGUgPT0gMzIpIHtcbiAgICAgIC8vIFNwYWNlXG4gICAgICBoYW5kbGUgPSB0cnVlO1xuICAgICAgb25JdGVtVGFwKGksICQkMShldi50YXJnZXQpKTtcbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlKSB7XG4gICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgc3RlcHBlci5zdGFydChpLCBkaXJlY3Rpb24sIGV2KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbktleVVwKCkge1xuICAgIHN0ZXBwZXIuc3RvcCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25JdGVtVGFwKGksICRpdGVtKSB7XG4gICAgdmFyIHdoZWVsID0gd2hlZWxzW2ldLFxuICAgICAgICBpZHggPSArJGl0ZW0uYXR0cignZGF0YS1pbmRleCcpLFxuICAgICAgICB2YWwgPSBnZXRWYWx1ZSh3aGVlbCwgaWR4KSxcbiAgICAgICAgc2VsZWN0ZWQgPSB0aGF0Ll90ZW1wU2VsZWN0ZWRbaV0sXG4gICAgICAgIG1heFNlbGVjdCA9IGlzTnVtZXJpYyh3aGVlbC5tdWx0aXBsZSkgPyB3aGVlbC5tdWx0aXBsZSA6IEluZmluaXR5O1xuXG4gICAgaWYgKHRyaWdnZXIoJ29uSXRlbVRhcCcsIHtcbiAgICAgIHRhcmdldDogJGl0ZW1bMF0sXG4gICAgICBpbmRleDogaSxcbiAgICAgIHZhbHVlOiB2YWwsXG4gICAgICBzZWxlY3RlZDogJGl0ZW0uaGFzQ2xhc3MoJ21ic2Mtc2MtaXRtLXNlbCcpXG4gICAgfSkgIT09IGZhbHNlICYmICF0aGF0Ll9wcmV2SXRlbVRhcCkge1xuICAgICAgLy8gU2VsZWN0IGl0ZW0gb24gdGFwXG4gICAgICBpZiAod2hlZWwubXVsdGlwbGUgJiYgIXdoZWVsLl9kaXNhYmxlZFt2YWxdKSB7XG4gICAgICAgIGlmIChzZWxlY3RlZFt2YWxdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAkaXRlbS5yZW1vdmVDbGFzcyhzZWxlY3RlZENsYXNzKS5yZW1vdmVBdHRyKCdhcmlhLXNlbGVjdGVkJyk7XG4gICAgICAgICAgZGVsZXRlIHNlbGVjdGVkW3ZhbF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG1heFNlbGVjdCA9PSAxKSB7XG4gICAgICAgICAgICB0aGF0Ll90ZW1wU2VsZWN0ZWRbaV0gPSBzZWxlY3RlZCA9IHt9O1xuXG4gICAgICAgICAgICB3aGVlbC5fJG1hcmt1cC5maW5kKCcubWJzYy1zYy1pdG0tc2VsJykucmVtb3ZlQ2xhc3Moc2VsZWN0ZWRDbGFzcykucmVtb3ZlQXR0cignYXJpYS1zZWxlY3RlZCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvYmplY3RUb0FycmF5KHNlbGVjdGVkKS5sZW5ndGggPCBtYXhTZWxlY3QpIHtcbiAgICAgICAgICAgICRpdGVtLmFkZENsYXNzKHNlbGVjdGVkQ2xhc3MpLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCAndHJ1ZScpO1xuICAgICAgICAgICAgc2VsZWN0ZWRbdmFsXSA9IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2V0V2hlZWxWYWx1ZSh3aGVlbCwgaSwgaWR4LCBhbmltVGltZSwgd2hlZWwuX2luZGV4IDwgaWR4ID8gMSA6IDIsIHRydWUsIHdoZWVsLm11bHRpcGxlKTtcblxuICAgICAgaWYgKHRoYXQubGl2ZSAmJiAoIXdoZWVsLm11bHRpcGxlIHx8IHdoZWVsLm11bHRpcGxlID09PSAxICYmIHMudGFwU2VsZWN0KSAmJiAocy5zZXRPblRhcCA9PT0gdHJ1ZSB8fCBzLnNldE9uVGFwW2ldKSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGF0LnNlbGVjdCgpO1xuICAgICAgICB9LCBzLnRhcFNlbGVjdCA/IDAgOiAyMDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoYXQuX3ByZXZJdGVtVGFwID0gZmFsc2U7XG4gIH0gLy8gUHJpdmF0ZSBmdW5jdGlvbnNcblxuXG4gIGZ1bmN0aW9uIHNob3VsZFNldChpLCBub3Njcm9sbCkge1xuICAgIHZhciB3aGVlbCA9IHdoZWVsc1tpXTtcbiAgICByZXR1cm4gd2hlZWwgJiYgKCF3aGVlbC5tdWx0aXBsZSB8fCB3aGVlbC5tdWx0aXBsZSAhPT0gMSAmJiBub3Njcm9sbCAmJiAocy5zZXRPblRhcCA9PT0gdHJ1ZSB8fCBzLnNldE9uVGFwW2ldKSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNaW4od2hlZWwpIHtcbiAgICByZXR1cm4gLSh3aGVlbC5tYXggLSB3aGVlbC5fb2Zmc2V0IC0gKHdoZWVsLm11bHRpcGxlICYmICFzY3JvbGwzZCA/IE1hdGguZmxvb3Iocy5yb3dzIC8gMikgOiAwKSkgKiBpdGVtSGVpZ2h0O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWF4KHdoZWVsKSB7XG4gICAgcmV0dXJuIC0od2hlZWwubWluIC0gd2hlZWwuX29mZnNldCArICh3aGVlbC5tdWx0aXBsZSAmJiAhc2Nyb2xsM2QgPyBNYXRoLmZsb29yKHMucm93cyAvIDIpIDogMCkpICogaXRlbUhlaWdodDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEluZGV4KHdoZWVsLCB2YWwpIHtcbiAgICByZXR1cm4gKHdoZWVsLl9hcnJheSA/IHdoZWVsLl9tYXBbdmFsXSA6ICt3aGVlbC5nZXRJbmRleCh2YWwsIHRoYXQpKSB8fCAwO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SXRlbSh3aGVlbCwgaSkge1xuICAgIHZhciBkYXRhID0gd2hlZWwuZGF0YTtcblxuICAgIGlmIChpID49IHdoZWVsLm1pbiAmJiBpIDw9IHdoZWVsLm1heCkge1xuICAgICAgcmV0dXJuIHdoZWVsLl9hcnJheSA/IHdoZWVsLmNpcmN1bGFyID8gJCQxKGRhdGEpLmdldChpICUgd2hlZWwuX2xlbmd0aCkgOiBkYXRhW2ldIDogJCQxLmlzRnVuY3Rpb24oZGF0YSkgPyBkYXRhKGksIHRoYXQpIDogJyc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SXRlbVZhbHVlKGl0ZW0pIHtcbiAgICByZXR1cm4gJCQxLmlzUGxhaW5PYmplY3QoaXRlbSkgPyBpdGVtLnZhbHVlICE9PSB1bmRlZmluZWQgPyBpdGVtLnZhbHVlIDogaXRlbS5kaXNwbGF5IDogaXRlbTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEl0ZW1UZXh0KGl0ZW0pIHtcbiAgICB2YXIgdGV4dCA9ICQkMS5pc1BsYWluT2JqZWN0KGl0ZW0pID8gaXRlbS5kaXNwbGF5IDogaXRlbTtcbiAgICByZXR1cm4gdGV4dCA9PT0gdW5kZWZpbmVkID8gJycgOiB0ZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VmFsdWUod2hlZWwsIGkpIHtcbiAgICByZXR1cm4gZ2V0SXRlbVZhbHVlKGdldEl0ZW0od2hlZWwsIGkpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0ZXAoaW5kZXgsIGRpcmVjdGlvbiwgZXYpIHtcbiAgICB2YXIgd2hlZWwgPSB3aGVlbHNbaW5kZXhdO1xuICAgIHNldFdoZWVsVmFsdWUod2hlZWwsIGluZGV4LCB3aGVlbC5faW5kZXggKyBkaXJlY3Rpb24sIHMuZGVsYXkgKyAxMDAsIGRpcmVjdGlvbiA9PSAxID8gMSA6IDIsIGZhbHNlLCBmYWxzZSwgZXYudHlwZSA9PSAna2V5ZG93bicpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNSZWFkT25seShpKSB7XG4gICAgcmV0dXJuICQkMS5pc0FycmF5KHMucmVhZG9ubHkpID8gcy5yZWFkb25seVtpXSA6IHMucmVhZG9ubHk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0V2hlZWwod3csIGwsIGtlZXApIHtcbiAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSB3aGVlbCwgaW4gY2FzZSBpZiBzYW1lIG9wdGlvbiBvYmplY3QgaXMgdXNlZCBmb3IgbXVsdGlwbGUgc2Nyb2xsZXIgaW5zdGFuY2VzXG4gICAgdmFyIHcgPSBleHRlbmQkMSh3aGVlbHNbbF0gfHwge30sIHd3KTtcbiAgICB2YXIgaW5kZXggPSB3Ll9pbmRleCAtIHcuX2JhdGNoO1xuICAgIHcuZGF0YSA9IHcuZGF0YSB8fCBbXTtcbiAgICB3LmtleSA9IHcua2V5ICE9PSB1bmRlZmluZWQgPyB3LmtleSA6IGw7XG4gICAgdy5sYWJlbCA9IHcubGFiZWwgIT09IHVuZGVmaW5lZCA/IHcubGFiZWwgOiBsO1xuICAgIHcuX21hcCA9IHt9O1xuICAgIHcuX2FycmF5ID0gJCQxLmlzQXJyYXkody5kYXRhKTsgLy8gTWFwIGtleXMgdG8gaW5kZXhcblxuICAgIGlmICh3Ll9hcnJheSkge1xuICAgICAgdy5fbGVuZ3RoID0gdy5kYXRhLmxlbmd0aDtcbiAgICAgICQkMS5lYWNoKHcuZGF0YSwgZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgICAgdy5fbWFwW2dldEl0ZW1WYWx1ZSh2KV0gPSBpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdy5jaXJjdWxhciA9IHMuY2lyY3VsYXIgPT09IHVuZGVmaW5lZCA/IHcuY2lyY3VsYXIgPT09IHVuZGVmaW5lZCA/IHcuX2FycmF5ICYmIHcuX2xlbmd0aCA+IHMucm93cyA6IHcuY2lyY3VsYXIgOiAkJDEuaXNBcnJheShzLmNpcmN1bGFyKSA/IHMuY2lyY3VsYXJbbF0gOiBzLmNpcmN1bGFyO1xuICAgIHcubWluID0gdy5fYXJyYXkgPyB3LmNpcmN1bGFyID8gLUluZmluaXR5IDogMCA6IHcubWluID09PSB1bmRlZmluZWQgPyAtSW5maW5pdHkgOiB3Lm1pbjtcbiAgICB3Lm1heCA9IHcuX2FycmF5ID8gdy5jaXJjdWxhciA/IEluZmluaXR5IDogdy5fbGVuZ3RoIC0gMSA6IHcubWF4ID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IHcubWF4O1xuICAgIHcuX25yID0gbDtcbiAgICB3Ll9pbmRleCA9IGdldEluZGV4KHcsIHRlbXBXaGVlbEFycmF5W2xdKTtcbiAgICB3Ll9kaXNhYmxlZCA9IHt9O1xuICAgIHcuX2JhdGNoID0gMDtcbiAgICB3Ll9jdXJyZW50ID0gdy5faW5kZXg7XG4gICAgdy5fZmlyc3QgPSB3Ll9pbmRleCAtIGJhdGNoU2l6ZTsgLy9NYXRoLm1heCh3Lm1pbiwgdy5fY3VycmVudCAtIGJhdGNoU2l6ZSk7XG5cbiAgICB3Ll9sYXN0ID0gdy5faW5kZXggKyBiYXRjaFNpemU7IC8vTWF0aC5taW4ody5tYXgsIHcuX2ZpcnN0ICsgMiAqIGJhdGNoU2l6ZSk7XG5cbiAgICB3Ll9vZmZzZXQgPSB3Ll9maXJzdDtcblxuICAgIGlmIChrZWVwKSB7XG4gICAgICB3Ll9vZmZzZXQgLT0gdy5fbWFyZ2luIC8gaXRlbUhlaWdodCArICh3Ll9pbmRleCAtIGluZGV4KTtcbiAgICAgIHcuX21hcmdpbiArPSAody5faW5kZXggLSBpbmRleCkgKiBpdGVtSGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB3Ll9tYXJnaW4gPSAwOyAvL3cuX2ZpcnN0ICogaXRlbUhlaWdodDtcbiAgICB9XG5cbiAgICB3Ll9yZWZyZXNoID0gZnVuY3Rpb24gKG5vU2Nyb2xsKSB7XG4gICAgICBleHRlbmQkMSh3Ll9zY3JvbGxlci5zZXR0aW5ncywge1xuICAgICAgICBtaW5TY3JvbGw6IGdldE1pbih3KSxcbiAgICAgICAgbWF4U2Nyb2xsOiBnZXRNYXgodylcbiAgICAgIH0pO1xuXG4gICAgICB3Ll9zY3JvbGxlci5yZWZyZXNoKG5vU2Nyb2xsKTtcbiAgICB9O1xuXG4gICAgd2hlZWxzTWFwW3cua2V5XSA9IHc7XG4gICAgcmV0dXJuIHc7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUl0ZW1zKHdoZWVsLCBpbmRleCwgc3RhcnQsIGVuZCwgaXMzZCkge1xuICAgIHZhciBpLFxuICAgICAgICBjc3MsXG4gICAgICAgIGl0ZW0sXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0ZXh0LFxuICAgICAgICBsYmwsXG4gICAgICAgIGludmFsaWQsXG4gICAgICAgIHNlbGVjdGVkLFxuICAgICAgICBodG1sID0gJycsXG4gICAgICAgIGNoZWNrZWQgPSB0aGF0Ll90ZW1wU2VsZWN0ZWRbaW5kZXhdLFxuICAgICAgICBkaXNhYmxlZCA9IHdoZWVsLl9kaXNhYmxlZCB8fCB7fTtcblxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICBpdGVtID0gZ2V0SXRlbSh3aGVlbCwgaSk7XG4gICAgICB0ZXh0ID0gZ2V0SXRlbVRleHQoaXRlbSk7XG4gICAgICB2YWx1ZSA9IGdldEl0ZW1WYWx1ZShpdGVtKTtcbiAgICAgIGNzcyA9IGl0ZW0gJiYgaXRlbS5jc3NDbGFzcyAhPT0gdW5kZWZpbmVkID8gaXRlbS5jc3NDbGFzcyA6ICcnO1xuICAgICAgbGJsID0gaXRlbSAmJiBpdGVtLmxhYmVsICE9PSB1bmRlZmluZWQgPyBpdGVtLmxhYmVsIDogJyc7XG4gICAgICBpbnZhbGlkID0gaXRlbSAmJiBpdGVtLmludmFsaWQ7XG4gICAgICBzZWxlY3RlZCA9IHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgPT0gdGVtcFdoZWVsQXJyYXlbaW5kZXhdICYmICF3aGVlbC5tdWx0aXBsZTsgLy8gVE9ETzogZG9uJ3QgZ2VuZXJhdGUgaXRlbXMgd2l0aCBubyB2YWx1ZSAodXNlIG1hcmdpbiBvciBwbGFjZWhvbGRlciBpbnN0ZWFkKVxuXG4gICAgICBodG1sICs9ICc8ZGl2IHJvbGU9XCJvcHRpb25cIiB0YWJpbmRleD1cIi0xXCIgYXJpYS1zZWxlY3RlZD1cIicgKyAoY2hlY2tlZFt2YWx1ZV0gPyB0cnVlIDogZmFsc2UpICsgJ1wiIGNsYXNzPVwibWJzYy1zYy1pdG0gJyArIChpczNkID8gJ21ic2Mtc2MtaXRtLTNkICcgOiAnJykgKyBjc3MgKyAnICcgKyAoc2VsZWN0ZWQgPyAnbWJzYy1zYy1pdG0tc2VsICcgOiAnJykgKyAoY2hlY2tlZFt2YWx1ZV0gPyBzZWxlY3RlZENsYXNzIDogJycpICsgKHZhbHVlID09PSB1bmRlZmluZWQgPyAnIG1ic2Mtc2MtaXRtLXBoJyA6ICcgbWJzYy1idG4tZScpICsgKGludmFsaWQgPyAnIG1ic2Mtc2MtaXRtLWludi1oIG1ic2MtZGlzYWJsZWQnIDogJycpICsgKGRpc2FibGVkW3ZhbHVlXSA/ICcgbWJzYy1zYy1pdG0taW52IG1ic2MtZGlzYWJsZWQnIDogJycpICsgJ1wiIGRhdGEtaW5kZXg9XCInICsgaSArICdcIiBkYXRhLXZhbD1cIicgKyBzYW5pdGl6ZSh2YWx1ZSkgKyAnXCInICsgKGxibCA/ICcgYXJpYS1sYWJlbD1cIicgKyBsYmwgKyAnXCInIDogJycpICsgKHNlbGVjdGVkID8gJyBhcmlhLXNlbGVjdGVkPVwidHJ1ZVwiJyA6ICcnKSArICcgc3R5bGU9XCJoZWlnaHQ6JyArIGl0ZW1IZWlnaHQgKyAncHg7bGluZS1oZWlnaHQ6JyArIGl0ZW1IZWlnaHQgKyAncHg7JyArIChpczNkID8gY3NzUHJlZml4ICsgJ3RyYW5zZm9ybTpyb3RhdGVYKCcgKyAod2hlZWwuX29mZnNldCAtIGkpICogc2Nyb2xsM2RBbmdsZSAlIDM2MCArICdkZWcpIHRyYW5zbGF0ZVooJyArIGl0ZW1IZWlnaHQgKiBzLnJvd3MgLyAyICsgJ3B4KTsnIDogJycpICsgJ1wiPicgKyAobGluZXMgPiAxID8gJzxkaXYgY2xhc3M9XCJtYnNjLXNjLWl0bS1tbFwiIHN0eWxlPVwibGluZS1oZWlnaHQ6JyArIE1hdGgucm91bmQoaXRlbUhlaWdodCAvIGxpbmVzKSArICdweDtmb250LXNpemU6JyArIE1hdGgucm91bmQoaXRlbUhlaWdodCAvIGxpbmVzICogMC44KSArICdweDtcIj4nIDogJycpICsgdGV4dCArIChsaW5lcyA+IDEgPyAnPC9kaXY+JyA6ICcnKSArICc8L2Rpdj4nO1xuICAgIH1cblxuICAgIHJldHVybiBodG1sO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5maW5pdGUod2hlZWwsIGksIHBvcykge1xuICAgIHZhciBpbmRleCA9IE1hdGgucm91bmQoLXBvcyAvIGl0ZW1IZWlnaHQpICsgd2hlZWwuX29mZnNldCxcbiAgICAgICAgZGlmZiA9IGluZGV4IC0gd2hlZWwuX2N1cnJlbnQsXG4gICAgICAgIGZpcnN0ID0gd2hlZWwuX2ZpcnN0LFxuICAgICAgICBsYXN0ID0gd2hlZWwuX2xhc3QsXG4gICAgICAgIGZpcnN0M2QgPSBmaXJzdCArIGJhdGNoU2l6ZSAtIGJhdGNoU2l6ZTNkICsgMSxcbiAgICAgICAgbGFzdDNkID0gbGFzdCAtIGJhdGNoU2l6ZSArIGJhdGNoU2l6ZTNkO1xuXG4gICAgaWYgKGRpZmYpIHtcbiAgICAgIHdoZWVsLl9maXJzdCArPSBkaWZmO1xuICAgICAgd2hlZWwuX2xhc3QgKz0gZGlmZjtcbiAgICAgIHdoZWVsLl9jdXJyZW50ID0gaW5kZXg7IC8vIEdlbmVyYXRlIGl0ZW1zXG4gICAgICAvL3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXG4gICAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgICAgd2hlZWwuXyRzY3JvbGxlci5hcHBlbmQoZ2VuZXJhdGVJdGVtcyh3aGVlbCwgaSwgTWF0aC5tYXgobGFzdCArIDEsIGZpcnN0ICsgZGlmZiksIGxhc3QgKyBkaWZmKSk7XG5cbiAgICAgICAgJCQxKCcubWJzYy1zYy1pdG0nLCB3aGVlbC5fJHNjcm9sbGVyKS5zbGljZSgwLCBNYXRoLm1pbihkaWZmLCBsYXN0IC0gZmlyc3QgKyAxKSkucmVtb3ZlKCk7IC8vIDNEXG5cbiAgICAgICAgaWYgKHNjcm9sbDNkKSB7XG4gICAgICAgICAgd2hlZWwuXyQzZC5hcHBlbmQoZ2VuZXJhdGVJdGVtcyh3aGVlbCwgaSwgTWF0aC5tYXgobGFzdDNkICsgMSwgZmlyc3QzZCArIGRpZmYpLCBsYXN0M2QgKyBkaWZmLCB0cnVlKSk7XG5cbiAgICAgICAgICAkJDEoJy5tYnNjLXNjLWl0bScsIHdoZWVsLl8kM2QpLnNsaWNlKDAsIE1hdGgubWluKGRpZmYsIGxhc3QzZCAtIGZpcnN0M2QgKyAxKSkuYXR0cignY2xhc3MnLCAnbWJzYy1zYy1pdG0tZGVsJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGlmZiA8IDApIHtcbiAgICAgICAgd2hlZWwuXyRzY3JvbGxlci5wcmVwZW5kKGdlbmVyYXRlSXRlbXMod2hlZWwsIGksIGZpcnN0ICsgZGlmZiwgTWF0aC5taW4oZmlyc3QgLSAxLCBsYXN0ICsgZGlmZikpKTtcblxuICAgICAgICAkJDEoJy5tYnNjLXNjLWl0bScsIHdoZWVsLl8kc2Nyb2xsZXIpLnNsaWNlKE1hdGgubWF4KGRpZmYsIGZpcnN0IC0gbGFzdCAtIDEpKS5yZW1vdmUoKTsgLy8gM0RcblxuICAgICAgICBpZiAoc2Nyb2xsM2QpIHtcbiAgICAgICAgICB3aGVlbC5fJDNkLnByZXBlbmQoZ2VuZXJhdGVJdGVtcyh3aGVlbCwgaSwgZmlyc3QzZCArIGRpZmYsIE1hdGgubWluKGZpcnN0M2QgLSAxLCBsYXN0M2QgKyBkaWZmKSwgdHJ1ZSkpO1xuXG4gICAgICAgICAgJCQxKCcubWJzYy1zYy1pdG0nLCB3aGVlbC5fJDNkKS5zbGljZShNYXRoLm1heChkaWZmLCBmaXJzdDNkIC0gbGFzdDNkIC0gMSkpLmF0dHIoJ2NsYXNzJywgJ21ic2Mtc2MtaXRtLWRlbCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdoZWVsLl9tYXJnaW4gKz0gZGlmZiAqIGl0ZW1IZWlnaHQ7XG5cbiAgICAgIHdoZWVsLl8kc2Nyb2xsZXIuY3NzKCdtYXJnaW4tdG9wJywgd2hlZWwuX21hcmdpbiArICdweCcpOyAvL30sIDEwKTtcblxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFZhbGlkKGluZGV4LCB2LCBkaXIsIGRpcykge1xuICAgIHZhciBjb3VudGVyLFxuICAgICAgICB3aGVlbCA9IHdoZWVsc1tpbmRleF0sXG4gICAgICAgIGRpc2FibGVkID0gZGlzIHx8IHdoZWVsLl9kaXNhYmxlZCxcbiAgICAgICAgaWR4ID0gZ2V0SW5kZXgod2hlZWwsIHYpLFxuICAgICAgICB2YWwgPSBnZXRWYWx1ZSh3aGVlbCwgaWR4KSxcbiAgICAgICAgdjEgPSB2YWwsXG4gICAgICAgIHYyID0gdmFsLFxuICAgICAgICBkaXN0MSA9IDAsXG4gICAgICAgIGRpc3QyID0gMDsgLy8gVE9ETzogd2hhdCBpZiBhbGwgaXRlbXMgYXJlIGludmFsaWRcblxuICAgIGlmIChkaXNhYmxlZFt2YWxdID09PSB0cnVlKSB7XG4gICAgICBjb3VudGVyID0gMDtcblxuICAgICAgd2hpbGUgKGlkeCAtIGRpc3QxID49IHdoZWVsLm1pbiAmJiBkaXNhYmxlZFt2MV0gJiYgY291bnRlciA8IDEwMCkge1xuICAgICAgICBjb3VudGVyKys7XG4gICAgICAgIGRpc3QxKys7XG4gICAgICAgIHYxID0gZ2V0VmFsdWUod2hlZWwsIGlkeCAtIGRpc3QxKTtcbiAgICAgIH1cblxuICAgICAgY291bnRlciA9IDA7XG5cbiAgICAgIHdoaWxlIChpZHggKyBkaXN0MiA8IHdoZWVsLm1heCAmJiBkaXNhYmxlZFt2Ml0gJiYgY291bnRlciA8IDEwMCkge1xuICAgICAgICBjb3VudGVyKys7XG4gICAgICAgIGRpc3QyKys7XG4gICAgICAgIHYyID0gZ2V0VmFsdWUod2hlZWwsIGlkeCArIGRpc3QyKTtcbiAgICAgIH0gLy8gSWYgd2UgaGF2ZSBkaXJlY3Rpb24gKCsvLSBvciBtb3VzZSB3aGVlbCksIHRoZSBkaXN0YW5jZSBkb2VzIG5vdCBjb3VudFxuXG5cbiAgICAgIGlmICgoZGlzdDIgPCBkaXN0MSAmJiBkaXN0MiAmJiBkaXIgIT09IDIgfHwgIWRpc3QxIHx8IGlkeCAtIGRpc3QxIDwgMCB8fCBkaXIgPT0gMSkgJiYgIWRpc2FibGVkW3YyXSkge1xuICAgICAgICB2YWwgPSB2MjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IHYxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBzY3JvbGxUb1Bvcyh0aW1lLCBpbmRleCwgZGlyLCBtYW51YWwsIHRhcCwgbm9zY3JvbGwsIHNob3VsZEZvY3VzKSB7XG4gICAgdmFyIGRpZmYsXG4gICAgICAgIGlkeCxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICByZXQsXG4gICAgICAgIGlzVmlzaWJsZSA9IHRoYXQuX2lzVmlzaWJsZTtcbiAgICBpc1ZhbGlkYXRpbmcgPSB0cnVlO1xuICAgIHJldCA9IHMudmFsaWRhdGUuY2FsbChlbCwge1xuICAgICAgdmFsdWVzOiB0ZW1wV2hlZWxBcnJheS5zbGljZSgwKSxcbiAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgIGRpcmVjdGlvbjogZGlyXG4gICAgfSwgdGhhdCkgfHwge307XG4gICAgaXNWYWxpZGF0aW5nID0gZmFsc2U7XG5cbiAgICBpZiAocmV0LnZhbGlkKSB7XG4gICAgICB0aGF0Ll90ZW1wV2hlZWxBcnJheSA9IHRlbXBXaGVlbEFycmF5ID0gcmV0LnZhbGlkLnNsaWNlKDApO1xuICAgIH1cblxuICAgIGlmICghbm9zY3JvbGwpIHtcbiAgICAgICQkMS5lYWNoKHdoZWVscywgZnVuY3Rpb24gKGksIHdoZWVsKSB7XG4gICAgICAgIGlmIChpc1Zpc2libGUpIHtcbiAgICAgICAgICAvLyBFbmFibGUgYWxsIGl0ZW1zXG4gICAgICAgICAgd2hlZWwuXyRtYXJrdXAuZmluZCgnLm1ic2Mtc2MtaXRtLWludicpLnJlbW92ZUNsYXNzKCdtYnNjLXNjLWl0bS1pbnYgbWJzYy1kaXNhYmxlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hlZWwuX2Rpc2FibGVkID0ge307IC8vIERpc2FibGUgaW52YWxpZCBpdGVtc1xuXG4gICAgICAgIGlmIChyZXQuZGlzYWJsZWQgJiYgcmV0LmRpc2FibGVkW2ldKSB7XG4gICAgICAgICAgJCQxLmVhY2gocmV0LmRpc2FibGVkW2ldLCBmdW5jdGlvbiAoaiwgdikge1xuICAgICAgICAgICAgd2hlZWwuX2Rpc2FibGVkW3ZdID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKGlzVmlzaWJsZSkge1xuICAgICAgICAgICAgICB3aGVlbC5fJG1hcmt1cC5maW5kKCcubWJzYy1zYy1pdG1bZGF0YS12YWw9XCInICsgc2FuaXRpemUodikgKyAnXCJdJykuYWRkQ2xhc3MoJ21ic2Mtc2MtaXRtLWludiBtYnNjLWRpc2FibGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gLy8gR2V0IGNsb3Nlc3QgdmFsaWQgdmFsdWVcblxuXG4gICAgICAgIHRlbXBXaGVlbEFycmF5W2ldID0gd2hlZWwubXVsdGlwbGUgPyB0ZW1wV2hlZWxBcnJheVtpXSA6IGdldFZhbGlkKGksIHRlbXBXaGVlbEFycmF5W2ldLCBkaXIpO1xuXG4gICAgICAgIGlmIChpc1Zpc2libGUpIHtcbiAgICAgICAgICBpZiAoIXdoZWVsLm11bHRpcGxlIHx8IGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdoZWVsLl8kbWFya3VwLmZpbmQoJy5tYnNjLXNjLWl0bS1zZWwnKS5yZW1vdmVDbGFzcyhzZWxlY3RlZENsYXNzKS5yZW1vdmVBdHRyKCdhcmlhLXNlbGVjdGVkJyk7XG4gICAgICAgICAgfSAvLyBHZXQgaW5kZXggb2YgdmFsaWQgdmFsdWVcblxuXG4gICAgICAgICAgaWR4ID0gZ2V0SW5kZXgod2hlZWwsIHRlbXBXaGVlbEFycmF5W2ldKTtcbiAgICAgICAgICBkaWZmID0gaWR4IC0gd2hlZWwuX2luZGV4ICsgd2hlZWwuX2JhdGNoO1xuXG4gICAgICAgICAgaWYgKE1hdGguYWJzKGRpZmYpID4gMiAqIGJhdGNoU2l6ZSArIDEpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGRpZmYgKyAoMiAqIGJhdGNoU2l6ZSArIDEpICogKGRpZmYgPiAwID8gLTEgOiAxKTtcbiAgICAgICAgICAgIHdoZWVsLl9vZmZzZXQgKz0gb2Zmc2V0O1xuICAgICAgICAgICAgd2hlZWwuX21hcmdpbiAtPSBvZmZzZXQgKiBpdGVtSGVpZ2h0O1xuXG4gICAgICAgICAgICB3aGVlbC5fcmVmcmVzaCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdoZWVsLl9pbmRleCA9IGlkeCArIHdoZWVsLl9iYXRjaDtcblxuICAgICAgICAgIGlmICh3aGVlbC5tdWx0aXBsZSkge1xuICAgICAgICAgICAgLy8gQWRkIHNlbGVjdGVkIHN0eWxpbmcgdG8gc2VsZWN0ZWQgZWxlbWVudHMgaW4gY2FzZSBvZiBtdWx0aXNlbGVjdFxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgdiBpbiB0aGF0Ll90ZW1wU2VsZWN0ZWRbaV0pIHtcbiAgICAgICAgICAgICAgICB3aGVlbC5fJG1hcmt1cC5maW5kKCcubWJzYy1zYy1pdG1bZGF0YS12YWw9XCInICsgc2FuaXRpemUodikgKyAnXCJdJykuYWRkQ2xhc3Moc2VsZWN0ZWRDbGFzcykuYXR0cignYXJpYS1zZWxlY3RlZCcsICd0cnVlJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTWFyayBlbGVtZW50IGFzIGFyaWEgc2VsZWN0ZWRcbiAgICAgICAgICAgIHdoZWVsLl8kbWFya3VwLmZpbmQoJy5tYnNjLXNjLWl0bVtkYXRhLXZhbD1cIicgKyBzYW5pdGl6ZSh0ZW1wV2hlZWxBcnJheVtpXSkgKyAnXCJdJykuYWRkQ2xhc3MoJ21ic2Mtc2MtaXRtLXNlbCcpLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCAndHJ1ZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh3aGVlbC5fJGFjdGl2ZSkge1xuICAgICAgICAgICAgd2hlZWwuXyRhY3RpdmUuYXR0cigndGFiaW5kZXgnLCAtMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd2hlZWwuXyRhY3RpdmUgPSB3aGVlbC5fJG1hcmt1cC5maW5kKCcubWJzYy1zYy1pdG1bZGF0YS1pbmRleD1cIicgKyB3aGVlbC5faW5kZXggKyAnXCJdJykuZXEoc2Nyb2xsM2QgJiYgd2hlZWwubXVsdGlwbGUgPyAxIDogMCkuYXR0cigndGFiaW5kZXgnLCAwKTtcblxuICAgICAgICAgIGlmIChzaG91bGRGb2N1cyAmJiBpbmRleCA9PT0gaSAmJiB3aGVlbC5fJGFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHdoZWVsLl8kYWN0aXZlWzBdLmZvY3VzKCk7XG5cbiAgICAgICAgICAgIHdoZWVsLl8kc2Nyb2xsZXIucGFyZW50KCkuc2Nyb2xsVG9wKDApO1xuICAgICAgICAgIH0gLy8gU2Nyb2xsIHRvIHZhbGlkIHZhbHVlXG5cblxuICAgICAgICAgIHdoZWVsLl9zY3JvbGxlci5zY3JvbGwoLShpZHggLSB3aGVlbC5fb2Zmc2V0ICsgd2hlZWwuX2JhdGNoKSAqIGl0ZW1IZWlnaHQsIGluZGV4ID09PSBpIHx8IGluZGV4ID09PSB1bmRlZmluZWQgPyB0aW1lIDogYW5pbVRpbWUsIHRhcCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRyaWdnZXIoJ29uVmFsaWRhdGVkJywge1xuICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgdGltZTogdGltZVxuICAgIH0pOyAvLyBHZXQgZm9ybWF0dGVkIHZhbHVlXG5cbiAgICB0aGF0Ll90ZW1wVmFsdWUgPSBzLmZvcm1hdFZhbHVlLmNhbGwoZWwsIHRlbXBXaGVlbEFycmF5LCB0aGF0KTtcblxuICAgIGlmIChpc1Zpc2libGUpIHtcbiAgICAgIHRoYXQuX3VwZGF0ZUhlYWRlcigpO1xuICAgIH0gLy8gSWYgaW4gbGl2ZSBtb2RlLCBzZXQgYW5kIGZpbGwgdmFsdWUgb24gZXZlcnkgbW92ZVxuXG5cbiAgICBpZiAodGhhdC5saXZlICYmIHNob3VsZFNldChpbmRleCwgbm9zY3JvbGwpKSB7XG4gICAgICB0aGF0Ll9oYXNWYWx1ZSA9IG1hbnVhbCB8fCB0aGF0Ll9oYXNWYWx1ZTtcbiAgICAgIHNldFZhbHVlKG1hbnVhbCwgbWFudWFsLCAwLCB0cnVlKTtcblxuICAgICAgaWYgKG1hbnVhbCkge1xuICAgICAgICB0cmlnZ2VyKCdvblNldCcsIHtcbiAgICAgICAgICB2YWx1ZVRleHQ6IHRoYXQuX3ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYW51YWwpIHtcbiAgICAgIHRyaWdnZXIoJ29uQ2hhbmdlJywge1xuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIHZhbHVlVGV4dDogdGhhdC5fdGVtcFZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRXaGVlbFZhbHVlKHdoZWVsLCBpLCBpZHgsIHRpbWUsIGRpciwgdGFwLCBub3Njcm9sbCwgc2hvdWxkRm9jdXMpIHtcbiAgICAvLyBHZXQgdGhlIHZhbHVlIGF0IHRoZSBnaXZlbiBpbmRleFxuICAgIHZhciB2YWx1ZSA9IGdldFZhbHVlKHdoZWVsLCBpZHgpO1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRlbXBXaGVlbEFycmF5W2ldID0gdmFsdWU7IC8vIEluIGNhc2Ugb2YgY2lyY3VsYXIgd2hlZWxzIGNhbGN1bGF0ZSB0aGUgb2Zmc2V0IG9mIHRoZSBjdXJyZW50IGJhdGNoXG5cbiAgICAgIHdoZWVsLl9iYXRjaCA9IHdoZWVsLl9hcnJheSA/IE1hdGguZmxvb3IoaWR4IC8gd2hlZWwuX2xlbmd0aCkgKiB3aGVlbC5fbGVuZ3RoIDogMDtcbiAgICAgIHdoZWVsLl9pbmRleCA9IGlkeDtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzY3JvbGxUb1Bvcyh0aW1lLCBpLCBkaXIsIHRydWUsIHRhcCwgbm9zY3JvbGwsIHNob3VsZEZvY3VzKTtcbiAgICAgIH0sIDEwKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRWYWx1ZShmaWxsLCBjaGFuZ2UsIHRpbWUsIG5vc2Nyb2xsLCB0ZW1wKSB7XG4gICAgaWYgKCFub3Njcm9sbCkge1xuICAgICAgc2Nyb2xsVG9Qb3ModGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX3RlbXBWYWx1ZSA9IHMuZm9ybWF0VmFsdWUuY2FsbChlbCwgdGhhdC5fdGVtcFdoZWVsQXJyYXksIHRoYXQpO1xuICAgIH1cblxuICAgIGlmICghdGVtcCkge1xuICAgICAgdGhhdC5fd2hlZWxBcnJheSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlbXBXaGVlbEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIEluIGNhc2Ugb2YgbXVsdGlwbGUgc2VsZWN0IHdoZWVsIHRha2UgdGhlIGZpcnN0IHNlbGVjdGVkIHZhbHVlLFxuICAgICAgICB0aGF0Ll93aGVlbEFycmF5W2ldID0gd2hlZWxzW2ldICYmIHdoZWVsc1tpXS5tdWx0aXBsZSA/IE9iamVjdC5rZXlzKHRoYXQuX3RlbXBTZWxlY3RlZFtpXSB8fCB7fSlbMF0gOiB0ZW1wV2hlZWxBcnJheVtpXTtcbiAgICAgIH1cblxuICAgICAgdGhhdC5fdmFsdWUgPSB0aGF0Ll9oYXNWYWx1ZSA/IHRoYXQuX3RlbXBWYWx1ZSA6IG51bGw7XG4gICAgICB0aGF0Ll9zZWxlY3RlZCA9IGV4dGVuZCQxKHRydWUsIHt9LCB0aGF0Ll90ZW1wU2VsZWN0ZWQpO1xuICAgIH1cblxuICAgIGlmIChmaWxsKSB7XG4gICAgICBpZiAodGhhdC5faXNJbnB1dCkge1xuICAgICAgICAkZWxtLnZhbCh0aGF0Ll9oYXNWYWx1ZSA/IHRoYXQuX3RlbXBWYWx1ZSA6ICcnKTtcbiAgICAgIH1cblxuICAgICAgdHJpZ2dlcignb25GaWxsJywge1xuICAgICAgICB2YWx1ZVRleHQ6IHRoYXQuX2hhc1ZhbHVlID8gdGhhdC5fdGVtcFZhbHVlIDogJycsXG4gICAgICAgIGNoYW5nZTogY2hhbmdlXG4gICAgICB9KTtcblxuICAgICAgaWYgKGNoYW5nZSkge1xuICAgICAgICB0aGF0Ll9wcmV2ZW50Q2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgJGVsbS50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2FsbCB0aGUgcGFyZW50IGNvbnN0cnVjdG9yXG5cblxuICBGcmFtZS5jYWxsKHRoaXMsIGVsLCBzZXR0aW5ncywgdHJ1ZSk7IC8vIFB1YmxpYyBmdW5jdGlvbnNcblxuICAvKipcclxuICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgc2Nyb2xsZXIuXHJcbiAgICogQHBhcmFtIHtBcnJheX0gdmFsIC0gTmV3IHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZpbGw9ZmFsc2VdIC0gU2V0IHRoZSB2YWx1ZSBvZiB0aGUgYXNzb2NpYXRlZCBpbnB1dCBlbGVtZW50LlxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NoYW5nZT1mYWxzZV0gLSBUcmlnZ2VyIGNoYW5nZSBvbiB0aGUgaW5wdXQgZWxlbWVudC5cclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt0ZW1wPWZhbHNlXSAtIElmIHRydWUsIHRoZW4gb25seSBzZXQgdGhlIHRlbXBvcmFyeSB2YWx1ZSAob25seSBzY3JvbGwgdGhlcmUgYnV0IG5vdCBzZXQgdGhlIHZhbHVlKS5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWU9MF0gLSBBbmltYXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICovXG5cbiAgdGhhdC5zZXRWYWwgPSB0aGF0Ll9zZXRWYWwgPSBmdW5jdGlvbiAodmFsLCBmaWxsLCBjaGFuZ2UsIHRlbXAsIHRpbWUpIHtcbiAgICB0aGF0Ll9oYXNWYWx1ZSA9IHZhbCAhPT0gbnVsbCAmJiB2YWwgIT09IHVuZGVmaW5lZDtcbiAgICB0aGF0Ll90ZW1wV2hlZWxBcnJheSA9IHRlbXBXaGVlbEFycmF5ID0gJCQxLmlzQXJyYXkodmFsKSA/IHZhbC5zbGljZSgwKSA6IHMucGFyc2VWYWx1ZS5jYWxsKGVsLCB2YWwsIHRoYXQpIHx8IFtdO1xuICAgIHNldFZhbHVlKGZpbGwsIGNoYW5nZSA9PT0gdW5kZWZpbmVkID8gZmlsbCA6IGNoYW5nZSwgdGltZSwgZmFsc2UsIHRlbXApO1xuICB9O1xuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBzZWxlY3RlZCB2YWx1ZS5cclxuICAgKi9cblxuXG4gIHRoYXQuZ2V0VmFsID0gdGhhdC5fZ2V0VmFsID0gZnVuY3Rpb24gKHRlbXApIHtcbiAgICB2YXIgdmFsID0gdGhhdC5faGFzVmFsdWUgfHwgdGVtcCA/IHRoYXRbdGVtcCA/ICdfdGVtcFZhbHVlJyA6ICdfdmFsdWUnXSA6IG51bGw7XG4gICAgcmV0dXJuIGlzTnVtZXJpYyh2YWwpID8gK3ZhbCA6IHZhbDtcbiAgfTtcbiAgLypcclxuICAgKiBTZXRzIHRoZSB3aGVlbCB2YWx1ZXMgKHBhc3NlZCBhcyBhbiBhcnJheSkuXHJcbiAgICovXG5cblxuICB0aGF0LnNldEFycmF5VmFsID0gdGhhdC5zZXRWYWw7XG4gIC8qXHJcbiAgICogUmV0dXJucyB0aGUgc2VsZWN0ZWQgd2hlZWwgdmFsdWVzIGFzIGFuIGFycmF5LlxyXG4gICAqL1xuXG4gIHRoYXQuZ2V0QXJyYXlWYWwgPSBmdW5jdGlvbiAodGVtcCkge1xuICAgIHJldHVybiB0ZW1wID8gdGhhdC5fdGVtcFdoZWVsQXJyYXkgOiB0aGF0Ll93aGVlbEFycmF5O1xuICB9O1xuXG4gIHRoYXQuY2hhbmdlV2hlZWwgPSBmdW5jdGlvbiAod2hscywgdGltZSwgbWFudWFsKSB7XG4gICAgdmFyIGksIHcsIHd3O1xuICAgICQkMS5lYWNoKHdobHMsIGZ1bmN0aW9uIChrZXksIHdoZWVsKSB7XG4gICAgICB3dyA9IHdoZWVsc01hcFtrZXldOyAvLyBDaGVjayBpZiB3aGVlbCBleGlzdHNcblxuICAgICAgaWYgKHd3KSB7XG4gICAgICAgIGkgPSB3dy5fbnI7XG4gICAgICAgIHcgPSBpbml0V2hlZWwod2hlZWwsIGksIHRydWUpO1xuXG4gICAgICAgIGlmICh0aGF0Ll9pc1Zpc2libGUpIHtcbiAgICAgICAgICBpZiAoc2Nyb2xsM2QpIHtcbiAgICAgICAgICAgIHcuXyQzZC5odG1sKGdlbmVyYXRlSXRlbXModywgaSwgdy5fZmlyc3QgKyBiYXRjaFNpemUgLSBiYXRjaFNpemUzZCArIDEsIHcuX2xhc3QgLSBiYXRjaFNpemUgKyBiYXRjaFNpemUzZCwgdHJ1ZSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHcuXyRzY3JvbGxlci5odG1sKGdlbmVyYXRlSXRlbXModywgaSwgdy5fZmlyc3QsIHcuX2xhc3QpKS5jc3MoJ21hcmdpbi10b3AnLCB3Ll9tYXJnaW4gKyAncHgnKTtcblxuICAgICAgICAgIHcuX3JlZnJlc2goaXNWYWxpZGF0aW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHRoYXQuX2lzVmlzaWJsZSAmJiAhdGhhdC5faXNMaXF1aWQgJiYgIWlzVmFsaWRhdGluZykge1xuICAgICAgdGhhdC5wb3NpdGlvbigpO1xuICAgIH1cblxuICAgIGlmICghaXNWYWxpZGF0aW5nKSB7XG4gICAgICBzY3JvbGxUb1Bvcyh0aW1lLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbWFudWFsKTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGNsb3Nlc3QgdmFsaWQgdmFsdWUuXHJcbiAgICovXG5cblxuICB0aGF0LmdldFZhbGlkVmFsdWUgPSBnZXRWYWxpZDsgLy8gUHJvdGVjdGVkIG92ZXJyaWRlc1xuXG4gIHRoYXQuX2dlbmVyYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGJsLFxuICAgICAgICBtYXhQb3B1cFdpZHRoID0gMCxcbiAgICAgICAgaHRtbCA9ICcnLFxuICAgICAgICBzdHlsZSA9IHNjcm9sbDNkID8gY3NzUHJlZml4ICsgJ3RyYW5zZm9ybTogdHJhbnNsYXRlWignICsgKGl0ZW1IZWlnaHQgKiBzLnJvd3MgLyAyICsgMykgKyAncHgpOycgOiAnJyxcbiAgICAgICAgaGlnaGxpZ2h0ID0gJzxkaXYgY2xhc3M9XCJtYnNjLXNjLXdobC1sXCIgc3R5bGU9XCInICsgc3R5bGUgKyAnaGVpZ2h0OicgKyBpdGVtSGVpZ2h0ICsgJ3B4O21hcmdpbi10b3A6LScgKyAoaXRlbUhlaWdodCAvIDIgKyAocy5zZWxlY3RlZExpbmVCb3JkZXIgfHwgMCkpICsgJ3B4O1wiPjwvZGl2PicsXG4gICAgICAgIGwgPSAwO1xuICAgICQkMS5lYWNoKHMud2hlZWxzLCBmdW5jdGlvbiAoaSwgd2cpIHtcbiAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJtYnNjLXctcCBtYnNjLXNjLXdobC1nci1jJyArIChzY3JvbGwzZCA/ICcgbWJzYy1zYy13aGwtZ3ItM2QtYycgOiAnJykgKyAocy5zaG93TGFiZWwgPyAnIG1ic2Mtc2MtbGJsLXYnIDogJycpICsgJ1wiPicgKyBoaWdobGlnaHQgKyAnPGRpdiBjbGFzcz1cIm1ic2Mtc2Mtd2hsLWdyJyArIChzY3JvbGwzZCA/ICcgbWJzYy1zYy13aGwtZ3ItM2QnIDogJycpICsgKHNob3dTY3JvbGxBcnJvd3MgPyAnIG1ic2Mtc2MtY3AnIDogJycpICsgKHMud2lkdGggfHwgcy5tYXhXaWR0aCA/ICdcIicgOiAnXCIgc3R5bGU9XCJtYXgtd2lkdGg6JyArIHMubWF4UG9wdXBXaWR0aCArICdweDtcIicpICsgJz4nO1xuICAgICAgJCQxLmVhY2god2csIGZ1bmN0aW9uIChqLCB3dykge1xuICAgICAgICAvLyBXaGVlbHNcbiAgICAgICAgdGhhdC5fdGVtcFNlbGVjdGVkW2xdID0gZXh0ZW5kJDEoe30sIHRoYXQuX3NlbGVjdGVkW2xdKTsgLy8gVE9ETzogdGhpcyBzaG91bGQgYmUgZG9uZSBvbiBpbml0aWFsaXphdGlvbiwgbm90IG9uIHNob3dcblxuICAgICAgICB2YXIgdyA9IGluaXRXaGVlbCh3dywgbCk7XG4gICAgICAgIHdoZWVsc1tsXSA9IHc7XG4gICAgICAgIG1heFBvcHVwV2lkdGggKz0gcy5tYXhXaWR0aCA/IHMubWF4V2lkdGhbbF0gfHwgcy5tYXhXaWR0aCA6IHMud2lkdGggPyBzLndpZHRoW2xdIHx8IHMud2lkdGggOiAwO1xuICAgICAgICBsYmwgPSB3LmxhYmVsICE9PSB1bmRlZmluZWQgPyB3LmxhYmVsIDogajtcbiAgICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cIm1ic2Mtc2Mtd2hsLXcgJyArICh3LmNzc0NsYXNzIHx8ICcnKSArICh3Lm11bHRpcGxlID8gJyBtYnNjLXNjLXdobC1tdWx0aScgOiAnJykgKyAnXCIgc3R5bGU9XCInICsgKHMud2lkdGggPyAnd2lkdGg6JyArIChzLndpZHRoW2xdIHx8IHMud2lkdGgpICsgJ3B4OycgOiAocy5taW5XaWR0aCA/ICdtaW4td2lkdGg6JyArIChzLm1pbldpZHRoW2xdIHx8IHMubWluV2lkdGgpICsgJ3B4OycgOiAnJykgKyAocy5tYXhXaWR0aCA/ICdtYXgtd2lkdGg6JyArIChzLm1heFdpZHRoW2xdIHx8IHMubWF4V2lkdGgpICsgJ3B4OycgOiAnJykpICsgJ1wiPicgKyAoaXNQb2ludGVyID8gJzxkaXYgY2xhc3M9XCJtYnNjLXNjLWJhci1jXCI+PGRpdiBjbGFzcz1cIm1ic2Mtc2MtYmFyXCI+PC9kaXY+PC9kaXY+JyA6ICcnKSArIC8vIFNjcm9sbGJhclxuICAgICAgICAnPGRpdiBjbGFzcz1cIm1ic2Mtc2Mtd2hsLW9cIiBzdHlsZT1cIicgKyBzdHlsZSArICdcIj48L2Rpdj4nICsgaGlnaGxpZ2h0ICsgJzxkaXYgYXJpYS1saXZlPVwib2ZmXCIgYXJpYS1sYWJlbD1cIicgKyBsYmwgKyAnXCInICsgKHcubXVsdGlwbGUgPyAnIGFyaWEtbXVsdGlzZWxlY3RhYmxlPVwidHJ1ZVwiJyA6ICcnKSArICcgcm9sZT1cImxpc3Rib3hcIiBkYXRhLWluZGV4PVwiJyArIGwgKyAnXCIgY2xhc3M9XCJtYnNjLXNjLXdobFwiJyArICcgc3R5bGU9XCInICsgJ2hlaWdodDonICsgcy5yb3dzICogaXRlbUhlaWdodCAqIChzY3JvbGwzZCA/IDEuMSA6IDEpICsgJ3B4O1wiPicgKyAoc2hvd1Njcm9sbEFycm93cyA/ICc8ZGl2IGRhdGEtaW5kZXg9XCInICsgbCArICdcIiBkYXRhLXN0ZXA9XCIxXCIgY2xhc3M9XCJtYnNjLXNjLWJ0biBtYnNjLXNjLWJ0bi1wbHVzICcgKyAocy5idG5QbHVzQ2xhc3MgfHwgJycpICsgJ1wiPjwvZGl2PicgKyAvLyArIGJ1dHRvblxuICAgICAgICAnPGRpdiBkYXRhLWluZGV4PVwiJyArIGwgKyAnXCIgZGF0YS1zdGVwPVwiLTFcIiBjbGFzcz1cIm1ic2Mtc2MtYnRuIG1ic2Mtc2MtYnRuLW1pbnVzICcgKyAocy5idG5NaW51c0NsYXNzIHx8ICcnKSArICdcIj48L2Rpdj4nIDogJycpICsgLy8gLSBidXR0b25cbiAgICAgICAgJzxkaXYgY2xhc3M9XCJtYnNjLXNjLWxibFwiPicgKyBsYmwgKyAnPC9kaXY+JyArIC8vIFdoZWVsIGxhYmVsXG4gICAgICAgICc8ZGl2IGNsYXNzPVwibWJzYy1zYy13aGwtY1wiJyArICcgc3R5bGU9XCJoZWlnaHQ6JyArIGl0ZW1IZWlnaHQzZCArICdweDttYXJnaW4tdG9wOi0nICsgKGl0ZW1IZWlnaHQzZCAvIDIgKyAxKSArICdweDsnICsgc3R5bGUgKyAnXCI+JyArICc8ZGl2IGNsYXNzPVwibWJzYy1zYy13aGwtc2NcIiBzdHlsZT1cInRvcDonICsgKGl0ZW1IZWlnaHQzZCAtIGl0ZW1IZWlnaHQpIC8gMiArICdweDtcIj4nOyAvLyBDcmVhdGUgd2hlZWwgdmFsdWVzXG5cbiAgICAgICAgaHRtbCArPSBnZW5lcmF0ZUl0ZW1zKHcsIGwsIHcuX2ZpcnN0LCB3Ll9sYXN0KSArICc8L2Rpdj48L2Rpdj4nO1xuXG4gICAgICAgIGlmIChzY3JvbGwzZCkge1xuICAgICAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJtYnNjLXNjLXdobC0zZFwiIHN0eWxlPVwiaGVpZ2h0OicgKyBpdGVtSGVpZ2h0ICsgJ3B4O21hcmdpbi10b3A6LScgKyBpdGVtSGVpZ2h0IC8gMiArICdweDtcIj4nO1xuICAgICAgICAgIGh0bWwgKz0gZ2VuZXJhdGVJdGVtcyh3LCBsLCB3Ll9maXJzdCArIGJhdGNoU2l6ZSAtIGJhdGNoU2l6ZTNkICsgMSwgdy5fbGFzdCAtIGJhdGNoU2l6ZSArIGJhdGNoU2l6ZTNkLCB0cnVlKTtcbiAgICAgICAgICBodG1sICs9ICc8L2Rpdj4nO1xuICAgICAgICB9XG5cbiAgICAgICAgaHRtbCArPSAnPC9kaXY+PC9kaXY+JztcbiAgICAgICAgbCsrO1xuICAgICAgfSk7XG4gICAgICBodG1sICs9ICc8L2Rpdj48L2Rpdj4nO1xuICAgIH0pO1xuXG4gICAgaWYgKG1heFBvcHVwV2lkdGgpIHtcbiAgICAgIHMubWF4UG9wdXBXaWR0aCA9IG1heFBvcHVwV2lkdGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG5cbiAgdGhhdC5fYXR0YWNoRXZlbnRzID0gZnVuY3Rpb24gKCRtYXJrdXApIHtcbiAgICBzdGVwcGVyID0gY3JlYXRlU3RlcHBlcigkJDEoJy5tYnNjLXNjLWJ0bicsICRtYXJrdXApLCBzdGVwLCBzLmRlbGF5LCBpc1JlYWRPbmx5LCB0cnVlKTtcbiAgICAkJDEoJy5tYnNjLXNjLXdobCcsICRtYXJrdXApLm9uKCdrZXlkb3duJywgb25LZXlEb3duKS5vbigna2V5dXAnLCBvbktleVVwKTtcbiAgfTtcblxuICB0aGF0Ll9kZXRhY2hFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgc3RlcHBlci5zdG9wKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdoZWVscy5sZW5ndGg7IGkrKykge1xuICAgICAgd2hlZWxzW2ldLl9zY3JvbGxlci5kZXN0cm95KCk7XG4gICAgfVxuICB9O1xuXG4gIHRoYXQuX21hcmt1cFJlYWR5ID0gZnVuY3Rpb24gKCRtKSB7XG4gICAgJG1hcmt1cCA9ICRtO1xuICAgICQkMSgnLm1ic2Mtc2Mtd2hsLXcnLCAkbWFya3VwKS5lYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICB2YXIgaWR4LFxuICAgICAgICAgICR3aCA9ICQkMSh0aGlzKSxcbiAgICAgICAgICB3aGVlbCA9IHdoZWVsc1tpXTtcbiAgICAgIHdoZWVsLl8kbWFya3VwID0gJHdoO1xuICAgICAgd2hlZWwuXyRzY3JvbGxlciA9ICQkMSgnLm1ic2Mtc2Mtd2hsLXNjJywgdGhpcyk7XG4gICAgICB3aGVlbC5fJDNkID0gJCQxKCcubWJzYy1zYy13aGwtM2QnLCB0aGlzKTtcbiAgICAgIHdoZWVsLl9zY3JvbGxlciA9IG5ldyBTY3JvbGxWaWV3QmFzZSh0aGlzLCB7XG4gICAgICAgIG1vdXNld2hlZWw6IHMubW91c2V3aGVlbCxcbiAgICAgICAgbW92ZUVsZW1lbnQ6IHdoZWVsLl8kc2Nyb2xsZXIsXG4gICAgICAgIHNjcm9sbGJhcjogJCQxKCcubWJzYy1zYy1iYXItYycsIHRoaXMpLFxuICAgICAgICBpbml0aWFsUG9zOiAod2hlZWwuX2ZpcnN0IC0gd2hlZWwuX2luZGV4KSAqIGl0ZW1IZWlnaHQsXG4gICAgICAgIGNvbnRTaXplOiBzLnJvd3MgKiBpdGVtSGVpZ2h0LFxuICAgICAgICBzbmFwOiBpdGVtSGVpZ2h0LFxuICAgICAgICBtaW5TY3JvbGw6IGdldE1pbih3aGVlbCksXG4gICAgICAgIG1heFNjcm9sbDogZ2V0TWF4KHdoZWVsKSxcbiAgICAgICAgbWF4U25hcFNjcm9sbDogYmF0Y2hTaXplLFxuICAgICAgICBwcmV2RGVmOiB0cnVlLFxuICAgICAgICBzdG9wUHJvcDogdHJ1ZSxcbiAgICAgICAgdGltZVVuaXQ6IDMsXG4gICAgICAgIGVhc2luZzogJ2N1YmljLWJlemllcigwLjE5MCwgMS4wMDAsIDAuMjIwLCAxLjAwMCknLFxuICAgICAgICBzeW5jOiBmdW5jdGlvbiBzeW5jKHBvcywgdGltZSwgZWFzaW5nKSB7XG4gICAgICAgICAgdmFyIHRpbWluZyA9IHRpbWUgPyBjc3NQcmVmaXggKyAndHJhbnNmb3JtICcgKyBNYXRoLnJvdW5kKHRpbWUpICsgJ21zICcgKyBlYXNpbmcgOiAnJztcblxuICAgICAgICAgIGlmIChzY3JvbGwzZCkge1xuICAgICAgICAgICAgd2hlZWwuXyQzZFswXS5zdHlsZVtqc1ByZWZpeCArICdUcmFuc2l0aW9uJ10gPSB0aW1pbmc7XG4gICAgICAgICAgICB3aGVlbC5fJDNkWzBdLnN0eWxlW2pzUHJlZml4ICsgJ1RyYW5zZm9ybSddID0gJ3JvdGF0ZVgoJyArIC1wb3MgLyBpdGVtSGVpZ2h0ICogc2Nyb2xsM2RBbmdsZSArICdkZWcpJztcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uU3RhcnQ6IGZ1bmN0aW9uIG9uU3RhcnQoZXYsIGluc3QpIHtcbiAgICAgICAgICBpbnN0LnNldHRpbmdzLnJlYWRvbmx5ID0gaXNSZWFkT25seShpKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25HZXN0dXJlU3RhcnQ6IGZ1bmN0aW9uIG9uR2VzdHVyZVN0YXJ0KCkge1xuICAgICAgICAgICR3aC5hZGRDbGFzcygnbWJzYy1zYy13aGwtYSBtYnNjLXNjLXdobC1hbmltJyk7XG4gICAgICAgICAgdHJpZ2dlcignb25XaGVlbEdlc3R1cmVTdGFydCcsIHtcbiAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uR2VzdHVyZUVuZDogZnVuY3Rpb24gb25HZXN0dXJlRW5kKGV2KSB7XG4gICAgICAgICAgdmFyIGRpciA9IGV2LmRpcmVjdGlvbiA9PSA5MCA/IDEgOiAyLFxuICAgICAgICAgICAgICB0aW1lID0gZXYuZHVyYXRpb24sXG4gICAgICAgICAgICAgIHBvcyA9IGV2LmRlc3RpbmF0aW9uWTtcbiAgICAgICAgICBpZHggPSBNYXRoLnJvdW5kKC1wb3MgLyBpdGVtSGVpZ2h0KSArIHdoZWVsLl9vZmZzZXQ7XG4gICAgICAgICAgc2V0V2hlZWxWYWx1ZSh3aGVlbCwgaSwgaWR4LCB0aW1lLCBkaXIpO1xuICAgICAgICB9LFxuICAgICAgICBvbkFuaW1hdGlvblN0YXJ0OiBmdW5jdGlvbiBvbkFuaW1hdGlvblN0YXJ0KCkge1xuICAgICAgICAgICR3aC5hZGRDbGFzcygnbWJzYy1zYy13aGwtYW5pbScpO1xuICAgICAgICB9LFxuICAgICAgICBvbkFuaW1hdGlvbkVuZDogZnVuY3Rpb24gb25BbmltYXRpb25FbmQoKSB7XG4gICAgICAgICAgJHdoLnJlbW92ZUNsYXNzKCdtYnNjLXNjLXdobC1hIG1ic2Mtc2Mtd2hsLWFuaW0nKTtcbiAgICAgICAgICB0cmlnZ2VyKCdvbldoZWVsQW5pbWF0aW9uRW5kJywge1xuICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHdoZWVsLl8kM2QuZmluZCgnLm1ic2Mtc2MtaXRtLWRlbCcpLnJlbW92ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdmU6IGZ1bmN0aW9uIG9uTW92ZShldikge1xuICAgICAgICAgIGluZmluaXRlKHdoZWVsLCBpLCBldi5wb3NZKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25CdG5UYXA6IGZ1bmN0aW9uIG9uQnRuVGFwKGV2KSB7XG4gICAgICAgICAgb25JdGVtVGFwKGksICQkMShldi50YXJnZXQpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgc2Nyb2xsVG9Qb3MoKTtcbiAgfTtcblxuICB0aGF0Ll9maWxsVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhhdC5faGFzVmFsdWUgPSB0cnVlO1xuICAgIHNldFZhbHVlKHRydWUsIHRydWUsIDAsIHRydWUpO1xuICB9O1xuXG4gIHRoYXQuX2NsZWFyVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgJCQxKCcubWJzYy1zYy13aGwtbXVsdGkgLm1ic2Mtc2MtaXRtLXNlbCcsICRtYXJrdXApLnJlbW92ZUNsYXNzKHNlbGVjdGVkQ2xhc3MpLnJlbW92ZUF0dHIoJ2FyaWEtc2VsZWN0ZWQnKTtcbiAgfTtcblxuICB0aGF0Ll9yZWFkVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHYgPSAkZWxtLnZhbCgpIHx8ICcnLFxuICAgICAgICBsID0gMDtcblxuICAgIGlmICh2ICE9PSAnJykge1xuICAgICAgdGhhdC5faGFzVmFsdWUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoYXQuX3RlbXBXaGVlbEFycmF5ID0gdGVtcFdoZWVsQXJyYXkgPSB0aGF0Ll9oYXNWYWx1ZSAmJiB0aGF0Ll93aGVlbEFycmF5ID8gdGhhdC5fd2hlZWxBcnJheS5zbGljZSgwKSA6IHMucGFyc2VWYWx1ZS5jYWxsKGVsLCB2LCB0aGF0KSB8fCBbXTtcbiAgICB0aGF0Ll90ZW1wU2VsZWN0ZWQgPSBleHRlbmQkMSh0cnVlLCB7fSwgdGhhdC5fc2VsZWN0ZWQpO1xuICAgICQkMS5lYWNoKHMud2hlZWxzLCBmdW5jdGlvbiAoaSwgd2cpIHtcbiAgICAgICQkMS5lYWNoKHdnLCBmdW5jdGlvbiAoaiwgdykge1xuICAgICAgICAvLyBXaGVlbHNcbiAgICAgICAgd2hlZWxzW2xdID0gaW5pdFdoZWVsKHcsIGwpO1xuICAgICAgICBsKys7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBzZXRWYWx1ZShmYWxzZSwgZmFsc2UsIDAsIHRydWUpO1xuICAgIHRyaWdnZXIoJ29uUmVhZCcpO1xuICB9O1xuXG4gIHRoYXQuX19wcm9jZXNzU2V0dGluZ3MgPSBmdW5jdGlvbiAocmVzcCkge1xuICAgIHMgPSB0aGF0LnNldHRpbmdzO1xuICAgIHRyaWdnZXIgPSB0aGF0LnRyaWdnZXI7XG4gICAgbGluZXMgPSBzLm11bHRpbGluZTtcbiAgICBzZWxlY3RlZENsYXNzID0gJ21ic2Mtc2MtaXRtLXNlbCBtYnNjLWljIG1ic2MtaWMtJyArIHMuY2hlY2tJY29uO1xuICAgIGlzUG9pbnRlciA9ICFzLnRvdWNoVWk7XG5cbiAgICBpZiAoaXNQb2ludGVyKSB7XG4gICAgICAvLyBTZXR0aW5ncyB0aGF0IG1pZ2h0IGJlIG5lZWRlZCBieSB0aGUgc2Nyb2xsZXIgcHJlc2V0IGFzIHdlbGxcbiAgICAgIHMudGFwU2VsZWN0ID0gdHJ1ZTtcbiAgICAgIHMuY2lyY3VsYXIgPSBmYWxzZTtcbiAgICAgIHMucm93cyA9IHJlc3Aucm93cyB8fCBzZXR0aW5ncy5yb3dzIHx8IDc7XG4gICAgfVxuICB9O1xuXG4gIHRoYXQuX19pbml0ID0gZnVuY3Rpb24gKG5ld1NldHRpbmdzKSB7XG4gICAgaWYgKG5ld1NldHRpbmdzKSB7XG4gICAgICAvLyBSZXNldCB3aGVlbCBhcnJheSBpbiBjYXNlIG9mIHNldHRpbmcgY2hhbmdlLFxuICAgICAgLy8gc2luY2UgaXQgbWlnaHQgYWZmZWN0IHRoZSBudW1iZXIgb2Ygd2hlZWxzXG4gICAgICB0aGF0Ll93aGVlbEFycmF5ID0gbnVsbDtcbiAgICB9XG5cbiAgICB3aGVlbHMgPSBbXTtcbiAgICB3aGVlbHNNYXAgPSB7fTtcbiAgICBzaG93U2Nyb2xsQXJyb3dzID0gcy5zaG93U2Nyb2xsQXJyb3dzO1xuICAgIHNjcm9sbDNkID0gcy5zY3JvbGwzZCAmJiBoYXMzZCAmJiAhc2hvd1Njcm9sbEFycm93cyAmJiAhaXNQb2ludGVyICYmIChzLnRoZW1lID09ICdpb3MnIHx8IHMuYmFzZVRoZW1lID09ICdpb3MnKTtcbiAgICBpdGVtSGVpZ2h0ID0gcy5oZWlnaHQ7XG4gICAgaXRlbUhlaWdodDNkID0gc2Nyb2xsM2QgPyBNYXRoLnJvdW5kKChpdGVtSGVpZ2h0IC0gKGl0ZW1IZWlnaHQgKiBzLnJvd3MgLyAyICsgMykgKiAwLjAzKSAvIDIpICogMiA6IGl0ZW1IZWlnaHQ7XG4gICAgYmF0Y2hTaXplM2QgPSBNYXRoLnJvdW5kKHMucm93cyAqIDEuOCk7XG4gICAgc2Nyb2xsM2RBbmdsZSA9IDM2MCAvIChiYXRjaFNpemUzZCAqIDIpOyAvLyBFbnN1cmUgYSBtaW5pbXVtIG51bWJlciBvZiAzIGl0ZW1zIGlmIGNsaWNrcGljayBidXR0b25zIHByZXNlbnRcblxuICAgIGlmIChzaG93U2Nyb2xsQXJyb3dzKSB7XG4gICAgICBzLnJvd3MgPSBNYXRoLm1heCgzLCBzLnJvd3MpO1xuICAgIH1cbiAgfTtcblxuICB0aGF0Ll9nZXRJdGVtVmFsdWUgPSBnZXRJdGVtVmFsdWU7IC8vIFByb3BlcnRpZXNcblxuICB0aGF0Ll90ZW1wU2VsZWN0ZWQgPSB7fTtcbiAgdGhhdC5fc2VsZWN0ZWQgPSB7fTsgLy8gQ29uc3RydWN0b3JcblxuICBpZiAoIWluaGVyaXQpIHtcbiAgICB0aGF0LmluaXQoKTtcbiAgfVxufTsgLy8gRXh0ZW5kIGRlZmF1bHRzXG5cblNjcm9sbGVyLnByb3RvdHlwZSA9IHtcbiAgX2hhc0RlZjogdHJ1ZSxcbiAgX2hhc1RoZW1lOiB0cnVlLFxuICBfaGFzTGFuZzogdHJ1ZSxcbiAgX3Jlc3BvbnNpdmU6IHRydWUsXG4gIF9jbGFzczogJ3Njcm9sbGVyJyxcbiAgX3ByZXNldHM6IHByZXNldHMsXG4gIF9kZWZhdWx0czogZXh0ZW5kJDEoe30sIEZyYW1lLnByb3RvdHlwZS5fZGVmYXVsdHMsIHtcbiAgICAvLyBPcHRpb25zXG4gICAgbWluV2lkdGg6IDgwLFxuICAgIGhlaWdodDogNDAsXG4gICAgcm93czogMyxcbiAgICBtdWx0aWxpbmU6IDEsXG4gICAgZGVsYXk6IDIwMCxcbiAgICByZWFkb25seTogZmFsc2UsXG4gICAgc2hvd0xhYmVsOiB0cnVlLFxuICAgIHNldE9uVGFwOiBmYWxzZSxcbiAgICB3aGVlbHM6IFtdLFxuICAgIHByZXNldDogJycsXG4gICAgc3BlZWRVbml0OiAwLjAwMTIsXG4gICAgdGltZVVuaXQ6IDAuMDgsXG4gICAgY2hlY2tJY29uOiAnY2hlY2ttYXJrJyxcbiAgICBjb21wQ2xhc3M6ICdtYnNjLXNjJyxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoKSB7fSxcbiAgICBmb3JtYXRWYWx1ZTogZnVuY3Rpb24gZm9ybWF0VmFsdWUoZCkge1xuICAgICAgcmV0dXJuIGQuam9pbignICcpO1xuICAgIH0sXG4gICAgcGFyc2VWYWx1ZTogZnVuY3Rpb24gcGFyc2VWYWx1ZSh2YWx1ZSwgaW5zdCkge1xuICAgICAgdmFyIHZhbCA9IFtdLFxuICAgICAgICAgIHJldCA9IFtdLFxuICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgIGZvdW5kLFxuICAgICAgICAgIGRhdGE7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbCA9ICh2YWx1ZSArICcnKS5zcGxpdCgnICcpO1xuICAgICAgfVxuXG4gICAgICAkJDEuZWFjaChpbnN0LnNldHRpbmdzLndoZWVscywgZnVuY3Rpb24gKGosIHdnKSB7XG4gICAgICAgICQkMS5lYWNoKHdnLCBmdW5jdGlvbiAoaywgdykge1xuICAgICAgICAgIGRhdGEgPSB3LmRhdGE7IC8vIERlZmF1bHQgdG8gZmlyc3Qgd2hlZWwgdmFsdWUgaWYgbm90IGZvdW5kXG5cbiAgICAgICAgICBmb3VuZCA9IGluc3QuX2dldEl0ZW1WYWx1ZShkYXRhWzBdKTtcbiAgICAgICAgICAkJDEuZWFjaChkYXRhLCBmdW5jdGlvbiAobCwgaXRlbSkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgZG8gc3RyaWN0IGNvbXBhcmlzb25cbiAgICAgICAgICAgIGlmICh2YWxbaV0gPT0gaW5zdC5fZ2V0SXRlbVZhbHVlKGl0ZW0pKSB7XG4gICAgICAgICAgICAgIGZvdW5kID0gaW5zdC5fZ2V0SXRlbVZhbHVlKGl0ZW0pO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0LnB1c2goZm91bmQpO1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9KVxufTtcbmNsYXNzZXMuU2Nyb2xsZXIgPSBTY3JvbGxlcjtcblxudmFyIGRlZmF1bHRzJDEgPSB7XG4gIHNlcGFyYXRvcjogJyAnLFxuICAvLyBMb2NhbGl6YXRpb25cbiAgZGF0ZUZvcm1hdDogJ21tL2RkL3l5JyxcbiAgZGF0ZURpc3BsYXk6ICdNTWRkeXknLFxuICB0aW1lRm9ybWF0OiAnaDppaSBBJyxcbiAgZGF5VGV4dDogJ0RheScsXG4gIG1vbnRoVGV4dDogJ01vbnRoJyxcbiAgeWVhclRleHQ6ICdZZWFyJyxcbiAgaG91clRleHQ6ICdIb3VycycsXG4gIG1pbnV0ZVRleHQ6ICdNaW51dGVzJyxcbiAgYW1wbVRleHQ6ICcmbmJzcDsnLFxuICBzZWNUZXh0OiAnU2Vjb25kcycsXG4gIG5vd1RleHQ6ICdOb3cnLFxuICB0b2RheVRleHQ6ICdUb2RheSdcbn07IC8vIC0tLSBUUklBTCBTRVJWRVIgQ09ERSBFTkQgLS0tXG5cbnZhciBEYXRlVGltZSA9IGZ1bmN0aW9uIERhdGVUaW1lKGluc3QpIHtcbiAgZnVuY3Rpb24gY29udmVydFJhbmdlcyhhcnIpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgdixcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGVuZCxcbiAgICAgICAgcmV0ID0gW107XG5cbiAgICBpZiAoYXJyKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHYgPSBhcnJbaV07IC8vIENoZWNrIGlmIGl0J3MgYSByYW5nZSwgYnV0IHNraXAgdGltZS1vbmx5IHJhbmdlc1xuXG4gICAgICAgIGlmICh2LnN0YXJ0ICYmIHYuZW5kICYmICFJU09fODYwMV9USU1FLnRlc3Qodi5zdGFydCkpIHtcbiAgICAgICAgICBzdGFydCA9IG5ldyBEYXRlKG1ha2VEYXRlKHYuc3RhcnQsIGZvcm1hdCwgcykpO1xuICAgICAgICAgIGVuZCA9IG5ldyBEYXRlKG1ha2VEYXRlKHYuZW5kLCBmb3JtYXQsIHMpKTtcblxuICAgICAgICAgIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKGFkanVzdGVkRGF0ZShzdGFydC5nZXRGdWxsWWVhcigpLCBzdGFydC5nZXRNb250aCgpLCBzdGFydC5nZXREYXRlKCkpKTtcbiAgICAgICAgICAgIHN0YXJ0LnNldERhdGUoc3RhcnQuZ2V0RGF0ZSgpICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldC5wdXNoKHYpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0ZXAodiwgc3QsIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgubWluKG1heCwgTWF0aC5mbG9vcih2IC8gc3QpICogc3QgKyBtaW4pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWF4KHN0ZXAsIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoKG1heCAtIG1pbikgLyBzdGVwKSAqIHN0ZXAgKyBtaW47XG4gIH1cblxuICBmdW5jdGlvbiBnZXRZZWFyKGQpIHtcbiAgICByZXR1cm4gcy5nZXRZZWFyKGQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TW9udGgoZCkge1xuICAgIHJldHVybiBzLmdldE1vbnRoKGQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGF5KGQpIHtcbiAgICByZXR1cm4gcy5nZXREYXkoZCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRIb3VycyhkKSB7XG4gICAgdmFyIGhvdXIgPSBkLmdldEhvdXJzKCk7XG4gICAgaG91ciA9IGhhc0FtUG0gJiYgaG91ciA+PSAxMiA/IGhvdXIgLSAxMiA6IGhvdXI7XG4gICAgcmV0dXJuIHN0ZXAoaG91ciwgc3RlcEhvdXIsIG1pbkhvdXIsIG1heEhvdXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWludXRlcyhkKSB7XG4gICAgcmV0dXJuIHN0ZXAoZC5nZXRNaW51dGVzKCksIHN0ZXBNaW51dGUsIG1pbk1pbnV0ZSwgbWF4TWludXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNlY29uZHMoZCkge1xuICAgIHJldHVybiBzdGVwKGQuZ2V0U2Vjb25kcygpLCBzdGVwU2Vjb25kLCBtaW5TZWNvbmQsIG1heFNlY29uZCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNaWxsaXNlY29uZHMoZCkge1xuICAgIHJldHVybiBkLmdldE1pbGxpc2Vjb25kcygpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QW1QbShkKSB7XG4gICAgcmV0dXJuIGQuZ2V0SG91cnMoKSA+IDExID8gMSA6IDA7XG4gIH0gLy8gLS0tIFRSSUFMIFNFUlZFUiBDT0RFIFNUQVJUIC0tLVxuXG5cbiAgZnVuY3Rpb24gZ2V0RnVsbERhdGUoZCkge1xuICAgIHJldHVybiBkLmdldEZ1bGxZZWFyKCkgKyAnLScgKyBwYWQoZC5nZXRNb250aCgpICsgMSkgKyAnLScgKyBwYWQoZC5nZXREYXRlKCkpO1xuICB9IC8vIC0tLSBUUklBTCBTRVJWRVIgQ09ERSBFTkQgLS0tXG5cblxuICBmdW5jdGlvbiBnZXRGdWxsVGltZShkKSB7XG4gICAgcmV0dXJuIHN0ZXAoTWF0aC5yb3VuZCgoZC5nZXRUaW1lKCkgLSBuZXcgRGF0ZShkKS5zZXRIb3VycygwLCAwLCAwLCAwKSkgLyAxMDAwKSwgdGltZVN0ZXAgfHwgMSwgMCwgODY0MDApO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QXJyYXlQYXJ0KGRhdGEsIHBhcnQsIGQsIGRlZikge1xuICAgIHZhciByZXQ7XG5cbiAgICBpZiAod2hlZWxPcmRlcltwYXJ0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXQgPSArZGF0YVt3aGVlbE9yZGVyW3BhcnRdXTtcblxuICAgICAgaWYgKCFpc05hTihyZXQpKSB7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGQpIHtcbiAgICAgIHJldHVybiBnZXREYXRlUGFydFtwYXJ0XShkKTtcbiAgICB9XG5cbiAgICBpZiAoaW5uZXJWYWx1ZXNbcGFydF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGlubmVyVmFsdWVzW3BhcnRdO1xuICAgIH1cblxuICAgIHJldHVybiBnZXREYXRlUGFydFtwYXJ0XShkZWYpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGF0ZShkYXRhKSB7XG4gICAgdmFyIGQsXG4gICAgICAgIGRlZiA9IG5ldyBEYXRlKG5ldyBEYXRlKCkuc2V0SG91cnMoMCwgMCwgMCwgMCkpO1xuXG4gICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGlmICh3aGVlbE9yZGVyLmRkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGQgPSBkYXRhW3doZWVsT3JkZXIuZGRdLnNwbGl0KCctJyk7XG4gICAgICBkID0gbmV3IERhdGUoZFswXSwgZFsxXSAtIDEsIGRbMl0pO1xuICAgIH1cblxuICAgIGlmICh3aGVlbE9yZGVyLnR0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGQgPSBkIHx8IGRlZjtcbiAgICAgIGQgPSBuZXcgRGF0ZShkLmdldFRpbWUoKSArIGRhdGFbd2hlZWxPcmRlci50dF0gJSA4NjQwMCAqIDEwMDApO1xuICAgIH1cblxuICAgIHZhciB5ZWFyID0gZ2V0QXJyYXlQYXJ0KGRhdGEsICd5JywgZCwgZGVmKSxcbiAgICAgICAgbW9udGggPSBnZXRBcnJheVBhcnQoZGF0YSwgJ20nLCBkLCBkZWYpLFxuICAgICAgICBkYXkgPSBNYXRoLm1pbihnZXRBcnJheVBhcnQoZGF0YSwgJ2QnLCBkLCBkZWYpLCBzLmdldE1heERheU9mTW9udGgoeWVhciwgbW9udGgpKSxcbiAgICAgICAgaG91ciA9IGdldEFycmF5UGFydChkYXRhLCAnaCcsIGQsIGRlZik7XG4gICAgcmV0dXJuIHMuZ2V0RGF0ZSh5ZWFyLCBtb250aCwgZGF5LCBoYXNBbVBtICYmIGdldEFycmF5UGFydChkYXRhLCAnYScsIGQsIGRlZikgPyBob3VyICsgMTIgOiBob3VyLCBnZXRBcnJheVBhcnQoZGF0YSwgJ2knLCBkLCBkZWYpLCBnZXRBcnJheVBhcnQoZGF0YSwgJ3MnLCBkLCBkZWYpLCBnZXRBcnJheVBhcnQoZGF0YSwgJ3UnLCBkLCBkZWYpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEFycmF5KGQsIGZpbGxJbm5lcikge1xuICAgIHZhciBpLFxuICAgICAgICBwYXJ0LFxuICAgICAgICBwYXJ0cyA9IFsneScsICdtJywgJ2QnLCAnYScsICdoJywgJ2knLCAncycsICd1JywgJ2RkJywgJ3R0J10sXG4gICAgICAgIHJldCA9IFtdO1xuXG4gICAgaWYgKGQgPT09IG51bGwgfHwgZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhcnQgPSBwYXJ0c1tpXTtcblxuICAgICAgaWYgKHdoZWVsT3JkZXJbcGFydF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXRbd2hlZWxPcmRlcltwYXJ0XV0gPSBnZXREYXRlUGFydFtwYXJ0XShkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpbGxJbm5lcikge1xuICAgICAgICBpbm5lclZhbHVlc1twYXJ0XSA9IGdldERhdGVQYXJ0W3BhcnRdKGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH0gLy8gLS0tIFRSSUFMIFNFUlZFUiBDT0RFIFNUQVJUIC0tLVxuXG5cbiAgZnVuY3Rpb24gZ2V0RGF0ZUluZGV4KGQsIGhhc0RheSkge1xuICAgIHJldHVybiBoYXNEYXkgPyAvLyBOdW1iZXIgb2YgZGF5cyBzaW5jZSAxOTcwLTAxLTAxXG4gICAgTWF0aC5mbG9vcihuZXcgRGF0ZShkKSAvIDguNjRlNykgOiAvLyBOdW1iZXIgb2YgbW9udGggc2luY2UgMTk3MC0wMS0wMVxuICAgIGQuZ2V0TW9udGgoKSArIDEyICogKGQuZ2V0RnVsbFllYXIoKSAtIDE5NzApO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0WWVhclZhbHVlKGkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGksXG4gICAgICBkaXNwbGF5OiAoL3l5L2kudGVzdChkYXRlRGlzcGxheSkgPyBpIDogKGkgKyAnJykuc3Vic3RyKDIsIDIpKSArIChzLnllYXJTdWZmaXggfHwgJycpXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFllYXJJbmRleCh2KSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREYXRlV2hlZWwodGVtcGxhdGUpIHtcbiAgICB2YXIgaGFzRGF5ID0gL2QvaS50ZXN0KHRlbXBsYXRlKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6ICcnLFxuICAgICAgY3NzQ2xhc3M6ICdtYnNjLWR0LXdobC1kYXRlJyxcbiAgICAgIG1pbjogbWluRGF0ZSA/IGdldERhdGVJbmRleChnZXRGdWxsRGF0ZShtaW5EYXRlKSwgaGFzRGF5KSA6IHVuZGVmaW5lZCxcbiAgICAgIG1heDogbWF4RGF0ZSA/IGdldERhdGVJbmRleChnZXRGdWxsRGF0ZShtYXhEYXRlKSwgaGFzRGF5KSA6IHVuZGVmaW5lZCxcbiAgICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoaSkge1xuICAgICAgICB2YXIgdG9kYXkgPSBuZXcgRGF0ZShuZXcgRGF0ZSgpLnNldEhvdXJzKDAsIDAsIDAsIDApKSxcbiAgICAgICAgICAgIGQgPSBoYXNEYXkgPyBuZXcgRGF0ZShpICogOC42NGU3KSA6IG5ldyBEYXRlKDE5NzAsIGksIDEpO1xuXG4gICAgICAgIGlmIChoYXNEYXkpIHtcbiAgICAgICAgICBkID0gbmV3IERhdGUoZC5nZXRVVENGdWxsWWVhcigpLCBkLmdldFVUQ01vbnRoKCksIGQuZ2V0VVRDRGF0ZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaW52YWxpZDogaGFzRGF5ICYmICFpc1ZhbGlkKGQsIHRydWUpLFxuICAgICAgICAgIHZhbHVlOiBnZXRGdWxsRGF0ZShkKSxcbiAgICAgICAgICBkaXNwbGF5OiB0b2RheS5nZXRUaW1lKCkgPT0gZC5nZXRUaW1lKCkgPyBzLnRvZGF5VGV4dCA6IGZvcm1hdERhdGUodGVtcGxhdGUsIGQsIHMpXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgZ2V0SW5kZXg6IGZ1bmN0aW9uIGdldEluZGV4KHYpIHtcbiAgICAgICAgcmV0dXJuIGdldERhdGVJbmRleCh2LCBoYXNEYXkpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUaW1lV2hlZWwodGVtcGxhdGUpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgc3RlcCxcbiAgICAgICAgdGltZSxcbiAgICAgICAgdmFsdWVzID0gW107XG5cbiAgICBpZiAoL3MvaS50ZXN0KHRlbXBsYXRlKSkge1xuICAgICAgc3RlcCA9IHN0ZXBTZWNvbmQ7XG4gICAgfSBlbHNlIGlmICgvaS9pLnRlc3QodGVtcGxhdGUpKSB7XG4gICAgICBzdGVwID0gc3RlcE1pbnV0ZSAqIDYwO1xuICAgIH0gZWxzZSBpZiAoL2gvaS50ZXN0KHRlbXBsYXRlKSkge1xuICAgICAgc3RlcCA9IHN0ZXBIb3VyICogMzYwMDtcbiAgICB9XG5cbiAgICB0aW1lU3RlcCA9IHN0ZXBzLnR0ID0gc3RlcDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCA4NjQwMDsgaSArPSBzdGVwKSB7XG4gICAgICB0aW1lID0gbmV3IERhdGUobmV3IERhdGUoKS5zZXRIb3VycygwLCAwLCAwLCAwKSArIGkgKiAxMDAwKTtcbiAgICAgIHZhbHVlcy5wdXNoKHtcbiAgICAgICAgdmFsdWU6IGksXG4gICAgICAgIGRpc3BsYXk6IGZvcm1hdERhdGUodGVtcGxhdGUsIHRpbWUsIHMpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6ICcnLFxuICAgICAgY3NzQ2xhc3M6ICdtYnNjLWR0LXdobC10aW1lJyxcbiAgICAgIGRhdGE6IHZhbHVlc1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRXaGVlbHMoKSB7XG4gICAgdmFyIGRhdGVQYXJ0cyxcbiAgICAgICAgdGltZVBhcnRzLFxuICAgICAgICB0ZW1wbGF0ZSxcbiAgICAgICAgaSxcbiAgICAgICAgaixcbiAgICAgICAgdHlwZXMsXG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgbW9udGhTdHIsXG4gICAgICAgIG5yID0gMCxcbiAgICAgICAgd2hlZWxzID0gW10sXG4gICAgICAgIGRhdGVHcm91cCA9IFtdLFxuICAgICAgICB0aW1lR3JvdXAgPSBbXTtcblxuICAgIGlmICgvZGF0ZS9pLnRlc3QocHJlc2V0KSkge1xuICAgICAgZGF0ZVBhcnRzID0gZGF0ZVdoZWVscy5zcGxpdCgvXFx8Ly50ZXN0KGRhdGVXaGVlbHMpID8gJ3wnIDogJycpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZGF0ZVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRlbXBsYXRlID0gZGF0ZVBhcnRzW2ldO1xuICAgICAgICB0eXBlcyA9IDA7XG5cbiAgICAgICAgaWYgKHRlbXBsYXRlLmxlbmd0aCkge1xuICAgICAgICAgIC8vIElmIGNvbnRhaW5zIGRpZmZlcmVudCBjaGFyYWN0ZXJzXG4gICAgICAgICAgaWYgKC95L2kudGVzdCh0ZW1wbGF0ZSkpIHtcbiAgICAgICAgICAgIGlzb1BhcnRzLnkgPSAxO1xuICAgICAgICAgICAgdHlwZXMrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoL20vaS50ZXN0KHRlbXBsYXRlKSkge1xuICAgICAgICAgICAgaXNvUGFydHMueSA9IDE7XG4gICAgICAgICAgICBpc29QYXJ0cy5tID0gMTtcbiAgICAgICAgICAgIHR5cGVzKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKC9kL2kudGVzdCh0ZW1wbGF0ZSkpIHtcbiAgICAgICAgICAgIGlzb1BhcnRzLnkgPSAxO1xuICAgICAgICAgICAgaXNvUGFydHMubSA9IDE7XG4gICAgICAgICAgICBpc29QYXJ0cy5kID0gMTtcbiAgICAgICAgICAgIHR5cGVzKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVzID4gMSAmJiB3aGVlbE9yZGVyLmRkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdoZWVsT3JkZXIuZGQgPSBucjtcbiAgICAgICAgICAgIG5yKys7XG4gICAgICAgICAgICBkYXRlR3JvdXAucHVzaChnZXREYXRlV2hlZWwodGVtcGxhdGUpKTtcbiAgICAgICAgICAgIHRpbWVHcm91cCA9IGRhdGVHcm91cDsgLy8gVE9ETyA/Pz9cblxuICAgICAgICAgICAgb25lRGF0ZVdoZWVsID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKC95L2kudGVzdCh0ZW1wbGF0ZSkgJiYgd2hlZWxPcmRlci55ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHdoZWVsT3JkZXIueSA9IG5yO1xuICAgICAgICAgICAgbnIrKzsgLy8gWWVhciB3aGVlbFxuXG4gICAgICAgICAgICBkYXRlR3JvdXAucHVzaCh7XG4gICAgICAgICAgICAgIGNzc0NsYXNzOiAnbWJzYy1kdC13aGwteScsXG4gICAgICAgICAgICAgIGxhYmVsOiBzLnllYXJUZXh0LFxuICAgICAgICAgICAgICBtaW46IG1pbkRhdGUgPyBzLmdldFllYXIobWluRGF0ZSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIG1heDogbWF4RGF0ZSA/IHMuZ2V0WWVhcihtYXhEYXRlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgZGF0YTogZ2V0WWVhclZhbHVlLFxuICAgICAgICAgICAgICBnZXRJbmRleDogZ2V0WWVhckluZGV4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKC9tL2kudGVzdCh0ZW1wbGF0ZSkgJiYgd2hlZWxPcmRlci5tID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIE1vbnRoIHdoZWVsXG4gICAgICAgICAgICB3aGVlbE9yZGVyLm0gPSBucjtcbiAgICAgICAgICAgIHZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgbnIrKztcblxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IDEyOyBqKyspIHtcbiAgICAgICAgICAgICAgbW9udGhTdHIgPSBkYXRlRGlzcGxheS5yZXBsYWNlKC9bZHl8XS9naSwgJycpLnJlcGxhY2UoL21tLywgcGFkKGogKyAxKSArIChzLm1vbnRoU3VmZml4IHx8ICcnKSkucmVwbGFjZSgvbS8sIGogKyAxICsgKHMubW9udGhTdWZmaXggfHwgJycpKTtcbiAgICAgICAgICAgICAgdmFsdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBqLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6IC9NTS8udGVzdChtb250aFN0cikgPyBtb250aFN0ci5yZXBsYWNlKC9NTS8sICc8c3BhbiBjbGFzcz1cIm1ic2MtZHQtbW9udGhcIj4nICsgcy5tb250aE5hbWVzW2pdICsgJzwvc3Bhbj4nKSA6IG1vbnRoU3RyLnJlcGxhY2UoL00vLCAnPHNwYW4gY2xhc3M9XCJtYnNjLWR0LW1vbnRoXCI+JyArIHMubW9udGhOYW1lc1Nob3J0W2pdICsgJzwvc3Bhbj4nKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0ZUdyb3VwLnB1c2goe1xuICAgICAgICAgICAgICBjc3NDbGFzczogJ21ic2MtZHQtd2hsLW0nLFxuICAgICAgICAgICAgICBsYWJlbDogcy5tb250aFRleHQsXG4gICAgICAgICAgICAgIGRhdGE6IHZhbHVlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmICgvZC9pLnRlc3QodGVtcGxhdGUpICYmIHdoZWVsT3JkZXIuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBEYXkgd2hlZWxcbiAgICAgICAgICAgIHdoZWVsT3JkZXIuZCA9IG5yO1xuICAgICAgICAgICAgdmFsdWVzID0gW107XG4gICAgICAgICAgICBucisrO1xuXG4gICAgICAgICAgICBmb3IgKGogPSAxOyBqIDwgMzI7IGorKykge1xuICAgICAgICAgICAgICB2YWx1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGosXG4gICAgICAgICAgICAgICAgZGlzcGxheTogKC9kZC9pLnRlc3QoZGF0ZURpc3BsYXkpID8gcGFkKGopIDogaikgKyAocy5kYXlTdWZmaXggfHwgJycpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlR3JvdXAucHVzaCh7XG4gICAgICAgICAgICAgIGNzc0NsYXNzOiAnbWJzYy1kdC13aGwtZCcsXG4gICAgICAgICAgICAgIGxhYmVsOiBzLmRheVRleHQsXG4gICAgICAgICAgICAgIGRhdGE6IHZhbHVlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdoZWVscy5wdXNoKGRhdGVHcm91cCk7XG4gICAgfVxuXG4gICAgaWYgKC90aW1lL2kudGVzdChwcmVzZXQpKSB7XG4gICAgICB0aW1lUGFydHMgPSB0aW1lV2hlZWxzLnNwbGl0KC9cXHwvLnRlc3QodGltZVdoZWVscykgPyAnfCcgOiAnJyk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aW1lUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0aW1lUGFydHNbaV07XG4gICAgICAgIHR5cGVzID0gMDtcblxuICAgICAgICBpZiAodGVtcGxhdGUubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gSWYgY29udGFpbnMgZGlmZmVyZW50IGNoYXJhY3RlcnNcbiAgICAgICAgICBpZiAoL2gvaS50ZXN0KHRlbXBsYXRlKSkge1xuICAgICAgICAgICAgaXNvUGFydHMuaCA9IDE7XG4gICAgICAgICAgICB0eXBlcysrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgvaS9pLnRlc3QodGVtcGxhdGUpKSB7XG4gICAgICAgICAgICBpc29QYXJ0cy5pID0gMTtcbiAgICAgICAgICAgIHR5cGVzKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKC9zL2kudGVzdCh0ZW1wbGF0ZSkpIHtcbiAgICAgICAgICAgIGlzb1BhcnRzLnMgPSAxO1xuICAgICAgICAgICAgdHlwZXMrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoL2EvaS50ZXN0KHRlbXBsYXRlKSkge1xuICAgICAgICAgICAgdHlwZXMrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZXMgPiAxICYmIHdoZWVsT3JkZXIudHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHdoZWVsT3JkZXIudHQgPSBucjtcbiAgICAgICAgICBucisrO1xuICAgICAgICAgIHRpbWVHcm91cC5wdXNoKGdldFRpbWVXaGVlbCh0ZW1wbGF0ZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKC9oL2kudGVzdCh0ZW1wbGF0ZSkgJiYgd2hlZWxPcmRlci5oID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBIb3VycyB3aGVlbFxuICAgICAgICAgIHZhbHVlcyA9IFtdO1xuICAgICAgICAgIHdoZWVsT3JkZXIuaCA9IG5yO1xuICAgICAgICAgIGlzb1BhcnRzLmggPSAxO1xuICAgICAgICAgIG5yKys7XG5cbiAgICAgICAgICBmb3IgKGogPSBtaW5Ib3VyOyBqIDwgKGhhc0FtUG0gPyAxMiA6IDI0KTsgaiArPSBzdGVwSG91cikge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goe1xuICAgICAgICAgICAgICB2YWx1ZTogaixcbiAgICAgICAgICAgICAgZGlzcGxheTogaGFzQW1QbSAmJiBqID09PSAwID8gMTIgOiAvaGgvaS50ZXN0KHRpbWVEaXNwbGF5KSA/IHBhZChqKSA6IGpcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRpbWVHcm91cC5wdXNoKHtcbiAgICAgICAgICAgIGNzc0NsYXNzOiAnbWJzYy1kdC13aGwtaCcsXG4gICAgICAgICAgICBsYWJlbDogcy5ob3VyVGV4dCxcbiAgICAgICAgICAgIGRhdGE6IHZhbHVlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKC9pL2kudGVzdCh0ZW1wbGF0ZSkgJiYgd2hlZWxPcmRlci5pID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBNaW51dGVzIHdoZWVsXG4gICAgICAgICAgdmFsdWVzID0gW107XG4gICAgICAgICAgd2hlZWxPcmRlci5pID0gbnI7XG4gICAgICAgICAgaXNvUGFydHMuaSA9IDE7XG4gICAgICAgICAgbnIrKztcblxuICAgICAgICAgIGZvciAoaiA9IG1pbk1pbnV0ZTsgaiA8IDYwOyBqICs9IHN0ZXBNaW51dGUpIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdmFsdWU6IGosXG4gICAgICAgICAgICAgIGRpc3BsYXk6IC9paS9pLnRlc3QodGltZURpc3BsYXkpID8gcGFkKGopIDogalxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGltZUdyb3VwLnB1c2goe1xuICAgICAgICAgICAgY3NzQ2xhc3M6ICdtYnNjLWR0LXdobC1pJyxcbiAgICAgICAgICAgIGxhYmVsOiBzLm1pbnV0ZVRleHQsXG4gICAgICAgICAgICBkYXRhOiB2YWx1ZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICgvcy9pLnRlc3QodGVtcGxhdGUpICYmIHdoZWVsT3JkZXIucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gU2Vjb25kcyB3aGVlbFxuICAgICAgICAgIHZhbHVlcyA9IFtdO1xuICAgICAgICAgIHdoZWVsT3JkZXIucyA9IG5yO1xuICAgICAgICAgIGlzb1BhcnRzLnMgPSAxO1xuICAgICAgICAgIG5yKys7XG5cbiAgICAgICAgICBmb3IgKGogPSBtaW5TZWNvbmQ7IGogPCA2MDsgaiArPSBzdGVwU2Vjb25kKSB7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaCh7XG4gICAgICAgICAgICAgIHZhbHVlOiBqLFxuICAgICAgICAgICAgICBkaXNwbGF5OiAvc3MvaS50ZXN0KHRpbWVEaXNwbGF5KSA/IHBhZChqKSA6IGpcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRpbWVHcm91cC5wdXNoKHtcbiAgICAgICAgICAgIGNzc0NsYXNzOiAnbWJzYy1kdC13aGwtcycsXG4gICAgICAgICAgICBsYWJlbDogcy5zZWNUZXh0LFxuICAgICAgICAgICAgZGF0YTogdmFsdWVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoL2EvaS50ZXN0KHRlbXBsYXRlKSAmJiB3aGVlbE9yZGVyLmEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHdoZWVsT3JkZXIuYSA9IG5yO1xuICAgICAgICAgIG5yKys7XG4gICAgICAgICAgdGltZUdyb3VwLnB1c2goe1xuICAgICAgICAgICAgY3NzQ2xhc3M6ICdtYnNjLWR0LXdobC1hJyxcbiAgICAgICAgICAgIGxhYmVsOiBzLmFtcG1UZXh0LFxuICAgICAgICAgICAgZGF0YTogL0EvLnRlc3QodGVtcGxhdGUpID8gW3tcbiAgICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICAgIGRpc3BsYXk6IHMuYW1UZXh0LnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgdmFsdWU6IDEsXG4gICAgICAgICAgICAgIGRpc3BsYXk6IHMucG1UZXh0LnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgIH1dIDogW3tcbiAgICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICAgIGRpc3BsYXk6IHMuYW1UZXh0XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIHZhbHVlOiAxLFxuICAgICAgICAgICAgICBkaXNwbGF5OiBzLnBtVGV4dFxuICAgICAgICAgICAgfV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGltZUdyb3VwICE9IGRhdGVHcm91cCkge1xuICAgICAgICB3aGVlbHMucHVzaCh0aW1lR3JvdXApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB3aGVlbHM7XG4gIH0gLy8gLS0tIFRSSUFMIFNFUlZFUiBDT0RFIEVORCAtLS1cblxuXG4gIGZ1bmN0aW9uIGdldEh0bWw1T3B0aW9ucygkZWxtKSB7XG4gICAgdmFyIGZvcm1hdCxcbiAgICAgICAgbWluLFxuICAgICAgICBtYXgsXG4gICAgICAgIHJldCA9IHt9OyAvLyBGb3JjZSBmb3JtYXQgZm9yIGh0bWw1IGRhdGUgaW5wdXRzIChleHBlcmltZW50YWwpXG5cbiAgICBpZiAoJGVsbS5pcygnaW5wdXQnKSkge1xuICAgICAgc3dpdGNoICgkZWxtLmF0dHIoJ3R5cGUnKSkge1xuICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICBmb3JtYXQgPSAneXktbW0tZGQnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2RhdGV0aW1lJzpcbiAgICAgICAgICBmb3JtYXQgPSAneXktbW0tZGRUSEg6aWk6c3NaJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYXRldGltZS1sb2NhbCc6XG4gICAgICAgICAgZm9ybWF0ID0gJ3l5LW1tLWRkVEhIOmlpOnNzJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgZm9ybWF0ID0gJ3l5LW1tJztcbiAgICAgICAgICByZXQuZGF0ZU9yZGVyID0gJ21teXknO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3RpbWUnOlxuICAgICAgICAgIGZvcm1hdCA9ICdISDppaTpzcyc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldC5mb3JtYXQgPSBmb3JtYXQ7IC8vIENoZWNrIGZvciBtaW4vbWF4IGF0dHJpYnV0ZXNcblxuICAgICAgbWluID0gJGVsbS5hdHRyKCdtaW4nKTtcbiAgICAgIG1heCA9ICRlbG0uYXR0cignbWF4Jyk7XG5cbiAgICAgIGlmIChtaW4gJiYgbWluICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldC5taW4gPSBwYXJzZURhdGUoZm9ybWF0LCBtaW4pO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF4ICYmIG1heCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXQubWF4ID0gcGFyc2VEYXRlKGZvcm1hdCwgbWF4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2xvc2VzdFZhbGlkRGF0ZShkLCBkaXIpIHtcbiAgICB2YXIgbmV4dCxcbiAgICAgICAgcHJldixcbiAgICAgICAgbmV4dFZhbGlkID0gZmFsc2UsXG4gICAgICAgIHByZXZWYWxpZCA9IGZhbHNlLFxuICAgICAgICB1cCA9IDAsXG4gICAgICAgIGRvd24gPSAwLFxuICAgICAgICAvLyBOb3JtYWxpemUgbWluIGFuZCBtYXggZGF0ZXMgZm9yIGNvbXBhcmluZyBsYXRlciAoc2V0IGRlZmF1bHQgdmFsdWVzIHdoZXJlIHRoZXJlIGFyZSBubyB2YWx1ZXMgZnJvbSB3aGVlbHMpXG4gICAgbWluZCA9IG1pbkRhdGUgPyBnZXREYXRlKGdldEFycmF5KG1pbkRhdGUpKSA6IC1JbmZpbml0eSxcbiAgICAgICAgbWF4ZCA9IG1heERhdGUgPyBnZXREYXRlKGdldEFycmF5KG1heERhdGUpKSA6IEluZmluaXR5O1xuXG4gICAgaWYgKGlzVmFsaWQoZCkpIHtcbiAgICAgIHJldHVybiBkO1xuICAgIH1cblxuICAgIGlmIChkIDwgbWluZCkge1xuICAgICAgZCA9IG1pbmQ7XG4gICAgfVxuXG4gICAgaWYgKGQgPiBtYXhkKSB7XG4gICAgICBkID0gbWF4ZDtcbiAgICB9XG5cbiAgICBuZXh0ID0gZDtcbiAgICBwcmV2ID0gZDtcblxuICAgIGlmIChkaXIgIT09IDIpIHtcbiAgICAgIG5leHRWYWxpZCA9IGlzVmFsaWQobmV4dCwgdHJ1ZSk7XG5cbiAgICAgIHdoaWxlICghbmV4dFZhbGlkICYmIG5leHQgPCBtYXhkICYmIHVwIDwgMTAwKSB7XG4gICAgICAgIG5leHQgPSBuZXcgRGF0ZShuZXh0LmdldFRpbWUoKSArIDEwMDAgKiA2MCAqIDYwICogMjQpO1xuICAgICAgICBuZXh0VmFsaWQgPSBpc1ZhbGlkKG5leHQsIHRydWUpO1xuICAgICAgICB1cCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkaXIgIT09IDEpIHtcbiAgICAgIHByZXZWYWxpZCA9IGlzVmFsaWQocHJldiwgdHJ1ZSk7XG5cbiAgICAgIHdoaWxlICghcHJldlZhbGlkICYmIHByZXYgPiBtaW5kICYmIGRvd24gPCAxMDApIHtcbiAgICAgICAgcHJldiA9IG5ldyBEYXRlKHByZXYuZ2V0VGltZSgpIC0gMTAwMCAqIDYwICogNjAgKiAyNCk7XG4gICAgICAgIHByZXZWYWxpZCA9IGlzVmFsaWQocHJldiwgdHJ1ZSk7XG4gICAgICAgIGRvd24rKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGlyID09PSAxICYmIG5leHRWYWxpZCkge1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxuXG4gICAgaWYgKGRpciA9PT0gMiAmJiBwcmV2VmFsaWQpIHtcbiAgICAgIHJldHVybiBwcmV2O1xuICAgIH1cblxuICAgIGlmIChpc1NhbWVNb250aChkLCBuZXh0KSkge1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxuXG4gICAgaWYgKGlzU2FtZU1vbnRoKGQsIHByZXYpKSB7XG4gICAgICByZXR1cm4gcHJldjtcbiAgICB9XG5cbiAgICByZXR1cm4gZG93biA8PSB1cCAmJiBwcmV2VmFsaWQgPyBwcmV2IDogbmV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU2FtZU1vbnRoKGQxLCBkMikge1xuICAgIHJldHVybiBzLmdldFllYXIoZDEpID09PSBzLmdldFllYXIoZDIpICYmIHMuZ2V0TW9udGgoZDEpID09PSBzLmdldE1vbnRoKGQyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVmFsaWQoZCwgc2tpcCkge1xuICAgIGlmICghc2tpcCAmJiBkIDwgbWluRGF0ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghc2tpcCAmJiBkID4gbWF4RGF0ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpc0luT2JqKGQsIHZhbGlkKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlzSW5PYmooZCwgaW52YWxpZCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSW5PYmooZCwgb2JqKSB7XG4gICAgdmFyIGN1cnIsIGosIHYsIHZhbDtcblxuICAgIGlmIChvYmopIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBvYmoubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY3VyciA9IG9ialtqXTtcbiAgICAgICAgdmFsID0gY3Vyci5kIHx8IGN1cnI7XG4gICAgICAgIHYgPSB2YWwgKyAnJztcblxuICAgICAgICBpZiAoIWN1cnIuc3RhcnQpIHtcbiAgICAgICAgICBpZiAoREFZX09GX1dFRUsudGVzdCh2KSkge1xuICAgICAgICAgICAgLy8gRGF5IG9mIHdlZWtcbiAgICAgICAgICAgIHYgPSArdi5yZXBsYWNlKCd3JywgJycpO1xuXG4gICAgICAgICAgICBpZiAodiA9PSBkLmdldERheSgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoREFZX09GX01PTlRILnRlc3QodikpIHtcbiAgICAgICAgICAgIC8vIERheSBvZiBtb250aDogJzInIG9yICcxMi8yNCdcbiAgICAgICAgICAgIHYgPSB2LnNwbGl0KCcvJyk7XG5cbiAgICAgICAgICAgIGlmICh2WzFdKSB7XG4gICAgICAgICAgICAgIGlmICh2WzBdIC0gMSA9PSBkLmdldE1vbnRoKCkgJiYgdlsxXSA9PSBkLmdldERhdGUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZbMF0gPT0gZC5nZXREYXRlKCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEV4YWN0IGRhdGVcbiAgICAgICAgICAgIGN1cnIgPSBtYWtlRGF0ZSh2YWwsIGZvcm1hdCwgcyk7XG5cbiAgICAgICAgICAgIGlmIChkLmdldEZ1bGxZZWFyKCkgPT0gY3Vyci5nZXRGdWxsWWVhcigpICYmIGQuZ2V0TW9udGgoKSA9PSBjdXJyLmdldE1vbnRoKCkgJiYgZC5nZXREYXRlKCkgPT0gY3Vyci5nZXREYXRlKCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVEYXRlcyhvYmosIHksIG0sIGZpcnN0LCBtYXhkYXlzLCBpbnZhbGlkcywgdmFsKSB7XG4gICAgdmFyIGQsIGRkLCBqLCBrLCB2O1xuXG4gICAgaWYgKG9iaikge1xuICAgICAgZm9yIChqID0gMDsgaiA8IG9iai5sZW5ndGg7IGorKykge1xuICAgICAgICBkID0gb2JqW2pdO1xuICAgICAgICBkZCA9IGQuZCB8fCBkO1xuICAgICAgICB2ID0gZGQgKyAnJztcblxuICAgICAgICBpZiAoIWQuc3RhcnQpIHtcbiAgICAgICAgICBpZiAoREFZX09GX1dFRUsudGVzdCh2KSkge1xuICAgICAgICAgICAgLy8gRGF5IG9mIHdlZWtcbiAgICAgICAgICAgIHYgPSArdi5yZXBsYWNlKCd3JywgJycpO1xuXG4gICAgICAgICAgICBmb3IgKGsgPSB2IC0gZmlyc3Q7IGsgPCBtYXhkYXlzOyBrICs9IDcpIHtcbiAgICAgICAgICAgICAgaWYgKGsgPj0gMCkge1xuICAgICAgICAgICAgICAgIGludmFsaWRzW2sgKyAxXSA9IHZhbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoREFZX09GX01PTlRILnRlc3QodikpIHtcbiAgICAgICAgICAgIC8vIERheSBvZiBtb250aDogJzInIG9yICcxMi8yNCdcbiAgICAgICAgICAgIHYgPSB2LnNwbGl0KCcvJyk7XG5cbiAgICAgICAgICAgIGlmICh2WzFdKSB7XG4gICAgICAgICAgICAgIGlmICh2WzBdIC0gMSA9PSBtKSB7XG4gICAgICAgICAgICAgICAgaW52YWxpZHNbdlsxXV0gPSB2YWw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGludmFsaWRzW3ZbMF1dID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBFeGFjdCBkYXRlXG4gICAgICAgICAgICBkID0gbWFrZURhdGUoZGQsIGZvcm1hdCwgcyk7XG5cbiAgICAgICAgICAgIGlmIChzLmdldFllYXIoZCkgPT0geSAmJiBzLmdldE1vbnRoKGQpID09IG0pIHtcbiAgICAgICAgICAgICAgaW52YWxpZHNbcy5nZXREYXkoZCldID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlVGltZXModm9iaiwgaW5kZXgsIHYsIHksIG0sIGQsIGludmFsaWRzLCB2YWxpZCkge1xuICAgIHZhciBhZGQsXG4gICAgICAgIGFsbCxcbiAgICAgICAgZGQsXG4gICAgICAgIGhvdXJzMSxcbiAgICAgICAgaG91cnMyLFxuICAgICAgICBob3VyczMsXG4gICAgICAgIGksXG4gICAgICAgIGkxLFxuICAgICAgICBpMixcbiAgICAgICAgaixcbiAgICAgICAgb2JqLFxuICAgICAgICBwYXJ0czEsXG4gICAgICAgIHBhcnRzMixcbiAgICAgICAgcHJvcDEsXG4gICAgICAgIHByb3AyLFxuICAgICAgICByZW1vdmUsXG4gICAgICAgIHNzLFxuICAgICAgICBzdHIsXG4gICAgICAgIHYxLFxuICAgICAgICB2MixcbiAgICAgICAgc3BlYyA9IHt9LFxuICAgICAgICBkYXkgPSBzLmdldERhdGUoeSwgbSwgZCksXG4gICAgICAgIHcgPSBbJ2EnLCAnaCcsICdpJywgJ3MnXTtcblxuICAgIGlmICh2b2JqKSB7XG4gICAgICAvLyBDaGVjayBpZiBydWxlcyBhcHBseSB0byB0aGUgc2VsZWN0ZWQgZGF0ZVxuICAgICAgZm9yIChpID0gMDsgaSA8IHZvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgb2JqID0gdm9ialtpXTtcblxuICAgICAgICBpZiAob2JqLnN0YXJ0KSB7XG4gICAgICAgICAgb2JqLmFwcGx5ID0gZmFsc2U7XG4gICAgICAgICAgZGQgPSBvYmouZDtcbiAgICAgICAgICBzcyA9IGRkICsgJyc7XG4gICAgICAgICAgc3RyID0gc3Muc3BsaXQoJy8nKTtcblxuICAgICAgICAgIGlmIChkZCAmJiAoZGQuZ2V0VGltZSAmJiB5ID09IHMuZ2V0WWVhcihkZCkgJiYgbSA9PSBzLmdldE1vbnRoKGRkKSAmJiBkID09IHMuZ2V0RGF5KGRkKSB8fCAvLyBFeGFjdCBkYXRlXG4gICAgICAgICAgIURBWV9PRl9XRUVLLnRlc3Qoc3MpICYmIChzdHJbMV0gJiYgZCA9PSBzdHJbMV0gJiYgbSA9PSBzdHJbMF0gLSAxIHx8ICFzdHJbMV0gJiYgZCA9PSBzdHJbMF0pIHx8IC8vIERheSBvZiBtb250aFxuICAgICAgICAgIERBWV9PRl9XRUVLLnRlc3Qoc3MpICYmIGRheS5nZXREYXkoKSA9PSArc3MucmVwbGFjZSgndycsICcnKSAvLyBEYXkgb2Ygd2Vla1xuICAgICAgICAgICkpIHtcbiAgICAgICAgICAgIG9iai5hcHBseSA9IHRydWU7XG4gICAgICAgICAgICBzcGVjW2RheV0gPSB0cnVlOyAvLyBQcmV2ZW50IGFwcGx5aW5nIGdlbmVyaWMgcnVsZSBvbiBkYXksIGlmIHNwZWNpZmljIGV4aXN0c1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBBcHBseSBydWxlc1xuXG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB2b2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG9iaiA9IHZvYmpbaV07XG4gICAgICAgIGFkZCA9IDA7XG4gICAgICAgIHJlbW92ZSA9IDA7XG4gICAgICAgIGkxID0gbWluc1t2XTtcbiAgICAgICAgaTIgPSBtYXhzW3ZdO1xuICAgICAgICBwcm9wMSA9IHRydWU7XG4gICAgICAgIHByb3AyID0gdHJ1ZTtcbiAgICAgICAgYWxsID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKG9iai5zdGFydCAmJiAob2JqLmFwcGx5IHx8ICFvYmouZCAmJiAhc3BlY1tkYXldKSkge1xuICAgICAgICAgIC8vIERlZmluZSB0aW1lIHBhcnRzXG4gICAgICAgICAgcGFydHMxID0gb2JqLnN0YXJ0LnNwbGl0KCc6Jyk7XG4gICAgICAgICAgcGFydHMyID0gb2JqLmVuZC5zcGxpdCgnOicpO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IDM7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnRzMVtqXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHBhcnRzMVtqXSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXJ0czJbal0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBwYXJ0czJbal0gPSA1OTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFydHMxW2pdID0gK3BhcnRzMVtqXTtcbiAgICAgICAgICAgIHBhcnRzMltqXSA9ICtwYXJ0czJbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHYgPT0gJ3R0Jykge1xuICAgICAgICAgICAgLy8gV2hlZWwgY29udGFpbmluZyBmdWxsIHRpbWVcbiAgICAgICAgICAgIGkxID0gc3RlcChNYXRoLnJvdW5kKChuZXcgRGF0ZShkYXkpLnNldEhvdXJzKHBhcnRzMVswXSwgcGFydHMxWzFdLCBwYXJ0czFbMl0pIC0gbmV3IERhdGUoZGF5KS5zZXRIb3VycygwLCAwLCAwLCAwKSkgLyAxMDAwKSwgdGltZVN0ZXAsIDAsIDg2NDAwKTtcbiAgICAgICAgICAgIGkyID0gc3RlcChNYXRoLnJvdW5kKChuZXcgRGF0ZShkYXkpLnNldEhvdXJzKHBhcnRzMlswXSwgcGFydHMyWzFdLCBwYXJ0czJbMl0pIC0gbmV3IERhdGUoZGF5KS5zZXRIb3VycygwLCAwLCAwLCAwKSkgLyAxMDAwKSwgdGltZVN0ZXAsIDAsIDg2NDAwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFydHMxLnVuc2hpZnQocGFydHMxWzBdID4gMTEgPyAxIDogMCk7XG4gICAgICAgICAgICBwYXJ0czIudW5zaGlmdChwYXJ0czJbMF0gPiAxMSA/IDEgOiAwKTtcblxuICAgICAgICAgICAgaWYgKGhhc0FtUG0pIHtcbiAgICAgICAgICAgICAgaWYgKHBhcnRzMVsxXSA+PSAxMikge1xuICAgICAgICAgICAgICAgIHBhcnRzMVsxXSA9IHBhcnRzMVsxXSAtIDEyO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHBhcnRzMlsxXSA+PSAxMikge1xuICAgICAgICAgICAgICAgIHBhcnRzMlsxXSA9IHBhcnRzMlsxXSAtIDEyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIExvb2sgYmVoaW5kXG5cblxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGluZGV4OyBqKyspIHtcbiAgICAgICAgICAgICAgaWYgKHZhbGlkVmFsdWVzW2pdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2MSA9IHN0ZXAocGFydHMxW2pdLCBzdGVwc1t3W2pdXSwgbWluc1t3W2pdXSwgbWF4c1t3W2pdXSk7XG4gICAgICAgICAgICAgICAgdjIgPSBzdGVwKHBhcnRzMltqXSwgc3RlcHNbd1tqXV0sIG1pbnNbd1tqXV0sIG1heHNbd1tqXV0pO1xuICAgICAgICAgICAgICAgIGhvdXJzMSA9IDA7XG4gICAgICAgICAgICAgICAgaG91cnMyID0gMDtcbiAgICAgICAgICAgICAgICBob3VyczMgPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKGhhc0FtUG0gJiYgaiA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICBob3VyczEgPSBwYXJ0czFbMF0gPyAxMiA6IDA7XG4gICAgICAgICAgICAgICAgICBob3VyczIgPSBwYXJ0czJbMF0gPyAxMiA6IDA7XG4gICAgICAgICAgICAgICAgICBob3VyczMgPSB2YWxpZFZhbHVlc1swXSA/IDEyIDogMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXByb3AxKSB7XG4gICAgICAgICAgICAgICAgICB2MSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFwcm9wMikge1xuICAgICAgICAgICAgICAgICAgdjIgPSBtYXhzW3dbal1dO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICgocHJvcDEgfHwgcHJvcDIpICYmIHYxICsgaG91cnMxIDwgdmFsaWRWYWx1ZXNbal0gKyBob3VyczMgJiYgdmFsaWRWYWx1ZXNbal0gKyBob3VyczMgPCB2MiArIGhvdXJzMikge1xuICAgICAgICAgICAgICAgICAgYWxsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsaWRWYWx1ZXNbal0gIT0gdjEpIHtcbiAgICAgICAgICAgICAgICAgIHByb3AxID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkVmFsdWVzW2pdICE9IHYyKSB7XG4gICAgICAgICAgICAgICAgICBwcm9wMiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAvLyBMb29rIGFoZWFkXG5cblxuICAgICAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgICBmb3IgKGogPSBpbmRleCArIDE7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocGFydHMxW2pdID4gMCkge1xuICAgICAgICAgICAgICAgICAgYWRkID0gc3RlcHNbdl07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzMltqXSA8IG1heHNbd1tqXV0pIHtcbiAgICAgICAgICAgICAgICAgIHJlbW92ZSA9IHN0ZXBzW3ZdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWFsbCkge1xuICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgbWluIGFuZCBtYXggdmFsdWVzXG4gICAgICAgICAgICAgIHYxID0gc3RlcChwYXJ0czFbaW5kZXhdLCBzdGVwc1t2XSwgbWluc1t2XSwgbWF4c1t2XSkgKyBhZGQ7XG4gICAgICAgICAgICAgIHYyID0gc3RlcChwYXJ0czJbaW5kZXhdLCBzdGVwc1t2XSwgbWluc1t2XSwgbWF4c1t2XSkgLSByZW1vdmU7XG5cbiAgICAgICAgICAgICAgaWYgKHByb3AxKSB7XG4gICAgICAgICAgICAgICAgaTEgPSB2MTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChwcm9wMikge1xuICAgICAgICAgICAgICAgIGkyID0gdjI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIERpc2FibGUgdmFsdWVzXG5cblxuICAgICAgICAgIGlmIChwcm9wMSB8fCBwcm9wMiB8fCBhbGwpIHtcbiAgICAgICAgICAgIGZvciAoaiA9IGkxOyBqIDw9IGkyOyBqICs9IHN0ZXBzW3ZdKSB7XG4gICAgICAgICAgICAgIGludmFsaWRzW2pdID0gIXZhbGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyAtLS0gVFJJQUwgU0VSVkVSIENPREUgU1RBUlQgLS0tXG5cblxuICB2YXIgdGltZVN0ZXAsXG4gICAgICBvbmVEYXRlV2hlZWwsXG4gICAgICB3aGVlbHMsXG4gICAgICB3aGVlbE9yZGVyID0ge30sXG4gICAgICBpbm5lclZhbHVlcyA9IHt9LFxuICAgICAgaXNvUGFydHMgPSB7fSxcbiAgICAgIHZhbGlkVmFsdWVzID0gW10sXG4gICAgICBodG1sNWRlZiA9IGdldEh0bWw1T3B0aW9ucygkJDEodGhpcykpLFxuICAgICAgb3JpZyA9IGV4dGVuZCQxKHt9LCBpbnN0LnNldHRpbmdzKSxcbiAgICAgIGNhbGVuZGFyU3lzdGVtID0gY2FsZW5kYXJzW29yaWcuY2FsZW5kYXJTeXN0ZW1dLFxuICAgICAgcyA9IGV4dGVuZCQxKGluc3Quc2V0dGluZ3MsIGRhdGVUaW1lRGVmYXVsdHMsIGNhbGVuZGFyU3lzdGVtLCBkZWZhdWx0cyQxLCBodG1sNWRlZiwgb3JpZyksXG4gICAgICBwcmVzZXQgPSBzLnByZXNldCxcbiAgICAgIGRpc3BsYXlGb3JtYXQgPSBwcmVzZXQgPT0gJ2RhdGV0aW1lJyA/IHMuZGF0ZUZvcm1hdCArIHMuc2VwYXJhdG9yICsgcy50aW1lRm9ybWF0IDogcHJlc2V0ID09ICd0aW1lJyA/IHMudGltZUZvcm1hdCA6IHMuZGF0ZUZvcm1hdCxcbiAgICAgIGZvcm1hdCA9IGh0bWw1ZGVmLmZvcm1hdCB8fCBkaXNwbGF5Rm9ybWF0LFxuICAgICAgZGF0ZVdoZWVscyA9IHMuZGF0ZVdoZWVscyB8fCBzLmRhdGVGb3JtYXQsXG4gICAgICB0aW1lV2hlZWxzID0gcy50aW1lV2hlZWxzIHx8IHMudGltZUZvcm1hdCxcbiAgICAgIC8vZGF0ZVdoZWVscyA9ICd8RCBNIGR8JywgLy8gVE9ETyBzZXR0aW5nc1xuICAvL3RpbWVXaGVlbHMgPSAnfGh8aWl8QXwnLFxuICBkYXRlRGlzcGxheSA9IHMuZGF0ZVdoZWVscyB8fCBzLmRhdGVEaXNwbGF5LFxuICAgICAgdGltZURpc3BsYXkgPSB0aW1lV2hlZWxzLFxuICAgICAgYmFzZVRoZW1lID0gcy5iYXNlVGhlbWUgfHwgcy50aGVtZSxcbiAgICAgIGludmFsaWQgPSBjb252ZXJ0UmFuZ2VzKHMuaW52YWxpZCksXG4gICAgICB2YWxpZCA9IGNvbnZlcnRSYW5nZXMocy52YWxpZCksXG4gICAgICBtaW5EYXRlID0gbWFrZURhdGUocy5taW4sIGZvcm1hdCwgcyksXG4gICAgICBtYXhEYXRlID0gbWFrZURhdGUocy5tYXgsIGZvcm1hdCwgcyksXG4gICAgICBoYXNUaW1lID0gL3RpbWUvaS50ZXN0KHByZXNldCksXG4gICAgICBoYXNBbVBtID0gL2gvLnRlc3QodGltZURpc3BsYXkpLFxuICAgICAgZ2VuRGF5TmFtZXMgPSAvRC8udGVzdChkYXRlRGlzcGxheSksXG4gICAgICBzdGVwUGFydHMgPSBzLnN0ZXBzIHx8IHt9LFxuICAgICAgc3RlcEhvdXIgPSBzdGVwUGFydHMuaG91ciB8fCBzLnN0ZXBIb3VyIHx8IDEsXG4gICAgICBzdGVwTWludXRlID0gc3RlcFBhcnRzLm1pbnV0ZSB8fCBzLnN0ZXBNaW51dGUgfHwgMSxcbiAgICAgIHN0ZXBTZWNvbmQgPSBzdGVwUGFydHMuc2Vjb25kIHx8IHMuc3RlcFNlY29uZCB8fCAxLFxuICAgICAgemVyb0Jhc2VkID0gc3RlcFBhcnRzLnplcm9CYXNlZCxcbiAgICAgIG1pbkhvdXIgPSB6ZXJvQmFzZWQgfHwgIW1pbkRhdGUgPyAwIDogbWluRGF0ZS5nZXRIb3VycygpICUgc3RlcEhvdXIsXG4gICAgICBtaW5NaW51dGUgPSB6ZXJvQmFzZWQgfHwgIW1pbkRhdGUgPyAwIDogbWluRGF0ZS5nZXRNaW51dGVzKCkgJSBzdGVwTWludXRlLFxuICAgICAgbWluU2Vjb25kID0gemVyb0Jhc2VkIHx8ICFtaW5EYXRlID8gMCA6IG1pbkRhdGUuZ2V0U2Vjb25kcygpICUgc3RlcFNlY29uZCxcbiAgICAgIG1heEhvdXIgPSBnZXRNYXgoc3RlcEhvdXIsIG1pbkhvdXIsIGhhc0FtUG0gPyAxMSA6IDIzKSxcbiAgICAgIG1heE1pbnV0ZSA9IGdldE1heChzdGVwTWludXRlLCBtaW5NaW51dGUsIDU5KSxcbiAgICAgIG1heFNlY29uZCA9IGdldE1heChzdGVwTWludXRlLCBtaW5NaW51dGUsIDU5KSxcbiAgICAgIG1pbnMgPSB7XG4gICAgeTogbWluRGF0ZSA/IG1pbkRhdGUuZ2V0RnVsbFllYXIoKSA6IC1JbmZpbml0eSxcbiAgICBtOiAwLFxuICAgIGQ6IDEsXG4gICAgaDogbWluSG91cixcbiAgICBpOiBtaW5NaW51dGUsXG4gICAgczogbWluU2Vjb25kLFxuICAgIGE6IDAsXG4gICAgdHQ6IDBcbiAgfSxcbiAgICAgIG1heHMgPSB7XG4gICAgeTogbWF4RGF0ZSA/IG1heERhdGUuZ2V0RnVsbFllYXIoKSA6IEluZmluaXR5LFxuICAgIG06IDExLFxuICAgIGQ6IDMxLFxuICAgIGg6IG1heEhvdXIsXG4gICAgaTogbWF4TWludXRlLFxuICAgIHM6IG1heFNlY29uZCxcbiAgICBhOiAxLFxuICAgIHR0OiA4NjQwMFxuICB9LFxuICAgICAgc3RlcHMgPSB7XG4gICAgeTogMSxcbiAgICBtOiAxLFxuICAgIGQ6IDEsXG4gICAgaDogc3RlcEhvdXIsXG4gICAgaTogc3RlcE1pbnV0ZSxcbiAgICBzOiBzdGVwU2Vjb25kLFxuICAgIGE6IDEsXG4gICAgdHQ6IDFcbiAgfSxcbiAgICAgIHdpZHRocyA9IHtcbiAgICBib290c3RyYXA6IDQ2LFxuICAgIGlvczogNTAsXG4gICAgbWF0ZXJpYWw6IDQ2LFxuICAgIG1vYmlzY3JvbGw6IDQ2LFxuICAgIHdpbmRvd3M6IDUwXG4gIH0sXG4gICAgICBnZXREYXRlUGFydCA9IHtcbiAgICB5OiBnZXRZZWFyLFxuICAgIG06IGdldE1vbnRoLFxuICAgIGQ6IGdldERheSxcbiAgICBoOiBnZXRIb3VycyxcbiAgICBpOiBnZXRNaW51dGVzLFxuICAgIHM6IGdldFNlY29uZHMsXG4gICAgdTogZ2V0TWlsbGlzZWNvbmRzLFxuICAgIGE6IGdldEFtUG0sXG4gICAgZGQ6IGdldEZ1bGxEYXRlLFxuICAgIHR0OiBnZXRGdWxsVGltZVxuICB9OyAvLyAtLS0gVFJJQUwgU0VSVkVSIENPREUgRU5EIC0tLVxuICAvLyBFeHRlbmRlZCBtZXRob2RzXG4gIC8vIC0tLVxuXG4gIGluc3QuZ2V0VmFsID0gZnVuY3Rpb24gKHRlbXApIHtcbiAgICByZXR1cm4gaW5zdC5faGFzVmFsdWUgfHwgdGVtcCA/IHJldHVybkRhdGUoZ2V0RGF0ZShpbnN0LmdldEFycmF5VmFsKHRlbXApKSwgcywgZm9ybWF0KSA6IG51bGw7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHNlbGVjdGVkIGRhdGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt0ZW1wPWZhbHNlXSBJZiB0cnVlLCByZXR1cm4gdGhlIGN1cnJlbnRseSBzaG93biBkYXRlIG9uIHRoZSBwaWNrZXIsIG90aGVyd2lzZSB0aGUgbGFzdCBzZWxlY3RlZCBvbmUuXHJcbiAgICogQHJldHVybiB7RGF0ZX1cclxuICAgKi9cblxuXG4gIGluc3QuZ2V0RGF0ZSA9IGZ1bmN0aW9uICh0ZW1wKSB7XG4gICAgcmV0dXJuIGluc3QuX2hhc1ZhbHVlIHx8IHRlbXAgPyBnZXREYXRlKGluc3QuZ2V0QXJyYXlWYWwodGVtcCkpIDogbnVsbDtcbiAgfTtcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgc2VsZWN0ZWQgZGF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtEYXRlfSBkIERhdGUgdG8gc2VsZWN0LlxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZpbGw9ZmFsc2VdIEFsc28gc2V0IHRoZSB2YWx1ZSBvZiB0aGUgYXNzb2NpYXRlZCBpbnB1dCBlbGVtZW50LiBEZWZhdWx0IGlzIHRydWUuXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lPTBdIEFuaW1hdGlvbiB0aW1lIHRvIHNjcm9sbCB0byB0aGUgc2VsZWN0ZWQgZGF0ZS5cclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt0ZW1wPWZhbHNlXSBTZXQgdGVtcG9yYXJ5IHZhbHVlIG9ubHkuXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbY2hhbmdlPWZpbGxdIFRyaWdnZXIgY2hhbmdlIG9uIGlucHV0IGVsZW1lbnQuXHJcbiAgICovXG5cblxuICBpbnN0LnNldERhdGUgPSBmdW5jdGlvbiAoZCwgZmlsbCwgdGltZSwgdGVtcCwgY2hhbmdlKSB7XG4gICAgaW5zdC5zZXRBcnJheVZhbChnZXRBcnJheShkLCB0cnVlKSwgZmlsbCwgY2hhbmdlLCB0ZW1wLCB0aW1lKTtcbiAgfTsgLy8gLS0tXG4gIC8vIEluaXRpYWxpemF0aW9uc1xuICAvLyAtLS1cblxuXG4gIHdoZWVscyA9IGdldFdoZWVscygpO1xuICBzLmlzb1BhcnRzID0gaXNvUGFydHM7XG4gIGluc3QuX2Zvcm1hdCA9IGRpc3BsYXlGb3JtYXQ7XG4gIGluc3QuX29yZGVyID0gd2hlZWxPcmRlcjtcblxuICBpbnN0LmhhbmRsZXJzLm5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpbnN0LnNldERhdGUobmV3IERhdGUoKSwgaW5zdC5saXZlLCAxMDAwLCB0cnVlLCB0cnVlKTtcbiAgfTtcblxuICBpbnN0LmJ1dHRvbnMubm93ID0ge1xuICAgIHRleHQ6IHMubm93VGV4dCxcbiAgICBpY29uOiBzLm5vd0ljb24sXG4gICAgaGFuZGxlcjogJ25vdydcbiAgfTsgLy8gLS0tXG5cbiAgcmV0dXJuIHtcbiAgICBtaW5XaWR0aDogb25lRGF0ZVdoZWVsICYmIGhhc1RpbWUgPyB3aWR0aHNbYmFzZVRoZW1lXSA6IHVuZGVmaW5lZCxcbiAgICBjb21wQ2xhc3M6ICdtYnNjLWR0IG1ic2Mtc2MnLFxuICAgIHdoZWVsczogd2hlZWxzLFxuICAgIGhlYWRlclRleHQ6IHMuaGVhZGVyVGV4dCA/IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmb3JtYXREYXRlKGRpc3BsYXlGb3JtYXQsIGdldERhdGUoaW5zdC5nZXRBcnJheVZhbCh0cnVlKSksIHMpO1xuICAgIH0gOiBmYWxzZSxcbiAgICBmb3JtYXRWYWx1ZTogZnVuY3Rpb24gZm9ybWF0VmFsdWUoZCkge1xuICAgICAgcmV0dXJuIGZvcm1hdERhdGUoZm9ybWF0LCBnZXREYXRlKGQpLCBzKTtcbiAgICB9LFxuICAgIHBhcnNlVmFsdWU6IGZ1bmN0aW9uIHBhcnNlVmFsdWUodmFsKSB7XG4gICAgICBpZiAoIXZhbCkge1xuICAgICAgICBpbm5lclZhbHVlcyA9IHt9O1xuICAgICAgICBpbnN0Ll9oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0QXJyYXkobWFrZURhdGUodmFsIHx8IHMuZGVmYXVsdFZhbHVlIHx8IG5ldyBEYXRlKCksIGZvcm1hdCwgcywgaXNvUGFydHMpLCAhIXZhbCk7XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoZGF0YSkge1xuICAgICAgdmFyIGksXG4gICAgICAgICAgaixcbiAgICAgICAgICBkYXlTdHIsXG4gICAgICAgICAgd2Vla0RheSxcbiAgICAgICAgICB2YWx1ZXMgPSBkYXRhLnZhbHVlcyxcbiAgICAgICAgICBpbmRleCA9IGRhdGEuaW5kZXgsXG4gICAgICAgICAgZGlyID0gZGF0YS5kaXJlY3Rpb24sXG4gICAgICAgICAgZGF5V2hlZWwgPSBzLndoZWVsc1swXVt3aGVlbE9yZGVyLmRdLFxuICAgICAgICAgIHZhbGlkYXRlZCA9IGdldENsb3Nlc3RWYWxpZERhdGUoZ2V0RGF0ZSh2YWx1ZXMpLCBkaXIpLFxuICAgICAgICAgIHRlbXAgPSBnZXRBcnJheSh2YWxpZGF0ZWQpLFxuICAgICAgICAgIGRpc2FibGVkID0gW10sXG4gICAgICAgICAgd2hlZWxzID0ge30sXG4gICAgICAgICAgeSA9IGdldERhdGVQYXJ0LnkodmFsaWRhdGVkKSxcbiAgICAgICAgICAvL2dldCh0ZW1wLCAneScpLFxuICAgICAgbSA9IGdldERhdGVQYXJ0Lm0odmFsaWRhdGVkKSxcbiAgICAgICAgICAvL2dldCh0ZW1wLCAnbScpLFxuICAgICAgbWF4ZGF5cyA9IHMuZ2V0TWF4RGF5T2ZNb250aCh5LCBtKSxcbiAgICAgICAgICBtaW5wcm9wID0gdHJ1ZSxcbiAgICAgICAgICBtYXhwcm9wID0gdHJ1ZTtcbiAgICAgICQkMS5lYWNoKFsnZGQnLCAneScsICdtJywgJ2QnLCAndHQnLCAnYScsICdoJywgJ2knLCAncyddLCBmdW5jdGlvbiAoeCwgaSkge1xuICAgICAgICB2YXIgbWluID0gbWluc1tpXSxcbiAgICAgICAgICAgIG1heCA9IG1heHNbaV0sXG4gICAgICAgICAgICB2YWwgPSBnZXREYXRlUGFydFtpXSh2YWxpZGF0ZWQpO1xuICAgICAgICBkaXNhYmxlZFt3aGVlbE9yZGVyW2ldXSA9IFtdO1xuXG4gICAgICAgIGlmIChtaW5wcm9wICYmIG1pbkRhdGUpIHtcbiAgICAgICAgICBtaW4gPSBnZXREYXRlUGFydFtpXShtaW5EYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXhwcm9wICYmIG1heERhdGUpIHtcbiAgICAgICAgICBtYXggPSBnZXREYXRlUGFydFtpXShtYXhEYXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgPCBtaW4pIHtcbiAgICAgICAgICB2YWwgPSBtaW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsID4gbWF4KSB7XG4gICAgICAgICAgdmFsID0gbWF4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgIT09ICdkZCcgJiYgaSAhPT0gJ3R0Jykge1xuICAgICAgICAgIGlmIChtaW5wcm9wKSB7XG4gICAgICAgICAgICBtaW5wcm9wID0gdmFsID09IG1pbjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWF4cHJvcCkge1xuICAgICAgICAgICAgbWF4cHJvcCA9IHZhbCA9PSBtYXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdoZWVsT3JkZXJbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChpICE9ICd5JyAmJiBpICE9ICdkZCcpIHtcbiAgICAgICAgICAgIGZvciAoaiA9IG1pbnNbaV07IGogPD0gbWF4c1tpXTsgaiArPSBzdGVwc1tpXSkge1xuICAgICAgICAgICAgICBpZiAoaiA8IG1pbiB8fCBqID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgZGlzYWJsZWRbd2hlZWxPcmRlcltpXV0ucHVzaChqKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gRGlzYWJsZSBzb21lIGRheXNcblxuXG4gICAgICAgICAgaWYgKGkgPT0gJ2QnKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3QgPSBzLmdldERhdGUoeSwgbSwgMSkuZ2V0RGF5KCksXG4gICAgICAgICAgICAgICAgaW52YWxpZHMgPSB7fTsgLy8gU2V0IGludmFsaWQgaW5kZXhlc1xuXG4gICAgICAgICAgICB2YWxpZGF0ZURhdGVzKGludmFsaWQsIHksIG0sIGZpcnN0LCBtYXhkYXlzLCBpbnZhbGlkcywgMSk7IC8vIERlbGV0ZSBpbmRleGVzIHdoaWNoIGFyZSB2YWxpZFxuXG4gICAgICAgICAgICB2YWxpZGF0ZURhdGVzKHZhbGlkLCB5LCBtLCBmaXJzdCwgbWF4ZGF5cywgaW52YWxpZHMsIDApO1xuICAgICAgICAgICAgJCQxLmVhY2goaW52YWxpZHMsIGZ1bmN0aW9uIChqLCB2KSB7XG4gICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgZGlzYWJsZWRbd2hlZWxPcmRlcltpXV0ucHVzaChqKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTsgLy8gSW52YWxpZCB0aW1lc1xuXG4gICAgICBpZiAoaGFzVGltZSkge1xuICAgICAgICAkJDEuZWFjaChbJ2EnLCAnaCcsICdpJywgJ3MnLCAndHQnXSwgZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgICAgICB2YXIgdmFsID0gZ2V0RGF0ZVBhcnRbdl0odmFsaWRhdGVkKSxcbiAgICAgICAgICAgICAgZCA9IGdldERhdGVQYXJ0LmQodmFsaWRhdGVkKSxcbiAgICAgICAgICAgICAgaW52YWxpZHMgPSB7fTtcblxuICAgICAgICAgIGlmICh3aGVlbE9yZGVyW3ZdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlVGltZXMoaW52YWxpZCwgaSwgdiwgeSwgbSwgZCwgaW52YWxpZHMsIDApO1xuICAgICAgICAgICAgdmFsaWRhdGVUaW1lcyh2YWxpZCwgaSwgdiwgeSwgbSwgZCwgaW52YWxpZHMsIDEpO1xuICAgICAgICAgICAgJCQxLmVhY2goaW52YWxpZHMsIGZ1bmN0aW9uIChqLCB4KSB7XG4gICAgICAgICAgICAgIGlmICh4KSB7XG4gICAgICAgICAgICAgICAgZGlzYWJsZWRbd2hlZWxPcmRlclt2XV0ucHVzaChqKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7IC8vIEdldCB2YWxpZCB2YWx1ZVxuXG4gICAgICAgICAgICB2YWxpZFZhbHVlc1tpXSA9IGluc3QuZ2V0VmFsaWRWYWx1ZSh3aGVlbE9yZGVyW3ZdLCB2YWwsIGRpciwgaW52YWxpZHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IC8vIFJlZ2VuZXJhdGUgZGF5IHdoZWVsIGlmIG51bWJlciBvZiBkYXlzIGluIG1vbnRoIGNoYW5nZXNcbiAgICAgIC8vIG9yIGlmIGRheSBuYW1lcyBuZWVkcyB0byBiZSByZWdlbmVyYXRlZFxuXG5cbiAgICAgIGlmIChkYXlXaGVlbCAmJiAoZGF5V2hlZWwuZGF0YS5sZW5ndGggIT09IG1heGRheXMgfHwgZ2VuRGF5TmFtZXMgJiYgKGluZGV4ID09PSB1bmRlZmluZWQgfHwgaW5kZXggPT09IHdoZWVsT3JkZXIueSB8fCBpbmRleCA9PT0gd2hlZWxPcmRlci5tKSkpIHtcbiAgICAgICAgd2hlZWxzW3doZWVsT3JkZXIuZF0gPSBkYXlXaGVlbDtcbiAgICAgICAgZGF5V2hlZWwuZGF0YSA9IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPD0gbWF4ZGF5czsgaSsrKSB7XG4gICAgICAgICAgd2Vla0RheSA9IHMuZ2V0RGF0ZSh5LCBtLCBpKS5nZXREYXkoKTtcbiAgICAgICAgICBkYXlTdHIgPSBkYXRlRGlzcGxheS5yZXBsYWNlKC9bbXl8XS9naSwgJycpLnJlcGxhY2UoL2RkLywgKGkgPCAxMCA/ICcwJyArIGkgOiBpKSArIChzLmRheVN1ZmZpeCB8fCAnJykpLnJlcGxhY2UoL2QvLCBpICsgKHMuZGF5U3VmZml4IHx8ICcnKSk7XG4gICAgICAgICAgZGF5V2hlZWwuZGF0YS5wdXNoKHtcbiAgICAgICAgICAgIHZhbHVlOiBpLFxuICAgICAgICAgICAgZGlzcGxheTogL0RELy50ZXN0KGRheVN0cikgPyBkYXlTdHIucmVwbGFjZSgvREQvLCAnPHNwYW4gY2xhc3M9XCJtYnNjLWR0LWRheVwiPicgKyBzLmRheU5hbWVzW3dlZWtEYXldICsgJzwvc3Bhbj4nKSA6IGRheVN0ci5yZXBsYWNlKC9ELywgJzxzcGFuIGNsYXNzPVwibWJzYy1kdC1kYXlcIj4nICsgcy5kYXlOYW1lc1Nob3J0W3dlZWtEYXldICsgJzwvc3Bhbj4nKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIE5lZWQgdG8gdXBkYXRlIGRheSB2YWx1ZSwgaWYgb3V0IG9mIG1vbnRoXG5cblxuICAgICAgICBpbnN0Ll90ZW1wV2hlZWxBcnJheVt3aGVlbE9yZGVyLmRdID0gdGVtcFt3aGVlbE9yZGVyLmRdO1xuICAgICAgICBpbnN0LmNoYW5nZVdoZWVsKHdoZWVscyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc2FibGVkOiBkaXNhYmxlZCxcbiAgICAgICAgdmFsaWQ6IHRlbXBcbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcblxudmFyIGlkJDEgPSAwO1xuXG5mdW5jdGlvbiBqc29ucCh1cmwsIGNhbGxiYWNrKSB7XG4gIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSxcbiAgICAgIHVuaXF1ZSA9ICdtYnNjanNvbnAnICsgKytpZCQxO1xuXG4gIHdpbmRvd1t1bmlxdWVdID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgIGRlbGV0ZSB3aW5kb3dbdW5pcXVlXTtcblxuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrKGRhdGEpO1xuICB9O1xuXG4gIHNjcmlwdC5zcmMgPSB1cmwgKyAodXJsLmluZGV4T2YoJz8nKSA+PSAwID8gJyYnIDogJz8nKSArICdjYWxsYmFjaz0nICsgdW5pcXVlO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG59XG5cbmZ1bmN0aW9uIGFqYXhHZXQodXJsLCBjYWxsYmFjaykge1xuICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICByZXF1ZXN0Lm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG5cbiAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDQwMCkge1xuICAgICAgLy8gU3VjY2VzcyFcbiAgICAgIGNhbGxiYWNrKEpTT04ucGFyc2UodGhpcy5yZXNwb25zZSkpO1xuICAgIH0gLy9lbHNlIHtcbiAgICAvLyBXZSByZWFjaGVkIG91ciB0YXJnZXQgc2VydmVyLCBidXQgaXQgcmV0dXJuZWQgYW4gZXJyb3JcbiAgICAvL31cblxuICB9O1xuXG4gIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uICgpIHsvLyBUaGVyZSB3YXMgYSBjb25uZWN0aW9uIGVycm9yIG9mIHNvbWUgc29ydFxuICB9O1xuXG4gIHJlcXVlc3Quc2VuZCgpO1xufVxuXG5mdW5jdGlvbiBnZXRKc29uKHVybCwgY2FsbGJhY2ssIHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gJ2pzb25wJykge1xuICAgIGpzb25wKHVybCwgY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIGFqYXhHZXQodXJsLCBjYWxsYmFjayk7XG4gIH1cbn1cblxudXRpbC5nZXRKc29uID0gZ2V0SnNvbjtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cbnZhciBkZWZhdWx0cyQyID0ge1xuICBjb250cm9sczogWydjYWxlbmRhciddLFxuICBmaXJzdERheTogMCxcbiAgd2Vla0RheXM6ICdzaG9ydCcsXG4gIG1heE1vbnRoV2lkdGg6IDE3MCxcbiAgYnJlYWtQb2ludE1kOiA3NjgsXG4gIG1vbnRoczogMSxcbiAgcGFnZUJ1ZmZlcjogMSxcbiAgd2Vla3M6IDYsXG4gIGhpZ2hsaWdodDogdHJ1ZSxcbiAgb3V0ZXJNb250aENoYW5nZTogdHJ1ZSxcbiAgcXVpY2tOYXY6IHRydWUsXG4gIHllYXJDaGFuZ2U6IHRydWUsXG4gIHRhYnM6ICdhdXRvJyxcbiAgLy8gQ1NTIGNsYXNzZXNcbiAgdG9kYXlDbGFzczogJ21ic2MtY2FsLXRvZGF5JyxcbiAgYnRuQ2FsUHJldkNsYXNzOiAnbWJzYy1pYyBtYnNjLWljLWFycm93LWxlZnQ2JyxcbiAgYnRuQ2FsTmV4dENsYXNzOiAnbWJzYy1pYyBtYnNjLWljLWFycm93LXJpZ2h0NicsXG4gIC8vIExvY2FsaXphdGlvblxuICBkYXRlVGV4dDogJ0RhdGUnLFxuICB0aW1lVGV4dDogJ1RpbWUnLFxuICB0b2RheVRleHQ6ICdUb2RheScsXG4gIGZyb21UZXh0OiAnU3RhcnQnLFxuICB0b1RleHQ6ICdFbmQnLFxuICBtb3JlRXZlbnRzVGV4dDogJ3tjb3VudH0gbW9yZScsXG4gIHByZXZNb250aFRleHQ6ICdQcmV2aW91cyBNb250aCcsXG4gIG5leHRNb250aFRleHQ6ICdOZXh0IE1vbnRoJyxcbiAgcHJldlllYXJUZXh0OiAnUHJldmlvdXMgWWVhcicsXG4gIG5leHRZZWFyVGV4dDogJ05leHQgWWVhcidcbn07IC8vIC0tLSBUUklBTCBTRVJWRVIgQ09ERSBFTkQgLS0tXG5cbnZhciBDYWxlbmRhckJhc2UgPSBmdW5jdGlvbiBDYWxlbmRhckJhc2UoaW5zdCkge1xuICB2YXIgJGNhbGVuZGFyLFxuICAgICAgJG1hcmt1cCxcbiAgICAgICRtb250aEhkcixcbiAgICAgICRtb250aFBpY2tlcixcbiAgICAgICR0YWJQYW5lQ29udCxcbiAgICAgICR0YWJQYW5lcyxcbiAgICAgICR5ZWFySGRyLFxuICAgICAgJHllYXJQaWNrZXIsXG4gICAgICBhY3RpdmVEYXRlLFxuICAgICAgYmFzZSxcbiAgICAgIGNhbFJvd3MsXG4gICAgICBjYWxTaXplLFxuICAgICAgY2FsV2lkdGgsXG4gICAgICBjb250ZXh0LFxuICAgICAgY29udHJvbHMsXG4gICAgICBjb250cm9sc0FycmF5LFxuICAgICAgY3NzRGlzYWJsZWQsXG4gICAgICBjc3NTZWxlY3RlZCxcbiAgICAgIGNzc1NlbGVjdGVkVGFiLFxuICAgICAgY3VyckZpcnN0RGF5LFxuICAgICAgZGF5TGFiZWxzLFxuICAgICAgZGF5UHJvcHMsXG4gICAgICBkYXlTY3JvbGwsXG4gICAgICBkaXNwbGF5Rm9ybWF0LFxuICAgICAgZmlyc3RXZWVrRGF5LFxuICAgICAgaGFzQ2FsLFxuICAgICAgaGFzTGFiZWxzLFxuICAgICAgaGFzTWFya3MsXG4gICAgICBoYXNUYWJzLFxuICAgICAgLy8gaGFzVGV4dCxcbiAgaGFzUXVpY2tOYXYsXG4gICAgICBob3ZlclRpbWVyLFxuICAgICAgaW52YWxpZE9iaixcbiAgICAgIGlzQ2VsbEhvdmVyLFxuICAgICAgaXNEYXlDbGljayxcbiAgICAgIGlzTGlxdWlkLFxuICAgICAgaXNNb250aFZpZXcsXG4gICAgICBpc1BhZ2VNb3ZlLFxuICAgICAgaXNSVEwsXG4gICAgICBpc1ZlcnRpY2FsLFxuICAgICAgbGFiZWxzT2JqLFxuICAgICAgbWFya2VkT2JqLFxuICAgICAgY29sb3JzT2JqLFxuICAgICAgbWF4RGF0ZSxcbiAgICAgIG1heEZpcnN0WWVhcixcbiAgICAgIG1heExhYmVscyxcbiAgICAgIG1heE1vbnRoLFxuICAgICAgbWF4WWVhcixcbiAgICAgIG1pbkRhdGUsXG4gICAgICBtaW5GaXJzdFllYXIsXG4gICAgICBtaW5Nb250aCxcbiAgICAgIG1pblllYXIsXG4gICAgICBtb250aEluZGV4LFxuICAgICAgbW9udGhOYW1lcyxcbiAgICAgIG1vbnRoU2Nyb2xsLFxuICAgICAgbmVlZHNTbGlkZSxcbiAgICAgIG5lZWRzUmVmcmVzaCxcbiAgICAgIHBhZ2VCdWZmZXIsXG4gICAgICBwYWdlTnIsXG4gICAgICBwYWdlT2Zmc2V0LFxuICAgICAgcGFnZVRvdGFsLFxuICAgICAgcnRsLFxuICAgICAgcyxcbiAgICAgIHNlbGVjdGVkRGF0ZSxcbiAgICAgIHNob3dPdXRlckRheXMsXG4gICAgICB0cmlnZ2VyLFxuICAgICAgdmFsaWRPYmosXG4gICAgICB2aXNpYmxlVGFiLFxuICAgICAgd2FzVG91Y2hlZCxcbiAgICAgIHdlZWtDb3VudGVyLFxuICAgICAgd2Vla0RheXMsXG4gICAgICB5ZWFyQ2hhbmdlLFxuICAgICAgeWVhckluZGV4LFxuICAgICAgeWVhclNjcm9sbCxcbiAgICAgIHllYXJTdWZmaXgsXG4gICAgICBsYWJlbElkeCA9IDEsXG4gICAgICBlbG0gPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIHNob3dDb250KCRjb250KSB7XG4gICAgaWYgKCRjb250Lmhhc0NsYXNzKCdtYnNjLWNhbC1oJykpIHtcbiAgICAgICRjb250LnJlbW92ZUNsYXNzKCdtYnNjLWNhbC1oJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGlkZUNvbnQoJGNvbnQpIHtcbiAgICBpZiAoISRjb250Lmhhc0NsYXNzKCdtYnNjLWNhbC1oJykpIHtcbiAgICAgICRjb250LmFkZENsYXNzKCdtYnNjLWNhbC1oJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG9nZ2xlQ29udCgkY29udCkge1xuICAgIGlmICgkY29udC5oYXNDbGFzcygnbWJzYy1jYWwtaCcpKSB7XG4gICAgICBzaG93Q29udCgkY29udCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpZGVDb250KCRjb250KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcmVQcm9jZXNzU2V0dGluZ3MoKSB7XG4gICAgdmFyIGN0cmxzLCBsYXlvdXQsIG9yaWc7XG4gICAgY29udHJvbHMgPSB7fTtcbiAgICBjb250cm9sc0FycmF5ID0gW107XG4gICAgZGF5TGFiZWxzID0ge307XG4gICAgdHJpZ2dlciA9IGluc3QudHJpZ2dlcjtcbiAgICBvcmlnID0gZXh0ZW5kJDEoe30sIGluc3Quc2V0dGluZ3MpO1xuICAgIHMgPSBleHRlbmQkMShpbnN0LnNldHRpbmdzLCBkZWZhdWx0cyQyLCBvcmlnKTtcbiAgICBjdHJscyA9IHMuY29udHJvbHMuam9pbignLCcpO1xuICAgIGZpcnN0V2Vla0RheSA9IHMuZmlyc3REYXk7XG4gICAgaXNSVEwgPSBzLnJ0bDtcbiAgICBwYWdlQnVmZmVyID0gcy5wYWdlQnVmZmVyO1xuICAgIHdlZWtDb3VudGVyID0gcy53ZWVrQ291bnRlcjtcbiAgICBjYWxSb3dzID0gcy53ZWVrcztcbiAgICBpc01vbnRoVmlldyA9IGNhbFJvd3MgPT0gNjtcbiAgICBpc1ZlcnRpY2FsID0gcy5jYWxlbmRhclNjcm9sbCA9PSAndmVydGljYWwnO1xuICAgIGNvbnRleHQgPSBpbnN0Ll9nZXRSZXNwQ29udCgpO1xuICAgIHdlZWtEYXlzID0gcy53ZWVrRGF5cyA9PSAnZnVsbCcgPyAnJyA6IHMud2Vla0RheXMgPT0gJ21pbicgPyAnTWluJyA6ICdTaG9ydCc7XG4gICAgbGF5b3V0ID0gcy5sYXlvdXQgfHwgKHMuZGlzcGxheSA9PSAnaW5saW5lJyB8fCAvdG9wfGJvdHRvbS8udGVzdChzLmRpc3BsYXkpICYmIHMudG91Y2hVaSA/ICdsaXF1aWQnIDogJycpO1xuICAgIGlzTGlxdWlkID0gbGF5b3V0ID09ICdsaXF1aWQnOyAvLyAmJiBzLmRpc3BsYXkgIT09ICdidWJibGUnO1xuXG4gICAgY2FsV2lkdGggPSBpc0xpcXVpZCA/IG51bGwgOiBzLmNhbGVuZGFyV2lkdGg7XG4gICAgcnRsID0gaXNSVEwgJiYgIWlzVmVydGljYWwgPyAtMSA6IDE7XG4gICAgY3NzRGlzYWJsZWQgPSAnbWJzYy1kaXNhYmxlZCAnICsgKHMuZGlzYWJsZWRDbGFzcyB8fCAnJyk7XG4gICAgY3NzU2VsZWN0ZWRUYWIgPSAnbWJzYy1zZWxlY3RlZCAnICsgKHMuc2VsZWN0ZWRUYWJDbGFzcyB8fCAnJyk7XG4gICAgY3NzU2VsZWN0ZWQgPSAnbWJzYy1zZWxlY3RlZCAnICsgKHMuc2VsZWN0ZWRDbGFzcyB8fCAnJyk7XG4gICAgbWF4TGFiZWxzID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcigoKHMuY2FsZW5kYXJIZWlnaHQgfHwgMCkgLyBjYWxSb3dzIC0gNDUpIC8gMTgpKTtcblxuICAgIGlmIChjdHJscy5tYXRjaCgvY2FsZW5kYXIvKSkge1xuICAgICAgY29udHJvbHMuY2FsZW5kYXIgPSAxO1xuICAgICAgaGFzQ2FsID0gdHJ1ZTtcbiAgICB9IC8vIEFsbG93IGRhdGUgc2Nyb2xsZXIgb25seSBpZiBjYWxlbmRhciBub3QgcHJlc2VudFxuXG5cbiAgICBpZiAoY3RybHMubWF0Y2goL2RhdGUvKSAmJiAhaGFzQ2FsKSB7XG4gICAgICBjb250cm9scy5kYXRlID0gMTtcbiAgICB9XG5cbiAgICBpZiAoY3RybHMubWF0Y2goL3RpbWUvKSkge1xuICAgICAgY29udHJvbHMudGltZSA9IDE7XG4gICAgfVxuXG4gICAgcy5jb250cm9scy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICBpZiAoY29udHJvbHNbdl0pIHtcbiAgICAgICAgY29udHJvbHNBcnJheS5wdXNoKHYpO1xuICAgICAgfVxuICAgIH0pOyAvLyBEaXNhYmxlIHF1aWNrIG5hdiBmb3Igd2VlayB2aWV3XG5cbiAgICBoYXNRdWlja05hdiA9IHMucXVpY2tOYXYgJiYgaGFzQ2FsICYmIGlzTW9udGhWaWV3OyAvLyBEaXNhYmxlIHllYXIgY2hhbmdlIGZvciB3ZWVrIHZpZXdcblxuICAgIHllYXJDaGFuZ2UgPSBzLnllYXJDaGFuZ2UgJiYgaXNNb250aFZpZXc7IC8vIEZ1bGxzY3JlZW4gbW9kZVxuXG4gICAgaWYgKGlzTGlxdWlkICYmIGhhc0NhbCAmJiBzLmRpc3BsYXkgPT0gJ2NlbnRlcicpIHtcbiAgICAgIGluc3QuX2lzRnVsbFNjcmVlbiA9IHRydWU7XG4gICAgfVxuXG4gICAgcy5sYXlvdXQgPSBsYXlvdXQ7IC8vIFBhc3MgYmFjayB0byBjb3JlIGlmIHNldCB0byBsaXF1aWRcblxuICAgIHMucHJlc2V0ID0gKGNvbnRyb2xzLmRhdGUgfHwgaGFzQ2FsID8gJ2RhdGUnIDogJycpICsgKGNvbnRyb2xzLnRpbWUgPyAndGltZScgOiAnJyk7XG4gIH1cblxuICBmdW5jdGlvbiBwb3N0UHJvY2Vzc1NldHRpbmdzKCkge1xuICAgIG1vbnRoTmFtZXMgPSB5ZWFyQ2hhbmdlID8gcy5tb250aE5hbWVzU2hvcnQgOiBzLm1vbnRoTmFtZXM7XG4gICAgeWVhclN1ZmZpeCA9IHMueWVhclN1ZmZpeCB8fCAnJztcbiAgICBtb250aEluZGV4ID0gKHMuZGF0ZVdoZWVscyB8fCBzLmRhdGVGb3JtYXQpLnNlYXJjaCgvbS9pKTtcbiAgICB5ZWFySW5kZXggPSAocy5kYXRlV2hlZWxzIHx8IHMuZGF0ZUZvcm1hdCkuc2VhcmNoKC95L2kpO1xuICAgIGRpc3BsYXlGb3JtYXQgPSBpbnN0Ll9mb3JtYXQ7XG5cbiAgICBpZiAocy5taW4pIHtcbiAgICAgIG1pbkRhdGUgPSBnZXREYXRlT25seShtYWtlRGF0ZShzLm1pbiwgZGlzcGxheUZvcm1hdCwgcykpO1xuICAgICAgbWluWWVhciA9IHMuZ2V0WWVhcihtaW5EYXRlKTtcbiAgICAgIG1pbk1vbnRoID0gcy5nZXRNb250aChtaW5EYXRlKTtcbiAgICAgIG1pbkZpcnN0WWVhciA9IHMuZ2V0RGF0ZShNYXRoLmZsb29yKG1pblllYXIgLyAxMikgKiAxMiwgMCwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHMubWF4KSB7XG4gICAgICBtYXhEYXRlID0gZ2V0RGF0ZU9ubHkobWFrZURhdGUocy5tYXgsIGRpc3BsYXlGb3JtYXQsIHMpKTtcbiAgICAgIG1heFllYXIgPSBzLmdldFllYXIobWF4RGF0ZSk7XG4gICAgICBtYXhNb250aCA9IHMuZ2V0TW9udGgobWF4RGF0ZSk7XG4gICAgICBtYXhGaXJzdFllYXIgPSBzLmdldERhdGUoTWF0aC5mbG9vcihtYXhZZWFyIC8gMTIpICogMTIsIDAsIDEpO1xuICAgIH1cblxuICAgIGluc3QuX21pbkRhdGUgPSBtaW5EYXRlO1xuICAgIGluc3QuX21heERhdGUgPSBtYXhEYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkVG9MaXN0KG9iaiwgZCwgZXYpIHtcbiAgICBvYmpbZF0gPSBvYmpbZF0gfHwgW107XG4gICAgb2JqW2RdLnB1c2goZXYpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZU9iaihsaXN0LCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIGQsXG4gICAgICAgIHYsXG4gICAgICAgIHllYXIsXG4gICAgICAgIG1vbnRoLFxuICAgICAgICBkYXksXG4gICAgICAgIG1heERheXMsXG4gICAgICAgIGVuZFRpbWUsXG4gICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgZ2V0RGF0ZSA9IHMuZ2V0RGF0ZSxcbiAgICAgICAgZ2V0WWVhciA9IHMuZ2V0WWVhcixcbiAgICAgICAgZ2V0TW9udGggPSBzLmdldE1vbnRoLFxuICAgICAgICBnZXREYXkgPSBzLmdldERheSxcbiAgICAgICAgZ2V0TWF4RGF5T2ZNb250aCA9IHMuZ2V0TWF4RGF5T2ZNb250aCxcbiAgICAgICAgc3RhcnRZZWFyID0gZ2V0WWVhcihzdGFydCksXG4gICAgICAgIHN0YXJ0TW9udGggPSBnZXRNb250aChzdGFydCksXG4gICAgICAgIG9iaiA9IHt9O1xuXG4gICAgaWYgKGxpc3QpIHtcbiAgICAgICQkMS5lYWNoKGxpc3QsIGZ1bmN0aW9uIChpLCBldikge1xuICAgICAgICBkID0gZXYuZCB8fCBldi5zdGFydCB8fCBldjtcbiAgICAgICAgdiA9IGQgKyAnJztcblxuICAgICAgICBpZiAoZXYuc3RhcnQgJiYgZXYuZW5kKSB7XG4gICAgICAgICAgc3RhcnRUaW1lID0gZ2V0RGF0ZU9ubHkobWFrZURhdGUoZXYuc3RhcnQsIGRpc3BsYXlGb3JtYXQsIHMpKTtcbiAgICAgICAgICBlbmRUaW1lID0gZ2V0RGF0ZU9ubHkobWFrZURhdGUoZXYuZW5kLCBkaXNwbGF5Rm9ybWF0LCBzKSk7XG5cbiAgICAgICAgICB3aGlsZSAoc3RhcnRUaW1lIDw9IGVuZFRpbWUpIHtcbiAgICAgICAgICAgIGFkZFRvTGlzdChvYmosIHN0YXJ0VGltZSwgZXYpO1xuICAgICAgICAgICAgc3RhcnRUaW1lID0gZ2V0RGF0ZShnZXRZZWFyKHN0YXJ0VGltZSksIGdldE1vbnRoKHN0YXJ0VGltZSksIGdldERheShzdGFydFRpbWUpICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKERBWV9PRl9XRUVLLnRlc3QodikpIHtcbiAgICAgICAgICAvLyBEYXkgb2Ygd2Vla1xuICAgICAgICAgIHN0YXJ0VGltZSA9IGdldEZpcnN0RGF5KHN0YXJ0LCBmYWxzZSwgK3YucmVwbGFjZSgndycsICcnKSk7XG5cbiAgICAgICAgICB3aGlsZSAoc3RhcnRUaW1lIDw9IGVuZCkge1xuICAgICAgICAgICAgYWRkVG9MaXN0KG9iaiwgc3RhcnRUaW1lLCBldik7XG4gICAgICAgICAgICBzdGFydFRpbWUgPSBnZXREYXRlKGdldFllYXIoc3RhcnRUaW1lKSwgZ2V0TW9udGgoc3RhcnRUaW1lKSwgZ2V0RGF5KHN0YXJ0VGltZSkgKyA3KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoREFZX09GX01PTlRILnRlc3QodikpIHtcbiAgICAgICAgICAvLyBEYXkgb2YgbW9udGg6ICcyJyBvciAnMTIvMjQnXG4gICAgICAgICAgdiA9IHYuc3BsaXQoJy8nKTtcbiAgICAgICAgICB2YXIgaGFzTW9udGggPSAhIXZbMV0sXG4gICAgICAgICAgICAgIHllYXJJbmMgPSBoYXNNb250aCA/IDEgOiAwLFxuICAgICAgICAgICAgICBtb250aEluYyA9IGhhc01vbnRoID8gMCA6IDEsXG4gICAgICAgICAgICAgIHZNb250aCA9IGhhc01vbnRoID8gdlswXSAtIDEgOiBzdGFydE1vbnRoLFxuICAgICAgICAgICAgICB2RGF5ID0gaGFzTW9udGggPyArdlsxXSA6ICt2WzBdO1xuICAgICAgICAgIG1heERheXMgPSBnZXRNYXhEYXlPZk1vbnRoKHN0YXJ0WWVhciwgdk1vbnRoKTtcbiAgICAgICAgICBzdGFydFRpbWUgPSBnZXREYXRlKHN0YXJ0WWVhciwgdk1vbnRoLCBNYXRoLm1pbih2RGF5LCBtYXhEYXlzKSk7XG5cbiAgICAgICAgICB3aGlsZSAoc3RhcnRUaW1lIDw9IGVuZCkge1xuICAgICAgICAgICAgeWVhciA9IGdldFllYXIoc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIG1vbnRoID0gZ2V0TW9udGgoc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIGRheSA9IGdldERheShzdGFydFRpbWUpO1xuXG4gICAgICAgICAgICBpZiAoZGF5ID09PSB2RGF5KSB7XG4gICAgICAgICAgICAgIGFkZFRvTGlzdChvYmosIHN0YXJ0VGltZSwgZXYpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYXhEYXlzID0gZ2V0TWF4RGF5T2ZNb250aCh5ZWFyICsgeWVhckluYywgbW9udGggKyBtb250aEluYyk7XG4gICAgICAgICAgICBzdGFydFRpbWUgPSBnZXREYXRlKHllYXIgKyB5ZWFySW5jLCBtb250aCArIG1vbnRoSW5jLCBNYXRoLm1pbih2RGF5LCBtYXhEYXlzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEV4YWN0IGRhdGVcbiAgICAgICAgICBhZGRUb0xpc3Qob2JqLCBnZXREYXRlT25seShtYWtlRGF0ZShkLCBkaXNwbGF5Rm9ybWF0LCBzKSksIGV2KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVmFsaWREYXRlKGQpIHtcbiAgICBpZiAoZCA8IG1pbkRhdGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZCA+IG1heERhdGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW52YWxpZE9ialtkXSA9PT0gdW5kZWZpbmVkIHx8IHZhbGlkT2JqW2RdICE9PSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREYXlQcm9wcyhkKSB7XG4gICAgdmFyIGksXG4gICAgICAgIG1hcmssXG4gICAgICAgIG1hcmtlZE1hcmt1cCxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIG1hcmtlZCA9IG1hcmtlZE9ialtkXSA/IG1hcmtlZE9ialtkXSA6IGZhbHNlLFxuICAgICAgICBjb2xvcnMgPSBjb2xvcnNPYmpbZF0gPyBjb2xvcnNPYmpbZF0gOiBmYWxzZSxcbiAgICAgICAgYmFja2dyb3VuZCA9IGNvbG9ycyAmJiBjb2xvcnNbMF0uYmFja2dyb3VuZCA/IGNvbG9yc1swXS5iYWNrZ3JvdW5kIDogbWFya2VkICYmIG1hcmtlZFswXS5iYWNrZ3JvdW5kLFxuICAgICAgICBjc3NDbGFzcyA9ICcnO1xuXG4gICAgaWYgKGNvbG9ycykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNvbG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjc3NDbGFzcyArPSAoY29sb3JzW2ldLmNzc0NsYXNzIHx8ICcnKSArICcgJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWFya2VkKSB7XG4gICAgICAvLyBNYXJrc1xuICAgICAgbWFya2VkTWFya3VwID0gJzxkaXYgY2xhc3M9XCJtYnNjLWNhbC1tYXJrc1wiPic7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtYXJrZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWFyayA9IG1hcmtlZFtpXTtcbiAgICAgICAgY3NzQ2xhc3MgKz0gKG1hcmsuY3NzQ2xhc3MgfHwgJycpICsgJyAnO1xuICAgICAgICBtYXJrZWRNYXJrdXAgKz0gJzxkaXYgY2xhc3M9XCJtYnNjLWNhbC1tYXJrXCInICsgKG1hcmsuY29sb3IgPyAnIHN0eWxlPVwiYmFja2dyb3VuZDonICsgbWFyay5jb2xvciArICc7XCInIDogJycpICsgJz48L2Rpdj4nO1xuICAgICAgfVxuXG4gICAgICBtYXJrZWRNYXJrdXAgKz0gJzwvZGl2Pic7XG4gICAgfVxuXG4gICAgcHJvcHMgPSB7XG4gICAgICBtYXJrZWQ6IG1hcmtlZCxcbiAgICAgIGJhY2tncm91bmQ6IGJhY2tncm91bmQsXG4gICAgICBjc3NDbGFzczogY3NzQ2xhc3MsXG4gICAgICAvLyBhcmlhTGFiZWw6IGhhc1RleHQgPyB0eHQgOiAnJyxcbiAgICAgIG1hcmt1cDogZGF5TGFiZWxzW2RdID8gZGF5TGFiZWxzW2RdLmpvaW4oJycpIDogaGFzTWFya3MgPyBtYXJrZWRNYXJrdXAgOiAnJ1xuICAgIH07XG4gICAgcmV0dXJuIGV4dGVuZCQxKHByb3BzLCBpbnN0Ll9nZXREYXlQcm9wcyhkLCBwcm9wcykpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0T2Zmc2V0U3R5bGUob2Zmc2V0KSB7XG4gICAgcmV0dXJuICcgc3R5bGU9XCInICsgKGlzVmVydGljYWwgPyAndHJhbnNmb3JtOiB0cmFuc2xhdGVZKCcgKyBvZmZzZXQgKiAxMDAgKyAnJSknIDogJ2xlZnQ6JyArIG9mZnNldCAqIDEwMCAqIHJ0bCArICclJykgKyAnXCInO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsY01vbnRoTnIoKSB7XG4gICAgLy8gQ2FsY3VsYXRlIHBhZ2VOclxuICAgIHBhZ2VOciA9IHMubW9udGhzID09ICdhdXRvJyA/IC8vIEV4YWN0IG1vbnRoIG51bWJlciBmcm9tIHNldHRpbmdcbiAgICBNYXRoLm1heCgxLCAvLyBNaW4gMSBtb250aFxuICAgIE1hdGgubWluKDMsIC8vIE1heCAzIG1vbnRoc1xuICAgIE1hdGguZmxvb3IoKGNhbFdpZHRoIHx8IGdldFdpZHRoKGNvbnRleHQpKSAvIDI4MCkpKSA6ICtzLm1vbnRocztcbiAgICBwYWdlVG90YWwgPSBwYWdlTnIgKyAyICogcGFnZUJ1ZmZlcjtcbiAgICBwYWdlT2Zmc2V0ID0gMDsgLy9NYXRoLnJvdW5kKHBhZ2VOciAvIDIpIC0gMTtcbiAgICAvLyBEb24ndCBhbGxvdyB2ZXJ0aWNhbCBzY3JvbGwgd2l0aCBtdWx0aXBsZSBtb250aHNcblxuICAgIGlzVmVydGljYWwgPSBpc1ZlcnRpY2FsICYmIHBhZ2VOciA8IDI7IC8vIERvbid0IHNob3cgb3V0ZXIgZGF5cyBieSBkZWZhdWx0IGZvciBtdWx0aXBsZSBtb250aHMgb3IgdmVydGljYWwgc2Nyb2xsXG5cbiAgICBzaG93T3V0ZXJEYXlzID0gcy5zaG93T3V0ZXJEYXlzID09PSB1bmRlZmluZWQgPyBwYWdlTnIgPCAyICYmICFpc1ZlcnRpY2FsIHx8ICFpc01vbnRoVmlldyA6IHMuc2hvd091dGVyRGF5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN0cmFpbihkKSB7XG4gICAgaWYgKGdldFBhZ2VEYXkoZCwgcGFnZU5yIC0gMSkgPiBtYXhEYXRlKSB7XG4gICAgICBkID0gZ2V0UGFnZURheShtYXhEYXRlLCAxIC0gcGFnZU5yKTtcbiAgICB9XG5cbiAgICBpZiAoZCA8IG1pbkRhdGUpIHtcbiAgICAgIGQgPSBtaW5EYXRlO1xuICAgIH1cblxuICAgIHJldHVybiBkO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TGFiZWxNYXJrdXAoZXZlbnQsIGksIHNob3dUZXh0KSB7XG4gICAgdmFyIG5vQmcgPSBldmVudC5iYWNrZ3JvdW5kID09PSAnbm9uZSc7XG4gICAgdmFyIGNvbG9yID0gbm9CZyA/ICdub25lJyA6IGV2ZW50LmNvbG9yO1xuICAgIHZhciB0eHRDb2xvciA9IG5vQmcgPyBldmVudC5jb2xvciA6IGdldFRleHRDb2xvcihjb2xvcik7XG4gICAgdmFyIHR4dCA9IGV2ZW50LnRleHQ7XG4gICAgcmV0dXJuICc8ZGl2IGRhdGEtaWQ9XCInICsgZXZlbnQuX2lkICsgJ1wiIGRhdGEtaW5kZXg9XCInICsgaSArICdcIiBjbGFzcz1cIm1ic2MtY2FsLXR4dCcgKyAobm9CZyA/ICcgbWJzYy1jYWwtdHh0LW9ubHknIDogJycpICsgJ1wiIHRpdGxlPVwiJyArICQkMSgnPGRpdj4nICsgdHh0ICsgJzwvZGl2PicpLnRleHQoKSArICdcIicgKyAoY29sb3IgPyAnIHN0eWxlPVwiYmFja2dyb3VuZDonICsgY29sb3IgKyAoc2hvd1RleHQgJiYgdHh0Q29sb3IgPyAnO2NvbG9yOicgKyB0eHRDb2xvciA6ICcnKSArICc7XCInIDogJycpICsgJz4nICsgKHNob3dUZXh0ID8gdHh0IDogJycpICsgJzwvZGl2Pic7XG4gIH1cblxuICBmdW5jdGlvbiBvbkdlbk1vbnRoKGQpIHtcbiAgICB2YXIgc3RhcnQgPSBnZXRGaXJzdERheShnZXRQYWdlRGF5KGQsIC1wYWdlT2Zmc2V0IC0gcGFnZUJ1ZmZlciksIGZhbHNlKTtcbiAgICB2YXIgZW5kID0gZ2V0Rmlyc3REYXkoZ2V0UGFnZURheShkLCAtcGFnZU9mZnNldCArIHBhZ2VOciArIHBhZ2VCdWZmZXIgLSAxKSwgZmFsc2UpO1xuICAgIGVuZCA9IHMuZ2V0RGF0ZShzLmdldFllYXIoZW5kKSwgcy5nZXRNb250aChlbmQpLCBzLmdldERheShlbmQpICsgY2FsUm93cyAqIDcpO1xuXG4gICAgaW5zdC5fb25HZW5Nb250aChzdGFydCwgZW5kKTtcblxuICAgIGludmFsaWRPYmogPSBwcmVwYXJlT2JqKHMuaW52YWxpZCwgc3RhcnQsIGVuZCk7XG4gICAgdmFsaWRPYmogPSBwcmVwYXJlT2JqKHMudmFsaWQsIHN0YXJ0LCBlbmQpO1xuICAgIG1hcmtlZE9iaiA9IHByZXBhcmVPYmoocy5sYWJlbHMgfHwgcy5ldmVudHMgfHwgcy5tYXJrZWQsIHN0YXJ0LCBlbmQpO1xuICAgIGNvbG9yc09iaiA9IHByZXBhcmVPYmoocy5jb2xvcnMsIHN0YXJ0LCBlbmQpO1xuICAgIGxhYmVsc09iaiA9IGluc3QuX2xhYmVscyB8fCBtYXJrZWRPYmogfHwgY29sb3JzT2JqO1xuICAgIGhhc0xhYmVscyA9IHMubGFiZWxzIHx8IGluc3QuX2xhYmVsczsgLy8gTXVsdGlwbGUgbGFiZWxzXG5cbiAgICBpZiAoaGFzTGFiZWxzKSB7XG4gICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICBkYXlMYWJlbHMgPSB7fTtcbiAgICAgICAgdmFyIGV2ZW50Um93cyA9IHt9O1xuICAgICAgICB2YXIgZGF5ID0gc3RhcnQ7XG5cbiAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAgICAgaWYgKGRheS5nZXREYXkoKSA9PSBmaXJzdFdlZWtEYXkpIHtcbiAgICAgICAgICAgIGV2ZW50Um93cyA9IHt9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBtYXhSb3dzID0gbWF4TGFiZWxzO1xuICAgICAgICAgIHZhciBldmVudHMgPSBsYWJlbHNPYmpbZGF5XSB8fCBbXTtcbiAgICAgICAgICB2YXIgZXZlbnRzTnIgPSBldmVudHMubGVuZ3RoO1xuICAgICAgICAgIHZhciBsYWJlbHMgPSBbXTtcbiAgICAgICAgICB2YXIgcHJldkV2ZW50ID0gdm9pZCAwO1xuICAgICAgICAgIHZhciBwcmV2SW5kZXggPSB2b2lkIDA7XG4gICAgICAgICAgdmFyIHJvdyA9IDA7XG4gICAgICAgICAgdmFyIGRpc3BsYXllZCA9IDA7XG4gICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgIHZhciB3aWR0aCA9IHZvaWQgMDtcblxuICAgICAgICAgIHdoaWxlIChyb3cgPCBtYXhSb3dzKSB7XG4gICAgICAgICAgICBwcmV2RXZlbnQgPSBudWxsOyAvLyBDaGVjayAgaWYgdGhlcmUgYXJlIGFueSBldmVudHMgYWxyZWFkeSBpbiB0aGlzIHJvd1xuXG4gICAgICAgICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZXYsIGopIHtcbiAgICAgICAgICAgICAgaWYgKGV2ZW50Um93c1tyb3ddID09IGV2KSB7XG4gICAgICAgICAgICAgICAgcHJldkV2ZW50ID0gZXY7XG4gICAgICAgICAgICAgICAgcHJldkluZGV4ID0gajtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChyb3cgPT0gbWF4Um93cyAtIDEgJiYgKGRpc3BsYXllZCA8IGV2ZW50c05yIC0gMSB8fCBldmVudHNOciAmJiBpID09IGV2ZW50c05yICYmICFwcmV2RXZlbnQpKSB7XG4gICAgICAgICAgICAgIHZhciBuciA9IGV2ZW50c05yIC0gZGlzcGxheWVkO1xuICAgICAgICAgICAgICB2YXIgdHh0ID0gKG5yID4gMSA/IHMubW9yZUV2ZW50c1BsdXJhbFRleHQgfHwgcy5tb3JlRXZlbnRzVGV4dCA6IHMubW9yZUV2ZW50c1RleHQpLnJlcGxhY2UoL3tjb3VudH0vLCBucik7XG5cbiAgICAgICAgICAgICAgaWYgKG5yKSB7XG4gICAgICAgICAgICAgICAgbGFiZWxzLnB1c2goJzxkaXYgY2xhc3M9XCJtYnNjLWNhbC10eHQtbW9yZVwiPicgKyB0eHQgKyAnPC9kaXY+Jyk7XG4gICAgICAgICAgICAgIH0gLy8gUmVtb3ZlIGV2ZW50IGZyb20gcHJldmlvdXMgZGF5cyBhbmQgcmVwbGFjZSBpdCB3aXRoIG1vcmUgbGFiZWxcblxuXG4gICAgICAgICAgICAgIGlmIChwcmV2RXZlbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudFJvd3Nbcm93XSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBwcmV2RXZlbnQuX2RheXMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgZGF5TGFiZWxzW2RdW3Jvd10gPSAnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLXR4dC1tb3JlXCI+JyArIHMubW9yZUV2ZW50c1RleHQucmVwbGFjZSgve2NvdW50fS8sIDEpICsgJzwvZGl2Pic7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkaXNwbGF5ZWQrKztcbiAgICAgICAgICAgICAgcm93Kys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZXZFdmVudCkge1xuICAgICAgICAgICAgICBpZiAocHJldkluZGV4ID09IGkpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoaXNTYW1lRGF5KGRheSwgbWFrZURhdGUocHJldkV2ZW50LmVuZCkpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRSb3dzW3Jvd10gPSBudWxsO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbGFiZWxzLnB1c2goZ2V0TGFiZWxNYXJrdXAocHJldkV2ZW50LCBwcmV2SW5kZXgpKTtcbiAgICAgICAgICAgICAgcm93Kys7XG4gICAgICAgICAgICAgIGRpc3BsYXllZCsrO1xuXG4gICAgICAgICAgICAgIHByZXZFdmVudC5fZGF5cy5wdXNoKGRheSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgPCBldmVudHNOcikge1xuICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBldmVudHNbaV07XG4gICAgICAgICAgICAgIHZhciBzdGFydFRpbWUgPSBldmVudC5zdGFydCAmJiBtYWtlRGF0ZShldmVudC5zdGFydCk7XG4gICAgICAgICAgICAgIHZhciBlbmRUaW1lID0gZXZlbnQuZW5kICYmIG1ha2VEYXRlKGV2ZW50LmVuZCk7XG4gICAgICAgICAgICAgIHZhciB3ZWVrRGF5ID0gZGF5LmdldERheSgpO1xuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gZmlyc3RXZWVrRGF5IC0gd2Vla0RheSA+IDAgPyA3IDogMDtcbiAgICAgICAgICAgICAgdmFyIG11bHRpRGF5ID0gZW5kVGltZSAmJiAhaXNTYW1lRGF5KHN0YXJ0VGltZSwgZW5kVGltZSk7XG5cbiAgICAgICAgICAgICAgaWYgKCFzdGFydFRpbWUgfHwgLy8gYWxsIGRheSBldmVudFxuICAgICAgICAgICAgICBpc1NhbWVEYXkoZGF5LCBzdGFydFRpbWUpIHx8IC8vIGV2ZW50IHN0YXJ0IGRheVxuICAgICAgICAgICAgICB3ZWVrRGF5ID09IGZpcnN0V2Vla0RheSAvLyBmaXJzdCBkYXkgb2Ygd2VlayAoaWYgZXZlbnQgY29udGludWVzIGZyb20gcHJldiB3ZWVrKSlcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuX2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuX2lkID0gbGFiZWxJZHgrKztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKG11bHRpRGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Um93c1tyb3ddID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGV2ZW50Ll9kYXlzID0gW2RheV07XG4gICAgICAgICAgICAgICAgICB3aWR0aCA9IG11bHRpRGF5ID8gTWF0aC5taW4oZ2V0RGF5RGlmZihkYXksIGdldERhdGVPbmx5KGVuZFRpbWUpKSArIDEsIDcgKyBmaXJzdFdlZWtEYXkgLSB3ZWVrRGF5IC0gb2Zmc2V0KSAqIDEwMCA6IDEwMDtcbiAgICAgICAgICAgICAgICAgIGxhYmVscy5wdXNoKG11bHRpRGF5ID8gJzxkaXYgY2xhc3M9XCJtYnNjLWNhbC10eHQtd1wiIHN0eWxlPVwid2lkdGg6JyArIHdpZHRoICsgJyVcIj4nICsgZ2V0TGFiZWxNYXJrdXAoZXZlbnQsIGksIHRydWUpICsgJzwvZGl2PicgKyBnZXRMYWJlbE1hcmt1cChldmVudCwgaSkgOiBnZXRMYWJlbE1hcmt1cChldmVudCwgaSwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgcm93Kys7XG4gICAgICAgICAgICAgICAgICBkaXNwbGF5ZWQrKztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGFiZWxzLnB1c2goJzxkaXYgY2xhc3M9XCJtYnNjLWNhbC10eHQtcGhcIj48L2Rpdj4nKTtcbiAgICAgICAgICAgICAgcm93Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF5TGFiZWxzW2RheV0gPSBsYWJlbHM7XG4gICAgICAgICAgZGF5ID0gcy5nZXREYXRlKHMuZ2V0WWVhcihkYXkpLCBzLmdldE1vbnRoKGRheSksIHMuZ2V0RGF5KGRheSkgKyAxKTtcbiAgICAgICAgfTtcblxuICAgICAgICB3aGlsZSAoZGF5IDwgZW5kKSB7XG4gICAgICAgICAgX2xvb3AoKTtcbiAgICAgICAgfVxuICAgICAgfSkoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkJlZm9yZU1vbnRoQ2hhbmdlKGQpIHtcbiAgICB2YXIgeSA9IHMuZ2V0WWVhcihkKSxcbiAgICAgICAgbSA9IHMuZ2V0TW9udGgoZCk7XG4gICAgY3VyckZpcnN0RGF5ID0gZDtcbiAgICBhY3RpdmVEYXRlID0gZDtcbiAgICBzZXRUaXRsZShkKTtcbiAgICB0cmlnZ2VyKCdvbk1vbnRoQ2hhbmdlJywge1xuICAgICAgeWVhcjogeSxcbiAgICAgIG1vbnRoOiBtXG4gICAgfSk7XG4gICAgdHJpZ2dlcignb25Nb250aExvYWRpbmcnLCB7XG4gICAgICB5ZWFyOiB5LFxuICAgICAgbW9udGg6IG1cbiAgICB9KTtcbiAgICB0cmlnZ2VyKCdvblBhZ2VDaGFuZ2UnLCB7XG4gICAgICBmaXJzdERheTogZFxuICAgIH0pO1xuICAgIHRyaWdnZXIoJ29uUGFnZUxvYWRpbmcnLCB7XG4gICAgICBmaXJzdERheTogZFxuICAgIH0pO1xuICAgIG9uR2VuTW9udGgoZCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkFmdGVyTW9udGhDaGFuZ2UoZCkge1xuICAgIHZhciB5ID0gcy5nZXRZZWFyKGQpLFxuICAgICAgICBtID0gcy5nZXRNb250aChkKTtcblxuICAgIGlmIChuZWVkc1JlZnJlc2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgb25QYWdlTG9hZGVkKGQsIHksIG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5BbGxNb250aHMoZCwgbmVlZHNSZWZyZXNoLCB0cnVlKTtcbiAgICB9XG5cbiAgICBmb2N1c0RhdGUoYWN0aXZlRGF0ZSwgZGF5U2Nyb2xsLmZvY3VzKTtcbiAgICBkYXlTY3JvbGwuZm9jdXMgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUGFnZUxvYWRlZChkLCB5LCBtKSB7XG4gICAgdmFyICRzY3JvbGxlciA9IGRheVNjcm9sbC4kc2Nyb2xsZXI7XG4gICAgJCQxKCcubWJzYy1jYWwtc2xpZGUnLCAkc2Nyb2xsZXIpLnJlbW92ZUNsYXNzKCdtYnNjLWNhbC1zbGlkZS1hJyk7XG4gICAgJCQxKCcubWJzYy1jYWwtc2xpZGUnLCAkc2Nyb2xsZXIpLnNsaWNlKHBhZ2VCdWZmZXIsIHBhZ2VCdWZmZXIgKyBwYWdlTnIpLmFkZENsYXNzKCdtYnNjLWNhbC1zbGlkZS1hJyk7XG4gICAgJCQxKCcubWJzYy1jYWwtc2xpZGUtYSAubWJzYy1jYWwtZGF5JywgJHNjcm9sbGVyKS5vbignbW91c2VlbnRlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkY2VsbCA9ICQkMSh0aGlzKTtcblxuICAgICAgaWYgKCF3YXNUb3VjaGVkICYmICFpc1BhZ2VNb3ZlKSB7XG4gICAgICAgIGhvdmVyVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpc0NlbGxIb3ZlciA9IHRydWU7XG4gICAgICAgICAgdHJpZ2dlcignb25DZWxsSG92ZXJJbicsIGdldERheUluZm8oJGNlbGwpKTtcbiAgICAgICAgfSwgMTUwKTtcbiAgICAgIH1cbiAgICB9KS5vbignbW91c2VsZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNsZWFyVGltZW91dChob3ZlclRpbWVyKTtcblxuICAgICAgaWYgKCF3YXNUb3VjaGVkICYmIGlzQ2VsbEhvdmVyKSB7XG4gICAgICAgIGlzQ2VsbEhvdmVyID0gZmFsc2U7XG4gICAgICAgIHRyaWdnZXIoJ29uQ2VsbEhvdmVyT3V0JywgZ2V0RGF5SW5mbygkJDEodGhpcykpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChoYXNMYWJlbHMpIHtcbiAgICAgICQkMSgnLm1ic2MtY2FsLXNsaWRlLWEgLm1ic2MtY2FsLXR4dCcsICRzY3JvbGxlcikub24oJ21vdXNlZW50ZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZCA9ICQkMSh0aGlzKS5hdHRyKCdkYXRhLWlkJyk7XG4gICAgICAgICQkMSgnLm1ic2MtY2FsLXR4dFtkYXRhLWlkPVwiJyArIGlkICsgJ1wiXScsICRzY3JvbGxlcikuYWRkQ2xhc3MoJ21ic2MtaG92ZXInKTtcbiAgICAgIH0pLm9uKCdtb3VzZWxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAkJDEoJy5tYnNjLWNhbC10eHQubWJzYy1ob3ZlcicsICRzY3JvbGxlcikucmVtb3ZlQ2xhc3MoJ21ic2MtaG92ZXInKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRyaWdnZXIoJ29uTW9udGhMb2FkZWQnLCB7XG4gICAgICB5ZWFyOiB5LFxuICAgICAgbW9udGg6IG1cbiAgICB9KTtcbiAgICB0cmlnZ2VyKCdvblBhZ2VMb2FkZWQnLCB7XG4gICAgICBmaXJzdERheTogZFxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuVGFiTWFya3VwKCkge1xuICAgIHZhciBodG1sLCB0YWJUZXh0O1xuICAgIGh0bWwgPSAnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLXRhYnMtY1wiPjxkaXYgY2xhc3M9XCJtYnNjLWNhbC10YWJzXCIgcm9sZT1cInRhYmxpc3RcIj4nO1xuICAgIGNvbnRyb2xzQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgdGFiVGV4dCA9IHNbKHYgPT0gJ2NhbGVuZGFyJyA/ICdkYXRlJyA6IHYpICsgJ1RleHQnXTtcbiAgICAgIGh0bWwgKz0gJzxkaXYgcm9sZT1cInRhYlwiIGFyaWEtY29udHJvbHM9XCInICsgKGVsbS5pZCArICctbWJzYy1wbmwtJyArIGkpICsgJ1wiIGNsYXNzPVwibWJzYy1jYWwtdGFiIG1ic2MtZnItYnRuLWUgJyArIChpID8gJycgOiBjc3NTZWxlY3RlZFRhYikgKyAnXCIgZGF0YS1jb250cm9sPVwiJyArIHYgKyAnXCInICsgKHMudGFiTGluayA/ICc+PGEgaHJlZj1cIiNcIj4nICsgdGFiVGV4dCArICc8L2E+JyA6ICcgdGFiaW5kZXg9XCIwXCI+JyArIHRhYlRleHQpICsgJzwvZGl2Pic7XG4gICAgfSk7XG4gICAgaHRtbCArPSAnPC9kaXY+PC9kaXY+JztcbiAgICByZXR1cm4gaHRtbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkNhbE1hcmt1cCgpIHtcbiAgICB2YXIgaHRtbCxcbiAgICAgICAgaSxcbiAgICAgICAgaixcbiAgICAgICAgayxcbiAgICAgICAgbW9udGhCdG5zLFxuICAgICAgICBtb250aHNNYXJrdXAsXG4gICAgICAgIHllYXJCdG5zID0gJycsXG4gICAgICAgIGJ0blByZXZDbGFzcyA9IGlzUlRMID8gcy5idG5DYWxOZXh0Q2xhc3MgOiBzLmJ0bkNhbFByZXZDbGFzcyxcbiAgICAgICAgYnRuTmV4dENsYXNzID0gaXNSVEwgPyBzLmJ0bkNhbFByZXZDbGFzcyA6IHMuYnRuQ2FsTmV4dENsYXNzOyAvLyBHZW5lcmF0ZSBtb250aCBidXR0b25zXG5cbiAgICBtb250aEJ0bnMgPSAnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLWJ0bi13XCI+PGRpdiBkYXRhLXN0ZXA9XCItMVwiIHJvbGU9XCJidXR0b25cIiB0YWJpbmRleD1cIjBcIiBhcmlhLWxhYmVsPVwiJyArIHMucHJldk1vbnRoVGV4dCArICdcIiBjbGFzcz1cIicgKyBidG5QcmV2Q2xhc3MgKyAnIG1ic2MtY2FsLXByZXYgbWJzYy1jYWwtcHJldi1tIG1ic2MtY2FsLWJ0biBtYnNjLWZyLWJ0biBtYnNjLWZyLWJ0bi1lXCI+PC9kaXY+JztcblxuICAgIGZvciAoaSA9IDA7IGkgPCAoY2FsUm93cyA/IHBhZ2VOciA6IDEpOyBpKyspIHtcbiAgICAgIG1vbnRoQnRucyArPSAnPGRpdiByb2xlPVwiYnV0dG9uXCIgY2xhc3M9XCJtYnNjLWNhbC1tb250aFwiPjwvZGl2Pic7XG4gICAgfVxuXG4gICAgbW9udGhCdG5zICs9ICc8ZGl2IGRhdGEtc3RlcD1cIjFcIiByb2xlPVwiYnV0dG9uXCIgdGFiaW5kZXg9XCIwXCIgYXJpYS1sYWJlbD1cIicgKyBzLm5leHRNb250aFRleHQgKyAnXCIgY2xhc3M9XCInICsgYnRuTmV4dENsYXNzICsgJyBtYnNjLWNhbC1uZXh0IG1ic2MtY2FsLW5leHQtbSBtYnNjLWNhbC1idG4gbWJzYy1mci1idG4gbWJzYy1mci1idG4tZVwiPjwvZGl2PjwvZGl2Pic7IC8vIEdlbmVyYXRlIHllYXIgYnV0dG9uc1xuXG4gICAgaWYgKHllYXJDaGFuZ2UpIHtcbiAgICAgIHllYXJCdG5zID0gJzxkaXYgY2xhc3M9XCJtYnNjLWNhbC1idG4td1wiPjxkaXYgZGF0YS1zdGVwPVwiLTEyXCIgcm9sZT1cImJ1dHRvblwiIHRhYmluZGV4PVwiMFwiIGFyaWEtbGFiZWw9XCInICsgcy5wcmV2WWVhclRleHQgKyAnXCIgY2xhc3M9XCInICsgYnRuUHJldkNsYXNzICsgJyBtYnNjLWNhbC1wcmV2IG1ic2MtY2FsLXByZXYteSBtYnNjLWNhbC1idG4gbWJzYy1mci1idG4gbWJzYy1mci1idG4tZVwiPjwvZGl2PicgKyAnPGRpdiByb2xlPVwiYnV0dG9uXCIgY2xhc3M9XCJtYnNjLWNhbC15ZWFyXCI+PC9kaXY+JyArICc8ZGl2IGRhdGEtc3RlcD1cIjEyXCIgcm9sZT1cImJ1dHRvblwiIHRhYmluZGV4PVwiMFwiIGFyaWEtbGFiZWw9XCInICsgcy5uZXh0WWVhclRleHQgKyAnXCIgY2xhc3M9XCInICsgYnRuTmV4dENsYXNzICsgJyBtYnNjLWNhbC1uZXh0IG1ic2MtY2FsLW5leHQteSBtYnNjLWNhbC1idG4gbWJzYy1mci1idG4gbWJzYy1mci1idG4tZVwiPjwvZGl2PjwvZGl2Pic7XG4gICAgfVxuXG4gICAgaWYgKGNhbFJvd3MpIHtcbiAgICAgIG1vbnRoc01hcmt1cCA9IGdlbkFsbE1vbnRocyhjdXJyRmlyc3REYXkpO1xuICAgIH1cblxuICAgIGh0bWwgPSAnPGRpdiBjbGFzcz1cIm1ic2Mtdy1wIG1ic2MtY2FsLWNcIj48ZGl2IGNsYXNzPVwibWJzYy1jYWwgJyArIChpc01vbnRoVmlldyA/ICcnIDogJyBtYnNjLWNhbC13ZWVrLXZpZXcnKSArIChwYWdlTnIgPiAxID8gJyBtYnNjLWNhbC1tdWx0aSAnIDogJycpICsgKHdlZWtDb3VudGVyID8gJyBtYnNjLWNhbC13ZWVrcyAnIDogJycpICsgKGlzVmVydGljYWwgPyAnIG1ic2MtY2FsLXZlcnRpY2FsJyA6ICcnKSArIChoYXNNYXJrcyA/ICcgbWJzYy1jYWwtaGFzLW1hcmtzJyA6ICcnKSArIChoYXNMYWJlbHMgPyAnIG1ic2MtY2FsLWhhcy1sYWJlbHMnIDogJycpICsgKCAvLyAoaGFzVGV4dCA/ICcgbWJzYy1jYWwtaGFzLXR4dCcgOiAnJykgK1xuICAgIHNob3dPdXRlckRheXMgPyAnJyA6ICcgbWJzYy1jYWwtaGlkZS1kaWZmICcpICsgKHMuY2FsZW5kYXJDbGFzcyB8fCAnJykgKyAnXCInICsgKCFpc0xpcXVpZCA/ICcgc3R5bGU9XCJ3aWR0aDonICsgKGNhbFdpZHRoIHx8IDI4MCAqIHBhZ2VOcikgKyAncHg7XCInIDogJycpICsgJz4nICsgJzxkaXYgY2xhc3M9XCJtYnNjLWNhbC1oZHJcIj4nICsgKHllYXJJbmRleCA8IG1vbnRoSW5kZXggfHwgcGFnZU5yID4gMSA/IHllYXJCdG5zICsgbW9udGhCdG5zIDogbW9udGhCdG5zICsgeWVhckJ0bnMpICsgJzwvZGl2Pic7XG5cbiAgICBpZiAoY2FsUm93cykge1xuICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLWJvZHlcIj48ZGl2IGNsYXNzPVwibWJzYy1jYWwtZGF5LXBpY2tlclwiPjxkaXYgY2xhc3M9XCJtYnNjLWNhbC1kYXlzLWNcIj4nO1xuXG4gICAgICBmb3IgKGogPSAwOyBqIDwgcGFnZU5yOyBqKyspIHtcbiAgICAgICAgLy8gR2VuZXJhdGUgd2VlayBkYXlzXG4gICAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJtYnNjLWNhbC1kYXlzXCI+JztcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgayA9IChpICsgZmlyc3RXZWVrRGF5KSAlIDc7XG4gICAgICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLXdlZWstZGF5JyArIGsgKyAnXCIgYXJpYS1sYWJlbD1cIicgKyBzLmRheU5hbWVzW2tdICsgJ1wiPicgKyBzWydkYXlOYW1lcycgKyB3ZWVrRGF5c11ba10gKyAnPC9kaXY+JztcbiAgICAgICAgfVxuXG4gICAgICAgIGh0bWwgKz0gJzwvZGl2Pic7XG4gICAgICB9XG5cbiAgICAgIGh0bWwgKz0gJzwvZGl2PicgKyAnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLXNjcm9sbC1jIG1ic2MtY2FsLWRheS1zY3JvbGwtYyAnICsgKHMuY2FsZW5kYXJDbGFzcyB8fCAnJykgKyAnXCInICsgKHMuY2FsZW5kYXJIZWlnaHQgPyAnIHN0eWxlPVwiaGVpZ2h0OicgKyBzLmNhbGVuZGFySGVpZ2h0ICsgJ3B4XCInIDogJycpICsgJz4nICsgJzxkaXYgY2xhc3M9XCJtYnNjLWNhbC1zY3JvbGxcIiBzdHlsZT1cIndpZHRoOicgKyAxMDAgLyBwYWdlTnIgKyAnJScgKyAnXCI+JyArIG1vbnRoc01hcmt1cCArICc8L2Rpdj48L2Rpdj4nO1xuICAgIH1cblxuICAgIGh0bWwgKz0gJzwvZGl2Pic7XG5cbiAgICBpZiAoaGFzUXVpY2tOYXYpIHtcbiAgICAgIC8vIEdlbmVyYXRlIG1vbnRoIHBpY2tlclxuICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLW1vbnRoLXBpY2tlciBtYnNjLWNhbC1waWNrZXIgbWJzYy1jYWwtaFwiPjxkaXYgY2xhc3M9XCJtYnNjLWNhbC1zY3JvbGwtYyAnICsgKHMuY2FsZW5kYXJDbGFzcyB8fCAnJykgKyAnXCI+JyArICc8ZGl2IGNsYXNzPVwibWJzYy1jYWwtc2Nyb2xsXCI+JztcblxuICAgICAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwibWJzYy1jYWwtc2xpZGVcIicgKyBnZXRPZmZzZXRTdHlsZShpIC0gMSkgKyAnPjxkaXYgcm9sZT1cImdyaWRcIiBjbGFzcz1cIm1ic2MtY2FsLXRhYmxlXCI+PGRpdiByb2xlPVwicm93XCIgY2xhc3M9XCJtYnNjLWNhbC1yb3dcIj4nO1xuXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCAxMjsgaisrKSB7XG4gICAgICAgICAgaWYgKGogJiYgaiAlIDMgPT09IDApIHtcbiAgICAgICAgICAgIGh0bWwgKz0gJzwvZGl2PjxkaXYgcm9sZT1cInJvd1wiIGNsYXNzPVwibWJzYy1jYWwtcm93XCI+JztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBodG1sICs9ICc8ZGl2IHJvbGU9XCJncmlkY2VsbFwiJyArIChpID09IDEgPyAnIHRhYmluZGV4PVwiLTFcIiBhcmlhLWxhYmVsPVwiJyArIHMubW9udGhOYW1lc1tqXSArICdcIiBkYXRhLXZhbD1cIicgKyBqICsgJ1wiJyA6ICcnKSArICcgY2xhc3M9XCJtYnNjLWNhbC1jZWxsJyArIChpID09IDEgPyAnIG1ic2MtYnRuLWUnIDogJycpICsgJ1wiPjxkaXYgY2xhc3M9XCJtYnNjLWNhbC1jZWxsLWkgbWJzYy1jYWwtY2VsbC10eHRcIj4nICsgKGkgPT0gMSA/IHMubW9udGhOYW1lc1Nob3J0W2pdIDogJyZuYnNwOycpICsgJzwvZGl2PjwvZGl2Pic7XG4gICAgICAgIH1cblxuICAgICAgICBodG1sICs9ICc8L2Rpdj48L2Rpdj48L2Rpdj4nO1xuICAgICAgfVxuXG4gICAgICBodG1sICs9ICc8L2Rpdj48L2Rpdj48L2Rpdj4nOyAvLyBHZW5lcmF0ZSB5ZWFyIHBpY2tlclxuXG4gICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwibWJzYy1jYWwteWVhci1waWNrZXIgbWJzYy1jYWwtcGlja2VyIG1ic2MtY2FsLWhcIj48ZGl2IGNsYXNzPVwibWJzYy1jYWwtc2Nyb2xsLWMgJyArIChzLmNhbGVuZGFyQ2xhc3MgfHwgJycpICsgJ1wiPicgKyAnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLXNjcm9sbFwiPic7XG5cbiAgICAgIGZvciAoaSA9IC0xOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgIGh0bWwgKz0gZ2VuWWVhcnMoZ2V0UGFnZVllYXIoY3VyckZpcnN0RGF5LCBpKSwgaSk7XG4gICAgICB9XG5cbiAgICAgIGh0bWwgKz0gJzwvZGl2PjwvZGl2PjwvZGl2Pic7XG4gICAgfSAvLyBDbG9zaW5nXG5cblxuICAgIGh0bWwgKz0gJzwvZGl2PjwvZGl2PjwvZGl2Pic7XG4gICAgcmV0dXJuIGh0bWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5ZZWFycyhkLCBvZmYpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgeWVhciA9IHMuZ2V0WWVhcihkKSxcbiAgICAgICAgaHRtbCA9ICc8ZGl2IGNsYXNzPVwibWJzYy1jYWwtc2xpZGVcIicgKyBnZXRPZmZzZXRTdHlsZShvZmYpICsgJz48ZGl2IHJvbGU9XCJncmlkXCIgY2xhc3M9XCJtYnNjLWNhbC10YWJsZVwiPjxkaXYgcm9sZT1cInJvd1wiIGNsYXNzPVwibWJzYy1jYWwtcm93XCI+JztcblxuICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICBpZiAoaSAmJiBpICUgMyA9PT0gMCkge1xuICAgICAgICBodG1sICs9ICc8L2Rpdj48ZGl2IHJvbGU9XCJyb3dcIiBjbGFzcz1cIm1ic2MtY2FsLXJvd1wiPic7XG4gICAgICB9XG5cbiAgICAgIGh0bWwgKz0gJzxkaXYgcm9sZT1cImdyaWRjZWxsXCIgdGFiaW5kZXg9XCItMVwiIGFyaWEtbGFiZWw9XCInICsgeWVhciArICdcIiBkYXRhLXZhbD1cIicgKyB5ZWFyICsgJ1wiJyArICcgY2xhc3M9XCJtYnNjLWNhbC1jZWxsIG1ic2MtYnRuLWUgJyArICh5ZWFyIDwgbWluWWVhciB8fCB5ZWFyID4gbWF4WWVhciA/ICcgbWJzYy1kaXNhYmxlZCAnIDogJycpICsgKHllYXIgPT0gcy5nZXRZZWFyKGN1cnJGaXJzdERheSkgPyBjc3NTZWxlY3RlZCA6ICcnKSArICdcIj48ZGl2IGNsYXNzPVwibWJzYy1jYWwtY2VsbC1pIG1ic2MtY2FsLWNlbGwtdHh0XCI+JyArIHllYXIgKyB5ZWFyU3VmZml4ICsgJzwvZGl2PjwvZGl2Pic7XG4gICAgICB5ZWFyKys7XG4gICAgfVxuXG4gICAgaHRtbCArPSAnPC9kaXY+PC9kaXY+PC9kaXY+JztcbiAgICByZXR1cm4gaHRtbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbk1vbnRoKGZpcnN0RGF5LCBvZmYpIHtcbiAgICB2YXIgYmcsXG4gICAgICAgIGN1cnIsXG4gICAgICAgIGNzc0NsYXNzLFxuICAgICAgICB5LFxuICAgICAgICBtLFxuICAgICAgICBkLFxuICAgICAgICBkaXNwbGF5TW9udGgsXG4gICAgICAgIGRpc3BsYXlEYXRlLFxuICAgICAgICBmdWxsRGF0ZSxcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIGlzVmFsaWQsXG4gICAgICAgIGlzU2VsZWN0ZWQsXG4gICAgICAgIGlzVG9kYXksXG4gICAgICAgIGlzT3V0ZXJEYXksXG4gICAgICAgIG1heERheXMsXG4gICAgICAgIGksXG4gICAgICAgIGosXG4gICAgICAgIGsgPSAxLFxuICAgICAgICB5ZWFyID0gcy5nZXRZZWFyKGZpcnN0RGF5KSxcbiAgICAgICAgbW9udGggPSBzLmdldE1vbnRoKGZpcnN0RGF5KSxcbiAgICAgICAgZGF5ID0gcy5nZXREYXkoZmlyc3REYXkpLFxuICAgICAgICBzZWxlY3RlZCA9IHMuZGVmYXVsdFZhbHVlID09PSBudWxsICYmICFpbnN0Ll9oYXNWYWx1ZSA/IG51bGwgOiBpbnN0LmdldERhdGUodHJ1ZSksXG4gICAgICAgIHdlZWtEYXkgPSBzLmdldERhdGUoeWVhciwgbW9udGgsIGRheSkuZ2V0RGF5KCksXG4gICAgICAgIC8vIEdldCB0aGUgd2Vla2RheSBvZiB0aGUgbW9udGhcbiAgICBvZmZzZXQgPSBmaXJzdFdlZWtEYXkgLSB3ZWVrRGF5ID4gMCA/IDcgOiAwLFxuICAgICAgICBodG1sID0gJzxkaXYgY2xhc3M9XCJtYnNjLWNhbC1zbGlkZVwiJyArIGdldE9mZnNldFN0eWxlKG9mZikgKyAnPjxkaXYgcm9sZT1cImdyaWRcIiBjbGFzcz1cIm1ic2MtY2FsLXRhYmxlXCI+PGRpdiByb2xlPVwicm93XCIgY2xhc3M9XCJtYnNjLWNhbC1yb3dcIj4nO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IDcgKiBjYWxSb3dzOyBqKyspIHtcbiAgICAgIGkgPSBqICsgZmlyc3RXZWVrRGF5IC0gb2Zmc2V0O1xuICAgICAgY3VyciA9IHMuZ2V0RGF0ZSh5ZWFyLCBtb250aCwgaSAtIHdlZWtEYXkgKyBkYXkpO1xuICAgICAgeSA9IGN1cnIuZ2V0RnVsbFllYXIoKTtcbiAgICAgIG0gPSBjdXJyLmdldE1vbnRoKCk7XG4gICAgICBkID0gY3Vyci5nZXREYXRlKCk7XG4gICAgICBkaXNwbGF5TW9udGggPSBzLmdldE1vbnRoKGN1cnIpO1xuICAgICAgZGlzcGxheURhdGUgPSBzLmdldERheShjdXJyKTtcbiAgICAgIG1heERheXMgPSBzLmdldE1heERheU9mTW9udGgoeSwgbSk7XG4gICAgICBmdWxsRGF0ZSA9IHkgKyAnLScgKyAobSArIDEpICsgJy0nICsgZDtcbiAgICAgIHByb3BzID0gZXh0ZW5kJDEoe1xuICAgICAgICB2YWxpZDogaXNWYWxpZERhdGUoY3VyciksXG4gICAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCAmJiBpc1NhbWVEYXkoc2VsZWN0ZWQsIGN1cnIpXG4gICAgICB9LCBnZXREYXlQcm9wcyhjdXJyKSk7XG4gICAgICBiZyA9IHByb3BzLmJhY2tncm91bmQgPT09ICdub25lJyA/IGZhbHNlIDogcHJvcHMuYmFja2dyb3VuZDtcbiAgICAgIGlzVmFsaWQgPSBwcm9wcy52YWxpZDtcbiAgICAgIGlzU2VsZWN0ZWQgPSBwcm9wcy5zZWxlY3RlZDtcbiAgICAgIGNzc0NsYXNzID0gcHJvcHMuY3NzQ2xhc3M7IC8vIENvbXBhcmUgZGF0ZXMgYXQgbm9vbiwgaW4gc29tZSB0aW1lem9uZXMgMDowMCBkb2Vzbid0IGV4aXN0cyBvbiBkYXlsaWdodCBzYXZpbmcgZGF5XG5cbiAgICAgIGlzVG9kYXkgPSBuZXcgRGF0ZShjdXJyKS5zZXRIb3VycygxMiwgMCwgMCwgMCkgPT09IG5ldyBEYXRlKCkuc2V0SG91cnMoMTIsIDAsIDAsIDApO1xuICAgICAgaXNPdXRlckRheSA9IGRpc3BsYXlNb250aCAhPT0gbW9udGg7IC8vIERheSBpcyBmcm9tIGFub3RoZXIgbW9udGhcblxuICAgICAgZGF5UHJvcHNbZnVsbERhdGVdID0gcHJvcHM7XG5cbiAgICAgIGlmIChqICYmIGogJSA3ID09PSAwKSB7XG4gICAgICAgIGh0bWwgKz0gJzwvZGl2PjxkaXYgcm9sZT1cInJvd1wiIGNsYXNzPVwibWJzYy1jYWwtcm93XCI+JztcbiAgICAgIH1cblxuICAgICAgaWYgKHdlZWtDb3VudGVyICYmIGogJSA3ID09PSAwKSB7XG4gICAgICAgIC8vIElmIGRpc3BsYXlpbmcgZGF5cyBmcm9tIG5leHQgbW9udGgsIHJlc2V0IG1vbnRoIGNvdW50ZXJcbiAgICAgICAgaWYgKHdlZWtDb3VudGVyID09ICdtb250aCcgJiYgaXNPdXRlckRheSAmJiBrID4gMSkge1xuICAgICAgICAgIGsgPSBkID09IDEgPyAxIDogMjtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrQ291bnRlciA9PSAneWVhcicpIHtcbiAgICAgICAgICBrID0gcy5nZXRXZWVrTnVtYmVyKHMuZ2V0RGF0ZSh5LCBtLCBkICsgKDcgLSBmaXJzdFdlZWtEYXkgKyAxKSAlIDcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGh0bWwgKz0gJzxkaXYgcm9sZT1cImdyaWRjZWxsXCIgY2xhc3M9XCJtYnNjLWNhbC1jZWxsIG1ic2MtY2FsLXdlZWstbnJcIj4nICsgayArICc8L2Rpdj4nO1xuICAgICAgICBrKys7XG4gICAgICB9XG5cbiAgICAgIGh0bWwgKz0gJzxkaXYgcm9sZT1cImdyaWRjZWxsXCInICsgLy8gQXJpYSBhdHRyaWJ1dGVzXG4gICAgICAnIGFyaWEtbGFiZWw9XCInICsgKGlzVG9kYXkgPyBzLnRvZGF5VGV4dCArICcsICcgOiAnJykgKyBzLmRheU5hbWVzW2N1cnIuZ2V0RGF5KCldICsgJywgJyArIHMubW9udGhOYW1lc1tkaXNwbGF5TW9udGhdICsgJyAnICsgZGlzcGxheURhdGUgKyAnICcgKyAocHJvcHMuYXJpYUxhYmVsID8gJywgJyArIHByb3BzLmFyaWFMYWJlbCA6ICcnKSArICdcIicgKyAoaXNPdXRlckRheSAmJiAhc2hvd091dGVyRGF5cyA/ICcgYXJpYS1oaWRkZW49XCJ0cnVlXCInIDogJyBkYXRhLWZ1bGw9XCInICsgZnVsbERhdGUgKyAnXCInKSArIChpc091dGVyRGF5IHx8ICFpc1ZhbGlkID8gJyBhcmlhLWRpc2FibGVkPVwidHJ1ZVwiJyA6ICcnKSArIChpc1NlbGVjdGVkID8gJyBhcmlhLXNlbGVjdGVkPVwidHJ1ZVwiJyA6ICcnKSArIChpc1ZhbGlkID8gJyB0YWJpbmRleD1cIi0xXCInIDogJycpICsgLy8gQ2xhc3Nlc1xuICAgICAgJyBjbGFzcz1cIm1ic2MtY2FsLWNlbGwgbWJzYy1jYWwtZGF5IG1ic2MtY2FsLWRheScgKyBpICUgNyArICcgJyArIChzLmRheUNsYXNzIHx8ICcnKSArICcgJyArIChpc1NlbGVjdGVkID8gY3NzU2VsZWN0ZWQgOiAnJykgKyAoaXNUb2RheSA/ICcgJyArIHMudG9kYXlDbGFzcyA6ICcnKSArIChjc3NDbGFzcyA/ICcgJyArIGNzc0NsYXNzIDogJycpICsgKGRpc3BsYXlEYXRlID09IDEgPyAnIG1ic2MtY2FsLWRheS1maXJzdCcgOiAnJykgKyAoZGlzcGxheURhdGUgPT0gbWF4RGF5cyA/ICcgbWJzYy1jYWwtZGF5LWxhc3QnIDogJycpICsgKGlzT3V0ZXJEYXkgPyAnIG1ic2MtY2FsLWRheS1kaWZmJyA6ICcnKSArIChpc1ZhbGlkID8gJyBtYnNjLWJ0bi1lJyA6ICcgbWJzYy1kaXNhYmxlZCcpICsgKHByb3BzLm1hcmtlZCA/ICcgbWJzYy1jYWwtZGF5LW1hcmtlZCcgOiAnJykgKyAoYmcgPyAnIG1ic2MtY2FsLWRheS1jb2xvcmVkJyA6ICcnKSArICdcIj48ZGl2IGNsYXNzPVwibWJzYy1jYWwtY2VsbC1pIG1ic2MtY2FsLWRheS1pXCI+PGRpdiBjbGFzcz1cIm1ic2MtY2FsLWRheS1kYXRlIG1ic2MtY2FsLWNlbGwtdHh0XCInICsgKGJnID8gJyBzdHlsZT1cImJhY2tncm91bmQ6JyArIGJnICsgJztjb2xvcjonICsgZ2V0VGV4dENvbG9yKGJnKSArICdcIicgOiAnJykgKyAnPicgKyBkaXNwbGF5RGF0ZSArICc8L2Rpdj4nXG4gICAgICAvKiBUUklBTCAqL1xuICAgICAgKyAoIC8vIEV4dHJhIG1hcmt1cCAoZXh0cmEgZGl2IGlzIG5lZWRlZCBpbiBSVEwgbW9kZSBmb3IgQ2hyb21lLCBvdGhlcndpc2UgbGFiZWxzIGFuZCBtYXJrcyBhcHBlYXIgYXQgdGhlIHRvcCBvZiB0aGUgY2VsbClcbiAgICAgIHByb3BzLm1hcmt1cCA/ICc8ZGl2IGNsYXNzPVwibWJzYy1jYWwtZGF5LW1hcmt1cFwiPicgKyBwcm9wcy5tYXJrdXAgKyAnPC9kaXY+JyA6ICcnKSArICc8L2Rpdj48L2Rpdj4nO1xuICAgIH1cblxuICAgIGh0bWwgKz0gJzwvZGl2PjwvZGl2PjwvZGl2Pic7XG4gICAgcmV0dXJuIGh0bWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5BbGxNb250aHMoZmlyc3REYXksIHJlbmRlciwgaW5zZXJ0KSB7XG4gICAgdmFyIGksXG4gICAgICAgIHkgPSBzLmdldFllYXIoZmlyc3REYXkpLFxuICAgICAgICBtID0gcy5nZXRNb250aChmaXJzdERheSksXG4gICAgICAgIHBvcyA9IGRheVNjcm9sbCA/IGRheVNjcm9sbC5wb3MgOiAwLFxuICAgICAgICBodG1sID0gJyc7XG4gICAgZGF5UHJvcHMgPSB7fTtcblxuICAgIGlmIChjYWxSb3dzKSB7XG4gICAgICBpZiAoIXJlbmRlcikge1xuICAgICAgICB0cmlnZ2VyKCdvbk1vbnRoTG9hZGluZycsIHtcbiAgICAgICAgICB5ZWFyOiB5LFxuICAgICAgICAgIG1vbnRoOiBtXG4gICAgICAgIH0pO1xuICAgICAgICB0cmlnZ2VyKCdvblBhZ2VMb2FkaW5nJywge1xuICAgICAgICAgIGZpcnN0RGF5OiBmaXJzdERheVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgb25HZW5Nb250aChmaXJzdERheSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBwYWdlVG90YWw7IGkrKykge1xuICAgICAgICBodG1sICs9IGdlbk1vbnRoKGdldFBhZ2VEYXkoZmlyc3REYXksIGkgLSBwYWdlT2Zmc2V0IC0gcGFnZUJ1ZmZlciksIHBvcyAqIHJ0bCArIGkgLSBwYWdlQnVmZmVyKTtcbiAgICAgIH1cbiAgICB9IC8vYWN0aXZhdGVNb250aCgpOyAvLyBUT0RPOiA/Pz9cblxuXG4gICAgbmVlZHNSZWZyZXNoID0gdW5kZWZpbmVkO1xuXG4gICAgaWYgKGluc2VydCAmJiBkYXlTY3JvbGwpIHtcbiAgICAgIGRheVNjcm9sbC4kYWN0aXZlID0gbnVsbDtcbiAgICAgIGRheVNjcm9sbC4kc2Nyb2xsZXIuaHRtbChodG1sKTtcbiAgICAgIG9uUGFnZUxvYWRlZChmaXJzdERheSwgeSwgbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGh0bWw7XG4gIH1cblxuICBmdW5jdGlvbiBmb2N1c0RhdGUoZCwgZm9jdXMpIHtcbiAgICBpZiAoZGF5U2Nyb2xsKSB7XG4gICAgICB2YXIgJGFjdGl2ZSA9IGRheVNjcm9sbC4kYWN0aXZlO1xuXG4gICAgICBpZiAoJGFjdGl2ZSAmJiAkYWN0aXZlLmxlbmd0aCkge1xuICAgICAgICAkYWN0aXZlWzBdLmJsdXIoKTtcblxuICAgICAgICBpZiAoJGFjdGl2ZS5oYXNDbGFzcygnbWJzYy1kaXNhYmxlZCcpKSB7XG4gICAgICAgICAgJGFjdGl2ZS5yZW1vdmVBdHRyKCd0YWJpbmRleCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRhY3RpdmUuYXR0cigndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkYXlTY3JvbGwuJGFjdGl2ZSA9ICQkMSgnLm1ic2MtY2FsLXNsaWRlLWEgLm1ic2MtY2FsLWRheVtkYXRhLWZ1bGw9XCInICsgZ2V0RGF0ZVN0cihkKSArICdcIl0nLCBkYXlTY3JvbGwuJHNjcm9sbGVyKS5hdHRyKCd0YWJpbmRleCcsICcwJyk7XG5cbiAgICAgIGlmIChmb2N1cyAmJiBkYXlTY3JvbGwuJGFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgICAgZGF5U2Nyb2xsLiRhY3RpdmVbMF0uZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoaWdobGlnaHREYXRlKGQpIHtcbiAgICB2YXIgJGN0eCA9IGRheVNjcm9sbCAmJiBkYXlTY3JvbGwuJHNjcm9sbGVyO1xuXG4gICAgaWYgKHMuaGlnaGxpZ2h0ICYmIGRheVNjcm9sbCkge1xuICAgICAgJCQxKCcubWJzYy1zZWxlY3RlZCcsICRjdHgpLnJlbW92ZUNsYXNzKGNzc1NlbGVjdGVkKS5yZW1vdmVBdHRyKCdhcmlhLXNlbGVjdGVkJyk7XG5cbiAgICAgIGlmIChzLmRlZmF1bHRWYWx1ZSAhPT0gbnVsbCB8fCBpbnN0Ll9oYXNWYWx1ZSkge1xuICAgICAgICAkJDEoJy5tYnNjLWNhbC1kYXlbZGF0YS1mdWxsPVwiJyArIGdldERhdGVTdHIoZCkgKyAnXCJdJywgJGN0eCkuYWRkQ2xhc3MoY3NzU2VsZWN0ZWQpLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCAndHJ1ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhpZ2hsaWdodFNlbGVjdGVkKHYsICRjdHgpIHtcbiAgICAkJDEoJy5tYnNjLXNlbGVjdGVkJywgJGN0eCkucmVtb3ZlQ2xhc3MoY3NzU2VsZWN0ZWQpLnJlbW92ZUF0dHIoJ2FyaWEtc2VsZWN0ZWQnKTtcbiAgICAkJDEoJy5tYnNjLWNhbC1jZWxsW2RhdGEtdmFsPVwiJyArIHYgKyAnXCJdJywgJGN0eCkuYWRkQ2xhc3MoY3NzU2VsZWN0ZWQpLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCAndHJ1ZScpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0RGF0ZShkLCBuYXYsIGFuaW0sIGZvY3VzKSB7XG4gICAgdmFyIGRpZmYsIG5ld0ZpcnN0RGF5O1xuXG4gICAgaWYgKCF2aXNpYmxlVGFiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGQgPCBtaW5EYXRlKSB7XG4gICAgICBkID0gbWluRGF0ZTtcbiAgICB9XG5cbiAgICBpZiAoZCA+IG1heERhdGUpIHtcbiAgICAgIGQgPSBtYXhEYXRlO1xuICAgIH1cblxuICAgIGlmICh2aXNpYmxlVGFiID09PSAnY2FsZW5kYXInIHx8ICFoYXNUYWJzIHx8IG5hdikge1xuICAgICAgaW5zdC5faXNTZXREYXRlID0gIW5hdjtcblxuICAgICAgaWYgKGhhc0NhbCAmJiBjYWxSb3dzKSB7XG4gICAgICAgIG5ld0ZpcnN0RGF5ID0gZ2V0Rmlyc3REYXkoY29uc3RyYWluKGQpLCBpc01vbnRoVmlldyk7XG5cbiAgICAgICAgaWYgKG5lZWRzU2xpZGUgJiYgKGQgPCBnZXRQYWdlRGF5KGN1cnJGaXJzdERheSwgLXBhZ2VPZmZzZXQpIHx8IGQgPj0gZ2V0UGFnZURheShjdXJyRmlyc3REYXksIHBhZ2VOciAtIHBhZ2VPZmZzZXQpKSkge1xuICAgICAgICAgIGRpZmYgPSBpc01vbnRoVmlldyA/IHMuZ2V0TW9udGgobmV3Rmlyc3REYXkpIC0gcy5nZXRNb250aChjdXJyRmlyc3REYXkpICsgKHMuZ2V0WWVhcihuZXdGaXJzdERheSkgLSBzLmdldFllYXIoY3VyckZpcnN0RGF5KSkgKiAxMiA6IE1hdGguZmxvb3IoZ2V0RGF5RGlmZihjdXJyRmlyc3REYXksIG5ld0ZpcnN0RGF5KSAvICg3ICogY2FsUm93cykpO1xuXG4gICAgICAgICAgaWYgKGRpZmYpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIHF1ZXVlIHRvIG5hdmlnYXRlIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBkYXlTY3JvbGwucXVldWUgPSBbXTtcbiAgICAgICAgICAgIGRheVNjcm9sbC5mb2N1cyA9IGZvY3VzICYmIGFuaW07XG4gICAgICAgICAgICBjaGFuZ2VQYWdlUXVldWUoZGF5U2Nyb2xsLCBkaWZmLCBhbmltKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRpZmYgfHwgIWFuaW0pIHtcbiAgICAgICAgICBmb2N1c0RhdGUoZCwgZm9jdXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFuYXYpIHtcbiAgICAgICAgICBoaWdobGlnaHREYXRlKGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc01vbnRoVmlldyAmJiAhZGlmZikge1xuICAgICAgICAgIHNldFRpdGxlKGN1cnJGaXJzdERheSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhY3RpdmVEYXRlID0gZDtcbiAgICAgICAgbmVlZHNTbGlkZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGluc3QuX29uU2V0RGF0ZShkLCBkaWZmKTtcblxuICAgICAgaW5zdC5faXNTZXREYXRlID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0VGl0bGUoZCwgc2tpcEJ1dHRvbnMpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgeWVhcixcbiAgICAgICAgbW9udGgsXG4gICAgICAgIGRkLFxuICAgICAgICB5ID0gcy5nZXRZZWFyKGQpLFxuICAgICAgICBtID0gcy5nZXRNb250aChkKSxcbiAgICAgICAgeXkgPSB5ICsgeWVhclN1ZmZpeDtcblxuICAgIGlmIChoYXNRdWlja05hdikge1xuICAgICAgLy8gSGlnaGxpZ2h0IG1vbnRoXG4gICAgICBoaWdobGlnaHRTZWxlY3RlZChtLCBtb250aFNjcm9sbC4kc2Nyb2xsZXIpOyAvLyBIaWdobGlnaHQgeWVhclxuXG4gICAgICBoaWdobGlnaHRTZWxlY3RlZCh5LCB5ZWFyU2Nyb2xsLiRzY3JvbGxlcik7IC8vIFNjcm9sbCB0byBzZWxlY3RlZCB5ZWFyXG5cbiAgICAgIGNoYW5nZVBhZ2VRdWV1ZSh5ZWFyU2Nyb2xsLCBNYXRoLmZsb29yKHkgLyAxMikgLSBNYXRoLmZsb29yKHMuZ2V0WWVhcih5ZWFyU2Nyb2xsLmZpcnN0KSAvIDEyKSwgdHJ1ZSk7IC8vIERpc2FibGUgb3V0IG9mIHJhbmdlIG1vbnRoc1xuXG4gICAgICAkJDEoJy5tYnNjLWNhbC1jZWxsJywgbW9udGhTY3JvbGwuJHNjcm9sbGVyKS5yZW1vdmVDbGFzcygnbWJzYy1kaXNhYmxlZCcpO1xuXG4gICAgICBpZiAoeSA9PT0gbWluWWVhcikge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbWluTW9udGg7IGkrKykge1xuICAgICAgICAgICQkMSgnLm1ic2MtY2FsLWNlbGxbZGF0YS12YWw9XCInICsgaSArICdcIl0nLCBtb250aFNjcm9sbC4kc2Nyb2xsZXIpLmFkZENsYXNzKCdtYnNjLWRpc2FibGVkJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHkgPT09IG1heFllYXIpIHtcbiAgICAgICAgZm9yIChpID0gbWF4TW9udGggKyAxOyBpIDw9IDEyOyBpKyspIHtcbiAgICAgICAgICAkJDEoJy5tYnNjLWNhbC1jZWxsW2RhdGEtdmFsPVwiJyArIGkgKyAnXCJdJywgbW9udGhTY3JvbGwuJHNjcm9sbGVyKS5hZGRDbGFzcygnbWJzYy1kaXNhYmxlZCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFza2lwQnV0dG9ucykge1xuICAgICAgLy8gRGlzYWJsZS9lbmFibGUgcHJldi9uZXh0IGJ1dHRvbnNcbiAgICAgIGNoZWNrQnRuKCQkMSgnLm1ic2MtY2FsLXByZXYtbScsICRtYXJrdXApLCBnZXRQYWdlRGF5KGQsIC1wYWdlT2Zmc2V0KSA8PSBtaW5EYXRlKTtcbiAgICAgIGNoZWNrQnRuKCQkMSgnLm1ic2MtY2FsLW5leHQtbScsICRtYXJrdXApLCBnZXRQYWdlRGF5KGQsIHBhZ2VOciAtIHBhZ2VPZmZzZXQpID4gbWF4RGF0ZSk7XG4gICAgICBjaGVja0J0bigkJDEoJy5tYnNjLWNhbC1wcmV2LXknLCAkbWFya3VwKSwgcy5nZXREYXRlKHkgLSAxLCBtICsgMSwgMSkgPD0gbWluRGF0ZSk7XG4gICAgICBjaGVja0J0bigkJDEoJy5tYnNjLWNhbC1uZXh0LXknLCAkbWFya3VwKSwgcy5nZXREYXRlKHkgKyAxLCBtLCAxKSA+IG1heERhdGUpO1xuICAgIH0gLy8gVXBkYXRlIHllYXIgaW4gaGVhZGVyXG5cblxuICAgICR5ZWFySGRyLmF0dHIoJ2FyaWEtbGFiZWwnLCB5KS5odG1sKHl5KTsgLy8gVXBkYXRlIG1vbnRoIGluIGhlYWRlclxuXG4gICAgZm9yIChpID0gMDsgaSA8IHBhZ2VOcjsgaSsrKSB7XG4gICAgICBkZCA9IGdldFBhZ2VEYXkoZCwgaSAtIHBhZ2VPZmZzZXQpO1xuXG4gICAgICBpZiAoc2VsZWN0ZWREYXRlID49IGRkICYmIHNlbGVjdGVkRGF0ZSA8IGdldFBhZ2VEYXkoZGQsIDEpKSB7XG4gICAgICAgIGRkID0gc2VsZWN0ZWREYXRlO1xuICAgICAgfVxuXG4gICAgICB5ZWFyID0gcy5nZXRZZWFyKGRkKTtcbiAgICAgIG1vbnRoID0gcy5nZXRNb250aChkZCk7XG4gICAgICB5eSA9IHllYXIgKyB5ZWFyU3VmZml4O1xuICAgICAgJG1vbnRoSGRyLmVxKGkpLmF0dHIoJ2FyaWEtbGFiZWwnLCBzLm1vbnRoTmFtZXNbbW9udGhdICsgKHllYXJDaGFuZ2UgPyAnJyA6ICcgJyArIHkpKS5odG1sKCgheWVhckNoYW5nZSAmJiB5ZWFySW5kZXggPCBtb250aEluZGV4ID8geXkgKyAnICcgOiAnJykgKyBtb250aE5hbWVzW21vbnRoXSArICgheWVhckNoYW5nZSAmJiB5ZWFySW5kZXggPiBtb250aEluZGV4ID8gJyAnICsgeXkgOiAnJykpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrQnRuKCRidG4sIGRpc2FibGUpIHtcbiAgICBpZiAoZGlzYWJsZSkge1xuICAgICAgJGJ0bi5hZGRDbGFzcyhjc3NEaXNhYmxlZCkuYXR0cignYXJpYS1kaXNhYmxlZCcsICd0cnVlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRidG4ucmVtb3ZlQ2xhc3MoY3NzRGlzYWJsZWQpLnJlbW92ZUF0dHIoJ2FyaWEtZGlzYWJsZWQnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXREYXlJbmZvKCRkYXkpIHtcbiAgICB2YXIgZGF5ID0gJGRheVswXSxcbiAgICAgICAgZnVsbCA9ICRkYXkuYXR0cignZGF0YS1mdWxsJyksXG4gICAgICAgIHBhcnRzID0gZnVsbCA/IGZ1bGwuc3BsaXQoJy0nKSA6IFtdLFxuICAgICAgICBkID0gYWRqdXN0ZWREYXRlKHBhcnRzWzBdLCBwYXJ0c1sxXSAtIDEsIHBhcnRzWzJdKSxcbiAgICAgICAgc2VsZWN0ZWQgPSAkZGF5Lmhhc0NsYXNzKCdtYnNjLXNlbGVjdGVkJyk7XG4gICAgcmV0dXJuIGV4dGVuZCQxKGRheVByb3BzW2Z1bGxdLCB7XG4gICAgICBkYXRlOiBkLFxuICAgICAgdGFyZ2V0OiBkYXksXG4gICAgICBzZWxlY3RlZDogc2VsZWN0ZWRcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdERheSgkZGF5LCBldikge1xuICAgIHZhciBjdXJyID0gaW5zdC5nZXREYXRlKHRydWUpLFxuICAgICAgICBwcm9wcyA9IGdldERheUluZm8oJGRheSksXG4gICAgICAgIGRheSA9ICRkYXlbMF0sXG4gICAgICAgIGQgPSBwcm9wcy5kYXRlLFxuICAgICAgICBkdGltZSA9IGFkanVzdGVkRGF0ZShkLmdldEZ1bGxZZWFyKCksIGQuZ2V0TW9udGgoKSwgZC5nZXREYXRlKCksIGN1cnIuZ2V0SG91cnMoKSwgY3Vyci5nZXRNaW51dGVzKCksIGN1cnIuZ2V0U2Vjb25kcygpKSxcbiAgICAgICAgJHRhcmdldCA9ICQkMShldi50YXJnZXQpLFxuICAgICAgICB0YXJnZXQgPSAkdGFyZ2V0WzBdO1xuXG4gICAgaWYgKCFzaG93T3V0ZXJEYXlzICYmICRkYXkuaGFzQ2xhc3MoJ21ic2MtY2FsLWRheS1kaWZmJykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwcm9wcy5kYXRlID0gZHRpbWU7IC8vIENoZWNrIGlmIGEgbGFiZWwgd2FzIHRhcHBlZFxuXG4gICAgaWYgKGhhc0xhYmVscyAmJiBkYXkuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgd2hpbGUgKHRhcmdldCAhPSBkYXkpIHtcbiAgICAgICAgaWYgKCR0YXJnZXQuaGFzQ2xhc3MoJ21ic2MtY2FsLXR4dCcpIHx8ICR0YXJnZXQuaGFzQ2xhc3MoJ21ic2MtY2FsLXR4dC1tb3JlJykpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAkdGFyZ2V0LmF0dHIoJ2RhdGEtaW5kZXgnKTtcbiAgICAgICAgICB2YXIgbGFiZWxzID0gbGFiZWxzT2JqW2RdO1xuXG4gICAgICAgICAgaWYgKHRyaWdnZXIoJ29uTGFiZWxUYXAnLCB7XG4gICAgICAgICAgICBkYXRlOiBkdGltZSxcbiAgICAgICAgICAgIGRvbUV2ZW50OiBldixcbiAgICAgICAgICAgIHRhcmdldDogJHRhcmdldFswXSxcbiAgICAgICAgICAgIGxhYmVsczogbGFiZWxzLFxuICAgICAgICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF1cbiAgICAgICAgICB9KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgICR0YXJnZXQgPSAkdGFyZ2V0LnBhcmVudCgpO1xuICAgICAgICB0YXJnZXQgPSAkdGFyZ2V0WzBdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0cmlnZ2VyKCdvbkRheUNoYW5nZScsIHByb3BzKSAhPT0gZmFsc2UgJiYgIXMucmVhZG9ubHkgJiYgISRkYXkuaGFzQ2xhc3MoJ21ic2MtZGlzYWJsZWQnKSkge1xuICAgICAgaW5zdC5fc2VsZWN0RGF5KCRkYXksIGQsIGR0aW1lLCBwcm9wcy5zZWxlY3RlZCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0TW9udGgoJG1vbnRoKSB7XG4gICAgaGlkZUNvbnQoJG1vbnRoUGlja2VyKTtcbiAgICBzZXREYXRlKHMuZ2V0RGF0ZShzLmdldFllYXIoZGF5U2Nyb2xsLmZpcnN0KSwgJG1vbnRoLmF0dHIoJ2RhdGEtdmFsJyksIDEpLCB0cnVlLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdFllYXIoJHllYXIpIHtcbiAgICBoaWRlQ29udCgkeWVhclBpY2tlcik7XG4gICAgc2V0RGF0ZShzLmdldERhdGUoJHllYXIuYXR0cignZGF0YS12YWwnKSwgcy5nZXRNb250aChkYXlTY3JvbGwuZmlyc3QpLCAxKSwgdHJ1ZSwgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRGaXJzdERheShkLCBpc01vbnRoLCB3KSB7XG4gICAgdmFyIHkgPSBzLmdldFllYXIoZCksXG4gICAgICAgIG0gPSBzLmdldE1vbnRoKGQpLFxuICAgICAgICB3ZWVrRGF5ID0gZC5nZXREYXkoKSxcbiAgICAgICAgb2Zmc2V0ID0gZmlyc3RXZWVrRGF5IC0gd2Vla0RheSA+IDAgPyA3IDogMDtcbiAgICByZXR1cm4gaXNNb250aCA/IHMuZ2V0RGF0ZSh5LCBtLCAxKSA6IHMuZ2V0RGF0ZSh5LCBtLCAodyA9PT0gdW5kZWZpbmVkID8gZmlyc3RXZWVrRGF5IDogdykgLSBvZmZzZXQgLSB3ZWVrRGF5ICsgcy5nZXREYXkoZCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UGFnZURheShkLCBkaWZmKSB7XG4gICAgdmFyIHllYXIgPSBzLmdldFllYXIoZCksXG4gICAgICAgIG1vbnRoID0gcy5nZXRNb250aChkKSxcbiAgICAgICAgZGF5ID0gcy5nZXREYXkoZCk7XG4gICAgcmV0dXJuIGlzTW9udGhWaWV3ID8gcy5nZXREYXRlKHllYXIsIG1vbnRoICsgZGlmZiwgMSkgOiBzLmdldERhdGUoeWVhciwgbW9udGgsIGRheSArIGRpZmYgKiBjYWxSb3dzICogNyk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQYWdlWWVhcihkLCBkaWZmKSB7XG4gICAgdmFyIHllYXIgPSBNYXRoLmZsb29yKHMuZ2V0WWVhcihkKSAvIDEyKSAqIDEyO1xuICAgIHJldHVybiBzLmdldERhdGUoeWVhciArIGRpZmYgKiAxMiwgMCwgMSk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGFuZ2VQYWdlUXVldWUocHJvcHMsIGRpZmYsIGFuaW0sIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFkaWZmIHx8ICFpbnN0Ll9pc1Zpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwcm9wcy5xdWV1ZS5wdXNoKGFyZ3VtZW50cyk7XG5cbiAgICBpZiAocHJvcHMucXVldWUubGVuZ3RoID09IDEpIHtcbiAgICAgIGNoYW5nZVBhZ2UocHJvcHMsIGRpZmYsIGFuaW0sIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGFuZ2VQYWdlKHByb3BzLCBkaWZmLCBhbmltLCBjYWxsYmFjaykge1xuICAgIHZhciBpLFxuICAgICAgICBpbmMsXG4gICAgICAgIGh0bWwgPSAnJyxcbiAgICAgICAgJHNjcm9sbGVyID0gcHJvcHMuJHNjcm9sbGVyLFxuICAgICAgICBwYWdlQnVmZmVyID0gcHJvcHMuYnVmZmVyLFxuICAgICAgICBwYWdlT2Zmc2V0ID0gcHJvcHMub2Zmc2V0LFxuICAgICAgICBwYWdlTnIgPSBwcm9wcy5wYWdlcyxcbiAgICAgICAgcGFnZVRvdGFsID0gcHJvcHMudG90YWwsXG4gICAgICAgIGZpcnN0RGF5ID0gcHJvcHMuZmlyc3QsXG4gICAgICAgIGdlblBhZ2UgPSBwcm9wcy5nZW5QYWdlLFxuICAgICAgICBnZXRGaXJzdCA9IHByb3BzLmdldEZpcnN0LFxuICAgICAgICBtb3ZlID0gZGlmZiA+IDAgPyBNYXRoLm1pbihkaWZmLCBwYWdlQnVmZmVyKSA6IE1hdGgubWF4KGRpZmYsIC1wYWdlQnVmZmVyKSxcbiAgICAgICAgcG9zID0gcHJvcHMucG9zICogcnRsICsgbW92ZSAtIGRpZmYgKyBwYWdlT2Zmc2V0LFxuICAgICAgICBsb2FkID0gTWF0aC5hYnMoZGlmZikgPiBwYWdlQnVmZmVyOyAvLyBDYWxsIGFueSBwZW5kaW5nIGNhbGxiYWNrXG5cbiAgICBpZiAocHJvcHMuY2FsbGJhY2spIHtcbiAgICAgIHByb3BzLmxvYWQoKTtcbiAgICAgIHByb3BzLmNhbGxiYWNrKHRydWUpO1xuICAgIH1cblxuICAgIHByb3BzLmZpcnN0ID0gZ2V0Rmlyc3QoZmlyc3REYXksIGRpZmYpO1xuICAgIHByb3BzLnBvcyArPSBtb3ZlICogcnRsO1xuICAgIHByb3BzLmNoYW5naW5nID0gdHJ1ZTtcblxuICAgIHByb3BzLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobG9hZCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFnZU5yOyBpKyspIHtcbiAgICAgICAgICBpbmMgPSBkaWZmICsgaSAtIHBhZ2VPZmZzZXQ7IC8vID8/P1xuXG4gICAgICAgICAgaHRtbCArPSBnZW5QYWdlKGdldEZpcnN0KGZpcnN0RGF5LCBpbmMpLCBwb3MgKyBpbmMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgJCQxKCcubWJzYy1jYWwtc2xpZGUnLCAkc2Nyb2xsZXIpLnNsaWNlKC1wYWdlTnIpLnJlbW92ZSgpO1xuICAgICAgICAgICRzY3JvbGxlci5hcHBlbmQoaHRtbCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlmZiA8IDApIHtcbiAgICAgICAgICAkJDEoJy5tYnNjLWNhbC1zbGlkZScsICRzY3JvbGxlcikuc2xpY2UoMCwgcGFnZU5yKS5yZW1vdmUoKTtcbiAgICAgICAgICAkc2Nyb2xsZXIucHJlcGVuZChodG1sKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBwcm9wcy5jYWxsYmFjayA9IGZ1bmN0aW9uIChmb3JjZVN0b3ApIHtcbiAgICAgIHZhciBuciA9IE1hdGguYWJzKG1vdmUpLFxuICAgICAgICAgIGh0bWwgPSAnJztcblxuICAgICAgaWYgKCFpbnN0Ll9pc1Zpc2libGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbnI7IGkrKykge1xuICAgICAgICBpbmMgPSBkaWZmICsgaSAtIHBhZ2VPZmZzZXQgLSBwYWdlQnVmZmVyICsgKGRpZmYgPiAwID8gcGFnZVRvdGFsIC0gbnIgOiAwKTsgLy8gPz8/XG5cbiAgICAgICAgaHRtbCArPSBnZW5QYWdlKGdldEZpcnN0KGZpcnN0RGF5LCBpbmMpLCBwb3MgKyBpbmMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgICAgJHNjcm9sbGVyLmFwcGVuZChodG1sKTtcbiAgICAgICAgJCQxKCcubWJzYy1jYWwtc2xpZGUnLCAkc2Nyb2xsZXIpLnNsaWNlKDAsIG1vdmUpLnJlbW92ZSgpO1xuICAgICAgfSBlbHNlIGlmIChkaWZmIDwgMCkge1xuICAgICAgICAkc2Nyb2xsZXIucHJlcGVuZChodG1sKTtcbiAgICAgICAgJCQxKCcubWJzYy1jYWwtc2xpZGUnLCAkc2Nyb2xsZXIpLnNsaWNlKG1vdmUpLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAobG9hZCkge1xuICAgICAgICBodG1sID0gJyc7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG5yOyBpKyspIHtcbiAgICAgICAgICBpbmMgPSBkaWZmICsgaSAtIHBhZ2VPZmZzZXQgLSBwYWdlQnVmZmVyICsgKGRpZmYgPiAwID8gMCA6IHBhZ2VUb3RhbCAtIG5yKTsgLy8gPz8/XG5cbiAgICAgICAgICBodG1sICs9IGdlblBhZ2UoZ2V0Rmlyc3QoZmlyc3REYXksIGluYyksIHBvcyArIGluYyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgICAgICAkJDEoJy5tYnNjLWNhbC1zbGlkZScsICRzY3JvbGxlcikuc2xpY2UoMCwgbW92ZSkucmVtb3ZlKCk7XG4gICAgICAgICAgJHNjcm9sbGVyLnByZXBlbmQoaHRtbCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlmZiA8IDApIHtcbiAgICAgICAgICAkJDEoJy5tYnNjLWNhbC1zbGlkZScsICRzY3JvbGxlcikuc2xpY2UobW92ZSkucmVtb3ZlKCk7XG4gICAgICAgICAgJHNjcm9sbGVyLmFwcGVuZChodG1sKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZWZyZXNoU2Nyb2xsZXIocHJvcHMpO1xuXG4gICAgICBpZiAoY2FsbGJhY2sgJiYgIWZvcmNlU3RvcCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuXG4gICAgICBwcm9wcy5jYWxsYmFjayA9IG51bGw7XG4gICAgICBwcm9wcy5sb2FkID0gbnVsbDtcbiAgICAgIHByb3BzLnF1ZXVlLnNoaWZ0KCk7XG4gICAgICBsb2FkID0gZmFsc2U7XG5cbiAgICAgIGlmIChwcm9wcy5xdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgY2hhbmdlUGFnZS5hcHBseSh0aGlzLCBwcm9wcy5xdWV1ZVswXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wcy5jaGFuZ2luZyA9IGZhbHNlO1xuICAgICAgICBwcm9wcy5vbkFmdGVyQ2hhbmdlKHByb3BzLmZpcnN0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJvcHMub25CZWZvcmVDaGFuZ2UocHJvcHMuZmlyc3QpO1xuXG4gICAgaWYgKHByb3BzLmxvYWQpIHtcbiAgICAgIHByb3BzLmxvYWQoKTtcbiAgICAgIHByb3BzLnNjcm9sbGVyLnNjcm9sbCgtcHJvcHMucG9zICogcHJvcHMuc2l6ZSwgYW5pbSA/IDIwMCA6IDAsIGZhbHNlLCBwcm9wcy5jYWxsYmFjayk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2Nyb2xsZXIoY29udCwgbWluLCBtYXgsIGJ1ZmZlciwgb2Zmc2V0LCBwYWdlcywgdG90YWwsIGZpcnN0LCBvblRhcCwgb25CZWZvcmVDaGFuZ2UsIG9uQWZ0ZXJDaGFuZ2UsIGdlblBhZ2UsIGdldEZpcnN0KSB7XG4gICAgdmFyIGF4aXMgPSBpc1ZlcnRpY2FsID8gJ1knIDogJ1gnLFxuICAgICAgICBwcm9wcyA9IHtcbiAgICAgICRzY3JvbGxlcjogJCQxKCcubWJzYy1jYWwtc2Nyb2xsJywgY29udCksXG4gICAgICBxdWV1ZTogW10sXG4gICAgICBidWZmZXI6IGJ1ZmZlcixcbiAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgcGFnZXM6IHBhZ2VzLFxuICAgICAgZmlyc3Q6IGZpcnN0LFxuICAgICAgdG90YWw6IHRvdGFsLFxuICAgICAgcG9zOiAwLFxuICAgICAgbWluOiBtaW4sXG4gICAgICBtYXg6IG1heCxcbiAgICAgIGdlblBhZ2U6IGdlblBhZ2UsXG4gICAgICBnZXRGaXJzdDogZ2V0Rmlyc3QsXG4gICAgICBvbkJlZm9yZUNoYW5nZTogb25CZWZvcmVDaGFuZ2UsXG4gICAgICBvbkFmdGVyQ2hhbmdlOiBvbkFmdGVyQ2hhbmdlXG4gICAgfTtcbiAgICBwcm9wcy5zY3JvbGxlciA9IG5ldyBTY3JvbGxWaWV3QmFzZShjb250LCB7XG4gICAgICBheGlzOiBheGlzLFxuICAgICAgZWFzaW5nOiAnJyxcbiAgICAgIGNvbnRTaXplOiAwLFxuICAgICAgbWF4U25hcFNjcm9sbDogYnVmZmVyLFxuICAgICAgbW91c2V3aGVlbDogcy5tb3VzZXdoZWVsID09PSB1bmRlZmluZWQgPyBpc1ZlcnRpY2FsIDogcy5tb3VzZXdoZWVsLFxuICAgICAgdGltZTogMjAwLFxuICAgICAgbG9jazogdHJ1ZSxcbiAgICAgIHJ0bDogaXNSVEwsXG4gICAgICBzdG9wUHJvcDogZmFsc2UsXG4gICAgICBtaW5TY3JvbGw6IDAsXG4gICAgICBtYXhTY3JvbGw6IDAsXG4gICAgICBvbkJ0blRhcDogZnVuY3Rpb24gb25CdG5UYXAoZXYpIHtcbiAgICAgICAgaWYgKGV2LmRvbUV2ZW50LnR5cGUgPT0gJ3RvdWNoZW5kJykge1xuICAgICAgICAgIHByZXZlbnRDbGljaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgb25UYXAoJCQxKGV2LnRhcmdldCksIGV2LmRvbUV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBvblN0YXJ0OiBmdW5jdGlvbiBvblN0YXJ0KCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoaG92ZXJUaW1lcik7XG4gICAgICB9LFxuICAgICAgb25HZXN0dXJlU3RhcnQ6IGZ1bmN0aW9uIG9uR2VzdHVyZVN0YXJ0KCkge1xuICAgICAgICBpc1BhZ2VNb3ZlID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBvbkFuaW1hdGlvblN0YXJ0OiBmdW5jdGlvbiBvbkFuaW1hdGlvblN0YXJ0KCkge1xuICAgICAgICBwcm9wcy5jaGFuZ2luZyA9IHRydWU7XG4gICAgICB9LFxuICAgICAgb25BbmltYXRpb25FbmQ6IGZ1bmN0aW9uIG9uQW5pbWF0aW9uRW5kKGV2KSB7XG4gICAgICAgIGlzUGFnZU1vdmUgPSBmYWxzZTtcblxuICAgICAgICBpZiAoZ2VuUGFnZSkge1xuICAgICAgICAgIGNoYW5nZVBhZ2VRdWV1ZShwcm9wcywgTWF0aC5yb3VuZCgoLXByb3BzLnBvcyAqIHByb3BzLnNpemUgLSBldlsncG9zJyArIGF4aXNdKSAvIHByb3BzLnNpemUpICogcnRsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaW5zdC5fc2Nyb2xsZXJzLnB1c2gocHJvcHMuc2Nyb2xsZXIpO1xuXG4gICAgcmV0dXJuIHByb3BzO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVmcmVzaFNjcm9sbGVyKHByb3BzLCBjaGVjaykge1xuICAgIHZhciBzaXplLFxuICAgICAgICBwbHVzID0gMCxcbiAgICAgICAgbWludXMgPSAwLFxuICAgICAgICBmaXJzdERheSA9IHByb3BzLmZpcnN0O1xuXG4gICAgaWYgKHByb3BzLmNoYW5naW5nICYmIGNoZWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BzLmdldEZpcnN0KSB7XG4gICAgICBwbHVzID0gcHJvcHMuYnVmZmVyO1xuICAgICAgbWludXMgPSBwcm9wcy5idWZmZXI7IC8vd2hpbGUgKG1pbnVzICYmIHMuZ2V0RGF0ZSh5LCBtICsgbWludXMgKyBtb250aE5yIC0gbW92ZU1vbnRoIC0gMSwgMSkgPiBtYXhEYXRlKSB7ID8/P1xuXG4gICAgICB3aGlsZSAobWludXMgJiYgcHJvcHMuZ2V0Rmlyc3QoZmlyc3REYXksIG1pbnVzICsgcHJvcHMucGFnZXMgLSBwcm9wcy5vZmZzZXQgLSAxKSA+IHByb3BzLm1heCkge1xuICAgICAgICBtaW51cy0tO1xuICAgICAgfSAvL3doaWxlIChwbHVzICYmIHMuZ2V0RGF0ZSh5LCBtIC0gcGx1cyAtIG1vdmVNb250aCwgMSkgPCBtaW5EYXRlKSB7ID8/P1xuXG5cbiAgICAgIHdoaWxlIChwbHVzICYmIHByb3BzLmdldEZpcnN0KGZpcnN0RGF5LCAxIC0gcGx1cyAtIHByb3BzLm9mZnNldCkgPD0gcHJvcHMubWluKSB7XG4gICAgICAgIHBsdXMtLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzaXplID0gTWF0aC5yb3VuZChjYWxTaXplIC8gcHJvcHMucGFnZXMpOyAvLyBQYWdlIHNpemUgbWlnaHQgYmUgYSBmcmFjdGlvbmFsIHZhbHVlIGluIGNhc2Ugb2YgbXVsdGlwbGUgbW9udGhzXG4gICAgLy8gc28gd2UgbmVlZCB0byBleHBsaWNpdGx5IHNldCB0aGUgcm91bmRlZCB2YWx1ZVxuXG4gICAgaWYgKGlzTGlxdWlkICYmIHNpemUgJiYgcHJvcHMuc2l6ZSAhPSBzaXplKSB7XG4gICAgICBwcm9wcy4kc2Nyb2xsZXJbaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJ10oc2l6ZSk7XG4gICAgfVxuXG4gICAgZXh0ZW5kJDEocHJvcHMuc2Nyb2xsZXIuc2V0dGluZ3MsIHtcbiAgICAgIHNuYXA6IHNpemUsXG4gICAgICBtaW5TY3JvbGw6ICgtcHJvcHMucG9zICogcnRsIC0gbWludXMpICogc2l6ZSxcbiAgICAgIG1heFNjcm9sbDogKC1wcm9wcy5wb3MgKiBydGwgKyBwbHVzKSAqIHNpemVcbiAgICB9KTtcbiAgICBwcm9wcy5zaXplID0gc2l6ZTtcbiAgICBwcm9wcy5zY3JvbGxlci5yZWZyZXNoKCk7XG4gIH1cblxuICBmdW5jdGlvbiByZWZyZXNoKHJlbmRlcikge1xuICAgIGluc3QuX29uUmVmcmVzaChyZW5kZXIpO1xuXG4gICAgaWYgKGluc3QuX2lzVmlzaWJsZSAmJiBoYXNDYWwgJiYgY2FsUm93cykge1xuICAgICAgaWYgKGRheVNjcm9sbCAmJiBkYXlTY3JvbGwuY2hhbmdpbmcpIHtcbiAgICAgICAgbmVlZHNSZWZyZXNoID0gcmVuZGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2VuQWxsTW9udGhzKGN1cnJGaXJzdERheSwgcmVuZGVyLCB0cnVlKTtcbiAgICAgICAgZm9jdXNEYXRlKGFjdGl2ZURhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVG91Y2hTdGFydChldikge1xuICAgIHdhc1RvdWNoZWQgPSBldi50eXBlID09PSAndG91Y2hzdGFydCc7XG4gIH1cblxuICBmdW5jdGlvbiBhdHRhY2hFdmVudHMoKSB7XG4gICAgaWYgKGhhc0NhbCAmJiBjYWxSb3dzKSB7XG4gICAgICB2YXIgJHNjcm9sbGVycyA9ICQkMSgnLm1ic2MtY2FsLXNjcm9sbC1jJywgJG1hcmt1cCk7IC8vIERheSBzZWxlY3RvclxuXG4gICAgICBkYXlTY3JvbGwgPSBjcmVhdGVTY3JvbGxlcigkc2Nyb2xsZXJzWzBdLCBtaW5EYXRlLCBtYXhEYXRlLCBwYWdlQnVmZmVyLCBwYWdlT2Zmc2V0LCBwYWdlTnIsIHBhZ2VUb3RhbCwgY3VyckZpcnN0RGF5LCBzZWxlY3REYXksIG9uQmVmb3JlTW9udGhDaGFuZ2UsIG9uQWZ0ZXJNb250aENoYW5nZSwgZ2VuTW9udGgsIGdldFBhZ2VEYXkpO1xuXG4gICAgICBpZiAoaGFzUXVpY2tOYXYpIHtcbiAgICAgICAgLy8gTW9udGggc2VsZWN0b3JcbiAgICAgICAgbW9udGhTY3JvbGwgPSBjcmVhdGVTY3JvbGxlcigkc2Nyb2xsZXJzWzFdLCBudWxsLCBudWxsLCAxLCAwLCAxLCAzLCBjdXJyRmlyc3REYXksIHNlbGVjdE1vbnRoKTsgLy8gWWVhciBzZWxlY3RvclxuXG4gICAgICAgIHllYXJTY3JvbGwgPSBjcmVhdGVTY3JvbGxlcigkc2Nyb2xsZXJzWzJdLCBtaW5GaXJzdFllYXIsIG1heEZpcnN0WWVhciwgMSwgMCwgMSwgMywgY3VyckZpcnN0RGF5LCBzZWxlY3RZZWFyLCBub29wLCBub29wLCBnZW5ZZWFycywgZ2V0UGFnZVllYXIpOyAvLyBTaG93IC8gaGlkZSBtb250aCBwaWNrZXJcblxuICAgICAgICBpbnN0LnRhcCgkbW9udGhIZHIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0b2dnbGVDb250KCRtb250aFBpY2tlcik7XG4gICAgICAgICAgaGlkZUNvbnQoJHllYXJQaWNrZXIpO1xuICAgICAgICB9KTsgLy8gU2hvdyAvIGhpZGUgeWVhciBwaWNrZXJcblxuICAgICAgICBpbnN0LnRhcCgkeWVhckhkciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRvZ2dsZUNvbnQoJHllYXJQaWNrZXIpO1xuICAgICAgICAgIGhpZGVDb250KCRtb250aFBpY2tlcik7XG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBJbml0IG5hdmlnYXRpb24gYXJyb3dzXG5cblxuICAgICAgY3JlYXRlU3RlcHBlcigkJDEoJy5tYnNjLWNhbC1idG4nLCAkbWFya3VwKSwgZnVuY3Rpb24gKGksIGRpZmYsIGV2LCBuZXh0KSB7XG4gICAgICAgIGNoYW5nZVBhZ2VRdWV1ZShkYXlTY3JvbGwsIGRpZmYsIHRydWUsIG5leHQpO1xuICAgICAgfSk7IC8vIFRyaWdnZXJzIG9uTW9udGhMb2FkZWQgb24gaW5pdGlhbCByZW5kZXJcblxuICAgICAgb25BZnRlck1vbnRoQ2hhbmdlKGN1cnJGaXJzdERheSk7IC8vIEZvY3VzIG9uIHRoZSBzZWxlY3RlZCBkYXRlIG9uIHNob3dcblxuICAgICAgaWYgKChzLmRlZmF1bHRWYWx1ZSAhPT0gbnVsbCB8fCBpbnN0Ll9oYXNWYWx1ZSkgJiYgIWluc3QuX211bHRpcGxlKSB7XG4gICAgICAgIGluc3QuX2FjdGl2ZUVsbSA9IGRheVNjcm9sbC4kYWN0aXZlWzBdO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW4oJGNhbGVuZGFyWzBdLCAndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIGxpc3RlbigkY2FsZW5kYXJbMF0sICdtb3VzZWRvd24nLCBvblRvdWNoU3RhcnQpO1xuICAgICAgJGNhbGVuZGFyIC8vIEtleWJvYXJkIG5hdmlnYXRpb25cbiAgICAgIC5vbigna2V5ZG93bicsIGZ1bmN0aW9uIChldikge1xuICAgICAgICB2YXIgeWVhciA9IHMuZ2V0WWVhcihhY3RpdmVEYXRlKSxcbiAgICAgICAgICAgIG1vbnRoID0gcy5nZXRNb250aChhY3RpdmVEYXRlKSxcbiAgICAgICAgICAgIGRheSA9IHMuZ2V0RGF5KGFjdGl2ZURhdGUpLFxuICAgICAgICAgICAgbmV3RGF0ZTtcblxuICAgICAgICBzd2l0Y2ggKGV2LmtleUNvZGUpIHtcbiAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgLy9TUEFDRVxuICAgICAgICAgICAgc2VsZWN0RGF5KGRheVNjcm9sbC4kYWN0aXZlLCBldik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzc6XG4gICAgICAgICAgICAvL0xFRlRfQVJST1c6XG4gICAgICAgICAgICBuZXdEYXRlID0gcy5nZXREYXRlKHllYXIsIG1vbnRoLCBkYXkgLSAxICogcnRsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgIC8vUklHSFRfQVJST1c6XG4gICAgICAgICAgICBuZXdEYXRlID0gcy5nZXREYXRlKHllYXIsIG1vbnRoLCBkYXkgKyAxICogcnRsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgIC8vVVBfQVJST1c6XG4gICAgICAgICAgICBuZXdEYXRlID0gcy5nZXREYXRlKHllYXIsIG1vbnRoLCBkYXkgLSA3KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICAgIC8vRE9XTl9BUlJPVzpcbiAgICAgICAgICAgIG5ld0RhdGUgPSBzLmdldERhdGUoeWVhciwgbW9udGgsIGRheSArIDcpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDM2OlxuICAgICAgICAgICAgLy9IT01FOlxuICAgICAgICAgICAgbmV3RGF0ZSA9IHMuZ2V0RGF0ZSh5ZWFyLCBtb250aCwgMSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzU6XG4gICAgICAgICAgICAvL0VORDpcbiAgICAgICAgICAgIG5ld0RhdGUgPSBzLmdldERhdGUoeWVhciwgbW9udGggKyAxLCAwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzMzpcbiAgICAgICAgICAgIC8vUEFHRV9VUDpcbiAgICAgICAgICAgIG5ld0RhdGUgPSBldi5hbHRLZXkgPyBzLmdldERhdGUoeWVhciAtIDEsIG1vbnRoLCBkYXkpIDogaXNNb250aFZpZXcgPyBzLmdldERhdGUoeWVhciwgbW9udGggLSAxLCBkYXkpIDogcy5nZXREYXRlKHllYXIsIG1vbnRoLCBkYXkgLSBjYWxSb3dzICogNyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAvL1BBR0VfRE9XTjpcbiAgICAgICAgICAgIG5ld0RhdGUgPSBldi5hbHRLZXkgPyBzLmdldERhdGUoeWVhciArIDEsIG1vbnRoLCBkYXkpIDogaXNNb250aFZpZXcgPyBzLmdldERhdGUoeWVhciwgbW9udGggKyAxLCBkYXkpIDogcy5nZXREYXRlKHllYXIsIG1vbnRoLCBkYXkgKyBjYWxSb3dzICogNyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXdEYXRlKSB7XG4gICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBzZXREYXRlKG5ld0RhdGUsIHRydWUsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSAvLyBUYWJzXG5cblxuICAgIGluc3QudGFwKCQkMSgnLm1ic2MtY2FsLXRhYicsICRtYXJrdXApLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpbnN0LmNoYW5nZVRhYigkJDEodGhpcykuYXR0cignZGF0YS1jb250cm9sJykpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJlUHJvY2Vzc1NldHRpbmdzKCk7XG4gIGJhc2UgPSBEYXRlVGltZS5jYWxsKHRoaXMsIGluc3QpO1xuICBwb3N0UHJvY2Vzc1NldHRpbmdzKCk7IC8vIFB1YmxpYyBmdW5jdGlvbnNcbiAgLy8gLS0tXG5cbiAgaW5zdC5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHJlZnJlc2goZmFsc2UpO1xuICB9O1xuXG4gIGluc3QucmVkcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgIHJlZnJlc2godHJ1ZSk7XG4gIH07XG5cbiAgaW5zdC5uYXZpZ2F0ZSA9IGZ1bmN0aW9uIChkLCBhbmltKSB7XG4gICAgc2V0RGF0ZShtYWtlRGF0ZShkLCBkaXNwbGF5Rm9ybWF0LCBzKSwgdHJ1ZSwgYW5pbSk7XG4gIH07XG5cbiAgaW5zdC5jaGFuZ2VUYWIgPSBmdW5jdGlvbiAodGFiKSB7XG4gICAgaWYgKCFpbnN0Ll9pc1Zpc2libGUgfHwgIWNvbnRyb2xzW3RhYl0gfHwgdmlzaWJsZVRhYiA9PSB0YWIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2aXNpYmxlVGFiID0gdGFiO1xuICAgICQkMSgnLm1ic2MtY2FsLXRhYicsICRtYXJrdXApLnJlbW92ZUNsYXNzKGNzc1NlbGVjdGVkVGFiKS5yZW1vdmVBdHRyKCdhcmlhLXNlbGVjdGVkJyk7XG4gICAgJCQxKCcubWJzYy1jYWwtdGFiW2RhdGEtY29udHJvbD1cIicgKyB0YWIgKyAnXCJdJywgJG1hcmt1cCkuYWRkQ2xhc3MoY3NzU2VsZWN0ZWRUYWIpLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCAndHJ1ZScpO1xuXG4gICAgaWYgKGhhc1RhYnMpIHtcbiAgICAgICR0YWJQYW5lcy5hZGRDbGFzcygnbWJzYy1jYWwtaCcpO1xuICAgICAgY29udHJvbHNbdmlzaWJsZVRhYl0ucmVtb3ZlQ2xhc3MoJ21ic2MtY2FsLWgnKTtcbiAgICB9XG5cbiAgICBpZiAodmlzaWJsZVRhYiA9PSAnY2FsZW5kYXInKSB7XG4gICAgICAvLyBTZXQgdGhlIGRhdGUgb2YgdGhlIGNhbGVuZGFyIGlmIGRhdGUgY2hhbmdlZCBmcm9tIHRoZSBzY3JvbGxlclxuICAgICAgc2V0RGF0ZShpbnN0LmdldERhdGUodHJ1ZSksIGZhbHNlLCB0cnVlKTtcbiAgICB9IC8vIEhpZGVcblxuXG4gICAgaW5zdC5fc2hvd0RheVBpY2tlcigpO1xuXG4gICAgaW5zdC50cmlnZ2VyKCdvblRhYkNoYW5nZScsIHtcbiAgICAgIHRhYjogdmlzaWJsZVRhYlxuICAgIH0pO1xuICB9OyAvLyAtLS1cbiAgLy8gUHJvdGVjdGVkIGZ1bmN0aW9uc1xuICAvLyAtLS1cblxuXG4gIGluc3QuX2NoZWNrU2l6ZSA9IHRydWU7XG4gIGluc3QuX29uR2VuTW9udGggPSBub29wO1xuICBpbnN0Ll9vblNldERhdGUgPSBub29wO1xuICBpbnN0Ll9vblJlZnJlc2ggPSBub29wO1xuICBpbnN0Ll9nZXREYXlQcm9wcyA9IG5vb3A7XG4gIGluc3QuX3ByZXBhcmVPYmogPSBwcmVwYXJlT2JqO1xuXG4gIGluc3QuX3Nob3dEYXlQaWNrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGhhc1F1aWNrTmF2KSB7XG4gICAgICBoaWRlQ29udCgkeWVhclBpY2tlcik7XG4gICAgICBoaWRlQ29udCgkbW9udGhQaWNrZXIpO1xuICAgIH1cbiAgfTtcblxuICBpbnN0Ll9zZWxlY3REYXkgPSBpbnN0Ll9fc2VsZWN0RGF5ID0gZnVuY3Rpb24gKCRkYXksIGQsIGR0aW1lKSB7XG4gICAgdmFyIGZpbGwgPSBpbnN0LmxpdmU7IC8vIFByZXZlbnRzIG1vbnRoIHNsaWRlIGluIHNldERhdGVcblxuICAgIG5lZWRzU2xpZGUgPSBzLm91dGVyTW9udGhDaGFuZ2U7XG4gICAgaXNEYXlDbGljayA9IHRydWU7IC8vIFNldCBkYXRlIG9uIHNjcm9sbGVyXG5cbiAgICBpbnN0LnNldERhdGUoZHRpbWUsIGZpbGwsIDEwMDAsICFmaWxsLCB0cnVlKTtcblxuICAgIGlmIChmaWxsKSB7XG4gICAgICB0cmlnZ2VyKCdvblNldCcsIHtcbiAgICAgICAgdmFsdWVUZXh0OiBpbnN0Ll92YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGluc3QuX2NoZWNrQnRuID0gY2hlY2tCdG47IC8vIC0tLVxuXG4gIHJldHVybiBleHRlbmQkMShiYXNlLCB7XG4gICAgbGFiZWxzOiBudWxsLFxuICAgIC8vIE92ZXJyaWRlcyBsYWJlbHMgY29taW5nIGZyb20gbGFuZ3VhZ2UgZmlsZXNcbiAgICBjb21wQ2xhc3M6ICdtYnNjLWNhbGVuZGFyIG1ic2MtZHQgbWJzYy1zYycsXG4gICAgb25NYXJrdXBSZWFkeTogZnVuY3Rpb24gb25NYXJrdXBSZWFkeShldikge1xuICAgICAgdmFyIGogPSAwO1xuICAgICAgJG1hcmt1cCA9ICQkMShldi50YXJnZXQpO1xuICAgICAgJHRhYlBhbmVDb250ID0gJCQxKCcubWJzYy1mci1jJywgJG1hcmt1cCk7XG4gICAgICBhY3RpdmVEYXRlID0gaW5zdC5nZXREYXRlKHRydWUpO1xuICAgICAgY2FsU2l6ZSA9IDA7XG5cbiAgICAgIGlmIChoYXNDYWwpIHtcbiAgICAgICAgaGFzTWFya3MgPSAhIShzLm1hcmtlZCB8fCBzLmRhdGEpICYmICFzLmxhYmVscyAmJiAhcy5tdWx0aUxhYmVsICYmICFzLnNob3dFdmVudENvdW50OyAvLyBoYXNUZXh0ID0gcy5zaG93RXZlbnRDb3VudCB8fCAhIShzLmV2ZW50cyB8fCBzLmxhYmVscyk7XG5cbiAgICAgICAgbmVlZHNTbGlkZSA9IHRydWU7XG4gICAgICAgIHZpc2libGVUYWIgPSAnY2FsZW5kYXInO1xuICAgICAgICBjYWxjTW9udGhOcigpO1xuICAgICAgICBjdXJyRmlyc3REYXkgPSBnZXRGaXJzdERheShjb25zdHJhaW4oYWN0aXZlRGF0ZSksIGlzTW9udGhWaWV3KTtcbiAgICAgICAgJHRhYlBhbmVDb250LmFwcGVuZChnZW5DYWxNYXJrdXAoKSk7XG4gICAgICAgICRtb250aEhkciA9ICQkMSgnLm1ic2MtY2FsLW1vbnRoJywgJG1hcmt1cCk7XG4gICAgICAgICR5ZWFySGRyID0gJCQxKCcubWJzYy1jYWwteWVhcicsICRtYXJrdXApO1xuICAgICAgICAkY2FsZW5kYXIgPSAkJDEoJy5tYnNjLWNhbC1kYXktc2Nyb2xsLWMnLCAkbWFya3VwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc1F1aWNrTmF2KSB7XG4gICAgICAgICR5ZWFyUGlja2VyID0gJCQxKCcubWJzYy1jYWwteWVhci1waWNrZXInLCAkbWFya3VwKTtcbiAgICAgICAgJG1vbnRoUGlja2VyID0gJCQxKCcubWJzYy1jYWwtbW9udGgtcGlja2VyJywgJG1hcmt1cCk7XG4gICAgICB9XG5cbiAgICAgICR0YWJQYW5lcyA9ICQkMSgnLm1ic2Mtdy1wJywgJG1hcmt1cCk7IC8vIEluc2VydCB0YWIgbWFya3VwXG5cbiAgICAgIGlmIChjb250cm9sc0FycmF5Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgJHRhYlBhbmVDb250LmJlZm9yZShnZW5UYWJNYXJrdXAoKSk7XG4gICAgICB9IC8vIEZpbmQgbWFya3VwIGZvciBjb250cm9sc1xuXG5cbiAgICAgIFsnZGF0ZScsICd0aW1lJywgJ2NhbGVuZGFyJ10uZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICBpZiAoY29udHJvbHNbdl0pIHtcbiAgICAgICAgICBjb250cm9sc1t2XSA9ICR0YWJQYW5lcy5lcShqKTtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH0gZWxzZSBpZiAodiA9PSAnZGF0ZScgJiYgIWNvbnRyb2xzLmRhdGUgJiYgaGFzQ2FsKSB7XG4gICAgICAgICAgJHRhYlBhbmVzLmVxKGopLnJlbW92ZSgpO1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIEluc2VydCBjb250cm9scyBpbiBjb3JyZWN0IG9yZGVyXG5cbiAgICAgIGNvbnRyb2xzQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAkdGFiUGFuZUNvbnQuYXBwZW5kKGNvbnRyb2xzW3ZdKTtcbiAgICAgIH0pOyAvLyBUT0RPOiB0aGlzIGlzIGFuIHVnbHkgc29sdXRpb25cblxuICAgICAgaWYgKCFoYXNDYWwgJiYgY29udHJvbHMuZGF0ZSkge1xuICAgICAgICBjb250cm9scy5kYXRlLmNzcygncG9zaXRpb24nLCAncmVsYXRpdmUnKTtcbiAgICAgIH1cblxuICAgICAgaW5zdC5fc2Nyb2xsZXJzID0gW107XG4gICAgICBhdHRhY2hFdmVudHMoKTtcbiAgICB9LFxuICAgIG9uU2hvdzogZnVuY3Rpb24gb25TaG93KCkge1xuICAgICAgaWYgKGhhc0NhbCAmJiBjYWxSb3dzKSB7XG4gICAgICAgIHNldFRpdGxlKGN1cnJGaXJzdERheSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkhpZGU6IGZ1bmN0aW9uIG9uSGlkZSgpIHtcbiAgICAgIGluc3QuX3Njcm9sbGVycy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHYuZGVzdHJveSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGRheVByb3BzID0gbnVsbDtcbiAgICAgIGRheVNjcm9sbCA9IG51bGw7XG4gICAgICBtb250aFNjcm9sbCA9IG51bGw7XG4gICAgICB5ZWFyU2Nyb2xsID0gbnVsbDtcbiAgICAgIHZpc2libGVUYWIgPSBudWxsO1xuICAgIH0sXG4gICAgb25WYWxpZGF0ZWQ6IGZ1bmN0aW9uIG9uVmFsaWRhdGVkKGV2KSB7XG4gICAgICB2YXIgY3RybCxcbiAgICAgICAgICBkLFxuICAgICAgICAgIGkgPSBldi5pbmRleCxcbiAgICAgICAgICBvcmRlciA9IGluc3QuX29yZGVyO1xuICAgICAgZCA9IGluc3QuZ2V0RGF0ZSh0cnVlKTtcbiAgICAgIHNlbGVjdGVkRGF0ZSA9IGQ7IC8vIEZpbmQgb3V0IG9uIHdoaWNoIGNvbnRyb2wgd2FzIHRoZSBzZWxlY3Rpb24gbWFkZVxuXG4gICAgICBpZiAoaXNEYXlDbGljaykge1xuICAgICAgICBjdHJsID0gJ2NhbGVuZGFyJztcbiAgICAgIH0gZWxzZSBpZiAoaSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN0cmwgPSBvcmRlci5kZCA9PSBpIHx8IG9yZGVyLmQgPT0gaSB8fCBvcmRlci5tID09IGkgfHwgb3JkZXIueSA9PSBpID8gJ2RhdGUnIDogJ3RpbWUnO1xuICAgICAgfVxuXG4gICAgICB0cmlnZ2VyKCdvblNldERhdGUnLCB7XG4gICAgICAgIGRhdGU6IGQsXG4gICAgICAgIGNvbnRyb2w6IGN0cmxcbiAgICAgIH0pOyAvLyBTZXQgZGF0ZSBvbiBjYWxlbmRhclxuXG4gICAgICBpZiAoY3RybCAhPT0gJ3RpbWUnKSB7XG4gICAgICAgIHNldERhdGUoZCwgZmFsc2UsICEhZXYudGltZSwgaXNEYXlDbGljayAmJiAhaW5zdC5fbXVsdGlwbGUpO1xuICAgICAgfVxuXG4gICAgICBpc0RheUNsaWNrID0gZmFsc2U7XG4gICAgfSxcbiAgICBvblBvc2l0aW9uOiBmdW5jdGlvbiBvblBvc2l0aW9uKGV2KSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICB5LFxuICAgICAgICAgIG0sXG4gICAgICAgICAgZG9SZWZyZXNoLFxuICAgICAgICAgIG1vZGFsSGVpZ2h0LFxuICAgICAgICAgIG5ld0NhbFNpemUsXG4gICAgICAgICAgYXZhaWxhYmxlSGVpZ2h0LFxuICAgICAgICAgIG9sZEhlaWdodCA9IGV2Lm9sZEhlaWdodCxcbiAgICAgICAgICB3aW5kb3dIZWlnaHQgPSBldi53aW5kb3dIZWlnaHQ7XG4gICAgICBoYXNUYWJzID0gKGV2Lmhhc1RhYnMgfHwgcy50YWJzID09PSB0cnVlIHx8IHMudGFicyAhPT0gZmFsc2UgJiYgaXNMaXF1aWQpICYmIGNvbnRyb2xzQXJyYXkubGVuZ3RoID4gMTtcblxuICAgICAgaWYgKGlzTGlxdWlkKSB7XG4gICAgICAgIGlmIChldi53aW5kb3dXaWR0aCA+PSBzLmJyZWFrUG9pbnRNZCkge1xuICAgICAgICAgICQkMShldi50YXJnZXQpLmFkZENsYXNzKCdtYnNjLWZyLW1kJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJCQxKGV2LnRhcmdldCkucmVtb3ZlQ2xhc3MoJ21ic2MtZnItbWQnKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBTaG93L2hpZGUgdGFic1xuXG5cbiAgICAgIGlmIChoYXNUYWJzKSB7XG4gICAgICAgICRtYXJrdXAuYWRkQ2xhc3MoJ21ic2MtY2FsLXRhYmJlZCcpO1xuICAgICAgICB2aXNpYmxlVGFiID0gJCQxKCcubWJzYy1jYWwtdGFiLm1ic2Mtc2VsZWN0ZWQnLCAkbWFya3VwKS5hdHRyKCdkYXRhLWNvbnRyb2wnKTtcbiAgICAgICAgJHRhYlBhbmVzLmFkZENsYXNzKCdtYnNjLWNhbC1oJyk7XG4gICAgICAgIGNvbnRyb2xzW3Zpc2libGVUYWJdLnJlbW92ZUNsYXNzKCdtYnNjLWNhbC1oJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB2aXNpYmxlVGFiID0gJ2NhbGVuZGFyJztcbiAgICAgICAgJG1hcmt1cC5yZW1vdmVDbGFzcygnbWJzYy1jYWwtdGFiYmVkJyk7XG4gICAgICAgICR0YWJQYW5lcy5yZW1vdmVDbGFzcygnbWJzYy1jYWwtaCcpO1xuICAgICAgfSAvLyBGdWxsIHNjcmVlbiBtb2RlXG5cblxuICAgICAgaWYgKGluc3QuX2lzRnVsbFNjcmVlbikge1xuICAgICAgICAvLyBSZXNldCBoZWlnaHRcbiAgICAgICAgJGNhbGVuZGFyLmhlaWdodCgnJyk7XG4gICAgICAgIG1vZGFsSGVpZ2h0ID0gZXYucG9wdXAub2Zmc2V0SGVpZ2h0OyAvLyBHZXQgYXZhaWxhYmxlIGhlaWdodFxuXG4gICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IHdpbmRvd0hlaWdodCAtIG1vZGFsSGVpZ2h0ICsgJGNhbGVuZGFyWzBdLm9mZnNldEhlaWdodDsgLy8gT25seSBzZXQgZml4ZWQgaGVpZ2h0IGlmIGNhbGVuZGFyIGhlaWdodCBpcyBiaWdnZXIgdGhhbiB2aWV3cG9ydCBoZWlnaHRcblxuICAgICAgICBpZiAod2luZG93SGVpZ2h0ID49IG1vZGFsSGVpZ2h0KSB7XG4gICAgICAgICAgJGNhbGVuZGFyLmhlaWdodChhdmFpbGFibGVIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNMYWJlbHMgJiYgY2FsUm93cyAmJiB3aW5kb3dIZWlnaHQgIT0gb2xkSGVpZ2h0KSB7XG4gICAgICAgIC8vIENoZWNrIGhvdyBtYW55IGxhYmVscyBjYW4gd2UgZGlzcGxheSBvbiBhIGRheVxuICAgICAgICB2YXIgY2FsSGVpZ2h0ID0gYXZhaWxhYmxlSGVpZ2h0IHx8ICRjYWxlbmRhclswXS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIHZhciBwaCA9ICRjYWxlbmRhci5maW5kKCcubWJzYy1jYWwtdHh0LC5tYnNjLWNhbC10eHQtcGgnKVswXTtcbiAgICAgICAgdmFyIG51bWJlckhlaWdodCA9IHBoLm9mZnNldFRvcDtcbiAgICAgICAgdmFyIHR4dEhlaWdodCA9IHBoLm9mZnNldEhlaWdodDtcbiAgICAgICAgdmFyIG5ld01heExhYmVscyA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoKGNhbEhlaWdodCAvIGNhbFJvd3MgLSBudW1iZXJIZWlnaHQpIC8gKHR4dEhlaWdodCArIDIpKSk7IC8vIFJlZHJhdyB0aGUgY2FsZW5kYXIsIGlmIG1heCBsYWJlbHMgY2hhbmdlZFxuXG4gICAgICAgIGlmIChtYXhMYWJlbHMgIT0gbmV3TWF4TGFiZWxzKSB7XG4gICAgICAgICAgbWF4TGFiZWxzID0gbmV3TWF4TGFiZWxzO1xuICAgICAgICAgIGluc3QucmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmVmcmVzaCBzY3JvbGx2aWV3c1xuXG5cbiAgICAgIGlmIChoYXNDYWwgJiYgY2FsUm93cykge1xuICAgICAgICAvLyBOZWVkIHRvIGNhbGN1bGF0ZSBzaXplXG4gICAgICAgIGlmIChpc0xpcXVpZCB8fCBpc1ZlcnRpY2FsIHx8IGhhc1RhYnMpIHtcbiAgICAgICAgICBuZXdDYWxTaXplID0gJGNhbGVuZGFyWzBdW2lzVmVydGljYWwgPyAnb2Zmc2V0SGVpZ2h0JyA6ICdvZmZzZXRXaWR0aCddO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0NhbFNpemUgPSBjYWxXaWR0aCB8fCBwYWdlTnIgKiAyODA7XG4gICAgICAgIH1cblxuICAgICAgICBkb1JlZnJlc2ggPSBuZXdDYWxTaXplICE9IGNhbFNpemU7XG4gICAgICAgIGNhbFNpemUgPSBuZXdDYWxTaXplOyAvLyBVc2UgbG9uZyBvciBzaG9ydCBtb250aCBuYW1lc1xuXG4gICAgICAgIGlmIChpc0xpcXVpZCAmJiBkb1JlZnJlc2gpIHtcbiAgICAgICAgICBpZiAoeWVhckNoYW5nZSkge1xuICAgICAgICAgICAgbW9udGhOYW1lcyA9IHMubWF4TW9udGhXaWR0aCA+ICRtb250aEhkclswXS5vZmZzZXRXaWR0aCA/IHMubW9udGhOYW1lc1Nob3J0IDogcy5tb250aE5hbWVzO1xuICAgICAgICAgICAgeSA9IHMuZ2V0WWVhcihjdXJyRmlyc3REYXkpO1xuICAgICAgICAgICAgbSA9IHMuZ2V0TW9udGgoY3VyckZpcnN0RGF5KTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhZ2VOcjsgaSsrKSB7XG4gICAgICAgICAgICAgICRtb250aEhkci5lcShpKS50ZXh0KG1vbnRoTmFtZXNbcy5nZXRNb250aChzLmdldERhdGUoeSwgbSAtIHBhZ2VPZmZzZXQgKyBpLCAxKSldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9SZWZyZXNoKSB7XG4gICAgICAgICAgcmVmcmVzaFNjcm9sbGVyKGRheVNjcm9sbCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhhc1F1aWNrTmF2ICYmIGRvUmVmcmVzaCkge1xuICAgICAgICByZWZyZXNoU2Nyb2xsZXIobW9udGhTY3JvbGwsIHRydWUpO1xuICAgICAgICByZWZyZXNoU2Nyb2xsZXIoeWVhclNjcm9sbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBDYWxlbmRhciA9IFNjcm9sbGVyO1xudmFyIGRlZmF1bHRzJDMgPSB7fTtcblxucHJlc2V0cy5jYWxlbmRhciA9IGZ1bmN0aW9uIChpbnN0KSB7XG4gIGZ1bmN0aW9uIGdldERhdGVPbmx5KGQpIHtcbiAgICByZXR1cm4gYWRqdXN0ZWREYXRlKGQuZ2V0RnVsbFllYXIoKSwgZC5nZXRNb250aCgpLCBkLmdldERhdGUoKSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRWYWx1ZXModmFsdWVzKSB7XG4gICAgdmFyIGQsXG4gICAgICAgIGksXG4gICAgICAgIGZpcnN0ID0gbnVsbDtcbiAgICBzZWxlY3RlZFZhbHVlcyA9IHt9O1xuXG4gICAgaWYgKHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGQgPSBtYWtlRGF0ZSh2YWx1ZXNbaV0sIGRpc3BsYXlGb3JtYXQsIHMsIHMuaXNvUGFydHMpO1xuICAgICAgICBmaXJzdCA9IGZpcnN0IHx8IGQ7XG4gICAgICAgIHNlbGVjdGVkVmFsdWVzW2dldERhdGVPbmx5KGQpXSA9IGQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpcnN0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVkcmF3KCkge1xuICAgIGluc3QucmVkcmF3KCk7XG4gIH0gLy8gLS0tXG5cblxuICB2YXIgYmFzZSxcbiAgICAgIGN0eCxcbiAgICAgIGRpc3BsYXlGb3JtYXQsXG4gICAgICBmaXJzdFNlbGVjdERheSxcbiAgICAgIG9yaWdWYWx1ZXMsXG4gICAgICBvcmlnID0gZXh0ZW5kJDEoe30sIGluc3Quc2V0dGluZ3MpLFxuICAgICAgcyA9IGV4dGVuZCQxKGluc3Quc2V0dGluZ3MsIGRlZmF1bHRzJDMsIG9yaWcpLFxuICAgICAgY3NzU2VsZWN0ZWQgPSAnbWJzYy1zZWxlY3RlZCAnICsgKHMuc2VsZWN0ZWRDbGFzcyB8fCAnJyksXG4gICAgICBkZWZhdWx0VmFsdWUgPSBzLmRlZmF1bHRWYWx1ZSxcbiAgICAgIG11bHRpID0gcy5zZWxlY3QgPT0gJ211bHRpcGxlJyB8fCBzLnNlbGVjdCA+IDEgfHwgcy5zZWxlY3RUeXBlID09ICd3ZWVrJyxcbiAgICAgIG1heFNlbGVjdCA9IGlzTnVtZXJpYyhzLnNlbGVjdCkgPyBzLnNlbGVjdCA6IEluZmluaXR5LFxuICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSB7fTtcbiAgYmFzZSA9IENhbGVuZGFyQmFzZS5jYWxsKHRoaXMsIGluc3QpO1xuICBmaXJzdFNlbGVjdERheSA9IHMuZmlyc3RTZWxlY3REYXkgPT09IHVuZGVmaW5lZCA/IHMuZmlyc3REYXkgOiBzLmZpcnN0U2VsZWN0RGF5O1xuICBkaXNwbGF5Rm9ybWF0ID0gaW5zdC5fZm9ybWF0O1xuXG4gIGlmIChtdWx0aSkge1xuICAgIHNldFZhbHVlcyhkZWZhdWx0VmFsdWUpO1xuICB9IC8vIEV4dGVuZGVkIG1ldGhvZHNcbiAgLy8gLS0tXG5cblxuICBpbnN0Ll9tdWx0aXBsZSA9IG11bHRpO1xuXG4gIGluc3QuX2dldERheVByb3BzID0gZnVuY3Rpb24gKGQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2VsZWN0ZWQ6IG11bHRpID8gc2VsZWN0ZWRWYWx1ZXNbZF0gIT09IHVuZGVmaW5lZCA6IHVuZGVmaW5lZFxuICAgIH07XG4gIH07XG5cbiAgaW5zdC5fc2VsZWN0RGF5ID0gZnVuY3Rpb24gKCRkYXksIGQsIGR0aW1lLCBzZWxlY3RlZCkge1xuICAgIHZhciBpc1NpbmdsZVNlbGVjdCA9IHMuc2VsZWN0ID09ICdzaW5nbGUnIHx8IHMuc2VsZWN0ID09IDEgfHwgcy5zZWxlY3QgPT09IHVuZGVmaW5lZDsgLy8gU2luZ2xlIHNlbGVjdCB3aXRoIGluc3RhbnQgY2xvc2VcblxuICAgIGlmIChzLnNldE9uRGF5VGFwICYmIGlzU2luZ2xlU2VsZWN0ICYmIHMuZGlzcGxheSAhPSAnaW5saW5lJykge1xuICAgICAgaW5zdC5zZXREYXRlKGR0aW1lKTtcbiAgICAgIGluc3Quc2VsZWN0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG11bHRpKSB7XG4gICAgICAvLyBNdWx0aXBsZSBkYXkgc2VsZWN0aW9uXG4gICAgICBpZiAocy5zZWxlY3RUeXBlID09ICd3ZWVrJykge1xuICAgICAgICAvLyBTZWxlY3Qgd2hvbGUgd2Vla1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIHNlbCxcbiAgICAgICAgICAgIGRpZmYgPSBkLmdldERheSgpIC0gZmlyc3RTZWxlY3REYXk7XG4gICAgICAgIGRpZmYgPSBkaWZmIDwgMCA/IDcgKyBkaWZmIDogZGlmZjtcblxuICAgICAgICBpZiAoaXNTaW5nbGVTZWxlY3QpIHtcbiAgICAgICAgICAvLyBPbmx5IG9uZSB3ZWVrIGNhbiBiZSBzZWxlY3RlZFxuICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgc2VsID0gYWRqdXN0ZWREYXRlKGQuZ2V0RnVsbFllYXIoKSwgZC5nZXRNb250aCgpLCBkLmdldERhdGUoKSAtIGRpZmYgKyBpKTtcblxuICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgZGVsZXRlIHNlbGVjdGVkVmFsdWVzW3NlbF07XG4gICAgICAgICAgfSBlbHNlIGlmIChvYmplY3RUb0FycmF5KHNlbGVjdGVkVmFsdWVzKS5sZW5ndGggLyA3IDwgbWF4U2VsZWN0KSB7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlc1tzZWxdID0gc2VsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlZHJhdygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2VsZWN0IGRheSBvbmx5XG4gICAgICAgIHZhciBkYXlzID0gJCQxKCcubWJzYy1jYWwtZGF5W2RhdGEtZnVsbD1cIicgKyAkZGF5LmF0dHIoJ2RhdGEtZnVsbCcpICsgJ1wiXScsIGN0eCk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgZGF5cy5yZW1vdmVDbGFzcyhjc3NTZWxlY3RlZCkucmVtb3ZlQXR0cignYXJpYS1zZWxlY3RlZCcpO1xuICAgICAgICAgIGRlbGV0ZSBzZWxlY3RlZFZhbHVlc1tkXTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmplY3RUb0FycmF5KHNlbGVjdGVkVmFsdWVzKS5sZW5ndGggPCBtYXhTZWxlY3QpIHtcbiAgICAgICAgICBkYXlzLmFkZENsYXNzKGNzc1NlbGVjdGVkKS5hdHRyKCdhcmlhLXNlbGVjdGVkJywgJ3RydWUnKTtcbiAgICAgICAgICBzZWxlY3RlZFZhbHVlc1tkXSA9IGQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIFN0YW5kYXJkIHNlbGVjdGlvblxuXG5cbiAgICBpbnN0Ll9fc2VsZWN0RGF5KCRkYXksIGQsIGR0aW1lKTtcbiAgfTtcblxuICBpbnN0LnNldFZhbCA9IGZ1bmN0aW9uICh2YWwsIGZpbGwsIGNoYW5nZSwgdGVtcCwgdGltZSkge1xuICAgIGlmIChtdWx0aSkge1xuICAgICAgdmFsID0gc2V0VmFsdWVzKHZhbCk7XG4gICAgfVxuXG4gICAgaW5zdC5fc2V0VmFsKHZhbCwgZmlsbCwgY2hhbmdlLCB0ZW1wLCB0aW1lKTtcblxuICAgIGlmIChtdWx0aSkge1xuICAgICAgcmVkcmF3KCk7XG4gICAgfVxuICB9O1xuXG4gIGluc3QuZ2V0VmFsID0gZnVuY3Rpb24gKHRlbXApIHtcbiAgICB2YXIgaSxcbiAgICAgICAgcmV0ID0gW107XG5cbiAgICBpZiAobXVsdGkpIHtcbiAgICAgIGZvciAoaSBpbiBzZWxlY3RlZFZhbHVlcykge1xuICAgICAgICByZXQucHVzaChyZXR1cm5EYXRlKHNlbGVjdGVkVmFsdWVzW2ldLCBzLCBkaXNwbGF5Rm9ybWF0KSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldHVybkRhdGUoaW5zdC5nZXREYXRlKHRlbXApLCBzLCBkaXNwbGF5Rm9ybWF0KTtcbiAgfTsgLy8gLS0tXG5cblxuICByZXR1cm4gZXh0ZW5kJDEoe30sIGJhc2UsIHtcbiAgICBoaWdobGlnaHQ6ICFtdWx0aSxcbiAgICBvdXRlck1vbnRoQ2hhbmdlOiAhbXVsdGksXG4gICAgcGFyc2VWYWx1ZTogZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XG4gICAgICBpZiAobXVsdGkgJiYgdiAmJiB0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdiA9IHNldFZhbHVlcyh2LnNwbGl0KCcsJykpO1xuICAgICAgfVxuXG4gICAgICBpZiAobXVsdGkgJiYgZGVmYXVsdFZhbHVlICYmIGRlZmF1bHRWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWVbMF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiYXNlLnBhcnNlVmFsdWUuY2FsbCh0aGlzLCB2KTtcbiAgICB9LFxuICAgIGZvcm1hdFZhbHVlOiBmdW5jdGlvbiBmb3JtYXRWYWx1ZShkKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICByZXQgPSBbXTtcblxuICAgICAgaWYgKG11bHRpKSB7XG4gICAgICAgIGZvciAoaSBpbiBzZWxlY3RlZFZhbHVlcykge1xuICAgICAgICAgIHJldC5wdXNoKGZvcm1hdERhdGUoZGlzcGxheUZvcm1hdCwgc2VsZWN0ZWRWYWx1ZXNbaV0sIHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQuam9pbignLCAnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhc2UuZm9ybWF0VmFsdWUuY2FsbCh0aGlzLCBkLCBpbnN0KTtcbiAgICB9LFxuICAgIG9uQ2xlYXI6IGZ1bmN0aW9uIG9uQ2xlYXIoKSB7XG4gICAgICBpZiAobXVsdGkpIHtcbiAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSB7fTtcbiAgICAgICAgcmVkcmF3KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkJlZm9yZVNob3c6IGZ1bmN0aW9uIG9uQmVmb3JlU2hvdygpIHtcbiAgICAgIGlmIChzLnNldE9uRGF5VGFwID09PSB1bmRlZmluZWQgJiYgKCFzLmJ1dHRvbnMgfHwgIXMuYnV0dG9ucy5sZW5ndGgpICYmIHMuY29udHJvbHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcy5zZXRPbkRheVRhcCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzLnNldE9uRGF5VGFwICYmIHMuZGlzcGxheSAhPSAnaW5saW5lJykge1xuICAgICAgICBzLm91dGVyTW9udGhDaGFuZ2UgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMuY291bnRlciAmJiBtdWx0aSkge1xuICAgICAgICBzLmhlYWRlclRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IDAsXG4gICAgICAgICAgICAgIHcgPSBzLnNlbGVjdFR5cGUgPT0gJ3dlZWsnID8gNyA6IDE7XG4gICAgICAgICAgJCQxLmVhY2goc2VsZWN0ZWRWYWx1ZXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxlbmd0aCsrO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxlbmd0aCA9IE1hdGgucm91bmQobGVuZ3RoIC8gdyk7XG4gICAgICAgICAgcmV0dXJuIChsZW5ndGggPiAxID8gcy5zZWxlY3RlZFBsdXJhbFRleHQgfHwgcy5zZWxlY3RlZFRleHQgOiBzLnNlbGVjdGVkVGV4dCkucmVwbGFjZSgve2NvdW50fS8sIGxlbmd0aCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBvbk1hcmt1cFJlYWR5OiBmdW5jdGlvbiBvbk1hcmt1cFJlYWR5KGV2KSB7XG4gICAgICBiYXNlLm9uTWFya3VwUmVhZHkuY2FsbCh0aGlzLCBldik7XG4gICAgICBjdHggPSAkJDEoZXYudGFyZ2V0KTtcblxuICAgICAgaWYgKG11bHRpKSB7XG4gICAgICAgICQkMSgnLm1ic2MtZnItaGRyJywgY3R4KS5hdHRyKCdhcmlhLWxpdmUnLCAnb2ZmJyk7XG4gICAgICAgIG9yaWdWYWx1ZXMgPSBleHRlbmQkMSh7fSwgc2VsZWN0ZWRWYWx1ZXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25DYW5jZWw6IGZ1bmN0aW9uIG9uQ2FuY2VsKCkge1xuICAgICAgaWYgKCFpbnN0LmxpdmUgJiYgbXVsdGkpIHtcbiAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBleHRlbmQkMSh7fSwgb3JpZ1ZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBNYnNjRGF0ZXRpbWVCYXNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjRGF0ZXRpbWVCYXNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY0RhdGV0aW1lQmFzZShpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCB2aWV3KSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NEYXRldGltZUJhc2UucHJvdG90eXBlLCBcImRlZmF1bHRWYWx1ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIE1ic2NEYXRldGltZUJhc2UucHJvdG90eXBlLCBcImludmFsaWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSlcclxuICAgIF0sIE1ic2NEYXRldGltZUJhc2UucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKVxyXG4gICAgXSwgTWJzY0RhdGV0aW1lQmFzZS5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NEYXRldGltZUJhc2UucHJvdG90eXBlLCBcInJldHVybkZvcm1hdFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjRGF0ZXRpbWVCYXNlLnByb3RvdHlwZSwgXCJzdGVwc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIE1ic2NEYXRldGltZUJhc2UucHJvdG90eXBlLCBcInZhbGlkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NEYXRldGltZUJhc2UucHJvdG90eXBlLCBcImNhbGVuZGFyU3lzdGVtXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NEYXRldGltZUJhc2UucHJvdG90eXBlLCBcImFtcG1UZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NEYXRldGltZUJhc2UucHJvdG90eXBlLCBcImFtVGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjRGF0ZXRpbWVCYXNlLnByb3RvdHlwZSwgXCJkYXRlRm9ybWF0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NEYXRldGltZUJhc2UucHJvdG90eXBlLCBcImRhdGVXaGVlbHNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBNYnNjRGF0ZXRpbWVCYXNlLnByb3RvdHlwZSwgXCJkYXlOYW1lc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIE1ic2NEYXRldGltZUJhc2UucHJvdG90eXBlLCBcImRheU5hbWVzU2hvcnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0RhdGV0aW1lQmFzZS5wcm90b3R5cGUsIFwiZGF5VGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjRGF0ZXRpbWVCYXNlLnByb3RvdHlwZSwgXCJob3VyVGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjRGF0ZXRpbWVCYXNlLnByb3RvdHlwZSwgXCJtaW51dGVUZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgTWJzY0RhdGV0aW1lQmFzZS5wcm90b3R5cGUsIFwibW9udGhOYW1lc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIE1ic2NEYXRldGltZUJhc2UucHJvdG90eXBlLCBcIm1vbnRoTmFtZXNTaG9ydFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjRGF0ZXRpbWVCYXNlLnByb3RvdHlwZSwgXCJtb250aFN1ZmZpeFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjRGF0ZXRpbWVCYXNlLnByb3RvdHlwZSwgXCJtb250aFRleHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0RhdGV0aW1lQmFzZS5wcm90b3R5cGUsIFwibm93VGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjRGF0ZXRpbWVCYXNlLnByb3RvdHlwZSwgXCJwbVRleHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0RhdGV0aW1lQmFzZS5wcm90b3R5cGUsIFwic2VjVGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjRGF0ZXRpbWVCYXNlLnByb3RvdHlwZSwgXCJ0aW1lRm9ybWF0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NEYXRldGltZUJhc2UucHJvdG90eXBlLCBcInRpbWVXaGVlbHNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0RhdGV0aW1lQmFzZS5wcm90b3R5cGUsIFwieWVhclN1ZmZpeFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjRGF0ZXRpbWVCYXNlLnByb3RvdHlwZSwgXCJ5ZWFyVGV4dFwiLCB2b2lkIDApO1xyXG4gICAgTWJzY0RhdGV0aW1lQmFzZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW21ic2MtZHQtYicgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBOZ1pvbmUsIE5nQ29udHJvbCwgTWJzY0lucHV0U2VydmljZSwgVmlld0NvbnRhaW5lclJlZl0pXHJcbiAgICBdLCBNYnNjRGF0ZXRpbWVCYXNlKTtcclxuICAgIHJldHVybiBNYnNjRGF0ZXRpbWVCYXNlO1xyXG59KE1ic2NTY3JvbGxlckJhc2UpKTtcclxudmFyIE1ic2NEYXRldGltZUJhc2VNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWJzY0RhdGV0aW1lQmFzZU1vZHVsZSgpIHtcclxuICAgIH1cclxuICAgIE1ic2NEYXRldGltZUJhc2VNb2R1bGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBOZ01vZHVsZSh7XHJcbiAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIE1ic2NTY3JvbGxlckJhc2VNb2R1bGVdLFxyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNYnNjRGF0ZXRpbWVCYXNlXSxcclxuICAgICAgICB9KVxyXG4gICAgXSwgTWJzY0RhdGV0aW1lQmFzZU1vZHVsZSk7XHJcbiAgICByZXR1cm4gTWJzY0RhdGV0aW1lQmFzZU1vZHVsZTtcclxufSgpKTtcblxudmFyIE1ic2NDYWxCYXNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjQ2FsQmFzZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NDYWxCYXNlKGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIHZpZXcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCB2aWV3KSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLm9uVGFiQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm9uTGFiZWxUYXAgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMub25Nb250aENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5vbk1vbnRoTG9hZGluZyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5vbk1vbnRoTG9hZGVkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm9uUGFnZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5vblBhZ2VMb2FkZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMub25QYWdlTG9hZGluZyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBNYnNjQ2FsQmFzZS5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jbG9uZURpY3Rpb25hcnkuY29sb3JzID0gW107XHJcbiAgICAgICAgdGhpcy5jbG9uZURpY3Rpb25hcnkubGFiZWxzID0gW107XHJcbiAgICAgICAgdGhpcy5jbG9uZURpY3Rpb25hcnkubWFya2VkID0gW107XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ09uSW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgTWJzY0NhbEJhc2UucHJvdG90eXBlLCBcImNhbGVuZGFySGVpZ2h0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIE1ic2NDYWxCYXNlLnByb3RvdHlwZSwgXCJjYWxlbmRhcldpZHRoXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NDYWxCYXNlLnByb3RvdHlwZSwgXCJjYWxlbmRhclNjcm9sbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIE1ic2NDYWxCYXNlLnByb3RvdHlwZSwgXCJjb2xvcnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NDYWxCYXNlLnByb3RvdHlwZSwgXCJjb3VudGVyXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NDYWxCYXNlLnByb3RvdHlwZSwgXCJkZWZhdWx0VmFsdWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBNYnNjQ2FsQmFzZS5wcm90b3R5cGUsIFwiZXZlbnRzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgTWJzY0NhbEJhc2UucHJvdG90eXBlLCBcImxhYmVsc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIE1ic2NDYWxCYXNlLnByb3RvdHlwZSwgXCJtYXJrZWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY0NhbEJhc2UucHJvdG90eXBlLCBcIm1vbnRoc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY0NhbEJhc2UucHJvdG90eXBlLCBcIm1vdXNld2hlZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NDYWxCYXNlLnByb3RvdHlwZSwgXCJvdXRlck1vbnRoQ2hhbmdlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjQ2FsQmFzZS5wcm90b3R5cGUsIFwic2hvd091dGVyRGF5c1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY0NhbEJhc2UucHJvdG90eXBlLCBcInRhYnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0NhbEJhc2UucHJvdG90eXBlLCBcIndlZWtDb3VudGVyXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NDYWxCYXNlLnByb3RvdHlwZSwgXCJ3ZWVrRGF5c1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBNYnNjQ2FsQmFzZS5wcm90b3R5cGUsIFwid2Vla3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NDYWxCYXNlLnByb3RvdHlwZSwgXCJ5ZWFyQ2hhbmdlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NDYWxCYXNlLnByb3RvdHlwZSwgXCJkYXRlVGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIE1ic2NDYWxCYXNlLnByb3RvdHlwZSwgXCJkYXlOYW1lc01pblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBNYnNjQ2FsQmFzZS5wcm90b3R5cGUsIFwiZmlyc3REYXlcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0NhbEJhc2UucHJvdG90eXBlLCBcInRpbWVUZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NDYWxCYXNlLnByb3RvdHlwZSwgXCJtb3JlRXZlbnRzUGx1cmFsVGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjQ2FsQmFzZS5wcm90b3R5cGUsIFwibW9yZUV2ZW50c1RleHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjQ2FsQmFzZS5wcm90b3R5cGUsIFwib25UYWJDaGFuZ2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjQ2FsQmFzZS5wcm90b3R5cGUsIFwib25MYWJlbFRhcFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NDYWxCYXNlLnByb3RvdHlwZSwgXCJvbk1vbnRoQ2hhbmdlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY0NhbEJhc2UucHJvdG90eXBlLCBcIm9uTW9udGhMb2FkaW5nXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY0NhbEJhc2UucHJvdG90eXBlLCBcIm9uTW9udGhMb2FkZWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjQ2FsQmFzZS5wcm90b3R5cGUsIFwib25QYWdlQ2hhbmdlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY0NhbEJhc2UucHJvdG90eXBlLCBcIm9uUGFnZUxvYWRlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NDYWxCYXNlLnByb3RvdHlwZSwgXCJvblBhZ2VMb2FkaW5nXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjQ2FsQmFzZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW21ic2MtY2FsLWInIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLCBOZ0NvbnRyb2wsIE1ic2NJbnB1dFNlcnZpY2UsIFZpZXdDb250YWluZXJSZWZdKVxyXG4gICAgXSwgTWJzY0NhbEJhc2UpO1xyXG4gICAgcmV0dXJuIE1ic2NDYWxCYXNlO1xyXG59KE1ic2NEYXRldGltZUJhc2UpKTtcclxudmFyIE1ic2NDYWxCYXNlTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1ic2NDYWxCYXNlTW9kdWxlKCkge1xyXG4gICAgfVxyXG4gICAgTWJzY0NhbEJhc2VNb2R1bGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBOZ01vZHVsZSh7XHJcbiAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIE1ic2NEYXRldGltZUJhc2VNb2R1bGVdLFxyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNYnNjQ2FsQmFzZV0sXHJcbiAgICAgICAgfSlcclxuICAgIF0sIE1ic2NDYWxCYXNlTW9kdWxlKTtcclxuICAgIHJldHVybiBNYnNjQ2FsQmFzZU1vZHVsZTtcclxufSgpKTtcblxudmFyIE1ic2NDYWxlbmRhciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY0NhbGVuZGFyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY0NhbGVuZGFyKGluaXRpYWxFbGVtZW50LCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIHZpZXcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbWVudCwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCB2aWV3KSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLm9wdGlvblNlcnZpY2UgPSBvcHRpb25TZXJ2aWNlO1xyXG4gICAgICAgIF90aGlzLm9uU2V0RGF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5vbkNlbGxIb3ZlckluID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm9uQ2VsbEhvdmVyT3V0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm9uRGF5Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSB7fTtcclxuICAgICAgICBfdGhpcy5pc011bHRpID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY0NhbGVuZGFyLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuY29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXROZXdWYWx1ZVByb3h5KHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBNYnNjQ2FsZW5kYXIucHJvdG90eXBlLnNldE5ld1ZhbHVlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB2YXIgY2hhbmdlZCA9IHZvaWQgMDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNNdWx0aSkge1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9ICFkZWVwRXF1YWxzQXJyYXkodiwgdGhpcy5pbnN0YW5jZS5nZXRWYWwoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5uZXJWYWx1ZSA9IHRoaXMuaW5zdGFuY2UuZ2V0VmFsKCk7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gKCghaW5uZXJWYWx1ZSAmJiB2KSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChpbm5lclZhbHVlICYmICF2KSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChpbm5lclZhbHVlICYmIHYgJiYgaW5uZXJWYWx1ZS50b1N0cmluZygpICE9PSB2LnRvU3RyaW5nKCkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodiwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lucHV0U2VydmljZSAmJiB0aGlzLl9pbnB1dFNlcnZpY2UuaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dFNlcnZpY2UuaW5wdXQuaW5uZXJWYWx1ZSA9IHRoaXMuaW5zdGFuY2UuX3ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1ic2NDYWxlbmRhci5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBleHRlbmQkMSh7IHByZXNldDogJ2NhbGVuZGFyJyB9LCB0aGlzLm9wdGlvblNlcnZpY2UgPyB0aGlzLm9wdGlvblNlcnZpY2Uub3B0aW9ucyA6IHt9LCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaiwgdGhpcy5vcHRpb25FeHRlbnNpb25zKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IENhbGVuZGFyKHRoaXMuZWxlbWVudCwgb3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5pbml0aWFsVmFsdWUgIT09IFwiXCIpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodGhpcy5pbml0aWFsVmFsdWUsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTWJzY0NhbGVuZGFyLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmlzTXVsdGkgPSB0aGlzLm9wdGlvbnMgJiYgKCh0aGlzLm9wdGlvbnMuc2VsZWN0ICYmIHRoaXMub3B0aW9ucy5zZWxlY3QgIT09ICdzaW5nbGUnKSB8fCAodGhpcy5vcHRpb25zLnNlbGVjdFR5cGUgPT0gJ3dlZWsnKSk7XHJcbiAgICAgICAgdGhpcy5jbG9uZURpY3Rpb25hcnkubWFya2VkID0gW107XHJcbiAgICAgICAgdGhpcy5jbG9uZURpY3Rpb25hcnkuaW52YWxpZCA9IFtdO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdPbkluaXQuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgTWJzY0NhbGVuZGFyLnByb3RvdHlwZSwgXCJjb250cm9sc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBNYnNjQ2FsZW5kYXIucHJvdG90eXBlLCBcImZpcnN0U2VsZWN0RGF5XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NDYWxlbmRhci5wcm90b3R5cGUsIFwic2VsZWN0VHlwZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjQ2FsZW5kYXIucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY0NhbGVuZGFyLnByb3RvdHlwZSwgXCJzZXRPbkRheVRhcFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NDYWxlbmRhci5wcm90b3R5cGUsIFwib25TZXREYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY0NhbGVuZGFyLnByb3RvdHlwZSwgXCJvbkNlbGxIb3ZlckluXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY0NhbGVuZGFyLnByb3RvdHlwZSwgXCJvbkNlbGxIb3Zlck91dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NDYWxlbmRhci5wcm90b3R5cGUsIFwib25EYXlDaGFuZ2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ21ic2Mtb3B0aW9ucycpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjQ2FsZW5kYXIucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ21ic2MtY2FsZW5kYXInKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXHJcbiAgICBdLCBNYnNjQ2FsZW5kYXIucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCdtYnNjLWNhbGVuZGFyQ2hhbmdlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NDYWxlbmRhci5wcm90b3R5cGUsIFwib25DaGFuZ2VFbWl0dGVyXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjQ2FsZW5kYXIgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBEaXJlY3RpdmUoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ1ttYnNjLWNhbGVuZGFyXScsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCdcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDIsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19wYXJhbSg0LCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZSxcclxuICAgICAgICAgICAgTmdDb250cm9sLFxyXG4gICAgICAgICAgICBNYnNjSW5wdXRTZXJ2aWNlLFxyXG4gICAgICAgICAgICBNYnNjT3B0aW9uc1NlcnZpY2UsXHJcbiAgICAgICAgICAgIFZpZXdDb250YWluZXJSZWZdKVxyXG4gICAgXSwgTWJzY0NhbGVuZGFyKTtcclxuICAgIHJldHVybiBNYnNjQ2FsZW5kYXI7XHJcbn0oTWJzY0NhbEJhc2UpKTtcclxudmFyIE1ic2NDYWxlbmRhckNvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY0NhbGVuZGFyQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY0NhbGVuZGFyQ29tcG9uZW50KGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCBudWxsKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnBsYWNlaG9sZGVyID0gJyc7XHJcbiAgICAgICAgX3RoaXMuZXJyb3JNZXNzYWdlID0gJyc7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgTWJzY0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnNldFRoZW1lQ2xhc3NlcygpO1xyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ2ljb24nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpbnB1dEljb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ2ljb24tYWxpZ24nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpY29uQWxpZ25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwicGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZXJyb3JcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlcnJvck1lc3NhZ2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY0NhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvcHRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjQ2FsZW5kYXJDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtY2FsZW5kYXInLFxyXG4gICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogSU5QVVRfVEVNUExBVEVcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDIsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDMsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDQsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLCBOZ0NvbnRyb2wsIE1ic2NJbnB1dFNlcnZpY2UsIE1ic2NPcHRpb25zU2VydmljZV0pXHJcbiAgICBdLCBNYnNjQ2FsZW5kYXJDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIE1ic2NDYWxlbmRhckNvbXBvbmVudDtcclxufShNYnNjQ2FsZW5kYXIpKTtcclxudmFyIE1ic2NDYWxlbmRhck1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNYnNjQ2FsZW5kYXJNb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBNYnNjQ2FsZW5kYXJNb2R1bGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBOZ01vZHVsZSh7XHJcbiAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIE1ic2NDYWxCYXNlTW9kdWxlLCBNYnNjSW5wdXRNb2R1bGVdLFxyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNYnNjQ2FsZW5kYXIsIE1ic2NDYWxlbmRhckNvbXBvbmVudF0sXHJcbiAgICAgICAgICAgIGV4cG9ydHM6IFtNYnNjQ2FsZW5kYXIsIE1ic2NDYWxlbmRhckNvbXBvbmVudF1cclxuICAgICAgICB9KVxyXG4gICAgXSwgTWJzY0NhbGVuZGFyTW9kdWxlKTtcclxuICAgIHJldHVybiBNYnNjQ2FsZW5kYXJNb2R1bGU7XHJcbn0oKSk7XG5cbnZhciBCdXR0b24gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9Gb3JtQ29udHJvbCkge1xuICBfaW5oZXJpdHNMb29zZShCdXR0b24sIF9Gb3JtQ29udHJvbCk7XG5cbiAgZnVuY3Rpb24gQnV0dG9uKGVsbSwgc2V0dGluZ3MpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9Gb3JtQ29udHJvbC5jYWxsKHRoaXMsIGVsbSwgc2V0dGluZ3MpIHx8IHRoaXM7XG4gICAgdmFyICRlbG0gPSBfdGhpcy5fJGVsbTtcbiAgICB2YXIgaGFzSWNvbiA9ICRlbG0uYXR0cignZGF0YS1pY29uJyk7XG4gICAgJGVsbS5hZGRDbGFzcygnbWJzYy1idG4gbWJzYy1uby10b3VjaCcpLmZpbmQoJy5tYnNjLWJ0bi1pYycpLnJlbW92ZSgpO1xuXG4gICAgaWYgKGhhc0ljb24pIHtcbiAgICAgICRlbG0ucHJlcGVuZCgnPHNwYW4gY2xhc3M9XCJtYnNjLWJ0bi1pYyBtYnNjLWljIG1ic2MtaWMtJyArIGhhc0ljb24gKyAnXCI+PC9zcGFuPicpO1xuXG4gICAgICBpZiAoJGVsbS50ZXh0KCkgPT09IFwiXCIpIHtcbiAgICAgICAgJGVsbS5hZGRDbGFzcygnbWJzYy1idG4taWNvbi1vbmx5Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3RoaXMuXyRyaXBwbGVFbG0gPSAkZWxtO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBCdXR0b24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRDbGFzc0VsbSA9IGZ1bmN0aW9uIGdldENsYXNzRWxtKCkge1xuICAgIHJldHVybiB0aGlzLl8kZWxtO1xuICB9O1xuXG4gIHJldHVybiBCdXR0b247XG59KEZvcm1Db250cm9sKTsgLy8gSW5pdCBtYnNjLWJ1dHRvbiBlbGVtZW50cyBvbiBwYWdlIGxvYWRcblxuYXV0b0luaXQoJ1ttYnNjLWJ1dHRvbl0nLCBCdXR0b24pO1xuXG52YXIgQ2hlY2tCb3ggPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9Gb3JtQ29udHJvbCkge1xuICBfaW5oZXJpdHNMb29zZShDaGVja0JveCwgX0Zvcm1Db250cm9sKTtcblxuICBmdW5jdGlvbiBDaGVja0JveChlbG0sIHNldHRpbmdzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfRm9ybUNvbnRyb2wuY2FsbCh0aGlzLCBlbG0sIHNldHRpbmdzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuXyRwYXJlbnQucHJlcGVuZChfdGhpcy5fJGVsbSkuYWRkQ2xhc3MoJ21ic2MtY2hlY2tib3ggbWJzYy1jb250cm9sLXcnKS5maW5kKCcubWJzYy1jaGVja2JveC1ib3gnKS5yZW1vdmUoKTtcblxuICAgIF90aGlzLl8kZWxtLmFmdGVyKCc8c3BhbiBjbGFzcz1cIm1ic2MtY2hlY2tib3gtYm94XCI+PC9zcGFuPicpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIENoZWNrQm94O1xufShGb3JtQ29udHJvbCk7IC8vIEluaXQgbWJzYy1jaGVja2JveCBlbGVtZW50cyBvbiBwYWdlIGxvYWRcblxuYXV0b0luaXQoJ1ttYnNjLWNoZWNrYm94XScsIENoZWNrQm94KTtcblxudmFyIFJhZGlvID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRm9ybUNvbnRyb2wpIHtcbiAgX2luaGVyaXRzTG9vc2UoUmFkaW8sIF9Gb3JtQ29udHJvbCk7XG5cbiAgZnVuY3Rpb24gUmFkaW8oZWxtLCBzZXR0aW5ncykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Zvcm1Db250cm9sLmNhbGwodGhpcywgZWxtLCBzZXR0aW5ncykgfHwgdGhpcztcblxuICAgIF90aGlzLl8kcGFyZW50LmFkZENsYXNzKCdtYnNjLXJhZGlvIG1ic2MtY29udHJvbC13JykuZmluZCgnLm1ic2MtcmFkaW8tYm94JykucmVtb3ZlKCk7XG5cbiAgICBfdGhpcy5fJGVsbS5hZnRlcignPHNwYW4gY2xhc3M9XCJtYnNjLXJhZGlvLWJveFwiPjxzcGFuPjwvc3Bhbj48L3NwYW4+Jyk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gUmFkaW87XG59KEZvcm1Db250cm9sKTsgLy8gSW5pdCBtYnNjLXJhZGlvIGVsZW1lbnRzIG9uIHBhZ2UgbG9hZFxuXG5hdXRvSW5pdCgnW21ic2MtcmFkaW9dJywgUmFkaW8pO1xuXG52YXIgU2VsZWN0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfSW5wdXQpIHtcbiAgX2luaGVyaXRzTG9vc2UoU2VsZWN0LCBfSW5wdXQpO1xuXG4gIGZ1bmN0aW9uIFNlbGVjdChlbG0sIHNldHRpbmdzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfSW5wdXQuY2FsbCh0aGlzLCBlbG0sIHNldHRpbmdzKSB8fCB0aGlzO1xuICAgIHZhciAkZWxtID0gX3RoaXMuXyRlbG07XG4gICAgdmFyICRwYXJlbnQgPSBfdGhpcy5fJHBhcmVudDtcbiAgICB2YXIgJGV4aXN0aW5nID0gJHBhcmVudC5maW5kKCcubWJzYy1zZWxlY3QtaW5wdXQnKTtcbiAgICB2YXIgJGlucHV0ID0gJGV4aXN0aW5nLmxlbmd0aCA/ICRleGlzdGluZyA6ICQkMSgnPGlucHV0IHRhYmluZGV4PVwiLTFcIiBjbGFzcz1cIm1ic2Mtc2VsZWN0LWlucHV0IG1ic2MtY29udHJvbFwiIHJlYWRvbmx5PicpO1xuICAgIF90aGlzLl8kaW5wdXQgPSAkaW5wdXQ7XG4gICAgX3RoaXMuX2RlbG0gPSAkaW5wdXRbMF07XG4gICAgX3RoaXMuX3NldFRleHQgPSBfdGhpcy5fc2V0VGV4dC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICAkcGFyZW50LmFkZENsYXNzKCdtYnNjLXNlbGVjdCcgKyAoX3RoaXMuXyRmcmFtZSA/ICcgbWJzYy1zZWxlY3QtaW5saW5lJyA6ICcnKSk7XG4gICAgJGVsbS5hZnRlcigkaW5wdXQpO1xuICAgICRpbnB1dC5hZnRlcignPHNwYW4gY2xhc3M9XCJtYnNjLXNlbGVjdC1pYyBtYnNjLWljIG1ic2MtaWMtYXJyb3ctZG93bjVcIj48L3NwYW4+Jyk7IC8vIFVwZGF0ZSBkdW1teSBpbnB1dCB0ZXh0IG9uIGNoYW5nZVxuXG4gICAgJGVsbS5vbignY2hhbmdlJywgX3RoaXMuX3NldFRleHQpO1xuXG4gICAgX3RoaXMuX3NldFRleHQoKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTZWxlY3QucHJvdG90eXBlO1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICBfSW5wdXQucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuXyRwYXJlbnQuZmluZCgnLm1ic2Mtc2VsZWN0LWljJykucmVtb3ZlKCk7XG5cbiAgICB0aGlzLl8kZWxtLm9mZignY2hhbmdlJywgdGhpcy5fc2V0VGV4dCk7XG4gIH07XG5cbiAgX3Byb3RvLl9zZXRUZXh0ID0gZnVuY3Rpb24gX3NldFRleHQoKSB7XG4gICAgdmFyIGVsbSA9IHRoaXMuX2VsbTtcbiAgICB2YXIgJGVsbSA9ICQkMShlbG0pOyAvLyBDaGVjayBpZiBzZWxlY3QgYW5kIG1vYmlzY3JvbGwgc2VsZWN0IHdhcyBub3QgaW5pdGlhbGl6ZWRcblxuICAgIGlmICgkZWxtLmlzKCdzZWxlY3QnKSAmJiAhJGVsbS5oYXNDbGFzcygnbWJzYy1jb21wJykpIHtcbiAgICAgIHRoaXMuXyRpbnB1dC52YWwoZWxtLnNlbGVjdGVkSW5kZXggIT0gLTEgPyBlbG0ub3B0aW9uc1tlbG0uc2VsZWN0ZWRJbmRleF0udGV4dCA6ICcnKTtcbiAgICB9IC8vIENoZWNrIGZsb2F0aW5nIGxhYmVsXG5cblxuICAgIHRoaXMucmVmcmVzaCgpO1xuICB9O1xuXG4gIHJldHVybiBTZWxlY3Q7XG59KElucHV0KTsgLy8gSW5pdCBtYnNjLXNlbGVjdCBlbGVtZW50cyBvbiBwYWdlIGxvYWRcblxuYXV0b0luaXQoJ1ttYnNjLWRyb3Bkb3duXScsIFNlbGVjdCk7XG5cbnZhciBldmVudHMkMiA9IFsnY2hhbmdlJywgJ2tleWRvd24nLCAnaW5wdXQnLCAnc2Nyb2xsJ107XG52YXIgc2l6ZURlYm91bmNlO1xuXG5mdW5jdGlvbiBzaXplVGV4dEFyZWFzKCkge1xuICBjbGVhclRpbWVvdXQoc2l6ZURlYm91bmNlKTtcbiAgc2l6ZURlYm91bmNlID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgJCQxKCd0ZXh0YXJlYS5tYnNjLWNvbnRyb2wnKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHNpemVUZXh0QXJlYSh0aGlzKTtcbiAgICB9KTtcbiAgfSwgMTAwKTtcbn1cblxuZnVuY3Rpb24gc2l6ZVRleHRBcmVhKGNvbnRyb2wpIHtcbiAgdmFyIGhlaWdodCxcbiAgICAgIGxpbmVOcixcbiAgICAgIGxpbmUsXG4gICAgICByb3dOciA9ICQkMShjb250cm9sKS5hdHRyKCdyb3dzJykgfHwgNjtcblxuICBpZiAoY29udHJvbC5vZmZzZXRIZWlnaHQpIHtcbiAgICBjb250cm9sLnN0eWxlLmhlaWdodCA9ICcnO1xuICAgIGxpbmUgPSBjb250cm9sLnNjcm9sbEhlaWdodCAtIGNvbnRyb2wub2Zmc2V0SGVpZ2h0O1xuICAgIGhlaWdodCA9IGNvbnRyb2wub2Zmc2V0SGVpZ2h0ICsgKGxpbmUgPiAwID8gbGluZSA6IDApO1xuICAgIGxpbmVOciA9IE1hdGgucm91bmQoaGVpZ2h0IC8gMjQpO1xuXG4gICAgaWYgKGxpbmVOciA+IHJvd05yKSB7XG4gICAgICAvL2NvbnRyb2wuc2Nyb2xsVG9wID0gaGVpZ2h0O1xuICAgICAgaGVpZ2h0ID0gMjQgKiByb3dOciArIChoZWlnaHQgLSBsaW5lTnIgKiAyNCk7XG4gICAgICAkJDEoY29udHJvbCkuYWRkQ2xhc3MoJ21ic2MtdGV4dGFyZWEtc2Nyb2xsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICQkMShjb250cm9sKS5yZW1vdmVDbGFzcygnbWJzYy10ZXh0YXJlYS1zY3JvbGwnKTtcbiAgICB9XG5cbiAgICBpZiAoaGVpZ2h0KSB7XG4gICAgICBjb250cm9sLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNjcm9sbFRleHRBcmVhKGVsbSkge1xuICB2YXIgJGVsbSA9ICQkMShlbG0pO1xuXG4gIGlmICghJGVsbS5oYXNDbGFzcygnbWJzYy10ZXh0YXJlYS1zY3JvbGwnKSkge1xuICAgIHZhciBsaW5lID0gZWxtLnNjcm9sbEhlaWdodCAtIGVsbS5vZmZzZXRIZWlnaHQsXG4gICAgICAgIGhlaWdodCA9IGVsbS5vZmZzZXRIZWlnaHQgKyBsaW5lLFxuICAgICAgICBsaW5lTnIgPSBNYXRoLnJvdW5kKGhlaWdodCAvIDI0KSxcbiAgICAgICAgcm93TnIgPSAkZWxtLmF0dHIoJ3Jvd3MnKSB8fCA2O1xuXG4gICAgaWYgKGxpbmVOciA8PSByb3dOcikge1xuICAgICAgZWxtLnNjcm9sbFRvcCA9IDA7XG4gICAgICBlbG0uc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICB9XG4gIH1cbn1cblxuaWYgKGlzQnJvd3Nlcikge1xuICAvLyBTZXQgaGVpZ2h0IG9mIHRleHRhcmVhcyBvbiB2aWV3cG9ydCBzaXplIGNoYW5nZXNcbiAgJCQxKHdpbmRvdykub24oJ3Jlc2l6ZSBvcmllbnRhdGlvbmNoYW5nZScsIHNpemVUZXh0QXJlYXMpO1xufVxuXG52YXIgVGV4dEFyZWEgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9JbnB1dCkge1xuICBfaW5oZXJpdHNMb29zZShUZXh0QXJlYSwgX0lucHV0KTtcblxuICBmdW5jdGlvbiBUZXh0QXJlYShlbG0sIHNldHRpbmdzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfSW5wdXQuY2FsbCh0aGlzLCBlbG0sIHNldHRpbmdzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuXyRwYXJlbnQuYWRkQ2xhc3MoJ21ic2MtdGV4dGFyZWEnKTtcblxuICAgIGV2ZW50cyQyLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICBfdGhpcy5fJGVsbS5vbihldiwgX3RoaXMuX2hhbmRsZSk7XG4gICAgfSk7XG4gICAgc2l6ZVRleHRBcmVhKGVsbSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFRleHRBcmVhLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBfSW5wdXQucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcblxuICAgIGV2ZW50cyQyLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICBfdGhpczIuXyRlbG0ub2ZmKGV2LCBfdGhpczIuX2hhbmRsZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnJlZnJlc2ggPSBmdW5jdGlvbiByZWZyZXNoKCkge1xuICAgIF9JbnB1dC5wcm90b3R5cGUucmVmcmVzaC5jYWxsKHRoaXMpO1xuXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2RlYm91bmNlKTtcbiAgICBzaXplVGV4dEFyZWEodGhpcy5fZWxtKTtcbiAgfTtcblxuICBfcHJvdG8uX2hhbmRsZSA9IGZ1bmN0aW9uIF9oYW5kbGUoZXYpIHtcbiAgICBfSW5wdXQucHJvdG90eXBlLl9oYW5kbGUuY2FsbCh0aGlzLCBldik7XG5cbiAgICBzd2l0Y2ggKGV2LnR5cGUpIHtcbiAgICAgIGNhc2UgJ2NoYW5nZSc6XG4gICAgICAgIHNpemVUZXh0QXJlYSh0aGlzLl9lbG0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAna2V5ZG93bic6XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIHRoaXMuX29uSW5wdXQoZXYpO1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzY3JvbGwnOlxuICAgICAgICBzY3JvbGxUZXh0QXJlYSh0aGlzLl9lbG0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX29uSW5wdXQgPSBmdW5jdGlvbiBfb25JbnB1dCgpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIGNsZWFyVGltZW91dCh0aGlzLl9kZWJvdW5jZSk7XG4gICAgdGhpcy5fZGVib3VuY2UgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNpemVUZXh0QXJlYShfdGhpczMuX2VsbSk7XG4gICAgfSwgMTAwKTtcbiAgfTtcblxuICByZXR1cm4gVGV4dEFyZWE7XG59KElucHV0KTtcblxuYXV0b0luaXQoJ1ttYnNjLXRleHRhcmVhXScsIFRleHRBcmVhKTtcblxudmFyIFNlZ21lbnRlZEl0ZW0gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9Gb3JtQ29udHJvbCkge1xuICBfaW5oZXJpdHNMb29zZShTZWdtZW50ZWRJdGVtLCBfRm9ybUNvbnRyb2wpO1xuXG4gIGZ1bmN0aW9uIFNlZ21lbnRlZEl0ZW0oZWxtLCBzZXR0aW5ncykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Zvcm1Db250cm9sLmNhbGwodGhpcywgZWxtLCBzZXR0aW5ncykgfHwgdGhpcztcbiAgICB2YXIgJHNlZ21lbnRDb250O1xuICAgIHZhciAkc2VnbWVudDtcbiAgICB2YXIgJGVsbSA9IF90aGlzLl8kZWxtO1xuICAgIHZhciAkcGFyZW50ID0gX3RoaXMuXyRwYXJlbnQ7XG5cbiAgICBpZiAoISRwYXJlbnQuaGFzQ2xhc3MoJ21ic2Mtc2VnbWVudGVkLWl0ZW0tcmVhZHknKSkge1xuICAgICAgJHNlZ21lbnRDb250ID0gJCQxKCc8ZGl2IGNsYXNzPVwibWJzYy1zZWdtZW50ZWQgbWJzYy1uby10b3VjaFwiPjwvZGl2PicpO1xuICAgICAgJHBhcmVudC5hZnRlcigkc2VnbWVudENvbnQpO1xuICAgICAgJHBhcmVudC5wYXJlbnQoKS5maW5kKCdpbnB1dFtuYW1lPVwiJyArICRlbG0uYXR0cignbmFtZScpICsgJ1wiXScpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJGlucHV0ID0gJCQxKHRoaXMpO1xuICAgICAgICAkc2VnbWVudCA9ICRpbnB1dC5wYXJlbnQoKS5hZGRDbGFzcygnbWJzYy1zZWdtZW50ZWQtaXRlbSBtYnNjLXNlZ21lbnRlZC1pdGVtLXJlYWR5Jyk7XG4gICAgICAgICQkMSgnPHNwYW4gY2xhc3M9XCJtYnNjLXNlZ21lbnRlZC1jb250ZW50XCI+JyArICgkaW5wdXQuYXR0cignZGF0YS1pY29uJykgPyAnPHNwYW4gY2xhc3M9XCJtYnNjLWljIG1ic2MtaWMtJyArICRpbnB1dC5hdHRyKCdkYXRhLWljb24nKSArICdcIj48L3NwYW4+JyA6ICcnKSArICc8L3NwYW4+JykuYXBwZW5kKCRzZWdtZW50LmNvbnRlbnRzKCkpLmFwcGVuZFRvKCRzZWdtZW50KTtcbiAgICAgICAgJHNlZ21lbnQucHJlcGVuZCgkaW5wdXQpO1xuICAgICAgICAkc2VnbWVudENvbnQuYXBwZW5kKCRzZWdtZW50KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIF90aGlzLl8kcmlwcGxlRWxtID0gJGVsbS5uZXh0KCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNlZ21lbnRlZEl0ZW0ucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRDbGFzc0VsbSA9IGZ1bmN0aW9uIGdldENsYXNzRWxtKCkge1xuICAgIHJldHVybiB0aGlzLl8kZWxtLmNsb3Nlc3QoJy5tYnNjLXNlZ21lbnRlZCcpO1xuICB9O1xuXG4gIHJldHVybiBTZWdtZW50ZWRJdGVtO1xufShGb3JtQ29udHJvbCk7IC8vIEluaXQgbWJzYy1zZWdtZW50ZWQgZWxlbWVudHMgb24gcGFnZSBsb2FkXG5cbmF1dG9Jbml0KCdbbWJzYy1zZWdtZW50ZWRdJywgU2VnbWVudGVkSXRlbSk7XG5cbnZhciBTdGVwcGVyID0gZnVuY3Rpb24gU3RlcHBlcihjb250cm9sLCBzZXR0aW5ncykge1xuICB2YXIgJGJ0blBsdXMsXG4gICAgICAkYnRuTWludXMsXG4gICAgICAkY29udHJvbHMsXG4gICAgICBjc3NDbGFzcyA9ICcnLFxuICAgICAgZGlzcGxheVZhbHVlLFxuICAgICAgbWF4LFxuICAgICAgbWluLFxuICAgICAgaW5wdXRTdHlsZSxcbiAgICAgIHJpcHBsZSxcbiAgICAgIHNjYWxlLFxuICAgICAgc3RlcCxcbiAgICAgIHN0ZXBwZXIsXG4gICAgICBzLFxuICAgICAgdGhlbWUsXG4gICAgICB2YWwsXG4gICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICRjb250cm9sID0gJCQxKGNvbnRyb2wpLFxuICAgICAgcmVhZHksXG4gICAgICAkcGFyZW50LFxuICAgICAgb2xkID0gdmFsO1xuXG4gIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICAgIHZhciB2O1xuXG4gICAgaWYgKCFjb250cm9sLmRpc2FibGVkKSB7XG4gICAgICB2ID0gcGFyc2VGbG9hdCgkJDEodGhpcykudmFsKCkpO1xuICAgICAgc2V0VmFsdWUoaXNOYU4odikgPyB2YWwgOiB2KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0Rpc2FibGVkKCkge1xuICAgIHJldHVybiBjb250cm9sLmRpc2FibGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RlcFZhbHVlKGluZGV4LCBkaXIpIHtcbiAgICBzZXRWYWx1ZSh2YWwgKyBkaXIgKiBzdGVwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFZhbHVlKHYsIGZpbGwsIGNoYW5nZSkge1xuICAgIG9sZCA9IHZhbDtcblxuICAgIGlmIChmaWxsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZpbGwgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChjaGFuZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY2hhbmdlID0gZmlsbDtcbiAgICB9XG5cbiAgICB2YWwgPSByb3VuZCh2KTtcbiAgICAkY29udHJvbHMucmVtb3ZlQ2xhc3MoJ21ic2MtZGlzYWJsZWQnKTtcblxuICAgIGlmIChmaWxsKSB7XG4gICAgICAkY29udHJvbC52YWwodmFsKTtcbiAgICB9XG5cbiAgICBpZiAodmFsID09IG1pbikge1xuICAgICAgJGJ0bk1pbnVzLmFkZENsYXNzKCdtYnNjLWRpc2FibGVkJyk7XG4gICAgfSBlbHNlIGlmICh2YWwgPT0gbWF4KSB7XG4gICAgICAkYnRuUGx1cy5hZGRDbGFzcygnbWJzYy1kaXNhYmxlZCcpO1xuICAgIH1cblxuICAgIGlmICh2YWwgIT09IG9sZCAmJiBjaGFuZ2UpIHtcbiAgICAgICRjb250cm9sLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEF0dHIoYXR0ciwgZGVmLCBzdHIpIHtcbiAgICB2YXIgdiA9ICRjb250cm9sLmF0dHIoYXR0cik7XG4gICAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSAnJyA/IGRlZiA6IHN0ciA/IHYgOiArdjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJvdW5kKHYpIHtcbiAgICByZXR1cm4gK01hdGgubWluKG1heCwgTWF0aC5tYXgoTWF0aC5yb3VuZCh2IC8gc3RlcCkgKiBzdGVwLCBtaW4pKS50b0ZpeGVkKHNjYWxlKTtcbiAgfSAvLyBDYWxsIHRoZSBwYXJlbnQgY29uc3RydWN0b3JcblxuXG4gIEJhc2UuY2FsbCh0aGlzLCBjb250cm9sLCBzZXR0aW5ncywgdHJ1ZSk7XG4gIC8qIFRSSUFMRlVOQyAqL1xuXG4gIHRoYXQuZ2V0VmFsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2ID0gcGFyc2VGbG9hdCgkY29udHJvbC52YWwoKSk7XG4gICAgdiA9IGlzTmFOKHYpID8gdmFsIDogdjtcbiAgICByZXR1cm4gcm91bmQodik7XG4gIH07XG5cbiAgdGhhdC5zZXRWYWwgPSBmdW5jdGlvbiAodiwgZmlsbCwgY2hhbmdlKSB7XG4gICAgdiA9IHBhcnNlRmxvYXQodik7XG4gICAgc2V0VmFsdWUoaXNOYU4odikgPyB2YWwgOiB2LCBmaWxsLCBjaGFuZ2UpO1xuICB9O1xuXG4gIHRoYXQuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmVhZHkgPSAkY29udHJvbC5wYXJlbnQoKS5oYXNDbGFzcygnbWJzYy1zdGVwcGVyJyk7XG4gICAgJHBhcmVudCA9IHJlYWR5ID8gJGNvbnRyb2wuY2xvc2VzdCgnLm1ic2Mtc3RlcHBlci1jb250JykgOiAkY29udHJvbC5wYXJlbnQoKTtcbiAgICBzID0gdGhhdC5zZXR0aW5ncztcbiAgICBtaW4gPSBzZXR0aW5ncy5taW4gPT09IHVuZGVmaW5lZCA/IGdldEF0dHIoJ21pbicsIHMubWluKSA6IHNldHRpbmdzLm1pbjtcbiAgICBtYXggPSBzZXR0aW5ncy5tYXggPT09IHVuZGVmaW5lZCA/IGdldEF0dHIoJ21heCcsIHMubWF4KSA6IHNldHRpbmdzLm1heDtcbiAgICBzdGVwID0gc2V0dGluZ3Muc3RlcCA9PT0gdW5kZWZpbmVkID8gZ2V0QXR0cignc3RlcCcsIHMuc3RlcCkgOiBzZXR0aW5ncy5zdGVwO1xuICAgIHNjYWxlID0gTWF0aC5hYnMoc3RlcCkgPCAxID8gKHN0ZXAgKyAnJykuc3BsaXQoJy4nKVsxXS5sZW5ndGggOiAwO1xuICAgIGlucHV0U3R5bGUgPSBzZXR0aW5ncy5pbnB1dFN0eWxlID09PSB1bmRlZmluZWQgPyBnZXRBdHRyKCdkYXRhLWlucHV0LXN0eWxlJywgcy5pbnB1dFN0eWxlLCB0cnVlKSA6IHNldHRpbmdzLmlucHV0U3R5bGU7XG4gICAgZGlzcGxheVZhbHVlID0gJGNvbnRyb2wuYXR0cignZGF0YS12YWwnKSB8fCBzLnZhbDtcbiAgICB2YWwgPSByb3VuZCgrY29udHJvbC52YWx1ZSB8fCAwKTtcbiAgICB0aGVtZSA9IG1vYmlzY3JvbGwudGhlbWVzLmZvcm1bcy50aGVtZV07XG4gICAgcmlwcGxlID0gdGhlbWUgJiYgdGhlbWUuYWRkUmlwcGxlID8gdGhlbWUgOiBudWxsO1xuXG4gICAgaWYgKCFyZWFkeSkge1xuICAgICAgJHBhcmVudC5hZGRDbGFzcygnbWJzYy1zdGVwcGVyLWNvbnQgbWJzYy1uby10b3VjaCBtYnNjLWNvbnRyb2wtdycpLmFkZENsYXNzKGlucHV0U3R5bGUgPT0gJ2JveCcgPyAnbWJzYy1pbnB1dC1ib3gnIDogJycpLmFkZENsYXNzKGlucHV0U3R5bGUgPT0gJ291dGxpbmUnID8gJ21ic2MtaW5wdXQtb3V0bGluZScgOiAnJykuYXBwZW5kKCc8c3BhbiBjbGFzcz1cIm1ic2Mtc2VnbWVudGVkIG1ic2Mtc3RlcHBlcicgKyAnXCI+PC9zcGFuPicpLmZpbmQoJy5tYnNjLXN0ZXBwZXInKS5hcHBlbmQoJzxzcGFuIGNsYXNzPVwibWJzYy1zZWdtZW50ZWQtaXRlbSBtYnNjLXN0ZXBwZXItY29udHJvbCBtYnNjLXN0ZXBwZXItbWludXMgJyArICh2YWwgPT0gbWluID8gJ21ic2MtZGlzYWJsZWQnIDogJycpICsgJ1wiIGRhdGEtc3RlcD1cIi0xXCIgdGFiaW5kZXg9XCIwXCI+PHNwYW4gY2xhc3M9XCJtYnNjLXNlZ21lbnRlZC1jb250ZW50XCI+PHNwYW4gY2xhc3M9XCJtYnNjLWljIG1ic2MtaWMtbWludXNcIj48L3NwYW4+PC9zcGFuPjwvc3Bhbj4nKS5hcHBlbmQoJzxzcGFuIGNsYXNzPVwibWJzYy1zZWdtZW50ZWQtaXRlbSBtYnNjLXN0ZXBwZXItY29udHJvbCBtYnNjLXN0ZXBwZXItcGx1cyAnICsgKHZhbCA9PSBtYXggPyAnbWJzYy1kaXNhYmxlZCcgOiAnJykgKyAnXCIgIGRhdGEtc3RlcD1cIjFcIiB0YWJpbmRleD1cIjBcIj48c3BhbiBjbGFzcz1cIm1ic2Mtc2VnbWVudGVkLWNvbnRlbnRcIj4gPHNwYW4gY2xhc3M9XCJtYnNjLWljIG1ic2MtaWMtcGx1c1wiPjwvc3Bhbj48L3NwYW4+PC9zcGFuPicpLnByZXBlbmQoJGNvbnRyb2wpO1xuICAgIH1cblxuICAgIGlmIChjc3NDbGFzcykge1xuICAgICAgJHBhcmVudC5yZW1vdmVDbGFzcyhjc3NDbGFzcykuZmluZCgnLm1ic2Mtc2VnbWVudGVkJykucmVtb3ZlQ2xhc3MoY3NzQ2xhc3MpO1xuICAgIH1cblxuICAgIGNzc0NsYXNzID0gJ21ic2MtJyArIHMudGhlbWUgKyAodGhlbWUuYmFzZVRoZW1lID8gJyBtYnNjLScgKyB0aGVtZS5iYXNlVGhlbWUgOiAnJykgKyAocy5ydGwgPyAnIG1ic2MtcnRsJyA6ICcgbWJzYy1sdHInKTtcbiAgICAkcGFyZW50LmFkZENsYXNzKGNzc0NsYXNzKS5maW5kKCcubWJzYy1zZWdtZW50ZWQnKS5hZGRDbGFzcyhjc3NDbGFzcyk7XG4gICAgJGJ0bk1pbnVzID0gJCQxKCcubWJzYy1zdGVwcGVyLW1pbnVzJywgJHBhcmVudCk7XG4gICAgJGJ0blBsdXMgPSAkJDEoJy5tYnNjLXN0ZXBwZXItcGx1cycsICRwYXJlbnQpO1xuICAgICRjb250cm9scyA9ICQkMSgnLm1ic2Mtc3RlcHBlci1jb250cm9sJywgJHBhcmVudCk7XG5cbiAgICBpZiAoIXJlYWR5KSB7XG4gICAgICBpZiAoZGlzcGxheVZhbHVlID09ICdsZWZ0Jykge1xuICAgICAgICAkcGFyZW50LmFkZENsYXNzKCdtYnNjLXN0ZXBwZXItdmFsLWxlZnQnKTtcbiAgICAgICAgJGNvbnRyb2wuYWZ0ZXIoJzxzcGFuIGNsYXNzPVwibWJzYy1zZWdtZW50ZWQtaXRlbVwiPjxzcGFuIGNsYXNzPVwibWJzYy1zZWdtZW50ZWQtY29udGVudFwiPjwvc3Bhbj48L3NwYW4+Jyk7XG4gICAgICB9IGVsc2UgaWYgKGRpc3BsYXlWYWx1ZSA9PSAncmlnaHQnKSB7XG4gICAgICAgICRwYXJlbnQuYWRkQ2xhc3MoJ21ic2Mtc3RlcHBlci12YWwtcmlnaHQnKTtcbiAgICAgICAgJGJ0blBsdXMuYWZ0ZXIoJzxzcGFuIGNsYXNzPVwibWJzYy1zZWdtZW50ZWQtaXRlbVwiPjxzcGFuIGNsYXNzPVwibWJzYy1zZWdtZW50ZWQtY29udGVudFwiPjwvc3Bhbj48L3NwYW4+Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkYnRuTWludXMuYWZ0ZXIoJzxzcGFuIGNsYXNzPVwibWJzYy1zZWdtZW50ZWQtaXRlbVwiPjxzcGFuIGNsYXNzPVwibWJzYy1zZWdtZW50ZWQtY29udGVudCBtYnNjLXN0ZXBwZXItdmFsXCI+PC9zcGFuPjwvc3Bhbj4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXN0ZXBwZXIpIHtcbiAgICAgICRjb250cm9sLm9uKCdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgICBzdGVwcGVyID0gY3JlYXRlU3RlcHBlcigkY29udHJvbHMsIHN0ZXBWYWx1ZSwgMTUwLCBjaGVja0Rpc2FibGVkLCBmYWxzZSwgcmlwcGxlKTtcbiAgICB9XG5cbiAgICAkY29udHJvbC52YWwodmFsKS5hdHRyKCdkYXRhLXJvbGUnLCAnc3RlcHBlcicpLmF0dHIoJ21pbicsIG1pbikuYXR0cignbWF4JywgbWF4KS5hdHRyKCdzdGVwJywgc3RlcCkuYWRkQ2xhc3MoJ21ic2MtY29udHJvbCcpO1xuICAgIGNvbnRyb2wubWJzY0luc3QgPSB0aGF0O1xuICB9O1xuXG4gIHRoYXQuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgJGNvbnRyb2wucmVtb3ZlQ2xhc3MoJ21ic2MtY29udHJvbCcpLm9mZignY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIHN0ZXBwZXIuZGVzdHJveSgpO1xuICAgIGRlbGV0ZSBjb250cm9sLm1ic2NJbnN0O1xuICB9O1xuXG4gIHRoYXQuaW5pdCgpO1xufTtcblN0ZXBwZXIucHJvdG90eXBlID0ge1xuICBfY2xhc3M6ICdzdGVwcGVyJyxcbiAgX2hhc0RlZjogdHJ1ZSxcbiAgX2hhc1RoZW1lOiB0cnVlLFxuICBfaGFzTGFuZzogdHJ1ZSxcbiAgX2RlZmF1bHRzOiB7XG4gICAgbWluOiAwLFxuICAgIG1heDogMTAwLFxuICAgIHN0ZXA6IDFcbiAgfVxufTtcbmNsYXNzZXMuU3RlcHBlciA9IFN0ZXBwZXI7IC8vIEluaXQgbWJzYy1zdGVwcGVyIGVsZW1lbnRzIG9uIHBhZ2UgbG9hZFxuXG5hdXRvSW5pdCgnW21ic2Mtc3RlcHBlcl0nLCBTdGVwcGVyKTtcblxudmFyIFByb2dyZXNzQmFzZSA9IGZ1bmN0aW9uIFByb2dyZXNzQmFzZShlbG0sIHNldHRpbmdzLCBpbmhlcml0KSB7XG4gIHZhciAkZWxtLFxuICAgICAgJHBhcmVudCxcbiAgICAgIGNzc0NsYXNzLFxuICAgICAgcyxcbiAgICAgIHRoYXQgPSB0aGlzOyAvLyBDYWxsIHRoZSBwYXJlbnQgY29uc3RydWN0b3JcblxuICBCYXNlLmNhbGwodGhpcywgZWxtLCBzZXR0aW5ncywgdHJ1ZSk7XG4gIHRoYXQuX19pbml0ID0gbm9vcDtcbiAgdGhhdC5fX2Rlc3Ryb3kgPSBub29wO1xuXG4gIHRoYXQuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHdhc0luaXQ7XG4gICAgcyA9IHRoYXQuc2V0dGluZ3M7XG4gICAgJGVsbSA9ICQkMShlbG0pOyAvLyBDaGVjayBpZiB0aGUgZWxlbWVudCB3YXMgYWxyZWFkeSBpbml0aWFsaXplZFxuXG4gICAgd2FzSW5pdCA9ICEhJHBhcmVudDtcbiAgICAkcGFyZW50ID0gJGVsbS5wYXJlbnQoKTtcbiAgICAkcGFyZW50ID0gJHBhcmVudC5oYXNDbGFzcygnbWJzYy1pbnB1dC13cmFwJykgPyAkcGFyZW50LnBhcmVudCgpIDogJHBhcmVudDtcbiAgICB0aGF0Ll8kcGFyZW50ID0gJHBhcmVudDtcblxuICAgIGlmIChjc3NDbGFzcykge1xuICAgICAgJHBhcmVudC5yZW1vdmVDbGFzcyhjc3NDbGFzcyk7XG4gICAgfVxuXG4gICAgY3NzQ2xhc3MgPSB0aGF0Ll9jc3MgKyAnIG1ic2MtcHJvZ3Jlc3MtdyBtYnNjLWNvbnRyb2wtdyAnICsgZ2V0Q3NzQ2xhc3Mocyk7XG4gICAgJHBhcmVudC5hZGRDbGFzcyhjc3NDbGFzcyk7XG4gICAgJGVsbS5hZGRDbGFzcygnbWJzYy1jb250cm9sJyk7XG5cbiAgICB0aGF0Ll9faW5pdCgpO1xuXG4gICAgaWYgKCF3YXNJbml0KSB7XG4gICAgICB0aGF0Ll9hdHRhY2hDaGFuZ2UoKTtcbiAgICB9IC8vIFNob3cgaW5pdGlhbCB2YWx1ZVxuXG5cbiAgICB0aGF0LnJlZnJlc2goKTtcbiAgICBlbG0ubWJzY0luc3QgPSB0aGF0O1xuICB9O1xuXG4gIHRoYXQuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhhdC5fX2Rlc3Ryb3koKTtcblxuICAgICRwYXJlbnQucmVtb3ZlQ2xhc3MoY3NzQ2xhc3MpO1xuICAgICRlbG0ucmVtb3ZlQ2xhc3MoJ21ic2MtY29udHJvbCcpO1xuICAgIGRlbGV0ZSBlbG0ubWJzY0luc3Q7XG4gIH07XG5cbiAgaWYgKCFpbmhlcml0KSB7XG4gICAgdGhhdC5pbml0KCk7XG4gIH1cbn07XG5cbnZhciBTbGlkZXJCYXNlID0gZnVuY3Rpb24gU2xpZGVyQmFzZShlbG0sIHNldHRpbmdzLCBpbmhlcml0KSB7XG4gIHZhciAkZWxtLFxuICAgICAgJGhhbmRsZSxcbiAgICAgICRoYW5kbGVDb250LFxuICAgICAgJGhhbmRsZXMsXG4gICAgICAkcGFyZW50LFxuICAgICAgJHRyYWNrLFxuICAgICAgYWN0aW9uLFxuICAgICAgYmFzZSxcbiAgICAgIGNoYW5nZWQsXG4gICAgICBkaWZmWCxcbiAgICAgIGRpZmZZLFxuICAgICAgZGlmZixcbiAgICAgIGVuZFgsXG4gICAgICBlbmRZLFxuICAgICAgaGFuZGxlSW5kZXgsXG4gICAgICBpc0hvdmVyLFxuICAgICAgaXNQcmVzc2VkLFxuICAgICAgaXNSdGwsXG4gICAgICBsaXN0ZW5lcixcbiAgICAgIGxpdmUsXG4gICAgICBtYXgsXG4gICAgICBtaW4sXG4gICAgICBtb3ZlZCxcbiAgICAgIG11bHRpcGxlLFxuICAgICAgb2xkVmFsdWUsXG4gICAgICBzdGVwLFxuICAgICAgcyxcbiAgICAgIHNjYWxlLFxuICAgICAgc3RhcnRYLFxuICAgICAgc3RhcnRZLFxuICAgICAgc3RlcERlY2ltYWwsXG4gICAgICB0aW1lcixcbiAgICAgIHRvdGFsV2lkdGgsXG4gICAgICB2YWx1ZSxcbiAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgbGFzdFVwZGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgZnVuY3Rpb24gb25TdGFydChldikge1xuICAgIGlmIChldi50eXBlID09PSAnbW91c2Vkb3duJykge1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBpZiAodGVzdFRvdWNoKGV2LCB0aGlzKSAmJiAoIWFjdGlvbiB8fCBpc0hvdmVyKSAmJiAhZWxtLmRpc2FibGVkICYmICFlbG0ucmVhZE9ubHlcbiAgICAvKiBUUklBTENPTkQgKi9cbiAgICApIHtcbiAgICAgICAgaWYgKHMuc3RvcFByb3ApIHtcbiAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFjdGlvbiA9IHRydWU7XG4gICAgICAgIG1vdmVkID0gZmFsc2U7XG4gICAgICAgIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgc3RhcnRYID0gZ2V0Q29vcmQoZXYsICdYJyk7XG4gICAgICAgIHN0YXJ0WSA9IGdldENvb3JkKGV2LCAnWScpO1xuICAgICAgICBlbmRYID0gc3RhcnRYO1xuICAgICAgICAkdHJhY2sucmVtb3ZlQ2xhc3MoJ21ic2MtcHJvZ3Jlc3MtYW5pbScpO1xuICAgICAgICAkaGFuZGxlID0gbXVsdGlwbGUgPyAkJDEoJy5tYnNjLXNsaWRlci1oYW5kbGUnLCB0aGlzKSA6ICRoYW5kbGVzO1xuXG4gICAgICAgIGlmICgkaGFuZGxlQ29udCkge1xuICAgICAgICAgICRoYW5kbGVDb250LnJlbW92ZUNsYXNzKCdtYnNjLWhhbmRsZS1jdXJyJyk7XG4gICAgICAgIH1cblxuICAgICAgICAkaGFuZGxlQ29udCA9ICRoYW5kbGUucGFyZW50KCkuYWRkQ2xhc3MoJ21ic2MtYWN0aXZlIG1ic2MtaGFuZGxlLWN1cnInKTtcbiAgICAgICAgJGVsbS5hZGRDbGFzcygnbWJzYy1hY3RpdmUnKTtcbiAgICAgICAgaGFuZGxlSW5kZXggPSArJGhhbmRsZS5hdHRyKCdkYXRhLWluZGV4Jyk7XG4gICAgICAgIHRvdGFsV2lkdGggPSAkdHJhY2tbMF0ub2Zmc2V0V2lkdGg7XG4gICAgICAgIGRpZmYgPSAkdHJhY2tbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblxuICAgICAgICBpZiAoZXYudHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgICBpc1ByZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICQkMShkb2N1bWVudCkub24oJ21vdXNlbW92ZScsIG9uTW92ZSkub24oJ21vdXNldXAnLCBvbkVuZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXYudHlwZSA9PT0gJ21vdXNlZW50ZXInKSB7XG4gICAgICAgICAgaXNIb3ZlciA9IHRydWU7XG4gICAgICAgICAgJCQxKGRvY3VtZW50KS5vbignbW91c2Vtb3ZlJywgb25Nb3ZlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Nb3ZlKGV2KSB7XG4gICAgaWYgKGFjdGlvbikge1xuICAgICAgZW5kWCA9IGdldENvb3JkKGV2LCAnWCcpO1xuICAgICAgZW5kWSA9IGdldENvb3JkKGV2LCAnWScpO1xuICAgICAgZGlmZlggPSBlbmRYIC0gc3RhcnRYO1xuICAgICAgZGlmZlkgPSBlbmRZIC0gc3RhcnRZO1xuXG4gICAgICBpZiAoTWF0aC5hYnMoZGlmZlgpID4gNSkge1xuICAgICAgICBtb3ZlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb3ZlZCB8fCBpc1ByZXNzZWQgfHwgaXNIb3Zlcikge1xuICAgICAgICBpZiAoTWF0aC5hYnMobGFzdFVwZGF0ZSAtIG5ldyBEYXRlKCkpID4gNTApIHtcbiAgICAgICAgICBsYXN0VXBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICB1cGRhdGVTbGlkZXIoZW5kWCwgcy5yb3VuZCwgbGl2ZSAmJiAoIWlzSG92ZXIgfHwgaXNQcmVzc2VkKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1vdmVkKSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGRpZmZZKSA+IDcgJiYgZXYudHlwZSA9PSAndG91Y2htb3ZlJykge1xuICAgICAgICBjbGVhblVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25FbmQoZXYpIHtcbiAgICBpZiAoYWN0aW9uKSB7XG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBpZiAoIW11bHRpcGxlKSB7XG4gICAgICAgICR0cmFjay5hZGRDbGFzcygnbWJzYy1wcm9ncmVzcy1hbmltJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0hvdmVyICYmICFpc1ByZXNzZWQpIHtcbiAgICAgICAgdXBkYXRlVmFsdWUodmFsdWVbaGFuZGxlSW5kZXhdLCBoYW5kbGVJbmRleCwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZVNsaWRlcihlbmRYLCB0cnVlLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFtb3ZlZCAmJiAhY2hhbmdlZCkge1xuICAgICAgICBpZiAoZXYudHlwZSA9PSAndG91Y2hlbmQnKSB7XG4gICAgICAgICAgLy8gUHJldmVudCBnaG9zdCBjbGlja1xuICAgICAgICAgIHByZXZlbnRDbGljaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdC5fb25UYXAodmFsdWVbaGFuZGxlSW5kZXhdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2LnR5cGUgPT0gJ21vdXNldXAnKSB7XG4gICAgICAgIGlzUHJlc3NlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXYudHlwZSA9PSAnbW91c2VsZWF2ZScpIHtcbiAgICAgICAgaXNIb3ZlciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzSG92ZXIpIHtcbiAgICAgICAgY2xlYW5VcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2FuY2VsKCkge1xuICAgIGlmIChhY3Rpb24pIHtcbiAgICAgIGNsZWFuVXAoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICB2YXIgdiA9IHRoYXQuX3JlYWRWYWx1ZSgkJDEodGhpcykpLFxuICAgICAgICBpID0gKyQkMSh0aGlzKS5hdHRyKCdkYXRhLWluZGV4Jyk7XG5cbiAgICBpZiAodiAhPT0gdmFsdWVbaV0pIHtcbiAgICAgIHZhbHVlW2ldID0gdjtcbiAgICAgIG9sZFZhbHVlW2ldID0gdjtcbiAgICAgIHVwZGF0ZVZhbHVlKHYsIGkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2xpY2soZXYpIHtcbiAgICAvLyBQcmV2ZW50IHByb3BhZ2F0aW5nIGNsaWNrIHRvIGxhYmVsXG4gICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkxhYmVsQ2xpY2soZXYpIHtcbiAgICAvLyBQcmV2ZW50IGNoYW5nZSBvbiBsYWJlbCBjbGljayBmb3Igc3dpdGhlc1xuICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbktleURvd24oZXYpIHtcbiAgICB2YXIgZGlyO1xuXG4gICAgaWYgKCFlbG0uZGlzYWJsZWQpIHtcbiAgICAgIHN3aXRjaCAoZXYua2V5Q29kZSkge1xuICAgICAgICBjYXNlIDM4OlxuICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgIGRpciA9IDE7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICBkaXIgPSAtMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKGRpcikge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmICghdGltZXIpIHtcbiAgICAgICAgICBoYW5kbGVJbmRleCA9ICskJDEodGhpcykuYXR0cignZGF0YS1pbmRleCcpO1xuICAgICAgICAgIHVwZGF0ZVZhbHVlKHZhbHVlW2hhbmRsZUluZGV4XSArIHN0ZXAgKiBkaXIsIGhhbmRsZUluZGV4LCB0cnVlKTtcbiAgICAgICAgICB0aW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHVwZGF0ZVZhbHVlKHZhbHVlW2hhbmRsZUluZGV4XSArIHN0ZXAgKiBkaXIsIGhhbmRsZUluZGV4LCB0cnVlKTtcbiAgICAgICAgICB9LCAyMDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25LZXlVcChldikge1xuICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgdGltZXIgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW5VcCgpIHtcbiAgICBhY3Rpb24gPSBmYWxzZTtcbiAgICAkaGFuZGxlQ29udC5yZW1vdmVDbGFzcygnbWJzYy1hY3RpdmUnKTtcbiAgICAkZWxtLnJlbW92ZUNsYXNzKCdtYnNjLWFjdGl2ZScpOyAvLyBEZXRhY2ggZG9jdW1lbnQgZXZlbnRzXG5cbiAgICAkJDEoZG9jdW1lbnQpLm9mZignbW91c2Vtb3ZlJywgb25Nb3ZlKS5vZmYoJ21vdXNldXAnLCBvbkVuZCk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVTbGlkZXIocG9zLCByb3VuZCwgZmlsbCkge1xuICAgIHZhciBwZXJjZW50ID0gcm91bmQgPyBNYXRoLm1pbihNYXRoW3RoYXQuX3JvdW5kaW5nIHx8ICdyb3VuZCddKE1hdGgubWF4KChwb3MgLSBkaWZmKSAqIDEwMCAvIHRvdGFsV2lkdGgsIDApIC8gc2NhbGUgLyBzdGVwKSAqIHN0ZXAgKiAxMDAgLyAobWF4IC0gbWluICsgYmFzZSksIDEwMCkgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigocG9zIC0gZGlmZikgKiAxMDAgLyB0b3RhbFdpZHRoLCAxMDApKTtcblxuICAgIGlmIChpc1J0bCkge1xuICAgICAgcGVyY2VudCA9IDEwMCAtIHBlcmNlbnQ7XG4gICAgfVxuXG4gICAgdXBkYXRlVmFsdWUoTWF0aC5yb3VuZCgobWluIC0gYmFzZSArIHBlcmNlbnQgLyBzY2FsZSkgKiBzdGVwRGVjaW1hbCkgLyBzdGVwRGVjaW1hbCwgaGFuZGxlSW5kZXgsIGZpbGwsIHBlcmNlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVmFsdWUodiwgaW5kZXgsIGZpbGwsIHBlcmNlbnQsIHJlZnJlc2gsIGNoYW5nZSkge1xuICAgIHZhciAkaGFuZGxlID0gJGhhbmRsZXMuZXEoaW5kZXgpLFxuICAgICAgICAkaGFuZGxlQ29udCA9ICRoYW5kbGUucGFyZW50KCk7XG4gICAgdiA9IE1hdGgubWluKG1heCwgTWF0aC5tYXgodiwgbWluKSk7XG5cbiAgICBpZiAoY2hhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNoYW5nZSA9IGZpbGw7XG4gICAgfVxuXG4gICAgaWYgKHRoYXQuX3VwZGF0ZSkge1xuICAgICAgdiA9IHRoYXQuX3VwZGF0ZSh2LCB2YWx1ZSwgaW5kZXgsIHBlcmNlbnQsIG11bHRpcGxlLCByZWZyZXNoLCAkaGFuZGxlQ29udCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRoYW5kbGVDb250LmNzcyh7XG4gICAgICAgIGxlZnQ6IGlzUnRsID8gJ2F1dG8nIDogKHBlcmNlbnQgfHwgZ2V0UGVyY2VudCh2LCBtaW4sIG1heCkpICsgJyUnLFxuICAgICAgICByaWdodDogaXNSdGwgPyAocGVyY2VudCB8fCBnZXRQZXJjZW50KHYsIG1pbiwgbWF4KSkgKyAnJScgOiAnYXV0bydcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh2ID4gbWluKSB7XG4gICAgICAkaGFuZGxlQ29udC5yZW1vdmVDbGFzcygnbWJzYy1zbGlkZXItc3RhcnQnKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlW2luZGV4XSA+IG1pbiB8fCByZWZyZXNoKSB7XG4gICAgICAkaGFuZGxlQ29udC5hZGRDbGFzcygnbWJzYy1zbGlkZXItc3RhcnQnKTtcbiAgICB9IC8vIFN0b3JlIG5ldyB2YWx1ZVxuXG5cbiAgICBpZiAoZmlsbCkge1xuICAgICAgdmFsdWVbaW5kZXhdID0gdjtcbiAgICB9IC8vIENoZWNrIGlmIHZhbHVlIGNoYW5nZWRcblxuXG4gICAgaWYgKGZpbGwgJiYgb2xkVmFsdWVbaW5kZXhdICE9IHYpIHtcbiAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgb2xkVmFsdWVbaW5kZXhdID0gdjsgLy8gU2V0IG5ldyB2YWx1ZSB0byB0aGUgaW5wdXRcblxuICAgICAgdGhhdC5fZmlsbFZhbHVlKHYsIGluZGV4LCBjaGFuZ2UpO1xuICAgIH1cblxuICAgICRoYW5kbGUuYXR0cignYXJpYS12YWx1ZW5vdycsIHYpO1xuICB9IC8vIENhbGwgdGhlIHBhcmVudCBjb25zdHJ1Y3RvclxuXG5cbiAgUHJvZ3Jlc3NCYXNlLmNhbGwodGhpcywgZWxtLCBzZXR0aW5ncywgdHJ1ZSk7XG4gIHRoYXQuX29uVGFwID0gbm9vcDtcbiAgdGhhdC5fX19pbml0ID0gbm9vcDtcbiAgdGhhdC5fX19kZXN0cm95ID0gbm9vcDtcblxuICB0aGF0Ll9hdHRhY2hDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgJGVsbS5vbihzLmNoYW5nZUV2ZW50LCBvbkNoYW5nZSk7XG4gIH07XG5cbiAgdGhhdC5fX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHdhc0luaXQ7XG5cbiAgICBpZiAoJGhhbmRsZXMpIHtcbiAgICAgIHdhc0luaXQgPSB0cnVlO1xuICAgICAgJGhhbmRsZXMucGFyZW50KCkucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgdGhhdC5fX19pbml0KCk7XG5cbiAgICAkcGFyZW50ID0gdGhhdC5fJHBhcmVudDtcbiAgICAkdHJhY2sgPSB0aGF0Ll8kdHJhY2s7XG4gICAgJGVsbSA9ICRwYXJlbnQuZmluZCgnaW5wdXQnKTtcbiAgICBzID0gdGhhdC5zZXR0aW5ncztcbiAgICBtaW4gPSB0aGF0Ll9taW47XG4gICAgbWF4ID0gdGhhdC5fbWF4O1xuICAgIGJhc2UgPSB0aGF0Ll9iYXNlIHx8IDA7XG4gICAgc3RlcCA9IHRoYXQuX3N0ZXA7XG4gICAgbGl2ZSA9IHRoYXQuX2xpdmU7XG4gICAgc3RlcERlY2ltYWwgPSBzdGVwICUgMSAhPT0gMCA/IDEwMCAvICgrKHN0ZXAgJSAxKS50b0ZpeGVkKDIpICogMTAwKSA6IDE7XG4gICAgc2NhbGUgPSAxMDAgLyAobWF4IC0gbWluICsgYmFzZSkgfHwgMTAwO1xuICAgIG11bHRpcGxlID0gJGVsbS5sZW5ndGggPiAxO1xuICAgIGlzUnRsID0gcy5ydGw7XG4gICAgdmFsdWUgPSBbXTtcbiAgICBvbGRWYWx1ZSA9IFtdOyAvLyBSZWFkIHZhbHVlc1xuXG4gICAgJGVsbS5lYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICB2YWx1ZVtpXSA9IHRoYXQuX3JlYWRWYWx1ZSgkJDEodGhpcykpO1xuICAgICAgJCQxKHRoaXMpLmF0dHIoJ2RhdGEtaW5kZXgnLCBpKTtcbiAgICB9KTtcbiAgICAkaGFuZGxlcyA9ICRwYXJlbnQuZmluZCgnLm1ic2Mtc2xpZGVyLWhhbmRsZScpO1xuICAgIGxpc3RlbmVyID0gJHBhcmVudC5maW5kKG11bHRpcGxlID8gJy5tYnNjLXNsaWRlci1oYW5kbGUtY29udCcgOiAnLm1ic2MtcHJvZ3Jlc3MtY29udCcpWzBdOyAvLyBBdHRhY2ggZXZlbnRzXG5cbiAgICAkaGFuZGxlcy5vbigna2V5ZG93bicsIG9uS2V5RG93bikub24oJ2tleXVwJywgb25LZXlVcCkub24oJ2JsdXInLCBvbktleVVwKTtcbiAgICBsaXN0ZW4obGlzdGVuZXIsICd0b3VjaHN0YXJ0Jywgb25TdGFydCwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGxpc3RlbihsaXN0ZW5lciwgJ21vdXNlZG93bicsIG9uU3RhcnQpO1xuICAgIGxpc3RlbihsaXN0ZW5lciwgJ3RvdWNoZW5kJywgb25FbmQpO1xuICAgIGxpc3RlbihsaXN0ZW5lciwgJ3RvdWNoY2FuY2VsJywgb25FbmQpO1xuICAgIGxpc3RlbihsaXN0ZW5lciwgJ3BvaW50ZXJjYW5jZWwnLCBvbkNhbmNlbCk7XG5cbiAgICBpZiAocy5ob3Zlcikge1xuICAgICAgbGlzdGVuKGxpc3RlbmVyLCAnbW91c2VlbnRlcicsIG9uU3RhcnQpO1xuICAgICAgbGlzdGVuKGxpc3RlbmVyLCAnbW91c2VsZWF2ZScsIG9uRW5kKTtcbiAgICB9XG5cbiAgICBpZiAoIXdhc0luaXQpIHtcbiAgICAgICRlbG0ub24oJ2NsaWNrJywgb25DbGljayk7XG4gICAgICAkcGFyZW50Lm9uKCdjbGljaycsIG9uTGFiZWxDbGljayk7IC8vIEF0dGFjaCB0byBkb2N1bWVudCB0byBhdm9pZCBub24tcGFzc2l2ZSBsaXN0ZW5lciB3YXJuaW5nc1xuXG4gICAgICBsaXN0ZW4oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCBvbk1vdmUsIHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB0aGF0Ll9fZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAkcGFyZW50Lm9mZignY2xpY2snLCBvbkxhYmVsQ2xpY2spO1xuICAgICRlbG0ub2ZmKHMuY2hhbmdlRXZlbnQsIG9uQ2hhbmdlKS5vZmYoJ2NsaWNrJywgb25DbGljayk7XG4gICAgJGhhbmRsZXMub2ZmKCdrZXlkb3duJywgb25LZXlEb3duKS5vZmYoJ2tleXVwJywgb25LZXlVcCkub2ZmKCdibHVyJywgb25LZXlVcCk7XG4gICAgdW5saXN0ZW4obGlzdGVuZXIsICd0b3VjaHN0YXJ0Jywgb25TdGFydCwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuICAgIHVubGlzdGVuKGxpc3RlbmVyLCAnbW91c2Vkb3duJywgb25TdGFydCk7XG4gICAgdW5saXN0ZW4obGlzdGVuZXIsICd0b3VjaGVuZCcsIG9uRW5kKTtcbiAgICB1bmxpc3RlbihsaXN0ZW5lciwgJ3RvdWNoY2FuY2VsJywgb25FbmQpO1xuICAgIHVubGlzdGVuKGxpc3RlbmVyLCAncG9pbnRlcmNhbmNlbCcsIG9uQ2FuY2VsKTtcbiAgICB1bmxpc3RlbihsaXN0ZW5lciwgJ21vdXNlZW50ZXInLCBvblN0YXJ0KTtcbiAgICB1bmxpc3RlbihsaXN0ZW5lciwgJ21vdXNlbGVhdmUnLCBvbkVuZCk7XG4gICAgdW5saXN0ZW4oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCBvbk1vdmUsIHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG5cbiAgICB0aGF0Ll9fX2Rlc3Ryb3koKTtcbiAgfTtcblxuICB0aGF0LnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgJGVsbS5lYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICB1cGRhdGVWYWx1ZSh0aGF0Ll9yZWFkVmFsdWUoJCQxKHRoaXMpKSwgaSwgdHJ1ZSwgZmFsc2UsIHRydWUsIGZhbHNlKTtcbiAgICB9KTtcbiAgfTtcblxuICB0aGF0LmdldFZhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbXVsdGlwbGUgPyB2YWx1ZS5zbGljZSgwKSA6IHZhbHVlWzBdO1xuICB9O1xuXG4gIHRoYXQuc2V0VmFsID0gdGhhdC5fc2V0VmFsID0gZnVuY3Rpb24gKHZhbCwgZmlsbCwgY2hhbmdlKSB7XG4gICAgaWYgKCEkJDEuaXNBcnJheSh2YWwpKSB7XG4gICAgICB2YWwgPSBbdmFsXTtcbiAgICB9XG5cbiAgICAkJDEuZWFjaCh2YWwsIGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICB2YWx1ZVtpXSA9IHY7XG4gICAgfSk7XG4gICAgJCQxLmVhY2godmFsLCBmdW5jdGlvbiAoaSwgdikge1xuICAgICAgdXBkYXRlVmFsdWUodiwgaSwgdHJ1ZSwgZmFsc2UsIHRydWUsIGNoYW5nZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgaWYgKCFpbmhlcml0KSB7XG4gICAgdGhhdC5pbml0KCk7XG4gIH1cbn07XG5cbnZhciBTd2l0Y2ggPSBmdW5jdGlvbiBTd2l0Y2goZWxtLCBzZXR0aW5ncykge1xuICB2YXIgJGVsbSxcbiAgICAgICRwYXJlbnQsXG4gICAgICBzLFxuICAgICAgZm9ybUNvbnRyb2wsXG4gICAgICB0aGF0ID0gdGhpcztcbiAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCB7fTtcbiAgZXh0ZW5kJDEoc2V0dGluZ3MsIHtcbiAgICBjaGFuZ2VFdmVudDogJ2NsaWNrJyxcbiAgICByb3VuZDogZmFsc2VcbiAgfSk7IC8vIENhbGwgdGhlIHBhcmVudCBjb25zdHJ1Y3RvclxuXG4gIFNsaWRlckJhc2UuY2FsbCh0aGlzLCBlbG0sIHNldHRpbmdzLCB0cnVlKTtcblxuICB0aGF0Ll9yZWFkVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGVsbS5jaGVja2VkID8gMSA6IDA7XG4gIH07XG5cbiAgdGhhdC5fZmlsbFZhbHVlID0gZnVuY3Rpb24gKHYsIGluZGV4LCBjaGFuZ2UpIHtcbiAgICAkZWxtLnByb3AoJ2NoZWNrZWQnLCAhIXYpO1xuXG4gICAgaWYgKGNoYW5nZSkge1xuICAgICAgJGVsbS50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICB9XG4gIH07XG5cbiAgdGhhdC5fb25UYXAgPSBmdW5jdGlvbiAodikge1xuICAgIHRoYXQuX3NldFZhbCh2ID8gMCA6IDEpO1xuICB9O1xuXG4gIHRoYXQuX19faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBzID0gdGhhdC5zZXR0aW5ncztcbiAgICAkZWxtID0gJCQxKGVsbSk7XG4gICAgJHBhcmVudCA9ICRlbG0ucGFyZW50KCk7XG4gICAgJHBhcmVudC5maW5kKCcubWJzYy1zd2l0Y2gtdHJhY2snKS5yZW1vdmUoKTtcbiAgICAkcGFyZW50LnByZXBlbmQoJGVsbSk7XG4gICAgJGVsbS5hdHRyKCdkYXRhLXJvbGUnLCAnc3dpdGNoJykuYWZ0ZXIoJzxzcGFuIGNsYXNzPVwibWJzYy1wcm9ncmVzcy1jb250IG1ic2Mtc3dpdGNoLXRyYWNrXCI+JyArICc8c3BhbiBjbGFzcz1cIm1ic2MtcHJvZ3Jlc3MtdHJhY2sgbWJzYy1wcm9ncmVzcy1hbmltXCI+JyArICc8c3BhbiBjbGFzcz1cIm1ic2Mtc2xpZGVyLWhhbmRsZS1jb250XCI+JyArICc8c3BhbiBjbGFzcz1cIm1ic2Mtc2xpZGVyLWhhbmRsZSBtYnNjLXN3aXRjaC1oYW5kbGVcIiBkYXRhLWluZGV4PVwiMFwiPicgKyAnPHNwYW4gY2xhc3M9XCJtYnNjLXN3aXRjaC10eHQtb2ZmXCI+JyArIHMub2ZmVGV4dCArICc8L3NwYW4+JyArICc8c3BhbiBjbGFzcz1cIm1ic2Mtc3dpdGNoLXR4dC1vblwiPicgKyBzLm9uVGV4dCArICc8L3NwYW4+JyArICc8L3NwYW4+PC9zcGFuPjwvc3Bhbj48L3NwYW4+Jyk7XG5cbiAgICBpZiAoZm9ybUNvbnRyb2wpIHtcbiAgICAgIGZvcm1Db250cm9sLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBmb3JtQ29udHJvbCA9IG5ldyBGb3JtQ29udHJvbChlbG0sIHMpO1xuICAgIHRoYXQuXyR0cmFjayA9ICRwYXJlbnQuZmluZCgnLm1ic2MtcHJvZ3Jlc3MtdHJhY2snKTtcbiAgICB0aGF0Ll9taW4gPSAwO1xuICAgIHRoYXQuX21heCA9IDE7XG4gICAgdGhhdC5fc3RlcCA9IDE7XG4gIH07XG5cbiAgdGhhdC5fX19kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGZvcm1Db250cm9sLmRlc3Ryb3koKTtcbiAgfTtcblxuICB0aGF0LmdldFZhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZWxtLmNoZWNrZWQ7XG4gIH07XG5cbiAgdGhhdC5zZXRWYWwgPSBmdW5jdGlvbiAodmFsLCBmaWxsLCBjaGFuZ2UpIHtcbiAgICB0aGF0Ll9zZXRWYWwodmFsID8gMSA6IDAsIGZpbGwsIGNoYW5nZSk7XG4gIH07XG5cbiAgdGhhdC5pbml0KCk7XG59O1xuU3dpdGNoLnByb3RvdHlwZSA9IHtcbiAgX2NsYXNzOiAnc3dpdGNoJyxcbiAgX2NzczogJ21ic2Mtc3dpdGNoJyxcbiAgX2hhc1RoZW1lOiB0cnVlLFxuICBfaGFzTGFuZzogdHJ1ZSxcbiAgX2hhc0RlZjogdHJ1ZSxcbiAgX2RlZmF1bHRzOiB7XG4gICAgc3RvcFByb3A6IHRydWUsXG4gICAgb2ZmVGV4dDogJ09mZicsXG4gICAgb25UZXh0OiAnT24nXG4gIH1cbn07XG5jbGFzc2VzLlN3aXRjaCA9IFN3aXRjaDsgLy8gSW5pdCBtYnNjLXN3aXRjaCBlbGVtZW50cyBvbiBwYWdlIGxvYWRcblxuYXV0b0luaXQoJ1ttYnNjLXN3aXRjaF0nLCBTd2l0Y2gpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbnZhciBQcm9ncmVzcyA9IGZ1bmN0aW9uIFByb2dyZXNzKGVsbSwgc2V0dGluZ3MsIGluaGVyaXQpIHtcbiAgdmFyICRkaXNwbGF5LFxuICAgICAgJGVsbSxcbiAgICAgICRwYXJlbnQsXG4gICAgICAkcHJvZ3Jlc3MsXG4gICAgICAkdGFyZ2V0LFxuICAgICAgJHRyYWNrLFxuICAgICAgbWluLFxuICAgICAgbWF4LFxuICAgICAgaW5wdXRTdHlsZSxcbiAgICAgIGxhYmVsU3R5bGUsXG4gICAgICBzLFxuICAgICAgdGVtcGxhdGUsXG4gICAgICB2YWx1ZSxcbiAgICAgIHZhbHVlVGV4dCxcbiAgICAgIHRoYXQgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuICAgIHZhciB2ID0gZ2V0QXR0cigndmFsdWUnLCBtaW4pO1xuXG4gICAgaWYgKHYgIT09IHZhbHVlKSB7XG4gICAgICB1cGRhdGVWYWx1ZSh2KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRBdHRyKGF0dHIsIGRlZiwgc3RyKSB7XG4gICAgdmFyIHYgPSAkZWxtLmF0dHIoYXR0cik7XG4gICAgcmV0dXJuIHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSAnJyA/IGRlZiA6IHN0ciA/IHYgOiArdjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVZhbHVlKHYsIHJlZnJlc2gsIGZpbGwsIGNoYW5nZSkge1xuICAgIHYgPVxuICAgIC8qIFRSSUFMQ09ORFJFViAqL1xuICAgIE1hdGgubWluKG1heCwgTWF0aC5tYXgodiwgbWluKSk7XG4gICAgJHByb2dyZXNzLmNzcygnd2lkdGgnLCAodiAtIG1pbikgKiAxMDAgLyAobWF4IC0gbWluKSArICclJyk7XG5cbiAgICBpZiAoZmlsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmaWxsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoY2hhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNoYW5nZSA9IGZpbGw7XG4gICAgfVxuXG4gICAgaWYgKHYgIT09IHZhbHVlIHx8IHJlZnJlc2gpIHtcbiAgICAgIC8vIERpc3BsYXkgdmFsdWVcbiAgICAgIHRoYXQuX2Rpc3BsYXkodik7XG4gICAgfVxuXG4gICAgaWYgKHYgIT09IHZhbHVlKSB7XG4gICAgICAvLyBTZXQgbmV3IHZhbHVlXG4gICAgICB2YWx1ZSA9IHY7IC8vIFB1dCBuZXcgdmFsdWUgaW4gdGhlIHByb2dyZXNzIGVsZW1lbnRcblxuICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgJGVsbS5hdHRyKCd2YWx1ZScsIHZhbHVlKTtcbiAgICAgIH0gLy8gVHJpZ2dlciBjaGFuZ2Ugb24gdGhlIGVsZW1lbnRcblxuXG4gICAgICBpZiAoY2hhbmdlKSB7XG4gICAgICAgICRlbG0udHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENhbGwgdGhlIHBhcmVudCBjb25zdHJ1Y3RvclxuXG5cbiAgUHJvZ3Jlc3NCYXNlLmNhbGwodGhpcywgZWxtLCBzZXR0aW5ncywgdHJ1ZSk7XG5cbiAgdGhhdC5fZGlzcGxheSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgdmFsdWVUZXh0ID0gdGVtcGxhdGUgJiYgcy5yZXR1cm5BZmZpeCA/IHRlbXBsYXRlLnJlcGxhY2UoL1xce3ZhbHVlXFx9LywgdikucmVwbGFjZSgvXFx7bWF4XFx9LywgbWF4KSA6IHY7XG5cbiAgICBpZiAoJHRhcmdldCkge1xuICAgICAgJHRhcmdldC5odG1sKHZhbHVlVGV4dCk7XG4gICAgfVxuXG4gICAgaWYgKCRkaXNwbGF5KSB7XG4gICAgICAkZGlzcGxheS5odG1sKHZhbHVlVGV4dCk7XG4gICAgfVxuICB9O1xuXG4gIHRoYXQuX2F0dGFjaENoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAkZWxtLm9uKCdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gIH07XG5cbiAgdGhhdC5fX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRpc3BsYXlWYWx1ZSwgaSwgc3RlcExhYmVscywgd2FzSW5pdDtcbiAgICBzID0gdGhhdC5zZXR0aW5ncztcbiAgICAkZWxtID0gJCQxKGVsbSk7IC8vIENoZWNrIGlmIHRoZSBlbGVtZW50IHdhcyBhbHJlYWR5IGluaXRpYWxpemVkXG5cbiAgICB3YXNJbml0ID0gISEkcGFyZW50O1xuICAgICRwYXJlbnQgPSB0aGF0Ll8kcGFyZW50OyAvLyBSZWFkIHNldHRpbmdzIGZyb20gZGF0YSBhdHRyaWJ1dGVzIG9yIHNldHRpbmdzIG9iamVjdFxuXG4gICAgbWluID0gdGhhdC5fbWluID0gc2V0dGluZ3MubWluID09PSB1bmRlZmluZWQgPyBnZXRBdHRyKCdtaW4nLCBzLm1pbikgOiBzZXR0aW5ncy5taW47XG4gICAgbWF4ID0gdGhhdC5fbWF4ID0gc2V0dGluZ3MubWF4ID09PSB1bmRlZmluZWQgPyBnZXRBdHRyKCdtYXgnLCBzLm1heCkgOiBzZXR0aW5ncy5tYXg7XG4gICAgaW5wdXRTdHlsZSA9IHNldHRpbmdzLmlucHV0U3R5bGUgPT09IHVuZGVmaW5lZCA/IGdldEF0dHIoJ2RhdGEtaW5wdXQtc3R5bGUnLCBzLmlucHV0U3R5bGUsIHRydWUpIDogc2V0dGluZ3MuaW5wdXRTdHlsZTtcbiAgICBsYWJlbFN0eWxlID0gc2V0dGluZ3MubGFiZWxTdHlsZSA9PT0gdW5kZWZpbmVkID8gZ2V0QXR0cignZGF0YS1sYWJlbC1zdHlsZScsIHMubGFiZWxTdHlsZSwgdHJ1ZSkgOiBzZXR0aW5ncy5sYWJlbFN0eWxlO1xuICAgIHZhbHVlID0gZ2V0QXR0cigndmFsdWUnLCBtaW4pO1xuICAgIGRpc3BsYXlWYWx1ZSA9ICRlbG0uYXR0cignZGF0YS12YWwnKSB8fCBzLnZhbDtcbiAgICBzdGVwTGFiZWxzID0gJGVsbS5hdHRyKCdkYXRhLXN0ZXAtbGFiZWxzJyk7XG4gICAgc3RlcExhYmVscyA9IHN0ZXBMYWJlbHMgPyBKU09OLnBhcnNlKHN0ZXBMYWJlbHMpIDogcy5zdGVwTGFiZWxzO1xuICAgIHRlbXBsYXRlID0gJGVsbS5hdHRyKCdkYXRhLXRlbXBsYXRlJykgfHwgKG1heCA9PSAxMDAgJiYgIXMudGVtcGxhdGUgPyAne3ZhbHVlfSUnIDogcy50ZW1wbGF0ZSk7XG5cbiAgICBpZiAoIXdhc0luaXQpIHtcbiAgICAgIHdyYXBMYWJlbCgkcGFyZW50LCBudWxsLCBpbnB1dFN0eWxlLCBsYWJlbFN0eWxlLCBlbG0pO1xuICAgICAgYWRkSWNvbigkZWxtKTsgLy8gR2VuZXJhdGUgdHJhY2sgYW5kIHByb2dyZXNzXG5cbiAgICAgICRwYXJlbnQuZmluZCgnLm1ic2MtaW5wdXQtd3JhcCcpLmFwcGVuZCgnPHNwYW4gY2xhc3M9XCJtYnNjLXByb2dyZXNzLWNvbnRcIj48c3BhbiBjbGFzcz1cIm1ic2MtcHJvZ3Jlc3MtdHJhY2sgbWJzYy1wcm9ncmVzcy1hbmltXCI+PHNwYW4gY2xhc3M9XCJtYnNjLXByb2dyZXNzLWJhclwiPjwvc3Bhbj48L3NwYW4+PC9zcGFuPicpO1xuICAgICAgJHByb2dyZXNzID0gdGhhdC5fJHByb2dyZXNzID0gJHBhcmVudC5maW5kKCcubWJzYy1wcm9ncmVzcy1iYXInKTtcbiAgICAgICR0cmFjayA9IHRoYXQuXyR0cmFjayA9ICRwYXJlbnQuZmluZCgnLm1ic2MtcHJvZ3Jlc3MtdHJhY2snKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRpc3BsYXlWYWx1ZSkge1xuICAgICAgICAkZGlzcGxheS5yZW1vdmUoKTtcbiAgICAgICAgJHBhcmVudC5yZW1vdmVDbGFzcygnbWJzYy1wcm9ncmVzcy12YWx1ZS0nICsgKGRpc3BsYXlWYWx1ZSA9PSAncmlnaHQnID8gJ3JpZ2h0JyA6ICdsZWZ0JykpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RlcExhYmVscykge1xuICAgICAgICAkJDEoJy5tYnNjLXByb2dyZXNzLXN0ZXAtbGFiZWwnLCAkdHJhY2spLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH0gLy8gU2V0IGF0dHJpYnV0ZXNcblxuXG4gICAgJGVsbS5hdHRyKCdtaW4nLCBtaW4pLmF0dHIoJ21heCcsIG1heCk7IC8vIEdlbmVyYXRlIHZhbHVlIGNvbnRhaW5lciBvbiBsZWZ0IG9yIHJpZ2h0IHNpZGVcblxuICAgIGlmIChkaXNwbGF5VmFsdWUpIHtcbiAgICAgICRkaXNwbGF5ID0gJCQxKCc8c3BhbiBjbGFzcz1cIm1ic2MtcHJvZ3Jlc3MtdmFsdWVcIj48L3NwYW4+Jyk7XG4gICAgICAkcGFyZW50LmFkZENsYXNzKCdtYnNjLXByb2dyZXNzLXZhbHVlLScgKyAoZGlzcGxheVZhbHVlID09ICdyaWdodCcgPyAncmlnaHQnIDogJ2xlZnQnKSkuZmluZCgnLm1ic2MtaW5wdXQtd3JhcCcpLmFwcGVuZCgkZGlzcGxheSk7XG4gICAgfSAvLyBHZW5lcmF0ZSBzdGVwIGxhYmVsc1xuXG5cbiAgICBpZiAoc3RlcExhYmVscykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHN0ZXBMYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgJHRyYWNrLmFwcGVuZCgnPHNwYW4gY2xhc3M9XCJtYnNjLXByb2dyZXNzLXN0ZXAtbGFiZWxcIiBzdHlsZT1cIicgKyAocy5ydGwgPyAncmlnaHQnIDogJ2xlZnQnKSArICc6ICcgKyAoc3RlcExhYmVsc1tpXSAtIG1pbikgKiAxMDAgLyAobWF4IC0gbWluKSArICclXCIgPicgKyBzdGVwTGFiZWxzW2ldICsgJzwvc3Bhbj4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAkdGFyZ2V0ID0gJCQxKCRlbG0uYXR0cignZGF0YS10YXJnZXQnKSB8fCBzLnRhcmdldCk7XG4gIH07XG5cbiAgdGhhdC5fX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgJHBhcmVudC5yZW1vdmVDbGFzcygnbWJzYy1pYy1sZWZ0IG1ic2MtaWMtcmlnaHQnKS5maW5kKCcubWJzYy1wcm9ncmVzcy1jb250JykucmVtb3ZlKCk7XG4gICAgJHBhcmVudC5maW5kKCcubWJzYy1pbnB1dC1pYycpLnJlbW92ZSgpO1xuICAgICRlbG0ub2ZmKCdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gIH07XG5cbiAgdGhhdC5yZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHVwZGF0ZVZhbHVlKGdldEF0dHIoJ3ZhbHVlJywgbWluKSwgdHJ1ZSwgZmFsc2UpO1xuICB9O1xuXG4gIHRoYXQuZ2V0VmFsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICB0aGF0LnNldFZhbCA9IGZ1bmN0aW9uICh2LCBmaWxsLCBjaGFuZ2UpIHtcbiAgICB1cGRhdGVWYWx1ZSh2LCB0cnVlLCBmaWxsLCBjaGFuZ2UpO1xuICB9O1xuXG4gIGlmICghaW5oZXJpdCkge1xuICAgIHRoYXQuaW5pdCgpO1xuICB9XG59O1xuUHJvZ3Jlc3MucHJvdG90eXBlID0ge1xuICBfY2xhc3M6ICdwcm9ncmVzcycsXG4gIF9jc3M6ICdtYnNjLXByb2dyZXNzJyxcbiAgX2hhc1RoZW1lOiB0cnVlLFxuICBfaGFzTGFuZzogdHJ1ZSxcbiAgX2hhc0RlZjogdHJ1ZSxcbiAgX2RlZmF1bHRzOiB7XG4gICAgbWluOiAwLFxuICAgIG1heDogMTAwLFxuICAgIHJldHVybkFmZml4OiB0cnVlXG4gIH1cbn07XG5jbGFzc2VzLlByb2dyZXNzID0gUHJvZ3Jlc3M7IC8vIEluaXQgbWJzYy1wcm9ncmVzcyBlbGVtZW50cyBvbiBwYWdlIGxvYWRcblxuYXV0b0luaXQoJ1ttYnNjLXByb2dyZXNzXScsIFByb2dyZXNzKTtcblxudmFyIFNsaWRlciA9IGZ1bmN0aW9uIFNsaWRlcihlbG0sIHNldHRpbmdzLCBpbmhlcml0KSB7XG4gIHZhciAkZWxtLFxuICAgICAgJHBhcmVudCxcbiAgICAgICRwcm9ncmVzcyxcbiAgICAgICR0b29sdGlwcyxcbiAgICAgICR0cmFjayxcbiAgICAgIGhhc1Byb2dyZXNzLFxuICAgICAgaGFzVG9vbHRpcCxcbiAgICAgIGlzUmFuZ2UsXG4gICAgICBpc1J0bCxcbiAgICAgIG1heCxcbiAgICAgIG1pbixcbiAgICAgIHN0ZXAsXG4gICAgICBzLFxuICAgICAgdGhhdCA9IHRoaXM7IC8vIENhbGwgdGhlIHBhcmVudCBjb25zdHJ1Y3RvclxuXG4gIFByb2dyZXNzLmNhbGwodGhpcywgZWxtLCBzZXR0aW5ncywgdHJ1ZSk7XG4gIHZhciBwcm9ncmVzc0luaXQgPSB0aGF0Ll9faW5pdCxcbiAgICAgIHByb2dyZXNzRGVzdHJveSA9IHRoYXQuX19kZXN0cm95O1xuICBTbGlkZXJCYXNlLmNhbGwodGhpcywgZWxtLCBzZXR0aW5ncywgdHJ1ZSk7XG4gIHZhciBzbGlkZXJJbml0ID0gdGhhdC5fX2luaXQsXG4gICAgICBzbGlkZXJEZXN0cm95ID0gdGhhdC5fX2Rlc3Ryb3k7IC8vIC0tLVxuXG4gIHRoYXQuX19pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHByb2dyZXNzSW5pdCgpO1xuICAgIHNsaWRlckluaXQoKTtcbiAgfTtcblxuICB0aGF0Ll9fZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBwcm9ncmVzc0Rlc3Ryb3koKTtcbiAgICBzbGlkZXJEZXN0cm95KCk7XG4gIH07XG5cbiAgdGhhdC5fdXBkYXRlID0gZnVuY3Rpb24gKHYsIHZhbHVlLCBpbmRleCwgcGVyY2VudCwgbXVsdGlwbGUsIHJlZnJlc2gsICRoYW5kbGVDb250KSB7XG4gICAgaWYgKGlzUmFuZ2UpIHtcbiAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICB2ID0gTWF0aC5taW4odiwgdmFsdWVbMV0pO1xuICAgICAgICAkcHJvZ3Jlc3MuY3NzKHtcbiAgICAgICAgICB3aWR0aDogZ2V0UGVyY2VudCh2YWx1ZVsxXSwgbWluLCBtYXgpIC0gZ2V0UGVyY2VudCh2LCBtaW4sIG1heCkgKyAnJScsXG4gICAgICAgICAgbGVmdDogaXNSdGwgPyAnYXV0bycgOiBnZXRQZXJjZW50KHYsIG1pbiwgbWF4KSArICclJyxcbiAgICAgICAgICByaWdodDogaXNSdGwgPyBnZXRQZXJjZW50KHYsIG1pbiwgbWF4KSArICclJyA6ICdhdXRvJ1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYgPSBNYXRoLm1heCh2LCB2YWx1ZVswXSk7XG4gICAgICAgICRwcm9ncmVzcy5jc3Moe1xuICAgICAgICAgIHdpZHRoOiBnZXRQZXJjZW50KHYsIG1pbiwgbWF4KSAtIGdldFBlcmNlbnQodmFsdWVbMF0sIG1pbiwgbWF4KSArICclJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG11bHRpcGxlIHx8ICFoYXNQcm9ncmVzcykge1xuICAgICAgJGhhbmRsZUNvbnQuY3NzKHtcbiAgICAgICAgbGVmdDogaXNSdGwgPyAnYXV0bycgOiAocGVyY2VudCB8fCBnZXRQZXJjZW50KHYsIG1pbiwgbWF4KSkgKyAnJScsXG4gICAgICAgIHJpZ2h0OiBpc1J0bCA/IChwZXJjZW50IHx8IGdldFBlcmNlbnQodiwgbWluLCBtYXgpKSArICclJyA6ICdhdXRvJ1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRwcm9ncmVzcy5jc3MoJ3dpZHRoJywgKHBlcmNlbnQgfHwgZ2V0UGVyY2VudCh2LCBtaW4sIG1heCkpICsgJyUnKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVG9vbHRpcCkge1xuICAgICAgJHRvb2x0aXBzLmVxKGluZGV4KS5odG1sKHYpO1xuICAgIH0gLy8gRGlzcGxheSB2YWx1ZSBpbiB0aGUgc3BlY2lmaWVkIGNvbnRhaW5lcihzKVxuXG5cbiAgICBpZiAoIW11bHRpcGxlICYmICh2YWx1ZVtpbmRleF0gIT0gdiB8fCByZWZyZXNoKSkge1xuICAgICAgdGhhdC5fZGlzcGxheSh2KTtcbiAgICB9IC8vIFJldHVybiB2YWxpZGF0ZWQgdmFsdWVcblxuXG4gICAgcmV0dXJuIHY7XG4gIH07XG5cbiAgdGhhdC5fcmVhZFZhbHVlID0gZnVuY3Rpb24gKCRlbG0pIHtcbiAgICByZXR1cm4gKyRlbG0udmFsKCk7XG4gIH07XG5cbiAgdGhhdC5fZmlsbFZhbHVlID0gZnVuY3Rpb24gKHYsIGluZGV4LCBjaGFuZ2UpIHtcbiAgICAkZWxtLmVxKGluZGV4KS52YWwodik7XG5cbiAgICBpZiAoY2hhbmdlKSB7XG4gICAgICAkZWxtLmVxKGluZGV4KS50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICB9XG4gIH07XG5cbiAgdGhhdC5fbWFya3VwUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGksIHN0ZXBOcjtcblxuICAgIGlmIChoYXNUb29sdGlwKSB7XG4gICAgICAkcGFyZW50LmFkZENsYXNzKCdtYnNjLXNsaWRlci1oYXMtdG9vbHRpcCcpO1xuICAgIH0gLy8gR2VuZXJhdGUgc3RlcCBtYXJrc1xuXG5cbiAgICBpZiAoc3RlcCAhPSAxKSB7XG4gICAgICBzdGVwTnIgPSAobWF4IC0gbWluKSAvIHN0ZXA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPD0gc3RlcE5yOyArK2kpIHtcbiAgICAgICAgJHRyYWNrLmFwcGVuZCgnPHNwYW4gY2xhc3M9XCJtYnNjLXNsaWRlci1zdGVwXCIgc3R5bGU9XCInICsgKGlzUnRsID8gJ3JpZ2h0JyA6ICdsZWZ0JykgKyAnOicgKyAxMDAgLyBzdGVwTnIgKiBpICsgJyVcIj48L3NwYW4+Jyk7XG4gICAgICB9XG4gICAgfSAvLyBHZW5lcmF0ZSBzbGlkZXIgaGFuZGxlc1xuXG5cbiAgICAkZWxtLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgIGlmICh0aGlzLnR5cGUgPT0gJ3JhbmdlJykge1xuICAgICAgICAvLyBTZXQgbWluIC8gbWF4IC8gc3RlcCBwcm9wZXJ0aWVzIGZvciBhbGwgaW5wdXRzXG4gICAgICAgICQkMSh0aGlzKS5hdHRyKCdtaW4nLCBtaW4pLmF0dHIoJ21heCcsIG1heCkuYXR0cignc3RlcCcsIHN0ZXApO1xuICAgICAgfVxuXG4gICAgICAoaGFzUHJvZ3Jlc3MgPyAkcHJvZ3Jlc3MgOiAkdHJhY2spLmFwcGVuZCgnPHNwYW4gY2xhc3M9XCJtYnNjLXNsaWRlci1oYW5kbGUtY29udCcgKyAoaXNSYW5nZSAmJiAhaSA/ICcgbWJzYy1zbGlkZXItaGFuZGxlLWxlZnQnIDogJycpICsgJ1wiPicgKyAnPHNwYW4gdGFiaW5kZXg9XCIwXCIgY2xhc3M9XCJtYnNjLXNsaWRlci1oYW5kbGVcIiBhcmlhLXZhbHVlbWluPVwiJyArIG1pbiArICdcIiBhcmlhLXZhbHVlbWF4PVwiJyArIG1heCArICdcIiBkYXRhLWluZGV4PVwiJyArIGkgKyAnXCI+PC9zcGFuPicgKyAoaGFzVG9vbHRpcCA/ICc8c3BhbiBjbGFzcz1cIm1ic2Mtc2xpZGVyLXRvb2x0aXBcIj48L3NwYW4+JyA6ICcnKSArICc8L3NwYW4+Jyk7XG4gICAgfSk7XG4gICAgJHRvb2x0aXBzID0gJHBhcmVudC5maW5kKCcubWJzYy1zbGlkZXItdG9vbHRpcCcpO1xuICB9O1xuXG4gIHRoYXQuX19faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJHBhcmVudCkge1xuICAgICAgJHBhcmVudC5yZW1vdmVDbGFzcygnbWJzYy1zbGlkZXItaGFzLXRvb2x0aXAnKTtcblxuICAgICAgaWYgKHN0ZXAgIT0gMSkge1xuICAgICAgICAkJDEoJy5tYnNjLXNsaWRlci1zdGVwJywgJHRyYWNrKS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAkcGFyZW50ID0gdGhhdC5fJHBhcmVudDtcbiAgICAkdHJhY2sgPSB0aGF0Ll8kdHJhY2s7XG4gICAgJHByb2dyZXNzID0gdGhhdC5fJHByb2dyZXNzO1xuICAgICRlbG0gPSAkcGFyZW50LmZpbmQoJ2lucHV0Jyk7XG4gICAgcyA9IHRoYXQuc2V0dGluZ3M7XG4gICAgbWluID0gdGhhdC5fbWluO1xuICAgIG1heCA9IHRoYXQuX21heDtcbiAgICB0aGF0Ll9zdGVwID0gc3RlcCA9IHNldHRpbmdzLnN0ZXAgPT09IHVuZGVmaW5lZCA/ICskZWxtLmF0dHIoJ3N0ZXAnKSB8fCBzLnN0ZXAgOiBzZXR0aW5ncy5zdGVwO1xuICAgIHRoYXQuX2xpdmUgPSBnZXRCb29sQXR0cignZGF0YS1saXZlJywgcy5saXZlLCAkZWxtKTtcbiAgICBoYXNUb29sdGlwID0gZ2V0Qm9vbEF0dHIoJ2RhdGEtdG9vbHRpcCcsIHMudG9vbHRpcCwgJGVsbSk7XG4gICAgaGFzUHJvZ3Jlc3MgPSBnZXRCb29sQXR0cignZGF0YS1oaWdobGlnaHQnLCBzLmhpZ2hsaWdodCwgJGVsbSkgJiYgJGVsbS5sZW5ndGggPCAzO1xuICAgIGlzUmFuZ2UgPSBoYXNQcm9ncmVzcyAmJiAkZWxtLmxlbmd0aCA9PSAyO1xuICAgIGlzUnRsID0gcy5ydGw7XG5cbiAgICB0aGF0Ll9tYXJrdXBSZWFkeSgpO1xuICB9O1xuXG4gIGlmICghaW5oZXJpdCkge1xuICAgIHRoYXQuaW5pdCgpO1xuICB9XG59O1xuU2xpZGVyLnByb3RvdHlwZSA9IHtcbiAgX2NsYXNzOiAncHJvZ3Jlc3MnLFxuICBfY3NzOiAnbWJzYy1wcm9ncmVzcyBtYnNjLXNsaWRlcicsXG4gIF9oYXNUaGVtZTogdHJ1ZSxcbiAgX2hhc0xhbmc6IHRydWUsXG4gIF9oYXNEZWY6IHRydWUsXG4gIF9kZWZhdWx0czoge1xuICAgIGNoYW5nZUV2ZW50OiAnY2hhbmdlJyxcbiAgICBzdG9wUHJvcDogdHJ1ZSxcbiAgICBtaW46IDAsXG4gICAgbWF4OiAxMDAsXG4gICAgc3RlcDogMSxcbiAgICBsaXZlOiB0cnVlLFxuICAgIGhpZ2hsaWdodDogdHJ1ZSxcbiAgICByb3VuZDogdHJ1ZSxcbiAgICByZXR1cm5BZmZpeDogdHJ1ZVxuICB9XG59O1xuY2xhc3Nlcy5TbGlkZXIgPSBTbGlkZXI7IC8vIEluaXQgbWJzYy1zbGlkZXIgZWxlbWVudHMgb24gcGFnZSBsb2FkXG5cbmF1dG9Jbml0KCdbbWJzYy1zbGlkZXJdJywgU2xpZGVyKTtcblxudmFyIFJhdGluZyA9IGZ1bmN0aW9uIFJhdGluZyhlbG0sIHNldHRpbmdzLCBpbmhlcml0KSB7XG4gIHZhciAkcHJvZ3Jlc3MsXG4gICAgICAkdHJhY2ssXG4gICAgICBtYXgsXG4gICAgICBtaW4sXG4gICAgICBlbXB0eSxcbiAgICAgIGZpbGxlZCxcbiAgICAgIHMsXG4gICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICRlbG0gPSAkJDEoZWxtKTsgLy8gQ2FsbCB0aGUgcGFyZW50IGNvbnN0cnVjdG9yXG5cbiAgU2xpZGVyLmNhbGwodGhpcywgZWxtLCBzZXR0aW5ncywgdHJ1ZSk7XG5cbiAgdGhhdC5fdXBkYXRlID0gZnVuY3Rpb24gKHYsIHZhbHVlLCBpbmRleCwgcGVyY2VudCwgbXVsdGlwbGUsIHJlZnJlc2gpIHtcbiAgICAkcHJvZ3Jlc3MuY3NzKCd3aWR0aCcsIGdldFBlcmNlbnQodiwgMCwgbWF4KSArICclJyk7IC8vIERpc3BsYXkgdmFsdWUgaW4gdGhlIHNwZWNpZmllZCBjb250YWluZXIocylcblxuICAgIGlmICghbXVsdGlwbGUgJiYgKHZhbHVlW2luZGV4XSAhPSB2IHx8IHJlZnJlc2gpKSB7XG4gICAgICB0aGF0Ll9kaXNwbGF5KHYpO1xuICAgIH0gLy8gUmV0dXJuIHZhbGlkYXRlZCB2YWx1ZVxuXG5cbiAgICByZXR1cm4gdjtcbiAgfTtcblxuICB0aGF0Ll9tYXJrdXBSZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgZW1wdHlTdHJpbmcgPSAnJyxcbiAgICAgICAgZmlsbGVkU3RyaW5nID0gJyc7XG4gICAgJHRyYWNrID0gdGhhdC5fJHRyYWNrO1xuICAgICRwcm9ncmVzcyA9IHRoYXQuXyRwcm9ncmVzcztcbiAgICBzID0gdGhhdC5zZXR0aW5ncztcbiAgICBtaW4gPSB0aGF0Ll9taW47XG4gICAgbWF4ID0gdGhhdC5fbWF4O1xuICAgIHRoYXQuX2Jhc2UgPSBtaW47XG4gICAgdGhhdC5fcm91bmRpbmcgPSBzLnJ0bCA/ICdmbG9vcicgOiAnY2VpbCc7XG4gICAgZW1wdHkgPSAkZWxtLmF0dHIoJ2RhdGEtZW1wdHknKSB8fCBzLmVtcHR5O1xuICAgIGZpbGxlZCA9ICRlbG0uYXR0cignZGF0YS1maWxsZWQnKSB8fCBzLmZpbGxlZDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBtYXg7ICsraSkge1xuICAgICAgZW1wdHlTdHJpbmcgKz0gJzxzcGFuIGNsYXNzPVwibWJzYy1pYyBtYnNjLWljLScgKyBlbXB0eSArICdcIj48L3NwYW4+JztcbiAgICAgIGZpbGxlZFN0cmluZyArPSAnPHNwYW4gY2xhc3M9XCJtYnNjLWljIG1ic2MtaWMtJyArIGZpbGxlZCArICdcIj48L3NwYW4+JztcbiAgICB9XG5cbiAgICAkdHJhY2suaHRtbChlbXB0eVN0cmluZyk7XG4gICAgJHRyYWNrLmFwcGVuZCgkcHJvZ3Jlc3MpO1xuICAgICRwcm9ncmVzcy5odG1sKGZpbGxlZFN0cmluZyk7XG4gICAgJHRyYWNrLmFwcGVuZCgnPHNwYW4gY2xhc3M9XCJtYnNjLXJhdGluZy1oYW5kbGUtY29udCcgKyAnXCI+JyArICc8c3BhbiB0YWJpbmRleD1cIjBcIiBjbGFzcz1cIm1ic2Mtc2xpZGVyLWhhbmRsZVwiIGFyaWEtdmFsdWVtaW49XCInICsgbWluICsgJ1wiIGFyaWEtdmFsdWVtYXg9XCInICsgbWF4ICsgJ1wiIGRhdGEtaW5kZXg9XCIwXCI+PC9zcGFuPicgKyAnPC9zcGFuPicpO1xuICB9O1xuXG4gIGlmICghaW5oZXJpdCkge1xuICAgIHRoYXQuaW5pdCgpO1xuICB9XG59O1xuUmF0aW5nLnByb3RvdHlwZSA9IHtcbiAgX2NsYXNzOiAncHJvZ3Jlc3MnLFxuICBfY3NzOiAnbWJzYy1wcm9ncmVzcyBtYnNjLXJhdGluZycsXG4gIF9oYXNUaGVtZTogdHJ1ZSxcbiAgX2hhc0xhbmc6IHRydWUsXG4gIF9oYXNEZWY6IHRydWUsXG4gIF9kZWZhdWx0czoge1xuICAgIGNoYW5nZUV2ZW50OiAnY2hhbmdlJyxcbiAgICBzdG9wUHJvcDogdHJ1ZSxcbiAgICBtaW46IDEsXG4gICAgbWF4OiA1LFxuICAgIHN0ZXA6IDEsXG4gICAgbGl2ZTogdHJ1ZSxcbiAgICByb3VuZDogdHJ1ZSxcbiAgICBob3ZlcjogdHJ1ZSxcbiAgICBoaWdobGlnaHQ6IHRydWUsXG4gICAgcmV0dXJuQWZmaXg6IHRydWUsXG4gICAgZW1wdHk6ICdzdGFyJyxcbiAgICBmaWxsZWQ6ICdzdGFyMydcbiAgfVxufTtcbmNsYXNzZXMuUmF0aW5nID0gUmF0aW5nOyAvLyBJbml0IG1ic2MtcmF0aW5nIGVsZW1lbnRzIG9uIHBhZ2UgbG9hZFxuXG5hdXRvSW5pdCgnW21ic2MtcmF0aW5nXScsIFJhdGluZyk7XG5cbnZhciBuciA9IDE7XG52YXIgQ29sbGFwc2libGVCYXNlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29sbGFwc2libGVCYXNlKGVsbSwgc2V0dGluZ3MpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGNvbnRlbnQ7XG4gICAgdmFyICRoZWFkZXI7XG4gICAgdmFyICRjb250ZW50O1xuICAgIHZhciAkZWxtID0gJCQxKGVsbSk7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIHRoaXMuX2lzT3BlbiA9IHNldHRpbmdzLmlzT3BlbiB8fCBmYWxzZTtcbiAgICAkZWxtLmFkZENsYXNzKCdtYnNjLWNvbGxhcHNpYmxlICcgKyAodGhpcy5faXNPcGVuID8gJ21ic2MtY29sbGFwc2libGUtb3BlbicgOiAnJykpO1xuXG4gICAgaWYgKCRlbG0uaGFzQ2xhc3MoJ21ic2MtY2FyZCcpKSB7XG4gICAgICAvLyBjYXJkIGVuaGFuY2VcbiAgICAgICRoZWFkZXIgPSAkZWxtLmZpbmQoJy5tYnNjLWNhcmQtaGVhZGVyJykuZXEoMCkuYWRkQ2xhc3MoJ21ic2MtY29sbGFwc2libGUtaGVhZGVyJyk7XG4gICAgICAkY29udGVudCA9ICRlbG0uZmluZCgnLm1ic2MtY2FyZC1jb250ZW50JykuZXEoMCkuYWRkQ2xhc3MoJ21ic2MtY29sbGFwc2libGUtY29udGVudCcpO1xuICAgIH0gZWxzZSBpZiAoJGVsbS5oYXNDbGFzcygnbWJzYy1mb3JtLWdyb3VwJykgfHwgJGVsbS5oYXNDbGFzcygnbWJzYy1mb3JtLWdyb3VwLWluc2V0JykpIHtcbiAgICAgIC8vIGZvcm0gZ3JvdXAgZW5oYW5jZVxuICAgICAgJGhlYWRlciA9ICRlbG0uZmluZCgnLm1ic2MtZm9ybS1ncm91cC10aXRsZScpLmVxKDApLmFkZENsYXNzKCdtYnNjLWNvbGxhcHNpYmxlLWhlYWRlcicpO1xuICAgICAgJGNvbnRlbnQgPSAkZWxtLmZpbmQoJy5tYnNjLWZvcm0tZ3JvdXAtY29udGVudCcpLmVxKDApLmFkZENsYXNzKCdtYnNjLWNvbGxhcHNpYmxlLWNvbnRlbnQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgaXQgaXMgdXNlZCBpbmRlcGVuZGVudGx5XG4gICAgICAkaGVhZGVyID0gJGVsbS5maW5kKCcubWJzYy1jb2xsYXBzaWJsZS1oZWFkZXInKS5lcSgwKTtcbiAgICAgICRjb250ZW50ID0gJGVsbS5maW5kKCcubWJzYy1jb2xsYXBzaWJsZS1jb250ZW50JykuZXEoMCk7XG4gICAgfVxuXG4gICAgY29udGVudCA9ICRjb250ZW50WzBdO1xuXG4gICAgaWYgKGNvbnRlbnQgJiYgIWNvbnRlbnQuaWQpIHtcbiAgICAgIGNvbnRlbnQuaWQgPSAnbWJzYy1jb2xsYXBzaWJsZS0nICsgbnIrKztcbiAgICB9XG5cbiAgICBpZiAoJGhlYWRlci5sZW5ndGggJiYgY29udGVudCkge1xuICAgICAgdmFyICRjb2xsYXBzaWJsZUljb24gPSAkJDEoJzxzcGFuIGNsYXNzPVwibWJzYy1jb2xsYXBzaWJsZS1pY29uIG1ic2MtaWMgbWJzYy1pYy1hcnJvdy1kb3duNVwiPjwvc3Bhbj4nKTtcbiAgICAgIHRhcCh0aGlzLCAkaGVhZGVyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmNvbGxhcHNlKCk7XG4gICAgICB9KTtcbiAgICAgICRoZWFkZXIuYXR0cigncm9sZScsICdidXR0b24nKS5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdGhpcy5faXNPcGVuKS5hdHRyKCdhcmlhLWNvbnRyb2xzJywgY29udGVudC5pZCkuYXR0cigndGFiaW5kZXgnLCAnMCcpLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgLy8gcHJldmVudCBmb2N1cyBvbiBtb3VzZSBkb3duXG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9KS5vbigna2V5ZG93bicsIGZ1bmN0aW9uIChldikge1xuICAgICAgICBpZiAoZXYud2hpY2ggPT09IDMyIHx8IGV2LmtleUNvZGUgPT0gMTMpIHtcbiAgICAgICAgICAvL3NwYWNlIG9yIGVudGVyIFxuICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBfdGhpcy5jb2xsYXBzZSgpO1xuICAgICAgICB9XG4gICAgICB9KS5hcHBlbmQoJGNvbGxhcHNpYmxlSWNvbik7XG4gICAgfVxuXG4gICAgZWxtLm1ic2NJbnN0ID0gdGhpcztcbiAgICB0aGlzLl8kaGVhZGVyID0gJGhlYWRlcjtcbiAgICB0aGlzLl8kY29udGVudCA9ICRjb250ZW50O1xuICAgIHRoaXMuXyRlbG0gPSAkZWxtO1xuICAgIHRoaXMuXyRhY2NvcmRpb25QYXJlbnQgPSAkZWxtLnBhcmVudCgnW21ic2MtYWNjb3JkaW9uXSwgbWJzYy1hY2NvcmRpb24sIC5tYnNjLWFjY29yZGlvbicpO1xuICAgIHRoaXMuc2hvdyA9IHRoaXMuc2hvdy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaGlkZSA9IHRoaXMuaGlkZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMudG9nZ2xlID0gdGhpcy50b2dnbGUuYmluZCh0aGlzKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDb2xsYXBzaWJsZUJhc2UucHJvdG90eXBlO1xuXG4gIF9wcm90by5jb2xsYXBzZSA9IGZ1bmN0aW9uIGNvbGxhcHNlKHNob3cpIHtcbiAgICB2YXIgJGVsbSA9IHRoaXMuXyRlbG07XG4gICAgdmFyICRjb250ZW50ID0gdGhpcy5fJGNvbnRlbnQ7XG5cbiAgICB2YXIgcmVtb3ZlSGVpZ2h0ID0gZnVuY3Rpb24gcmVtb3ZlSGVpZ2h0KCkge1xuICAgICAgJGNvbnRlbnQub2ZmKCd0cmFuc2l0aW9uZW5kJywgcmVtb3ZlSGVpZ2h0KS5jc3MoJ2hlaWdodCcsICcnKTtcbiAgICB9O1xuXG4gICAgaWYgKHNob3cgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc2hvdyA9ICF0aGlzLl9pc09wZW47XG4gICAgfVxuXG4gICAgaWYgKHNob3cgJiYgdGhpcy5faXNPcGVuIHx8ICFzaG93ICYmICF0aGlzLl9pc09wZW4gfHwgISRjb250ZW50Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzaG93KSB7XG4gICAgICBpZiAoaGFzVHJhbnNpdGlvbikge1xuICAgICAgICAkY29udGVudC5vbigndHJhbnNpdGlvbmVuZCcsIHJlbW92ZUhlaWdodCkuY3NzKCdoZWlnaHQnLCAkY29udGVudFswXS5zY3JvbGxIZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICAkZWxtLmFkZENsYXNzKCdtYnNjLWNvbGxhcHNpYmxlLW9wZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgJGNvbnRlbnQuY3NzKCdoZWlnaHQnLCBnZXRDb21wdXRlZFN0eWxlKCRjb250ZW50WzBdKS5oZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJGNvbnRlbnQuY3NzKCdoZWlnaHQnLCAwKTtcbiAgICAgICAgJGVsbS5yZW1vdmVDbGFzcygnbWJzYy1jb2xsYXBzaWJsZS1vcGVuJyk7XG4gICAgICB9LCA1MCk7XG4gICAgfVxuXG4gICAgaWYgKHNob3cgJiYgdGhpcy5fJGFjY29yZGlvblBhcmVudCkge1xuICAgICAgdGhpcy5fJGFjY29yZGlvblBhcmVudC5maW5kKCcubWJzYy1jb2xsYXBzaWJsZS1vcGVuJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzICE9PSAkZWxtWzBdKSB7XG4gICAgICAgICAgdGhpcy5tYnNjSW5zdC5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX2lzT3BlbiA9IHNob3c7XG5cbiAgICB0aGlzLl8kaGVhZGVyLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCB0aGlzLl9pc09wZW4pO1xuICB9O1xuXG4gIF9wcm90by5zaG93ID0gZnVuY3Rpb24gc2hvdygpIHtcbiAgICB0aGlzLmNvbGxhcHNlKHRydWUpO1xuICB9O1xuXG4gIF9wcm90by5oaWRlID0gZnVuY3Rpb24gaGlkZSgpIHtcbiAgICB0aGlzLmNvbGxhcHNlKGZhbHNlKTtcbiAgfTtcblxuICBfcHJvdG8udG9nZ2xlID0gZnVuY3Rpb24gdG9nZ2xlKCkge1xuICAgIHRoaXMuY29sbGFwc2UoKTtcbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fJGVsbS5yZW1vdmVDbGFzcygnbWJzYy1jb2xsYXBzaWJsZSBtYnNjLWNvbGxhcHNpYmxlLW9wZW4nKTtcblxuICAgIHRoaXMuXyRjb250ZW50LnJlbW92ZUNsYXNzKCdtYnNjLWNvbGxhcHNpYmxlLWNvbnRlbnQnKTtcblxuICAgIHRoaXMuXyRoZWFkZXIucmVtb3ZlQ2xhc3MoJ21ic2MtY29sbGFwc2libGUtaGVhZGVyJykuZmluZCgnLm1ic2MtY29sbGFwc2libGUtaWNvbicpLnJlbW92ZSgpO1xuICB9O1xuXG4gIHJldHVybiBDb2xsYXBzaWJsZUJhc2U7XG59KCk7XG5jbGFzc2VzLkNvbGxhcHNpYmxlQmFzZSA9IENvbGxhcHNpYmxlQmFzZTtcblxudmFyIGlkJDIgPSAwO1xuXG5mdW5jdGlvbiBpbml0Q29udHJvbHMoJGN0eCwgY29udHJvbHMsIHMsIHNoYWxsb3cpIHtcbiAgJCQxKCdpbnB1dCxzZWxlY3QsdGV4dGFyZWEscHJvZ3Jlc3MsYnV0dG9uJywgJGN0eCkuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRyb2wgPSB0aGlzLFxuICAgICAgICAkY29udHJvbCA9ICQkMShjb250cm9sKSxcbiAgICAgICAgLy8kcGFyZW50ID0gJGNvbnRyb2wucGFyZW50KCksXG4gICAgdHlwZSA9IGdldENvbnRyb2xUeXBlKCRjb250cm9sKTsgLy8gU2tpcCBlbGVtZW50cyB3aXRoIGRhdGEtZW5oYW5jZT1cImZhbHNlXCJcblxuICAgIGlmICgkY29udHJvbC5hdHRyKCdkYXRhLWVuaGFuY2UnKSAhPSAnZmFsc2UnXG4gICAgLyogVFJJQUxDT05EICovXG4gICAgKSB7XG4gICAgICAgIGlmICgkY29udHJvbC5oYXNDbGFzcygnbWJzYy1jb250cm9sJykpIHtcbiAgICAgICAgICBpZiAoY29udHJvbC5tYnNjSW5zdCkge1xuICAgICAgICAgICAgY29udHJvbC5tYnNjSW5zdC5vcHRpb24oe1xuICAgICAgICAgICAgICB0aGVtZTogcy50aGVtZSxcbiAgICAgICAgICAgICAgbGFuZzogcy5sYW5nLFxuICAgICAgICAgICAgICBydGw6IHMucnRsLFxuICAgICAgICAgICAgICBvblRleHQ6IHMub25UZXh0LFxuICAgICAgICAgICAgICBvZmZUZXh0OiBzLm9mZlRleHQsXG4gICAgICAgICAgICAgIHN0b3BQcm9wOiBzLnN0b3BQcm9wXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFjb250cm9sLmlkKSB7XG4gICAgICAgICAgICBjb250cm9sLmlkID0gJ21ic2MtZm9ybS1jb250cm9sLScgKyArK2lkJDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICAgICAgY2FzZSAnc3VibWl0JzpcbiAgICAgICAgICAgICAgY29udHJvbHNbY29udHJvbC5pZF0gPSBuZXcgQnV0dG9uKGNvbnRyb2wsIHtcbiAgICAgICAgICAgICAgICB0aGVtZTogcy50aGVtZSxcbiAgICAgICAgICAgICAgICBydGw6IHMucnRsLFxuICAgICAgICAgICAgICAgIHRhcDogcy50YXBcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdzd2l0Y2gnOlxuICAgICAgICAgICAgICBjb250cm9sc1tjb250cm9sLmlkXSA9IG5ldyBTd2l0Y2goY29udHJvbCwge1xuICAgICAgICAgICAgICAgIHRoZW1lOiBzLnRoZW1lLFxuICAgICAgICAgICAgICAgIGxhbmc6IHMubGFuZyxcbiAgICAgICAgICAgICAgICBydGw6IHMucnRsLFxuICAgICAgICAgICAgICAgIHRhcDogcy50YXAsXG4gICAgICAgICAgICAgICAgb25UZXh0OiBzLm9uVGV4dCxcbiAgICAgICAgICAgICAgICBvZmZUZXh0OiBzLm9mZlRleHQsXG4gICAgICAgICAgICAgICAgc3RvcFByb3A6IHMuc3RvcFByb3BcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdjaGVja2JveCc6XG4gICAgICAgICAgICAgIGNvbnRyb2xzW2NvbnRyb2wuaWRdID0gbmV3IENoZWNrQm94KGNvbnRyb2wsIHtcbiAgICAgICAgICAgICAgICB0YXA6IHMudGFwLFxuICAgICAgICAgICAgICAgIHRoZW1lOiBzLnRoZW1lLFxuICAgICAgICAgICAgICAgIHJ0bDogcy5ydGxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdyYW5nZSc6XG4gICAgICAgICAgICAgIGlmICghJCQxKGNvbnRyb2wpLnBhcmVudCgpLmhhc0NsYXNzKCdtYnNjLXNsaWRlcicpKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbHNbY29udHJvbC5pZF0gPSBuZXcgU2xpZGVyKGNvbnRyb2wsIHtcbiAgICAgICAgICAgICAgICAgIHRoZW1lOiBzLnRoZW1lLFxuICAgICAgICAgICAgICAgICAgbGFuZzogcy5sYW5nLFxuICAgICAgICAgICAgICAgICAgcnRsOiBzLnJ0bCxcbiAgICAgICAgICAgICAgICAgIHN0b3BQcm9wOiBzLnN0b3BQcm9wLFxuICAgICAgICAgICAgICAgICAgbGFiZWxTdHlsZTogcy5sYWJlbFN0eWxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAncmF0aW5nJzpcbiAgICAgICAgICAgICAgY29udHJvbHNbY29udHJvbC5pZF0gPSBuZXcgUmF0aW5nKGNvbnRyb2wsIHtcbiAgICAgICAgICAgICAgICB0aGVtZTogcy50aGVtZSxcbiAgICAgICAgICAgICAgICBsYW5nOiBzLmxhbmcsXG4gICAgICAgICAgICAgICAgcnRsOiBzLnJ0bCxcbiAgICAgICAgICAgICAgICBzdG9wUHJvcDogcy5zdG9wUHJvcFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3Byb2dyZXNzJzpcbiAgICAgICAgICAgICAgY29udHJvbHNbY29udHJvbC5pZF0gPSBuZXcgUHJvZ3Jlc3MoY29udHJvbCwge1xuICAgICAgICAgICAgICAgIHRoZW1lOiBzLnRoZW1lLFxuICAgICAgICAgICAgICAgIGxhbmc6IHMubGFuZyxcbiAgICAgICAgICAgICAgICBydGw6IHMucnRsLFxuICAgICAgICAgICAgICAgIGxhYmVsU3R5bGU6IHMubGFiZWxTdHlsZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3JhZGlvJzpcbiAgICAgICAgICAgICAgY29udHJvbHNbY29udHJvbC5pZF0gPSBuZXcgUmFkaW8oY29udHJvbCwge1xuICAgICAgICAgICAgICAgIHRhcDogcy50YXAsXG4gICAgICAgICAgICAgICAgdGhlbWU6IHMudGhlbWUsXG4gICAgICAgICAgICAgICAgcnRsOiBzLnJ0bFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgICAgICBjYXNlICdzZWxlY3Qtb25lJzpcbiAgICAgICAgICAgIGNhc2UgJ3NlbGVjdC1tdWx0aXBsZSc6XG4gICAgICAgICAgICAgIGNvbnRyb2xzW2NvbnRyb2wuaWRdID0gbmV3IFNlbGVjdChjb250cm9sLCB7XG4gICAgICAgICAgICAgICAgdGFwOiBzLnRhcCxcbiAgICAgICAgICAgICAgICBpbnB1dFN0eWxlOiBzLmlucHV0U3R5bGUsXG4gICAgICAgICAgICAgICAgbGFiZWxTdHlsZTogcy5sYWJlbFN0eWxlLFxuICAgICAgICAgICAgICAgIHRoZW1lOiBzLnRoZW1lLFxuICAgICAgICAgICAgICAgIHJ0bDogcy5ydGxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgICAgICAgIGNvbnRyb2xzW2NvbnRyb2wuaWRdID0gbmV3IFRleHRBcmVhKGNvbnRyb2wsIHtcbiAgICAgICAgICAgICAgICB0YXA6IHMudGFwLFxuICAgICAgICAgICAgICAgIGlucHV0U3R5bGU6IHMuaW5wdXRTdHlsZSxcbiAgICAgICAgICAgICAgICBsYWJlbFN0eWxlOiBzLmxhYmVsU3R5bGUsXG4gICAgICAgICAgICAgICAgdGhlbWU6IHMudGhlbWUsXG4gICAgICAgICAgICAgICAgcnRsOiBzLnJ0bFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3NlZ21lbnRlZCc6XG4gICAgICAgICAgICAgIGNvbnRyb2xzW2NvbnRyb2wuaWRdID0gbmV3IFNlZ21lbnRlZEl0ZW0oY29udHJvbCwge1xuICAgICAgICAgICAgICAgIHRoZW1lOiBzLnRoZW1lLFxuICAgICAgICAgICAgICAgIHJ0bDogcy5ydGwsXG4gICAgICAgICAgICAgICAgdGFwOiBzLnRhcCxcbiAgICAgICAgICAgICAgICBpbnB1dFN0eWxlOiBzLmlucHV0U3R5bGVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdzdGVwcGVyJzpcbiAgICAgICAgICAgICAgY29udHJvbHNbY29udHJvbC5pZF0gPSBuZXcgU3RlcHBlcihjb250cm9sLCB7XG4gICAgICAgICAgICAgICAgdGhlbWU6IHMudGhlbWUsXG4gICAgICAgICAgICAgICAgcnRsOiBzLnJ0bFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2hpZGRlbic6XG4gICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY29udHJvbHNbY29udHJvbC5pZF0gPSBuZXcgSW5wdXQoY29udHJvbCwge1xuICAgICAgICAgICAgICAgIHRhcDogcy50YXAsXG4gICAgICAgICAgICAgICAgaW5wdXRTdHlsZTogcy5pbnB1dFN0eWxlLFxuICAgICAgICAgICAgICAgIGxhYmVsU3R5bGU6IHMubGFiZWxTdHlsZSxcbiAgICAgICAgICAgICAgICB0aGVtZTogcy50aGVtZSxcbiAgICAgICAgICAgICAgICBydGw6IHMucnRsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfSk7XG4gICQkMSgnW2RhdGEtY29sbGFwc2libGVdOm5vdCgubWJzYy1jb2xsYXBzaWJsZSknLCAkY3R4KS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udHJvbCA9IHRoaXMsXG4gICAgICAgICRjb250cm9sID0gJCQxKGNvbnRyb2wpLFxuICAgICAgICBpc09wZW4gPSAkY29udHJvbC5hdHRyKCdkYXRhLW9wZW4nKTtcblxuICAgIGlmICghY29udHJvbC5pZCkge1xuICAgICAgY29udHJvbC5pZCA9ICdtYnNjLWZvcm0tY29udHJvbC0nICsgKytpZCQyO1xuICAgIH1cblxuICAgIGNvbnRyb2xzW2NvbnRyb2wuaWRdID0gbmV3IENvbGxhcHNpYmxlQmFzZShjb250cm9sLCB7XG4gICAgICBpc09wZW46IGlzT3BlbiAhPT0gdW5kZWZpbmVkICYmIGlzT3BlbiAhPSAnZmFsc2UnXG4gICAgfSk7XG4gICAgaW5zdGFuY2VzW2NvbnRyb2wuaWRdID0gY29udHJvbHNbY29udHJvbC5pZF07XG4gIH0pOyAvLyBTZXQgaW5pdGlhbCBoZWlnaHQgZm9yIHRleHRhcmVhc1xuXG4gIGlmICghc2hhbGxvdykge1xuICAgIHNpemVUZXh0QXJlYXMoKTtcbiAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbnZhciBoYWxmQm9yZGVyJDEgPSBvcyA9PSAnaW9zJyAmJiBtYWpvclZlcnNpb24gPiA3O1xudmFyIENhcmQgPSBmdW5jdGlvbiBDYXJkKGVsLCBzZXR0aW5ncykge1xuICB2YXIgcyxcbiAgICAgIGNvbGxhcHNpYmxlSW5zdCxcbiAgICAgIGNzc0NsYXNzID0gJycsXG4gICAgICAkZWxtID0gJCQxKGVsKSxcbiAgICAgIGNvbnRyb2xzID0ge30sXG4gICAgICB0aGF0ID0gdGhpcztcblxuICBmdW5jdGlvbiB0b3VjaGVkKCkge1xuICAgICRlbG0ucmVtb3ZlQ2xhc3MoJ21ic2Mtbm8tdG91Y2gnKTtcbiAgfSAvLyBDYWxsIHRoZSBwYXJlbnQgY29uc3RydWN0b3JcblxuXG4gIEJhc2UuY2FsbCh0aGlzLCBlbCwgc2V0dGluZ3MsIHRydWUpO1xuXG4gIHRoYXQucmVmcmVzaCA9IGZ1bmN0aW9uIChzaGFsbG93KSB7XG4gICAgaW5pdENvbnRyb2xzKCRlbG0sIGNvbnRyb2xzLCBzLCBzaGFsbG93KTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQ2FyZCBpbml0aWFsaXphdGlvbi5cclxuICAgKi9cblxuXG4gIHRoYXQuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlzQ29sbGFwc2libGUgPSBzLmNvbGxhcHNpYmxlICE9PSB1bmRlZmluZWQgfHwgJGVsbS5hdHRyKCdkYXRhLWNvbGxhcHNpYmxlJykgIT09IHVuZGVmaW5lZDtcblxuICAgIGlmICghJGVsbS5oYXNDbGFzcygnbWJzYy1jYXJkJykpIHtcbiAgICAgICRlbG0uc2hvdygpO1xuICAgICAgbGlzdGVuKGVsLCAndG91Y2hzdGFydCcsIHRvdWNoZWQsIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGNzc0NsYXNzKSB7XG4gICAgICAkZWxtLnJlbW92ZUNsYXNzKGNzc0NsYXNzKTtcbiAgICB9IC8vIC0tLSBUUklBTCBTRVJWRVIgQ09ERSBTVEFSVCAtLS1cblxuXG4gICAgY3NzQ2xhc3MgPSAnbWJzYy1jYXJkIG1ic2MtZm9ybSBtYnNjLW5vLXRvdWNoIG1ic2MtJyArIHMudGhlbWUgKyAoaGFsZkJvcmRlciQxID8gJyBtYnNjLWZvcm0taGInIDogJycpICsgKHMuYmFzZVRoZW1lID8gJyBtYnNjLScgKyBzLmJhc2VUaGVtZSA6ICcnKSArIChzLnJ0bCA/ICcgbWJzYy1ydGwnIDogJyBtYnNjLWx0cicpOyAvLyAtLS0gVFJJQUwgU0VSVkVSIENPREUgRU5EIC0tLVxuXG4gICAgJGVsbS5hZGRDbGFzcyhjc3NDbGFzcykucmVtb3ZlQ2xhc3MoJ21ic2MtY2xvYWsnKTtcblxuICAgIGlmIChpc0NvbGxhcHNpYmxlICYmICFjb2xsYXBzaWJsZUluc3QpIHtcbiAgICAgIHZhciBpc09wZW4gPSAkZWxtLmF0dHIoJ2RhdGEtb3BlbicpO1xuICAgICAgY29sbGFwc2libGVJbnN0ID0gbmV3IENvbGxhcHNpYmxlQmFzZShlbCwge1xuICAgICAgICBpc09wZW46IGlzT3BlbiAhPT0gdW5kZWZpbmVkICYmIGlzT3BlbiAhPSAnZmFsc2UnIHx8IHMuY29sbGFwc2libGUgPT09IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKiBUUklBTCAqL1xuXG5cbiAgICB0aGF0LnJlZnJlc2goKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogRGVzdHJveXMgdGhlIG1vYmlzY3JvbGwgaW5zdGFuY2UuXHJcbiAgICovXG5cblxuICB0aGF0Ll9kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICRlbG0ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3MpO1xuICAgIHVubGlzdGVuKGVsLCAndG91Y2hzdGFydCcsIHRvdWNoZWQsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcblxuICAgIGZvciAodmFyIGlkIGluIGNvbnRyb2xzKSB7XG4gICAgICBjb250cm9sc1tpZF0uZGVzdHJveSgpO1xuICAgIH1cblxuICAgIGlmIChjb2xsYXBzaWJsZUluc3QpIHtcbiAgICAgIGNvbGxhcHNpYmxlSW5zdC5kZXN0cm95KCk7XG4gICAgfVxuICB9O1xuXG4gIHRoYXQudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjb2xsYXBzaWJsZUluc3QpIHtcbiAgICAgIGNvbGxhcHNpYmxlSW5zdC50b2dnbGUoKTtcbiAgICB9XG4gIH07XG5cbiAgdGhhdC5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjb2xsYXBzaWJsZUluc3QpIHtcbiAgICAgIGNvbGxhcHNpYmxlSW5zdC5oaWRlKCk7XG4gICAgfVxuICB9O1xuXG4gIHRoYXQuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY29sbGFwc2libGVJbnN0KSB7XG4gICAgICBjb2xsYXBzaWJsZUluc3Quc2hvdygpO1xuICAgIH1cbiAgfTsgLy8gQ29uc3RydWN0b3JcblxuXG4gIHMgPSB0aGF0LnNldHRpbmdzO1xuICB0aGF0LmluaXQoKTtcbn07IC8vIEV4dGVuZCBkZWZhdWx0c1xuXG5DYXJkLnByb3RvdHlwZSA9IHtcbiAgX2hhc0RlZjogdHJ1ZSxcbiAgX2hhc1RoZW1lOiB0cnVlLFxuICBfaGFzTGFuZzogdHJ1ZSxcbiAgX2NsYXNzOiAnY2FyZCcsXG4gIF9kZWZhdWx0czoge1xuICAgIHRhcDogaGFzR2hvc3RDbGljayxcbiAgICBzdG9wUHJvcDogdHJ1ZSxcbiAgICBydGw6IGZhbHNlXG4gIH1cbn07XG5jbGFzc2VzLkNhcmQgPSBDYXJkOyAvLyBJbml0IG1ic2MtY2FyZCBlbGVtZW50cyBvbiBwYWdlIGxvYWQgb3Igd2hlbiBtYnNjLWVuaGFuY2UgZXZlbnQgaXMgdHJpZ2dlcmVzXG5cbmF1dG9Jbml0KCdbbWJzYy1jYXJkXScsIENhcmQsIHRydWUpO1xuXG52YXIgU0VMRUNURURfQ0xBU1MgPSAnbWJzYy1zZWxlY3RlZCc7XG52YXIgQUNUSVZFX0NMQVNTID0gJ21ic2MtbHYtaXRlbS1hY3RpdmUnO1xudmFyIGNvbmZpcm1zLFxuICAgIGhhbGZCb3JkZXIkMiA9IG9zID09ICdpb3MnICYmIG1ham9yVmVyc2lvbiA+IDcsXG4gICAgZ3VpZCA9IDEsXG4gICAgdHJhbnNwID0gJ3RyYW5zcGFyZW50JztcbnZhciBMaXN0VmlldyA9IGZ1bmN0aW9uIExpc3RWaWV3KGVsZW0sIHNldHRpbmdzKSB7XG4gIHZhciBhY3Rpb24sXG4gICAgICBhY3Rpb25XaWR0aCxcbiAgICAgIGFjdGl2ZVRpbWVyLFxuICAgICAgYW5pbVBvcyxcbiAgICAgIGNhbmNlbCxcbiAgICAgIGNvbmZpcm1JdGVtLFxuICAgICAgY29uZmlybUluZGV4LFxuICAgICAgY29udCxcbiAgICAgIGNvbnQwLFxuICAgICAgY3VyckluZGV4LFxuICAgICAgY3Vyckxpc3QsXG4gICAgICBjdXJyUGgsXG4gICAgICBjdXJyUGFyZW50LFxuICAgICAgY3VyclNpYmxpbmdzLFxuICAgICAgY3VyclN0YWdlLFxuICAgICAgY3VyclN0YWdlSWR4LFxuICAgICAgZGVib3VuY2UsXG4gICAgICBkZW1vTW9kZSxcbiAgICAgIGRpc2FibGVkLFxuICAgICAgZGlmZlgsXG4gICAgICBkaWZmWSxcbiAgICAgIGRyb3BEb3duLFxuICAgICAgZHJvcFVwLFxuICAgICAgZHJhZ2dlZCxcbiAgICAgIGR1bW15Q29udCxcbiAgICAgIGVuZFRpbWVyLFxuICAgICAgZW5kWCxcbiAgICAgIGVuZFksXG4gICAgICBldmVudCxcbiAgICAgIGZpbGwsXG4gICAgICBmb3VuZCxcbiAgICAgIGdyb3VwSGVhZGVyLFxuICAgICAgaGFkRW5oYW5jZSxcbiAgICAgIGhhbmRsZVBvcyxcbiAgICAgIGhhc0NvbnRleHQsXG4gICAgICBoYW5kbGVEaXYsXG4gICAgICBob3ZlckRpcixcbiAgICAgIGhvdmVySXRlbSxcbiAgICAgIGhvdmVySXRlbU9wZW5lZCxcbiAgICAgIGhvdmVyVGltZSxcbiAgICAgIGhvdmVyVGltZW91dCxcbiAgICAgIGhvdmVyVGltZXIsXG4gICAgICBodG1sTGVmdCxcbiAgICAgIGh0bWxSaWdodCxcbiAgICAgIGljb24sXG4gICAgICBpY29uYyxcbiAgICAgIHN0YWdlYyxcbiAgICAgIGlzQ2xpY2ssXG4gICAgICBpc0xvYWRpbmcsXG4gICAgICBpc1RvdWNoLFxuICAgICAgaXRlbXcsXG4gICAgICBpdGVtLFxuICAgICAgaXRlbUhlaWdodCxcbiAgICAgIGl0ZW1JbmRleCxcbiAgICAgIGl0ZW1Ob2RlLFxuICAgICAgaXRlbVNlbGVjdG9yLFxuICAgICAgaXRlbVRvcCxcbiAgICAgIGxpc3ROb2RlLFxuICAgICAgbGlzdFNlbGVjdG9yLFxuICAgICAgbG9hZGluZyxcbiAgICAgIG1heERyYWcsXG4gICAgICBtaW5EcmFnLFxuICAgICAgbXVsdGljLFxuICAgICAgbXVsdGlwbGUsXG4gICAgICBuZXh0SXRlbSxcbiAgICAgIG5leHRPZmZzZXQsXG4gICAgICBuZXh0U3RhZ2UsXG4gICAgICBuZXh0SXRlbXMsXG4gICAgICBvblNjcm9sbFRocm90dGxlLFxuICAgICAgb25TY3JvbGxEZWJvdW5jZSxcbiAgICAgIHByZXZDbGljayxcbiAgICAgIHByZXZlbnRIb3ZlcixcbiAgICAgIHByZXZlbnRUaW1lcixcbiAgICAgIHByZXZJdGVtcyxcbiAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgcHJldkl0ZW0sXG4gICAgICBwcmV2T2Zmc2V0LFxuICAgICAgcHJldlN0YWdlLFxuICAgICAgcXVpY2tTd2lwZSxcbiAgICAgIHJhZklELFxuICAgICAgcmFmUnVubmluZyxcbiAgICAgIHMsXG4gICAgICBzY3JvbGwsXG4gICAgICBzZWxlY3RhYmxlLFxuICAgICAgc2ltdWxhdGluZyxcbiAgICAgIHNsaWRlQ29udCxcbiAgICAgIHN0YWdlTnIsXG4gICAgICBzdGFnZXMsXG4gICAgICBzdGFydFBvcyxcbiAgICAgIHN0YXJ0VGltZSxcbiAgICAgIHN0YXJ0WCxcbiAgICAgIHN0YXJ0WSxcbiAgICAgIHN0eWxlLFxuICAgICAgc3dpcGUsXG4gICAgICBzd2lwZUludGVydmFsLFxuICAgICAgc3dpcGVUaW1lb3V0LFxuICAgICAgdGFwSGlnaGxpZ2h0LFxuICAgICAgdGV4dCxcbiAgICAgIHRpbWVyLFxuICAgICAgdHlwZSxcbiAgICAgIHR5cGVzLFxuICAgICAgdW5kb1JlZixcbiAgICAgIHVuZG9BbmltLFxuICAgICAgd25kLFxuICAgICAgd25kMCxcbiAgICAgIHduZEhlaWdodCxcbiAgICAgIHduZFNjcm9sbCxcbiAgICAgIHduZFRvcCxcbiAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgZSA9IGVsZW0sXG4gICAgICBlbG0gPSAkJDEoZSksXG4gICAgICB0cmFuc2l0aW9uID0gMCxcbiAgICAgIHNsaWRlTGV2ZWwgPSAwLFxuICAgICAgc3RhcnRUb3AgPSAwLFxuICAgICAgc3RhZ2VPYmogPSB7fSxcbiAgICAgIGFjdGlvblF1ZXVlID0ge30sXG4gICAgICB0cmVlTWFwID0ge307XG5cbiAgZnVuY3Rpb24gb25BY3Rpb25TdGFydCgpIHtcbiAgICBxdWlja1N3aXBlID0gZmFsc2U7XG4gICAgcHJldkNsaWNrID0gZmFsc2U7XG4gICAgYW5pbVBvcyA9IDA7XG4gICAgc3RhcnRQb3MgPSAwO1xuICAgIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG4gICAgaXRlbXcgPSBjdXJyTGlzdC53aWR0aCgpO1xuICAgIGN1cnJTaWJsaW5ncyA9IGdldENoaWxkcmVuKGN1cnJMaXN0KTtcbiAgICBpdGVtSW5kZXggPSBjdXJyU2libGluZ3MuaW5kZXgoaXRlbSk7XG4gICAgaXRlbUhlaWdodCA9IGl0ZW1bMF0ub2Zmc2V0SGVpZ2h0O1xuICAgIHN0YXJ0VG9wID0gaXRlbVswXS5vZmZzZXRUb3A7XG4gICAgdHlwZSA9IHR5cGVzW2l0ZW0uYXR0cignZGF0YS10eXBlJykgfHwgJ2RlZmF1bHRzJ107XG4gICAgc3RhZ2VzID0gdHlwZS5zdGFnZXM7XG4gIH1cblxuICBmdW5jdGlvbiBvblN0YXJ0KGV2KSB7XG4gICAgdmFyIGl0bTtcbiAgICB2YXIgdGFyZ2V0ID0gY2xvc2VzdChjb250MCwgZXYudGFyZ2V0LCAnLm1ic2MtbHYtaXRlbScpO1xuXG4gICAgaWYgKCF0YXJnZXQgfHwgIWNvbnQwLmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXYudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICBjb250LnJlbW92ZUNsYXNzKCdtYnNjLW5vLXRvdWNoJyk7XG4gICAgICBwcmV2ZW50SG92ZXIgPSB0cnVlO1xuICAgICAgY2xlYXJUaW1lb3V0KHByZXZlbnRUaW1lcik7XG4gICAgfVxuXG4gICAgaWYgKHRlc3RUb3VjaChldiwgdGFyZ2V0KSAmJiAhYWN0aW9uICYmICF0cmFuc2l0aW9uICYmICFjb25maXJtcyAmJiAhdW5kb2luZ1xuICAgIC8qIFRSSUFMQ09ORCAqL1xuICAgICkge1xuICAgICAgICBhY3Rpb24gPSB0cnVlO1xuICAgICAgICBjYW5jZWwgPSB0cnVlO1xuICAgICAgICBpc0NsaWNrID0gZmFsc2U7XG4gICAgICAgIGlzVG91Y2ggPSBldi50eXBlID09PSAndG91Y2hzdGFydCc7XG4gICAgICAgIHN0YXJ0WCA9IGdldENvb3JkKGV2LCAnWCcpO1xuICAgICAgICBzdGFydFkgPSBnZXRDb29yZChldiwgJ1knKTtcbiAgICAgICAgZGlmZlggPSAwO1xuICAgICAgICBkaWZmWSA9IDA7XG4gICAgICAgIGl0ZW0gPSAkJDEodGFyZ2V0KTtcbiAgICAgICAgaXRtID0gaXRlbTsgLy8gTG9jYWwgcmVmZXJlbmNlXG5cbiAgICAgICAgb25BY3Rpb25TdGFydCgpO1xuICAgICAgICB0YXBIaWdobGlnaHQgPSB0eXBlLmFjdGlvbmFibGUgfHwgaXRlbS5oYXNDbGFzcygnbWJzYy1sdi1wYXJlbnQnKSB8fCBpdGVtLmhhc0NsYXNzKCdtYnNjLWx2LWJhY2snKTtcbiAgICAgICAgaXRlbVRvcCA9IGl0ZW0ub2Zmc2V0KCkudG9wO1xuXG4gICAgICAgIGlmICh0YXBIaWdobGlnaHQpIHtcbiAgICAgICAgICBhY3RpdmVUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaXRtLmFkZENsYXNzKGlzVG91Y2ggPyBBQ1RJVkVfQ0xBU1MgOiAnJyk7XG4gICAgICAgICAgICBldmVudCgnb25JdGVtQWN0aXZhdGUnLCB7XG4gICAgICAgICAgICAgIHRhcmdldDogaXRtWzBdLFxuICAgICAgICAgICAgICBkb21FdmVudDogZXZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIDEyMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhhdC5zb3J0YWJsZSAmJiAhaXRlbS5oYXNDbGFzcygnbWJzYy1sdi1iYWNrJykpIHtcbiAgICAgICAgICBpZiAoIXRoYXQuc29ydGFibGUuZ3JvdXApIHtcbiAgICAgICAgICAgIG5leHRJdGVtcyA9IGl0ZW0ubmV4dFVudGlsKCcubWJzYy1sdi1nci10aXRsZScpLmZpbHRlcignLm1ic2MtbHYtaXRlbScpO1xuICAgICAgICAgICAgcHJldkl0ZW1zID0gaXRlbS5wcmV2VW50aWwoJy5tYnNjLWx2LWdyLXRpdGxlJykuZmlsdGVyKCcubWJzYy1sdi1pdGVtJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbWluRHJhZyA9ICghdGhhdC5zb3J0YWJsZS5ncm91cCA/IHByZXZJdGVtcy5sZW5ndGggPyBwcmV2SXRlbXMuZXEoLTEpIDogaXRlbSA6IGN1cnJMaXN0LmNoaWxkcmVuKGl0ZW1TZWxlY3RvcikuZXEoMCkpWzBdLm9mZnNldFRvcCAtIHN0YXJ0VG9wO1xuICAgICAgICAgIG1heERyYWcgPSAoIXRoYXQuc29ydGFibGUuZ3JvdXAgPyBuZXh0SXRlbXMubGVuZ3RoID8gbmV4dEl0ZW1zLmVxKC0xKSA6IGl0ZW0gOiBjdXJyTGlzdC5jaGlsZHJlbihpdGVtU2VsZWN0b3IpLmVxKC0xKSlbMF0ub2Zmc2V0VG9wIC0gc3RhcnRUb3A7XG5cbiAgICAgICAgICBpZiAodGhhdC5zb3J0YWJsZS5oYW5kbGUpIHtcbiAgICAgICAgICAgIGlmICgkJDEoZXYudGFyZ2V0KS5oYXNDbGFzcygnbWJzYy1sdi1oYW5kbGUnKSkge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoYWN0aXZlVGltZXIpO1xuXG4gICAgICAgICAgICAgIGlmIChqc1ByZWZpeCA9PT0gJ01veicpIHtcbiAgICAgICAgICAgICAgICAvLyBPbiBGRiB3ZSBuZWVkIHRvIHByZXZlbnQgdG91Y2hzdGFydCB0byBkaXNhYmxlIHNjcm9sbFxuICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgb25Tb3J0U3RhcnQoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgb25Tb3J0U3RhcnQoKTtcbiAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGZpbGwuYXBwZW5kVG8oaXRlbSk7XG4gICAgICAgICAgICAgIGZpbGxbMF0uc3R5bGVbanNQcmVmaXggKyAnQW5pbWF0aW9uJ10gPSAnbWJzYy1sdi1maWxsICcgKyAocy5zb3J0RGVsYXkgLSAxMDApICsgJ21zIGxpbmVhcic7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dChlbmRUaW1lcik7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dChhY3RpdmVUaW1lcik7XG4gICAgICAgICAgICAgIGNhbmNlbCA9IGZhbHNlO1xuICAgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGZpbGxbMF0uc3R5bGVbanNQcmVmaXggKyAnQW5pbWF0aW9uJ10gPSAnJztcbiAgICAgICAgICAgICAgICBvblNvcnRTdGFydCgpO1xuICAgICAgICAgICAgICB9LCBzLnNvcnREZWxheSAtIDgwKTtcbiAgICAgICAgICAgIH0sIDgwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXYudHlwZSA9PSAnbW91c2Vkb3duJykge1xuICAgICAgICAgICQkMShkb2N1bWVudCkub24oJ21vdXNlbW92ZScsIG9uTW92ZSkub24oJ21vdXNldXAnLCBvbkVuZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uTW92ZShldikge1xuICAgIHZhciBzb3J0Q2hhbmdlID0gZmFsc2UsXG4gICAgICAgIGRyb3BDaGFuZ2UgPSB0cnVlLFxuICAgICAgICBwcmV2UG9zID0gYW5pbVBvcztcblxuICAgIGlmIChhY3Rpb24pIHtcbiAgICAgIGVuZFggPSBnZXRDb29yZChldiwgJ1gnKTtcbiAgICAgIGVuZFkgPSBnZXRDb29yZChldiwgJ1knKTtcbiAgICAgIGRpZmZYID0gZW5kWCAtIHN0YXJ0WDtcbiAgICAgIGRpZmZZID0gZW5kWSAtIHN0YXJ0WTtcbiAgICAgIGNsZWFyVGltZW91dChlbmRUaW1lcik7XG5cbiAgICAgIGlmICghZHJhZ2dlZCAmJiAhc3dpcGUgJiYgIXNjcm9sbCAmJiAhaXRlbS5oYXNDbGFzcygnbWJzYy1sdi1iYWNrJykpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKGRpZmZZKSA+IDEwKSB7XG4gICAgICAgICAgLy8gSXQncyBhIHNjcm9sbFxuICAgICAgICAgIHNjcm9sbCA9IHRydWU7XG4gICAgICAgICAgb25FbmQoZXh0ZW5kJDEoe30sIGV2LCB7XG4gICAgICAgICAgICB0eXBlOiBldi50eXBlID09ICdtb3VzZW1vdmUnID8gJ21vdXNldXAnIDogJ3RvdWNoZW5kJ1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoYWN0aXZlVGltZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGRpZmZYKSA+IDcpIHtcbiAgICAgICAgICAvLyBJdCdzIGEgc3dpcGVcbiAgICAgICAgICBvblN3aXBlU3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3dpcGUpIHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYW5pbVBvcyA9IGRpZmZYIC8gaXRlbXcgKiAxMDA7XG4gICAgICAgIG9uU3dpcGVNb3ZlKHByZXZQb3MpO1xuICAgICAgfSBlbHNlIGlmIChkcmFnZ2VkKSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBzY3JvbGxlZCxcbiAgICAgICAgICAgIHN0ID0gd25kLnNjcm9sbFRvcCgpLFxuICAgICAgICAgICAgZGlmZiA9IE1hdGgubWF4KG1pbkRyYWcsIE1hdGgubWluKGRpZmZZICsgd25kU2Nyb2xsLCBtYXhEcmFnKSksXG4gICAgICAgICAgICB0b3AgPSBoYXNDb250ZXh0ID8gaXRlbVRvcCAtIHduZFRvcCArIHN0IC0gd25kU2Nyb2xsIDogaXRlbVRvcDsgLy8gQ2hlY2sgaWYgc2Nyb2xsIGlzIG5lZWRlZFxuXG4gICAgICAgIGlmICh3bmRIZWlnaHQgKyBzdCA8IHRvcCArIGRpZmYgKyBpdGVtSGVpZ2h0KSB7XG4gICAgICAgICAgd25kLnNjcm9sbFRvcCh0b3AgKyBkaWZmIC0gd25kSGVpZ2h0ICsgaXRlbUhlaWdodCk7XG4gICAgICAgICAgc2Nyb2xsZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHRvcCArIGRpZmYgPCBzdCkge1xuICAgICAgICAgIHduZC5zY3JvbGxUb3AodG9wICsgZGlmZik7XG4gICAgICAgICAgc2Nyb2xsZWQgPSB0cnVlO1xuICAgICAgICB9IC8vIFVwZGF0ZSBzY3JvbGwgdmFsdWVzIGlmIHdpbmRvdyB3YXMgc2Nyb2xsZWRcblxuXG4gICAgICAgIGlmIChzY3JvbGxlZCkge1xuICAgICAgICAgIHduZFNjcm9sbCArPSB3bmQuc2Nyb2xsVG9wKCkgLSBzdDtcbiAgICAgICAgfSAvLyBDaGVjayBvdmVybGFwIHdpdGggbmV4dCBpdGVtXG5cblxuICAgICAgICBpZiAobmV4dE9mZnNldCkge1xuICAgICAgICAgIC8vIElmIHN1YnRyZWUgZXhpc3RzLCBkcm9wIGVsZW1lbnQgb24gc3VidHJlZSBhdCAxLzQsIGNoYW5nZSBzb3J0IG9yZGVyIGF0IDMvNCBvdmVybGFwXG4gICAgICAgICAgaWYgKHRoYXQuc29ydGFibGUubXVsdGlMZXZlbCAmJiBuZXh0SXRlbS5oYXNDbGFzcygnbWJzYy1sdi1wYXJlbnQnKSkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0VG9wICsgaXRlbUhlaWdodCAvIDQgKyBkaWZmID4gbmV4dE9mZnNldCkge1xuICAgICAgICAgICAgICBzb3J0Q2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnRUb3AgKyBpdGVtSGVpZ2h0IC0gaXRlbUhlaWdodCAvIDQgKyBkaWZmID4gbmV4dE9mZnNldCkge1xuICAgICAgICAgICAgICBkcm9wRG93biA9IG5leHRJdGVtLmFkZENsYXNzKCdtYnNjLWx2LWl0ZW0taGwnKTtcbiAgICAgICAgICAgICAgZHJvcENoYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgfSAvLyBDaGVjayAxLzIgb3ZlcmxhcFxuXG4gICAgICAgICAgfSBlbHNlIGlmIChzdGFydFRvcCArIGl0ZW1IZWlnaHQgLyAyICsgZGlmZiA+IG5leHRPZmZzZXQpIHtcbiAgICAgICAgICAgIC8vIElmIG92ZXIgYmFjayBidXR0b24sIGhpZ2hsaWdodCB0byBkcm9wIHRvIHBhcmVudCBsZXZlbFxuICAgICAgICAgICAgaWYgKG5leHRJdGVtLmhhc0NsYXNzKCdtYnNjLWx2LWJhY2snKSkge1xuICAgICAgICAgICAgICBpZiAodGhhdC5zb3J0YWJsZS5tdWx0aUxldmVsKSB7XG4gICAgICAgICAgICAgICAgZHJvcFVwID0gbmV4dEl0ZW0uYWRkQ2xhc3MoJ21ic2MtbHYtaXRlbS1obCcpO1xuICAgICAgICAgICAgICAgIGRyb3BDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc29ydENoYW5nZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNvcnRDaGFuZ2UpIHtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLmluc2VydEFmdGVyKG5leHRJdGVtKTtcbiAgICAgICAgICAgIHByZXZJdGVtID0gbmV4dEl0ZW07XG4gICAgICAgICAgICBuZXh0SXRlbSA9IGdldE5leHRQcmV2KG5leHRJdGVtLCAnbmV4dCcpO1xuICAgICAgICAgICAgcHJldk9mZnNldCA9IG5leHRPZmZzZXQ7XG4gICAgICAgICAgICBuZXh0T2Zmc2V0ID0gbmV4dEl0ZW0ubGVuZ3RoICYmIG5leHRJdGVtWzBdLm9mZnNldFRvcDtcbiAgICAgICAgICAgIGN1cnJJbmRleCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBDaGVjayBvdmVybGFwIHdpdGggcHJldiBpdGVtXG5cblxuICAgICAgICBpZiAoIXNvcnRDaGFuZ2UgJiYgcHJldk9mZnNldCkge1xuICAgICAgICAgIC8vIElmIHN1YnRyZWUgZXhpc3RzLCBkcm9wIGVsZW1lbnQgb24gc3VidHJlZSBhdCAxLzMsIGNoYW5nZSBzb3J0IG9yZGVyIGF0IDIvMyBvdmVybGFwXG4gICAgICAgICAgaWYgKHRoYXQuc29ydGFibGUubXVsdGlMZXZlbCAmJiBwcmV2SXRlbS5oYXNDbGFzcygnbWJzYy1sdi1wYXJlbnQnKSkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0VG9wICsgaXRlbUhlaWdodCAtIGl0ZW1IZWlnaHQgLyA0ICsgZGlmZiA8IHByZXZPZmZzZXQpIHtcbiAgICAgICAgICAgICAgc29ydENoYW5nZSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0VG9wICsgaXRlbUhlaWdodCAvIDQgKyBkaWZmIDwgcHJldk9mZnNldCkge1xuICAgICAgICAgICAgICBkcm9wRG93biA9IHByZXZJdGVtLmFkZENsYXNzKCdtYnNjLWx2LWl0ZW0taGwnKTtcbiAgICAgICAgICAgICAgZHJvcENoYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgfSAvLyBDaGVjayAxLzIgb3ZlcmxhcFxuXG4gICAgICAgICAgfSBlbHNlIGlmIChzdGFydFRvcCArIGl0ZW1IZWlnaHQgLyAyICsgZGlmZiA8IHByZXZPZmZzZXQpIHtcbiAgICAgICAgICAgIC8vIElmIG92ZXIgYmFjayBidXR0b24sIGhpZ2hsaWdodCB0byBkcm9wIHRvIHBhcmVudCBsZXZlbFxuICAgICAgICAgICAgaWYgKHByZXZJdGVtLmhhc0NsYXNzKCdtYnNjLWx2LWJhY2snKSkge1xuICAgICAgICAgICAgICBpZiAodGhhdC5zb3J0YWJsZS5tdWx0aUxldmVsKSB7XG4gICAgICAgICAgICAgICAgZHJvcFVwID0gcHJldkl0ZW0uYWRkQ2xhc3MoJ21ic2MtbHYtaXRlbS1obCcpO1xuICAgICAgICAgICAgICAgIGRyb3BDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc29ydENoYW5nZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNvcnRDaGFuZ2UpIHtcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLmluc2VydEJlZm9yZShwcmV2SXRlbSk7XG4gICAgICAgICAgICBuZXh0SXRlbSA9IHByZXZJdGVtO1xuICAgICAgICAgICAgcHJldkl0ZW0gPSBnZXROZXh0UHJldihwcmV2SXRlbSwgJ3ByZXYnKTtcbiAgICAgICAgICAgIG5leHRPZmZzZXQgPSBwcmV2T2Zmc2V0O1xuICAgICAgICAgICAgcHJldk9mZnNldCA9IHByZXZJdGVtLmxlbmd0aCAmJiBwcmV2SXRlbVswXS5vZmZzZXRUb3AgKyBwcmV2SXRlbVswXS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICBjdXJySW5kZXgtLTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHJvcENoYW5nZSkge1xuICAgICAgICAgIGlmIChkcm9wRG93bikge1xuICAgICAgICAgICAgZHJvcERvd24ucmVtb3ZlQ2xhc3MoJ21ic2MtbHYtaXRlbS1obCcpO1xuICAgICAgICAgICAgZHJvcERvd24gPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZHJvcFVwKSB7XG4gICAgICAgICAgICBkcm9wVXAucmVtb3ZlQ2xhc3MoJ21ic2MtbHYtaXRlbS1obCcpO1xuICAgICAgICAgICAgZHJvcFVwID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNvcnRDaGFuZ2UpIHtcbiAgICAgICAgICBldmVudCgnb25Tb3J0Q2hhbmdlJywge1xuICAgICAgICAgICAgdGFyZ2V0OiBpdGVtWzBdLFxuICAgICAgICAgICAgaW5kZXg6IGN1cnJJbmRleFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZHJhZyhpdGVtLCBkaWZmKTtcbiAgICAgICAgZXZlbnQoJ29uU29ydCcsIHtcbiAgICAgICAgICB0YXJnZXQ6IGl0ZW1bMF0sXG4gICAgICAgICAgaW5kZXg6IGN1cnJJbmRleFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoZGlmZlgpID4gNSB8fCBNYXRoLmFicyhkaWZmWSkgPiA1KSB7XG4gICAgICAgIC8vIENhbmNlbCBkcmFnc3RhcnQgaWYgbW92ZW1lbnQgaXMgPiA1cHhcbiAgICAgICAgc3RvcFRpbWVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25FbmQoZXYpIHtcbiAgICB2YXIgZGlzdCxcbiAgICAgICAgbWFwLFxuICAgICAgICBwYXJlbnQsXG4gICAgICAgIGl0bSA9IGl0ZW07XG5cbiAgICBpZiAoYWN0aW9uKSB7XG4gICAgICBhY3Rpb24gPSBmYWxzZTtcbiAgICAgIHN0b3BUaW1lcigpO1xuXG4gICAgICBpZiAoZXYudHlwZSA9PSAnbW91c2V1cCcpIHtcbiAgICAgICAgJCQxKGRvY3VtZW50KS5vZmYoJ21vdXNlbW92ZScsIG9uTW92ZSkub2ZmKCdtb3VzZXVwJywgb25FbmQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNjcm9sbCkge1xuICAgICAgICBwcmV2ZW50VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwcmV2ZW50SG92ZXIgPSBmYWxzZTtcbiAgICAgICAgfSwgMzAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN3aXBlIHx8IHNjcm9sbCB8fCBkcmFnZ2VkKSB7XG4gICAgICAgIHByZXZDbGljayA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzd2lwZSkge1xuICAgICAgICBvblN3aXBlRW5kKCk7XG4gICAgICB9IGVsc2UgaWYgKGRyYWdnZWQpIHtcbiAgICAgICAgLy8gU29ydCBlbmRcbiAgICAgICAgcGFyZW50ID0gY3Vyckxpc3Q7XG5cbiAgICAgICAgaWYgKGRyb3BEb3duKSB7XG4gICAgICAgICAgcmVzZXRJdGVtKGl0ZW0uZGV0YWNoKCkpO1xuICAgICAgICAgIG1hcCA9IHRyZWVNYXBbZHJvcERvd24uYXR0cignZGF0YS1yZWYnKV07XG4gICAgICAgICAgY3VyckluZGV4ID0gZ2V0Q2hpbGRyZW4obWFwLmNoaWxkKS5sZW5ndGg7XG4gICAgICAgICAgZHJvcERvd24ucmVtb3ZlQ2xhc3MoJ21ic2MtbHYtaXRlbS1obCcpO1xuXG4gICAgICAgICAgaWYgKHMubmF2aWdhdGVPbkRyb3ApIHtcbiAgICAgICAgICAgIG5hdmlnYXRlKGRyb3BEb3duLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHRoYXQuYWRkKG51bGwsIGl0ZW0sIG51bGwsIG51bGwsIGRyb3BEb3duLCB0cnVlKTtcbiAgICAgICAgICAgICAgc2Nyb2xsVG9JdGVtKGl0ZW0pO1xuICAgICAgICAgICAgICBvblNvcnRFbmQoaXRlbSwgaXRlbUluZGV4LCBwYXJlbnQsIHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoYXQuYWRkKG51bGwsIGl0ZW0sIG51bGwsIG51bGwsIGRyb3BEb3duLCB0cnVlKTtcbiAgICAgICAgICAgIG9uU29ydEVuZChpdGVtLCBpdGVtSW5kZXgsIHBhcmVudCwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGRyb3BVcCkge1xuICAgICAgICAgIHJlc2V0SXRlbShpdGVtLmRldGFjaCgpKTtcbiAgICAgICAgICBtYXAgPSB0cmVlTWFwW2Ryb3BVcC5hdHRyKCdkYXRhLWJhY2snKV07XG4gICAgICAgICAgY3VyckluZGV4ID0gZ2V0Q2hpbGRyZW4obWFwLnBhcmVudCkuaW5kZXgobWFwLml0ZW0pICsgMTtcbiAgICAgICAgICBkcm9wVXAucmVtb3ZlQ2xhc3MoJ21ic2MtbHYtaXRlbS1obCcpO1xuXG4gICAgICAgICAgaWYgKHMubmF2aWdhdGVPbkRyb3ApIHtcbiAgICAgICAgICAgIG5hdmlnYXRlKGRyb3BVcCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB0aGF0LmFkZChudWxsLCBpdGVtLCBjdXJySW5kZXgsIG51bGwsIGN1cnJMaXN0LCB0cnVlKTtcbiAgICAgICAgICAgICAgc2Nyb2xsVG9JdGVtKGl0ZW0pO1xuICAgICAgICAgICAgICBvblNvcnRFbmQoaXRlbSwgaXRlbUluZGV4LCBwYXJlbnQsIHRydWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoYXQuYWRkKG51bGwsIGl0ZW0sIGN1cnJJbmRleCwgbnVsbCwgbWFwLnBhcmVudCwgdHJ1ZSk7XG4gICAgICAgICAgICBvblNvcnRFbmQoaXRlbSwgaXRlbUluZGV4LCBwYXJlbnQsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaXN0ID0gcGxhY2Vob2xkZXJbMF0ub2Zmc2V0VG9wIC0gc3RhcnRUb3A7IC8vIEFuaW1hdGUgaXRlbSB0byBpdHMgcGxhY2VcblxuICAgICAgICAgIGRyYWcoaXRlbSwgZGlzdCwgTWF0aC5hYnMoZGlzdCAtIE1hdGgubWF4KG1pbkRyYWcsIE1hdGgubWluKGRpZmZZICsgd25kU2Nyb2xsLCBtYXhEcmFnKSkpICogNiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzZXRJdGVtKGl0ZW0pO1xuICAgICAgICAgICAgaXRlbS5pbnNlcnRCZWZvcmUocGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgb25Tb3J0RW5kKGl0ZW0sIGl0ZW1JbmRleCwgcGFyZW50LCBjdXJySW5kZXggIT09IGl0ZW1JbmRleCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBkcmFnZ2VkID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCFzY3JvbGwgJiYgTWF0aC5hYnMoZGlmZlgpIDwgNSAmJiBNYXRoLmFicyhkaWZmWSkgPCA1KSB7XG4gICAgICAgIC8vIFRhcFxuICAgICAgICBpc0NsaWNrID0gdHJ1ZTsgLy8gVHJpZ2dlciBjbGljayBhbmQgYWN0aXZhdGUgdGFyZ2V0LCBpZiBpdCdzIGEgZm9ybSBjb250cm9sXG5cbiAgICAgICAgaWYgKGV2LnR5cGUgPT09ICd0b3VjaGVuZCcgJiYgcy50YXApIHtcbiAgICAgICAgICBhY3RpdmF0ZUNvbnRyb2woZXYudGFyZ2V0LCBnZXRDb250cm9sVHlwZSgkJDEoZXYudGFyZ2V0KSksIGV2KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjbGVhclRpbWVvdXQoYWN0aXZlVGltZXIpO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGl0bS5yZW1vdmVDbGFzcyhBQ1RJVkVfQ0xBU1MpO1xuICAgICAgICBldmVudCgnb25JdGVtRGVhY3RpdmF0ZScsIHtcbiAgICAgICAgICB0YXJnZXQ6IGl0bVswXVxuICAgICAgICB9KTtcbiAgICAgIH0sIDEwMCk7XG4gICAgICBzY3JvbGwgPSBmYWxzZTtcbiAgICAgIGN1cnJTdGFnZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25DbGljayhldikge1xuICAgIHZhciBpc1NlbGVjdGVkLCByZXQ7XG5cbiAgICBpZiAoaXNDbGljaykge1xuICAgICAgaXNTZWxlY3RlZCA9IGl0ZW0uYXR0cignZGF0YS1zZWxlY3RlZCcpID09ICd0cnVlJztcblxuICAgICAgaWYgKHR5cGUudGFwKSB7XG4gICAgICAgIHJldCA9IHR5cGUudGFwLmNhbGwoZSwge1xuICAgICAgICAgIHRhcmdldDogaXRlbSxcbiAgICAgICAgICBpbmRleDogaXRlbUluZGV4LFxuICAgICAgICAgIGRvbUV2ZW50OiBldlxuICAgICAgICB9LCB0aGF0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRhcEhpZ2hsaWdodCAmJiAhaXRlbS5oYXNDbGFzcyhBQ1RJVkVfQ0xBU1MpKSB7XG4gICAgICAgIGl0ZW0uYWRkQ2xhc3MoaXNUb3VjaCA/IEFDVElWRV9DTEFTUyA6ICcnKTtcbiAgICAgICAgZXZlbnQoJ29uSXRlbUFjdGl2YXRlJywge1xuICAgICAgICAgIHRhcmdldDogaXRlbVswXSxcbiAgICAgICAgICBkb21FdmVudDogZXZcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIHNlbGVjdCBvciBkZXNlbGVjdCBpdGVtIG9uIHRhcFxuXG5cbiAgICAgIGlmIChzZWxlY3RhYmxlKSB7XG4gICAgICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICBkZXNlbGVjdEl0ZW0oaXRlbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdEl0ZW0oaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlc2VsZWN0SXRlbSgkJDEoaXRlbVNlbGVjdG9yLCBjb250KS5maWx0ZXIoJy4nICsgU0VMRUNURURfQ0xBU1MpKTtcbiAgICAgICAgICBzZWxlY3RJdGVtKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldCA9IGV2ZW50KCdvbkl0ZW1UYXAnLCB7XG4gICAgICAgIHRhcmdldDogaXRlbVswXSxcbiAgICAgICAgaW5kZXg6IGl0ZW1JbmRleCxcbiAgICAgICAgZG9tRXZlbnQ6IGV2LFxuICAgICAgICBzZWxlY3RlZDogaXNTZWxlY3RlZFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChyZXQgIT09IGZhbHNlKSB7XG4gICAgICAgIG5hdmlnYXRlKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uSWNvblN0YXJ0KGV2KSB7XG4gICAgdmFyIHRhcmdldCA9IGNsb3Nlc3QoY29udDAsIGV2LnRhcmdldCwgJy5tYnNjLWx2LWljLW0nKTtcblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFkZW1vTW9kZSkge1xuICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHN0YXJ0WCA9IGdldENvb3JkKGV2LCAnWCcpO1xuICAgIHN0YXJ0WSA9IGdldENvb3JkKGV2LCAnWScpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25Td2lwZVN0YXJ0KCkge1xuICAgIHN3aXBlID0gdmFsdWVPckZ1bmModHlwZS5zd2lwZSwge1xuICAgICAgdGFyZ2V0OiBpdGVtWzBdLFxuICAgICAgaW5kZXg6IGl0ZW1JbmRleCxcbiAgICAgIGRpcmVjdGlvbjogZGlmZlggPiAwID8gJ3JpZ2h0JyA6ICdsZWZ0J1xuICAgIH0pO1xuXG4gICAgaWYgKHN3aXBlKSB7XG4gICAgICBzdG9wVGltZXIoKTtcbiAgICAgIGNsZWFyVGltZW91dChhY3RpdmVUaW1lcik7XG5cbiAgICAgIGlmICh0eXBlLmFjdGlvbnMpIHtcbiAgICAgICAgLy8gR2V0IHRoZSB3aWR0aCBvZiB0aGUgYWN0aW9uIG1lbnUgZnJvbSBzZXR0aW5nc1xuICAgICAgICAvLyBOdW1lcmljIHZhbHVlcyBhcmUgY29udmVydGVkIHRvIHN0cmluZywgYmVjYXVzZSAwIGlzIGFsc28gYWNjZXB0ZWQsIHdlIGNvbnZlcnQgYmFjayB0byBudW1iZXIgYXQgdGhlIGVuZFxuICAgICAgICBhY3Rpb25XaWR0aCA9IGdldEFjdGlvbldpZHRoKHR5cGUsIGRpZmZYKTsgLy8gU2hvdyBhY3Rpb24gaWNvbnMgYW5kIHNldCB3aWR0aFxuXG4gICAgICAgIG11bHRpYy5odG1sKHR5cGUuaWNvbnMpLnNob3coKS5jaGlsZHJlbigpLmNzcygnd2lkdGgnLCBhY3Rpb25XaWR0aCArICclJyk7IC8vIEhpZGUgc3RhZ2UgaWNvbnNcblxuICAgICAgICBpY29uYy5oaWRlKCk7IC8vIFNldCBkaXNhYmxlZCBhY3Rpb25zXG5cbiAgICAgICAgJCQxKCcubWJzYy1sdi1pYy1tJywgc3RhZ2VjKS5yZW1vdmVDbGFzcygnbWJzYy1sdi1pYy1kaXNhYmxlZCcpO1xuICAgICAgICAkJDEodHlwZS5sZWZ0TWVudSkuZWFjaChkaXNhYmxlQWN0aW9ucyk7XG4gICAgICAgICQkMSh0eXBlLnJpZ2h0TWVudSkuZWFjaChkaXNhYmxlQWN0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpY29uYy5zaG93KCk7XG4gICAgICAgIG11bHRpYy5oaWRlKCk7XG4gICAgICAgIGN1cnJTdGFnZUlkeCA9IHR5cGUuc3RhcnQ7XG4gICAgICAgIGN1cnJTdGFnZSA9IHN0YWdlc1tjdXJyU3RhZ2VJZHhdO1xuICAgICAgICBwcmV2U3RhZ2UgPSBzdGFnZXNbY3VyclN0YWdlSWR4IC0gMV07XG4gICAgICAgIG5leHRTdGFnZSA9IHN0YWdlc1tjdXJyU3RhZ2VJZHggKyAxXTtcbiAgICAgIH1cblxuICAgICAgaXRlbS5hZGRDbGFzcygnbWJzYy1sdi1pdGVtLXN3aXBpbmcnKS5yZW1vdmVDbGFzcyhBQ1RJVkVfQ0xBU1MpO1xuICAgICAgdGV4dC5jc3MoJ2xpbmUtaGVpZ2h0JywgaXRlbUhlaWdodCArICdweCcpO1xuICAgICAgc3RhZ2VjLmNzcyh7XG4gICAgICAgIHRvcDogc3RhcnRUb3AsXG4gICAgICAgIGhlaWdodDogaXRlbUhlaWdodCxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBnZXRGaXJzdENvbG9yKGRpZmZYKVxuICAgICAgfSkuYWRkQ2xhc3MoJ21ic2MtbHYtc3RhZ2UtYy12JykuYXBwZW5kVG8oY3Vyckxpc3QucGFyZW50KCkpO1xuXG4gICAgICBpZiAocy5pY29uU2xpZGUpIHtcbiAgICAgICAgaXRlbS5hcHBlbmQoaWNvbmMpO1xuICAgICAgfVxuXG4gICAgICBldmVudCgnb25TbGlkZVN0YXJ0Jywge1xuICAgICAgICB0YXJnZXQ6IGl0ZW1bMF0sXG4gICAgICAgIGluZGV4OiBpdGVtSW5kZXhcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uU3dpcGVNb3ZlKHByZXZQb3MpIHtcbiAgICB2YXIgc3RhZ2VDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICBpZiAoIXJhZlJ1bm5pbmcpIHtcbiAgICAgIGlmICh0eXBlLmFjdGlvbnMpIHtcbiAgICAgICAgc3RhZ2VjLmF0dHIoJ2NsYXNzJywgJ21ic2MtbHYtc3RhZ2UtYy12IG1ic2MtbHYtc3RhZ2UtYyBtYnNjLWx2LScgKyAoYW5pbVBvcyA8IDAgPyAncmlnaHQnIDogJ2xlZnQnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJldlN0YWdlICYmIChhbmltUG9zIDwgMCA/IGFuaW1Qb3MgPD0gcHJldlN0YWdlLnBlcmNlbnQgOiBhbmltUG9zIDwgY3VyclN0YWdlLnBlcmNlbnQpKSB7XG4gICAgICAgICAgY3VyclN0YWdlSWR4LS07XG4gICAgICAgICAgbmV4dFN0YWdlID0gY3VyclN0YWdlO1xuICAgICAgICAgIGN1cnJTdGFnZSA9IHByZXZTdGFnZTtcbiAgICAgICAgICBwcmV2U3RhZ2UgPSBzdGFnZXNbY3VyclN0YWdlSWR4IC0gMV07XG4gICAgICAgICAgc3RhZ2VDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0U3RhZ2UgJiYgKGFuaW1Qb3MgPCAwID8gYW5pbVBvcyA+IGN1cnJTdGFnZS5wZXJjZW50IDogYW5pbVBvcyA+PSBuZXh0U3RhZ2UucGVyY2VudCkpIHtcbiAgICAgICAgICBjdXJyU3RhZ2VJZHgrKztcbiAgICAgICAgICBwcmV2U3RhZ2UgPSBjdXJyU3RhZ2U7XG4gICAgICAgICAgY3VyclN0YWdlID0gbmV4dFN0YWdlO1xuICAgICAgICAgIG5leHRTdGFnZSA9IHN0YWdlc1tjdXJyU3RhZ2VJZHggKyAxXTtcbiAgICAgICAgICBzdGFnZUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJTdGFnZSkge1xuICAgICAgICAgIGlmIChzdGFnZUNoYW5nZWQgfHwgYW5pbVBvcyA+IDAgPT0gcHJldlBvcyA8PSAwKSB7XG4gICAgICAgICAgICAvLyBBbHNvIG5lZWQgdG8gdXBkYXRlIHN0YWdlIGJhY2tncm91bmQgaWYgc3dpcGUgZGlyZWN0aW9uIGNoYW5nZWRcbiAgICAgICAgICAgIHNldFN0YWdlUHJvcHMoY3VyclN0YWdlLCBzLmljb25TbGlkZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0YWdlQ2hhbmdlZCkge1xuICAgICAgICAgICAgZXZlbnQoJ29uU3RhZ2VDaGFuZ2UnLCB7XG4gICAgICAgICAgICAgIHRhcmdldDogaXRlbVswXSxcbiAgICAgICAgICAgICAgaW5kZXg6IGl0ZW1JbmRleCxcbiAgICAgICAgICAgICAgc3RhZ2U6IGN1cnJTdGFnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghc2ltdWxhdGluZykge1xuICAgICAgICByYWZSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgcmFmSUQgPSByYWYoc2xpZGVNb3ZlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblN3aXBlRW5kKGNhbGxiYWNrKSB7XG4gICAgZnVuY3Rpb24gb25DbG9zZUFjdGlvbnMoZXYpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBjbG9zZXN0KGNvbnQwLCBldi50YXJnZXQsICcubWJzYy1sdi1pYy1tJyk7XG5cbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHNsaWRlRW5kKGl0ZW0sIHRydWUsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcXVpY2tTd2lwZUxlZnQsXG4gICAgICAgIHF1aWNrU3dpcGVSaWdodCxcbiAgICAgICAgdGltZURpZmYsXG4gICAgICAgIGl0bSA9IGl0ZW1bMF0sXG4gICAgICAgIHBlbmRpbmcgPSBmYWxzZSxcbiAgICAgICAgcmV2ZXJ0ID0gdHJ1ZTtcbiAgICByYWZjKHJhZklEKTtcbiAgICByYWZSdW5uaW5nID0gZmFsc2U7IC8vIFdlIG5lZWQgYW4gYWRkaXRpb25hbCBjYWxsIHRvIHNldCB0aGUgcG9zaXRpb24gaW4gY2FzZSB3aGVuXG4gICAgLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGRpZCBub3QgY2FsbCBpdCBhdCBsZWFzdCBvbmNlXG4gICAgLy8gRS5nLiBpbiBhIGNhc2Ugb2YgYSBxdWljayBzd2lwZSBhbmltYXRpb24gZnJhbWUgaXNcbiAgICAvLyBjYW5jZWxsZWQgYmVmb3JlIHRoZSBmaXJzdCBjYWxsXG5cbiAgICBpZiAoIXNpbXVsYXRpbmcpIHtcbiAgICAgIHNsaWRlTW92ZSgpO1xuICAgIH1cblxuICAgIGlmICh0eXBlLmFjdGlvbnMpIHtcbiAgICAgIGlmIChNYXRoLmFicyhhbmltUG9zKSA+IDEwICYmIGFjdGlvbldpZHRoKSB7XG4gICAgICAgIHNsaWRlKGl0ZW0sIGFuaW1Qb3MgPCAwID8gLWFjdGlvbldpZHRoIDogYWN0aW9uV2lkdGgsIDIwMCk7XG4gICAgICAgIHBlbmRpbmcgPSB0cnVlO1xuICAgICAgICBjb25maXJtcyA9IHRydWU7XG4gICAgICAgIGNvbmZpcm1JdGVtID0gaXRlbTtcbiAgICAgICAgY29uZmlybUluZGV4ID0gaXRlbUluZGV4O1xuXG4gICAgICAgIGlmIChpdG0uX19tYnNjT2ZmKSB7XG4gICAgICAgICAgaXRtLl9fbWJzY09mZigpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGlzdGVuKGRvY3VtZW50LCAndG91Y2hzdGFydCcsIG9uQ2xvc2VBY3Rpb25zLCB7XG4gICAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIGxpc3Rlbihkb2N1bWVudCwgJ21vdXNlZG93bicsIG9uQ2xvc2VBY3Rpb25zKTtcblxuICAgICAgICBpdG0uX19tYnNjT2ZmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHVubGlzdGVuKGRvY3VtZW50LCAndG91Y2hzdGFydCcsIG9uQ2xvc2VBY3Rpb25zLCB7XG4gICAgICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHVubGlzdGVuKGRvY3VtZW50LCAnbW91c2Vkb3duJywgb25DbG9zZUFjdGlvbnMpO1xuICAgICAgICAgIGRlbGV0ZSBpdG0uX19tYnNjT2ZmO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYW5pbVBvcykge1xuICAgICAgaWYgKHMucXVpY2tTd2lwZSAmJiAhc2ltdWxhdGluZykge1xuICAgICAgICB0aW1lRGlmZiA9IG5ldyBEYXRlKCkgLSBzdGFydFRpbWU7XG4gICAgICAgIHF1aWNrU3dpcGVMZWZ0ID0gdGltZURpZmYgPCAzMDAgJiYgZGlmZlggPCAtNTA7XG4gICAgICAgIHF1aWNrU3dpcGVSaWdodCA9IHRpbWVEaWZmIDwgMzAwICYmIGRpZmZYID4gNTA7XG5cbiAgICAgICAgaWYgKHF1aWNrU3dpcGVMZWZ0KSB7XG4gICAgICAgICAgcXVpY2tTd2lwZSA9IHRydWU7XG4gICAgICAgICAgY3VyclN0YWdlID0gdHlwZS5sZWZ0O1xuICAgICAgICAgIHNldFN0YWdlUHJvcHMoY3VyclN0YWdlLCBzLmljb25TbGlkZSk7XG4gICAgICAgIH0gZWxzZSBpZiAocXVpY2tTd2lwZVJpZ2h0KSB7XG4gICAgICAgICAgcXVpY2tTd2lwZSA9IHRydWU7XG4gICAgICAgICAgY3VyclN0YWdlID0gdHlwZS5yaWdodDtcbiAgICAgICAgICBzZXRTdGFnZVByb3BzKGN1cnJTdGFnZSwgcy5pY29uU2xpZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyU3RhZ2UgJiYgY3VyclN0YWdlLmFjdGlvbikge1xuICAgICAgICBkaXNhYmxlZCA9IHZhbHVlT3JGdW5jKGN1cnJTdGFnZS5kaXNhYmxlZCwge1xuICAgICAgICAgIHRhcmdldDogaXRlbVswXSxcbiAgICAgICAgICBpbmRleDogaXRlbUluZGV4XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgICAgICBwZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgICBjb25maXJtcyA9IHNpbXVsYXRpbmcgfHwgdmFsdWVPckZ1bmMoY3VyclN0YWdlLmNvbmZpcm0sIHtcbiAgICAgICAgICAgIHRhcmdldDogaXRlbVswXSxcbiAgICAgICAgICAgIGluZGV4OiBpdGVtSW5kZXhcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChjb25maXJtcykge1xuICAgICAgICAgICAgLy8gU2xpZGUgdG8gdGV4dCArIGljb24gd2lkdGhcbiAgICAgICAgICAgIHNsaWRlKGl0ZW0sIChhbmltUG9zIDwgMCA/IC0xIDogMSkgKiBpY29uY1swXS5vZmZzZXRXaWR0aCAqIDEwMCAvIGl0ZW13LCAyMDAsIHRydWUpOyAvLyBUYXAgdG8gY29uZmlybVxuXG4gICAgICAgICAgICBzZXRDb25maXJtKGN1cnJTdGFnZSwgaXRlbSwgaXRlbUluZGV4LCBmYWxzZSwgY2FsbGJhY2spO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBydW5BY3Rpb24oY3VyclN0YWdlLCBpdGVtLCBpdGVtSW5kZXgsIGNhbGxiYWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgIHNsaWRlRW5kKGl0ZW0sIHJldmVydCwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHN3aXBlID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBvblNvcnRTdGFydCgpIHtcbiAgICBkcmFnZ2VkID0gdHJ1ZTtcbiAgICBkcm9wRG93biA9IGZhbHNlO1xuICAgIGRyb3BVcCA9IGZhbHNlO1xuICAgIHduZFNjcm9sbCA9IDA7XG4gICAgY3VyckluZGV4ID0gaXRlbUluZGV4O1xuXG4gICAgaWYgKHMudmlicmF0ZSkge1xuICAgICAgdmlicmF0ZSgpO1xuICAgIH1cblxuICAgIG5leHRJdGVtID0gZ2V0TmV4dFByZXYoaXRlbSwgJ25leHQnKTtcbiAgICBuZXh0T2Zmc2V0ID0gbmV4dEl0ZW0ubGVuZ3RoICYmIG5leHRJdGVtWzBdLm9mZnNldFRvcDtcbiAgICBwcmV2SXRlbSA9IGdldE5leHRQcmV2KGl0ZW0sICdwcmV2Jyk7XG4gICAgcHJldk9mZnNldCA9IHByZXZJdGVtLmxlbmd0aCAmJiBwcmV2SXRlbVswXS5vZmZzZXRUb3AgKyBwcmV2SXRlbVswXS5vZmZzZXRIZWlnaHQ7XG4gICAgcGxhY2Vob2xkZXIuaGVpZ2h0KGl0ZW1IZWlnaHQpLmluc2VydEFmdGVyKGl0ZW0pOyAvLyBJdGVtIGlzIHJlbW92ZWQgZnJvbSBvcmlnaW5hbCBsaXN0LCBvdGhlcndpc2UgbWVzc2VzIHVwIHN0cmlwZWQgbGF5b3V0XG5cbiAgICBpdGVtLmNzcyh7XG4gICAgICB0b3A6IHN0YXJ0VG9wXG4gICAgfSkuYWRkQ2xhc3MoJ21ic2MtbHYtaXRlbS1kcmFnZ2luZycpLnJlbW92ZUNsYXNzKEFDVElWRV9DTEFTUykuYXBwZW5kVG8oZHVtbXlDb250KTtcbiAgICBldmVudCgnb25Tb3J0U3RhcnQnLCB7XG4gICAgICB0YXJnZXQ6IGl0ZW1bMF0sXG4gICAgICBpbmRleDogY3VyckluZGV4XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBvblNvcnRFbmQoaXRlbSwgaXRlbUluZGV4LCBwYXJlbnQsIHVwZGF0ZSkge1xuICAgIGl0ZW0ucmVtb3ZlQ2xhc3MoJ21ic2MtbHYtaXRlbS1kcmFnZ2luZycpO1xuICAgIHBsYWNlaG9sZGVyLnJlbW92ZSgpO1xuICAgIGV2ZW50KCdvblNvcnRFbmQnLCB7XG4gICAgICB0YXJnZXQ6IGl0ZW1bMF0sXG4gICAgICBpbmRleDogY3VyckluZGV4XG4gICAgfSk7XG5cbiAgICBpZiAocy52aWJyYXRlKSB7XG4gICAgICB2aWJyYXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKHVwZGF0ZSkge1xuICAgICAgdGhhdC5hZGRVbmRvQWN0aW9uKGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgIHRoYXQubW92ZShpdGVtLCBpdGVtSW5kZXgsIG51bGwsIG5leHQsIHBhcmVudCwgdHJ1ZSk7XG4gICAgICB9LCB0cnVlKTtcbiAgICAgIGV2ZW50KCdvblNvcnRVcGRhdGUnLCB7XG4gICAgICAgIHRhcmdldDogaXRlbVswXSxcbiAgICAgICAgaW5kZXg6IGN1cnJJbmRleFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Nb3VzZUxlYXZlKCkge1xuICAgIGlmICghcHJldmVudEhvdmVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQoaG92ZXJUaW1lcik7XG5cbiAgICAgIGlmIChjb25maXJtcykge1xuICAgICAgICB0cmlnZ2VyKGRvY3VtZW50LCAndG91Y2hzdGFydCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaG92ZXJJdGVtT3BlbmVkKSB7XG4gICAgICAgIHRoYXQuY2xvc2UoaG92ZXJJdGVtLCBob3ZlclRpbWUpO1xuICAgICAgICBob3Zlckl0ZW1PcGVuZWQgPSBmYWxzZTtcbiAgICAgICAgaG92ZXJJdGVtID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblJlc2l6ZSgpIHtcbiAgICBjbGVhclRpbWVvdXQoZGVib3VuY2UpO1xuICAgIGRlYm91bmNlID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB3bmRIZWlnaHQgPSB3bmQwLmlubmVySGVpZ2h0IHx8IHduZC5pbm5lckhlaWdodCgpO1xuICAgICAgd25kVG9wID0gaGFzQ29udGV4dCA/IHduZC5vZmZzZXQoKS50b3AgOiAwO1xuXG4gICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgIC8vIFJlcG9zaXRpb24gc3RhZ2UgYmFja2dyb3VuZCwgaWNvbiBhbmQgdGV4dFxuICAgICAgICBzdGFydFRvcCA9IGl0ZW1bMF0ub2Zmc2V0VG9wO1xuICAgICAgICBpdGVtSGVpZ2h0ID0gaXRlbVswXS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIHN0YWdlYy5jc3Moe1xuICAgICAgICAgIHRvcDogc3RhcnRUb3AsXG4gICAgICAgICAgaGVpZ2h0OiBpdGVtSGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIDIwMCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkxpc3RDbGljayhldikge1xuICAgIGlmIChwcmV2Q2xpY2spIHtcbiAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHByZXZDbGljayA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uU2Nyb2xsQm90dG9tKCkge1xuICAgIGlmICghaXNMb2FkaW5nKSB7XG4gICAgICBjbGVhclRpbWVvdXQob25TY3JvbGxEZWJvdW5jZSk7XG4gICAgICBvblNjcm9sbERlYm91bmNlID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSBoYXNDb250ZXh0ID8gd25kMC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyB3bmQuaW5uZXJIZWlnaHQoKSA6IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICAgICAgICAgIHJlYWNoZWRCb3R0b20gPSBsb2FkaW5nWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAtIDMgPCBoZWlnaHQ7XG5cbiAgICAgICAgaWYgKCFpc0xvYWRpbmcgJiYgcmVhY2hlZEJvdHRvbSkge1xuICAgICAgICAgIGV2ZW50KCdvbkxpc3RFbmQnKTtcbiAgICAgICAgfVxuICAgICAgfSwgMjUwKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvblNjcm9sbCgpIHtcbiAgICBpZiAoZHJhZ2dlZCB8fCAhYWN0aW9uKSB7XG4gICAgICB2YXIgZ3JvdXAsXG4gICAgICAgICAgc3QgPSB3bmQuc2Nyb2xsVG9wKCksXG4gICAgICAgICAgZWxtVG9wID0gZWxtLm9mZnNldCgpLnRvcCxcbiAgICAgICAgICBlbG1IZWlnaHQgPSBlbG1bMF0ub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgIHduZFRvcCA9IGhhc0NvbnRleHQgPyB3bmQub2Zmc2V0KCkudG9wIDogc3Q7XG4gICAgICAkJDEoJy5tYnNjLWx2LWdyLXRpdGxlJywgZWxtKS5lYWNoKGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICAgIGlmICgkJDEodikub2Zmc2V0KCkudG9wIDwgd25kVG9wKSB7XG4gICAgICAgICAgZ3JvdXAgPSB2O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGVsbVRvcCA8IHduZFRvcCAmJiBlbG1Ub3AgKyBlbG1IZWlnaHQgPiB3bmRUb3ApIHtcbiAgICAgICAgZ3JvdXBIZWFkZXIuc2hvdygpLmVtcHR5KCkuYXBwZW5kKCQkMShncm91cCkuY2xvbmUoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBncm91cEhlYWRlci5oaWRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGlzYWJsZUFjdGlvbnMoaSwgdikge1xuICAgIGlmICh2YWx1ZU9yRnVuYyh2LmRpc2FibGVkLCB7XG4gICAgICB0YXJnZXQ6IGl0ZW1bMF0sXG4gICAgICBpbmRleDogaXRlbUluZGV4XG4gICAgfSkpIHtcbiAgICAgICQkMSgnLm1ic2MtaWMtJyArIHYuaWNvbiwgc3RhZ2VjKS5hZGRDbGFzcygnbWJzYy1sdi1pYy1kaXNhYmxlZCcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJ1bkFjdGlvbihzdGFnZSwgaXRlbSwgaW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJldmVydCxcbiAgICAgICAgdW5kb1N0YWdlID0ge1xuICAgICAgaWNvbjogJ3VuZG8yJyxcbiAgICAgIHRleHQ6IHMudW5kb1RleHQsXG4gICAgICBhY3Rpb246IGZ1bmN0aW9uIGFjdGlvbigpIHtcbiAgICAgICAgdGhhdC51bmRvKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdGFnZS51bmRvKSB7XG4gICAgICB0aGF0LnN0YXJ0QWN0aW9uVHJhY2soKTsgLy8gQWRkIHVzZXIgZGVmaW5lZCB1bmRvXG5cbiAgICAgIGlmICgkJDEuaXNGdW5jdGlvbihzdGFnZS51bmRvKSkge1xuICAgICAgICB0aGF0LmFkZFVuZG9BY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0YWdlLnVuZG8uY2FsbChlLCB7XG4gICAgICAgICAgICB0YXJnZXQ6IGl0ZW1bMF0sXG4gICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgICB9LCB0aGF0KTtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIFJlbWVtYmVyIHRoZSBpdGVtIHdoZXJlIHRoZSB1bmRvIGlzIGRpc3BsYXllZFxuXG5cbiAgICAgIHVuZG9SZWYgPSBpdGVtLmF0dHIoJ2RhdGEtcmVmJyk7XG4gICAgfVxuXG4gICAgcmV2ZXJ0ID0gc3RhZ2UuYWN0aW9uLmNhbGwoZSwge1xuICAgICAgdGFyZ2V0OiBpdGVtWzBdLFxuICAgICAgaW5kZXg6IGluZGV4XG4gICAgfSwgdGhhdCk7XG5cbiAgICBpZiAoc3RhZ2UudW5kbykge1xuICAgICAgdGhhdC5lbmRBY3Rpb25UcmFjaygpO1xuXG4gICAgICBpZiAocmV2ZXJ0ICE9PSBmYWxzZSkge1xuICAgICAgICBzbGlkZShpdGVtLCAraXRlbS5hdHRyKCdkYXRhLXBvcycpIDwgMCA/IC0xMDAgOiAxMDAsIDIwMCk7XG4gICAgICB9XG5cbiAgICAgIHBsYWNlaG9sZGVyLmhlaWdodChpdGVtSGVpZ2h0KS5pbnNlcnRBZnRlcihpdGVtKTtcbiAgICAgIGl0ZW0uY3NzKCd0b3AnLCBzdGFydFRvcCkuYWRkQ2xhc3MoJ21ic2MtbHYtaXRlbS11bmRvJyk7XG4gICAgICBtdWx0aWMuaGlkZSgpO1xuICAgICAgaWNvbmMuc2hvdygpO1xuICAgICAgc3RhZ2VjLmFwcGVuZChpY29uYyk7XG4gICAgICBzZXRTdGFnZVByb3BzKHVuZG9TdGFnZSk7XG4gICAgICBzZXRDb25maXJtKHVuZG9TdGFnZSwgaXRlbSwgaW5kZXgsIHRydWUsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2xpZGVFbmQoaXRlbSwgcmV2ZXJ0LCBjYWxsYmFjayk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q29uZmlybShzdGFnZSwgaXRlbSwgaW5kZXgsIHBoLCBjYWxsYmFjaykge1xuICAgIGZ1bmN0aW9uIG9uQWN0aW9uQ2FuY2VsKGV2KSB7XG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBpZiAocGgpIHtcbiAgICAgICAgY2xlYW5VbmRvKGl0ZW0pO1xuICAgICAgfVxuXG4gICAgICBzbGlkZUVuZChpdGVtLCB0cnVlLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25BY3Rpb25Db25maXJtU3RhcnQoZXYpIHtcbiAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgc3RhcnRYID0gZ2V0Q29vcmQoZXYsICdYJyk7XG4gICAgICBzdGFydFkgPSBnZXRDb29yZChldiwgJ1knKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkFjdGlvbkNvbmZpcm1FbmQoZXYpIHtcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGlmIChldi50eXBlID09PSAndG91Y2hlbmQnKSB7XG4gICAgICAgIHByZXZlbnRDbGljaygpO1xuICAgICAgfSAvLyBJZiBtb3ZlbWVudCBpcyBsZXNzIHRoYW4gMTBweCwgaXQncyBhIHRhcFxuXG5cbiAgICAgIGlmIChNYXRoLmFicyhnZXRDb29yZChldiwgJ1gnKSAtIHN0YXJ0WCkgPCAxMCAmJiBNYXRoLmFicyhnZXRDb29yZChldiwgJ1knKSAtIHN0YXJ0WSkgPCAxMCkge1xuICAgICAgICBydW5BY3Rpb24oc3RhZ2UsIGl0ZW0sIGluZGV4LCBjYWxsYmFjayk7XG5cbiAgICAgICAgaWYgKHBoKSB7XG4gICAgICAgICAgdW5kb0FuaW0gPSBudWxsO1xuICAgICAgICAgIGNsZWFuVW5kbyhpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzdGFydFgsXG4gICAgICAgIHN0YXJ0WSxcbiAgICAgICAgaXRtID0gaXRlbVswXTtcbiAgICBjb25maXJtcyA9IHRydWU7XG5cbiAgICBpZiAoaXRtLl9fbWJzY09mZikge1xuICAgICAgaXRtLl9fbWJzY09mZigpO1xuICAgIH1cblxuICAgIGxpc3Rlbihkb2N1bWVudCwgJ3RvdWNoc3RhcnQnLCBvbkFjdGlvbkNhbmNlbCwge1xuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgICBsaXN0ZW4oZG9jdW1lbnQsICdtb3VzZWRvd24nLCBvbkFjdGlvbkNhbmNlbCk7XG5cbiAgICBpZiAoIWRlbW9Nb2RlKSB7XG4gICAgICBsaXN0ZW4oaWNvbmNbMF0sICd0b3VjaHN0YXJ0Jywgb25BY3Rpb25Db25maXJtU3RhcnQsIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBsaXN0ZW4oaWNvbmNbMF0sICdtb3VzZWRvd24nLCBvbkFjdGlvbkNvbmZpcm1TdGFydCk7XG4gICAgICBsaXN0ZW4oaWNvbmNbMF0sICd0b3VjaGVuZCcsIG9uQWN0aW9uQ29uZmlybUVuZCk7XG4gICAgICBsaXN0ZW4oaWNvbmNbMF0sICdtb3VzZXVwJywgb25BY3Rpb25Db25maXJtRW5kKTtcbiAgICB9XG5cbiAgICBpdG0uX19tYnNjT2ZmID0gZnVuY3Rpb24gKCkge1xuICAgICAgdW5saXN0ZW4oZG9jdW1lbnQsICd0b3VjaHN0YXJ0Jywgb25BY3Rpb25DYW5jZWwsIHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgdW5saXN0ZW4oZG9jdW1lbnQsICdtb3VzZWRvd24nLCBvbkFjdGlvbkNhbmNlbCk7XG4gICAgICB1bmxpc3RlbihpY29uY1swXSwgJ3RvdWNoc3RhcnQnLCBvbkFjdGlvbkNvbmZpcm1TdGFydCwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHVubGlzdGVuKGljb25jWzBdLCAnbW91c2Vkb3duJywgb25BY3Rpb25Db25maXJtU3RhcnQpO1xuICAgICAgdW5saXN0ZW4oaWNvbmNbMF0sICd0b3VjaGVuZCcsIG9uQWN0aW9uQ29uZmlybUVuZCk7XG4gICAgICB1bmxpc3RlbihpY29uY1swXSwgJ21vdXNldXAnLCBvbkFjdGlvbkNvbmZpcm1FbmQpO1xuICAgICAgZGVsZXRlIGl0bS5fX21ic2NPZmY7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNsaWRlTW92ZSgpIHtcbiAgICBzbGlkZShpdGVtLCBzdGFydFBvcyArIGRpZmZYICogMTAwIC8gaXRlbXcpO1xuICAgIHJhZlJ1bm5pbmcgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNsaWRlRW5kKGl0ZW0sIHJldmVydCwgY2FsbGJhY2spIHtcbiAgICBpZiAoaXRlbVswXS5fX21ic2NPZmYpIHtcbiAgICAgIGl0ZW1bMF0uX19tYnNjT2ZmKCk7XG4gICAgfVxuXG4gICAgaWYgKHJldmVydCAhPT0gZmFsc2UpIHtcbiAgICAgIHNsaWRlKGl0ZW0sIDAsIGl0ZW0uYXR0cignZGF0YS1wb3MnKSAhPT0gJzAnID8gMjAwIDogMCwgZmFsc2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYW5TdGFnZShpdGVtLCBjYWxsYmFjayk7XG4gICAgICAgIHJlc2V0SXRlbShpdGVtKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhblN0YWdlKGl0ZW0sIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBjb25maXJtcyA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2xpZGUoaXRlbSwgcG9zLCB0aW1lLCBweCwgY2FsbGJhY2spIHtcbiAgICBwb3MgPSBNYXRoLm1heChzd2lwZSA9PSAncmlnaHQnID8gMCA6IC0xMDAsIE1hdGgubWluKHBvcywgc3dpcGUgPT0gJ2xlZnQnID8gMCA6IDEwMCkpO1xuICAgIHN0eWxlID0gaXRlbVswXS5zdHlsZTtcbiAgICBpdGVtLmF0dHIoJ2RhdGEtcG9zJywgcG9zKTtcbiAgICBzdHlsZVtqc1ByZWZpeCArICdUcmFuc2Zvcm0nXSA9ICd0cmFuc2xhdGUzZCgnICsgKHB4ID8gaXRlbXcgKiBwb3MgLyAxMDAgKyAncHgnIDogcG9zICsgJyUnKSArICcsMCwwKSc7XG4gICAgc3R5bGVbanNQcmVmaXggKyAnVHJhbnNpdGlvbiddID0gY3NzUHJlZml4ICsgJ3RyYW5zZm9ybSAnICsgKHRpbWUgfHwgMCkgKyAnbXMnO1xuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0cmFuc2l0aW9uKys7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgdHJhbnNpdGlvbi0tO1xuICAgICAgfSwgdGltZSk7XG4gICAgfVxuXG4gICAgYW5pbVBvcyA9IHBvcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYWcoaXRlbSwgdG9wLCB0aW1lLCBjYWxsYmFjaykge1xuICAgIHRvcCA9IE1hdGgubWF4KG1pbkRyYWcsIE1hdGgubWluKHRvcCwgbWF4RHJhZykpO1xuICAgIHN0eWxlID0gaXRlbVswXS5zdHlsZTtcbiAgICBzdHlsZVtqc1ByZWZpeCArICdUcmFuc2Zvcm0nXSA9ICd0cmFuc2xhdGUzZCgwLCcgKyB0b3AgKyAncHgsMCknO1xuICAgIHN0eWxlW2pzUHJlZml4ICsgJ1RyYW5zaXRpb24nXSA9IGNzc1ByZWZpeCArICd0cmFuc2Zvcm0gJyArICh0aW1lIHx8IDApICsgJ21zIGVhc2Utb3V0JztcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdHJhbnNpdGlvbisrO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIHRyYW5zaXRpb24tLTtcbiAgICAgIH0sIHRpbWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0b3BUaW1lcigpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXG4gICAgaWYgKCFjYW5jZWwgJiYgdGhhdC5zb3J0YWJsZSkge1xuICAgICAgY2FuY2VsID0gdHJ1ZTtcbiAgICAgIGZpbGwucmVtb3ZlKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0U3RhZ2VQcm9wcyhzdGFnZSwgaWNvblNsaWRlKSB7XG4gICAgdmFyIHR4dCA9IHZhbHVlT3JGdW5jKHN0YWdlLnRleHQsIHtcbiAgICAgIHRhcmdldDogaXRlbVswXSxcbiAgICAgIGluZGV4OiBpdGVtSW5kZXhcbiAgICB9KSB8fCAnJztcblxuICAgIGlmICh2YWx1ZU9yRnVuYyhzdGFnZS5kaXNhYmxlZCwge1xuICAgICAgdGFyZ2V0OiBpdGVtWzBdLFxuICAgICAgaW5kZXg6IGl0ZW1JbmRleFxuICAgIH0pKSB7XG4gICAgICBzdGFnZWMuYWRkQ2xhc3MoJ21ic2MtbHYtaWMtZGlzYWJsZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhZ2VjLnJlbW92ZUNsYXNzKCdtYnNjLWx2LWljLWRpc2FibGVkJyk7XG4gICAgfVxuXG4gICAgc3RhZ2VjLmNzcygnYmFja2dyb3VuZC1jb2xvcicsIHN0YWdlLmNvbG9yIHx8IChzdGFnZS5wZXJjZW50ID09PSAwID8gZ2V0Rmlyc3RDb2xvcihhbmltUG9zKSA6IHRyYW5zcCkpO1xuICAgIGljb25jLmF0dHIoJ2NsYXNzJywgJ21ic2MtbHYtaWMtYyBtYnNjLWx2LWljLScgKyAoaWNvblNsaWRlID8gJ21vdmUtJyA6ICcnKSArIChhbmltUG9zIDwgMCA/ICdyaWdodCcgOiAnbGVmdCcpKTtcbiAgICBpY29uLmF0dHIoJ2NsYXNzJywgJyBtYnNjLWx2LWljLXMgbWJzYy1sdi1pYyBtYnNjLWljIG1ic2MtaWMtJyArIChzdGFnZS5pY29uIHx8ICdub25lJykpO1xuICAgIHRleHQuYXR0cignY2xhc3MnLCAnbWJzYy1sdi1pYy10ZXh0JyArIChzdGFnZS5pY29uID8gJycgOiAnIG1ic2MtbHYtaWMtdGV4dC1vbmx5JykgKyAodHh0ID8gJycgOiAnIG1ic2MtbHYtaWMtb25seScpKS5odG1sKHR4dCB8fCAnJm5ic3A7Jyk7XG5cbiAgICBpZiAocy5hbmltYXRlSWNvbnMpIHtcbiAgICAgIGlmIChxdWlja1N3aXBlKSB7XG4gICAgICAgIGljb24uYWRkQ2xhc3MoJ21ic2MtbHYtaWMtdicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWNvbi5hZGRDbGFzcygnbWJzYy1sdi1pYy1hJyk7XG4gICAgICAgIH0sIDEwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhblN0YWdlKGl0ZW0sIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgIC8vIERvbid0IGNsZWFuIHN0YWdlcyBpZiBhbm90aGVyIGFjdGlvbiBzdGFydGVkXG4gICAgICBpY29uLmF0dHIoJ2NsYXNzJywgJ21ic2MtbHYtaWMtcyBtYnNjLWx2LWljIG1ic2MtaWMgbWJzYy1pYy1ub25lJyk7XG4gICAgICBzdGFnZWMuYXR0cignc3R5bGUnLCAnJykucmVtb3ZlQ2xhc3MoJ21ic2MtbHYtc3RhZ2UtYy12Jyk7XG4gICAgICB0ZXh0Lmh0bWwoJycpO1xuICAgIH1cblxuICAgIHN0YWdlYy5yZW1vdmVDbGFzcygnbWJzYy1sdi1sZWZ0IG1ic2MtbHYtcmlnaHQnKTtcblxuICAgIGlmIChpdGVtKSB7XG4gICAgICBldmVudCgnb25TbGlkZUVuZCcsIHtcbiAgICAgICAgdGFyZ2V0OiBpdGVtWzBdLFxuICAgICAgICBpbmRleDogaXRlbUluZGV4XG4gICAgICB9KTtcblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW5VbmRvKGl0ZW0pIHtcbiAgICBpdGVtLmNzcygndG9wJywgJycpLnJlbW92ZUNsYXNzKCdtYnNjLWx2LWl0ZW0tdW5kbycpOyAvLyBSZW1vdmUgcGxhY2Vob2xkZXJcblxuICAgIGlmICh1bmRvQW5pbSkge1xuICAgICAgdGhhdC5hbmltYXRlKHBsYWNlaG9sZGVyLCAnY29sbGFwc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBsYWNlaG9sZGVyLnJlbW92ZSgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBsYWNlaG9sZGVyLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIGNsZWFuU3RhZ2UoKTtcbiAgICB1bmRvUmVmID0gbnVsbDtcbiAgICB1bmRvQW5pbSA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEl0ZW0oaXRlbSkge1xuICAgIHN0eWxlID0gaXRlbVswXS5zdHlsZTtcbiAgICBzdHlsZVtqc1ByZWZpeCArICdUcmFuc2Zvcm0nXSA9ICcnO1xuICAgIHN0eWxlW2pzUHJlZml4ICsgJ1RyYW5zaXRpb24nXSA9ICcnO1xuICAgIHN0eWxlLnRvcCA9ICcnO1xuICAgIGl0ZW0ucmVtb3ZlQ2xhc3MoJ21ic2MtbHYtaXRlbS1zd2lwaW5nJyk7XG4gIH1cblxuICBmdW5jdGlvbiB2YWx1ZU9yRnVuYyh2YWwsIGFyZ3MpIHtcbiAgICByZXR1cm4gJCQxLmlzRnVuY3Rpb24odmFsKSA/IHZhbC5jYWxsKHRoaXMsIGFyZ3MsIHRoYXQpIDogdmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTZWxlY3RhYmxlKGl0ZW0pIHtcbiAgICByZXR1cm4gc2VsZWN0YWJsZSAmJiAhaXRlbS5oYXNDbGFzcygnbWJzYy1sdi1wYXJlbnQnKSAmJiAhaXRlbS5oYXNDbGFzcygnbWJzYy1sdi1iYWNrJyk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0SXRlbShpdGVtKSB7XG4gICAgdmFyIGlkID0gaXRlbS5hdHRyKCdkYXRhLXJlZicpLFxuICAgICAgICByb2xlID0gaXRlbS5hdHRyKCdkYXRhLXJvbGUnKSxcbiAgICAgICAgdHlwZSA9IHR5cGVzW2l0ZW0uYXR0cignZGF0YS10eXBlJykgfHwgJ2RlZmF1bHRzJ10sXG4gICAgICAgIHNlbGVjdGVkID0gaXNTZWxlY3RhYmxlKGl0ZW0pICYmIGl0ZW0uYXR0cignZGF0YS1zZWxlY3RlZCcpID09ICd0cnVlJztcblxuICAgIGlmICghaWQpIHtcbiAgICAgIGlkID0gZ3VpZCsrO1xuICAgICAgaXRlbS5hdHRyKCdkYXRhLXJlZicsIGlkKTtcbiAgICB9XG5cbiAgICB0cmVlTWFwW2lkXSA9IHtcbiAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICBjaGlsZDogaXRlbS5jaGlsZHJlbihsaXN0U2VsZWN0b3IpLFxuICAgICAgcGFyZW50OiBpdGVtLnBhcmVudCgpLFxuICAgICAgcmVmOiBpdGVtLnBhcmVudCgpWzBdID09PSBlID8gbnVsbCA6IGl0ZW0ucGFyZW50KCkucGFyZW50KCkuYXR0cignZGF0YS1yZWYnKVxuICAgIH07XG4gICAgaXRlbS5hZGRDbGFzcyhyb2xlID09ICdsaXN0LWRpdmlkZXInID8gJ21ic2MtbHYtZ3ItdGl0bGUnIDogJ21ic2MtbHYtaXRlbScgKyAodHlwZS5hY3Rpb25hYmxlID8gJyBtYnNjLWx2LWl0ZW0tYWN0aW9uYWJsZScgOiAnJykgKyAoc2VsZWN0ZWQgPyAnICcgKyBTRUxFQ1RFRF9DTEFTUyA6ICcnKSk7XG4gICAgaXRlbS5hdHRyKCdhcmlhLXNlbGVjdGVkJywgc2VsZWN0ZWQgPyAndHJ1ZScgOiAnZmFsc2UnKTsgLy8gQWRkIHNvcnQgaGFuZGxlXG5cbiAgICBpZiAodGhhdC5zb3J0YWJsZS5oYW5kbGUgJiYgcm9sZSAhPSAnbGlzdC1kaXZpZGVyJyAmJiAhaXRlbS5jaGlsZHJlbignLm1ic2MtbHYtaGFuZGxlLWMnKS5sZW5ndGgpIHtcbiAgICAgIGl0ZW0uYXBwZW5kKGhhbmRsZURpdik7XG4gICAgfVxuXG4gICAgaWYgKHMuZW5oYW5jZSAmJiAhaXRlbS5oYXNDbGFzcygnbWJzYy1sdi1pdGVtLWVuaGFuY2VkJykpIHtcbiAgICAgIHZhciBpdGVtSWNvbiA9IGl0ZW0uYXR0cignZGF0YS1pY29uJyksXG4gICAgICAgICAgaXRlbUltZyA9IGl0ZW0uZmluZCgnaW1nJykuZXEoMCkuYWRkQ2xhc3MoJ21ic2MtbHYtaW1nJyk7XG5cbiAgICAgIGlmIChpdGVtSW1nLmlzKCc6Zmlyc3QtY2hpbGQnKSkge1xuICAgICAgICBpdGVtLmFkZENsYXNzKCdtYnNjLWx2LWltZy0nICsgKHMucnRsID8gJ3JpZ2h0JyA6ICdsZWZ0JykpO1xuICAgICAgfSBlbHNlIGlmIChpdGVtSW1nLmxlbmd0aCkge1xuICAgICAgICBpdGVtLmFkZENsYXNzKCdtYnNjLWx2LWltZy0nICsgKHMucnRsID8gJ2xlZnQnIDogJ3JpZ2h0JykpO1xuICAgICAgfVxuXG4gICAgICBpdGVtLmFkZENsYXNzKCdtYnNjLWx2LWl0ZW0tZW5oYW5jZWQnKS5jaGlsZHJlbigpLmVhY2goZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgICAgdiA9ICQkMSh2KTtcblxuICAgICAgICBpZiAodi5pcygncCwgaDEsIGgyLCBoMywgaDQsIGg1LCBoNicpKSB7XG4gICAgICAgICAgdi5hZGRDbGFzcygnbWJzYy1sdi10eHQnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChpdGVtSWNvbikge1xuICAgICAgICBpdGVtLmFkZENsYXNzKCdtYnNjLWx2LWl0ZW0taWMtJyArIChpdGVtLmF0dHIoJ2RhdGEtaWNvbi1hbGlnbicpIHx8IChzLnJ0bCA/ICdyaWdodCcgOiAnbGVmdCcpKSkuYXBwZW5kKCc8ZGl2IGNsYXNzPVwibWJzYy1sdi1pdGVtLWljIG1ic2MtaWMgbWJzYy1pYy0nICsgaXRlbUljb24gKyAnXCI+PC9kaXY+Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIFRSSUFMICovXG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRCcmFuY2goZWxtKSB7XG4gICAgLy8gQ3JlYXRlIG1hcCBvYmplY3RcbiAgICAkJDEoaXRlbVNlbGVjdG9yLCBlbG0pLm5vdCgnLm1ic2MtbHYtYmFjaycpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgaW5pdEl0ZW0oJCQxKHRoaXMpKTtcbiAgICB9KTsgLy8gQWRkIGV4dHJhIGNsYXNzZXMgYW5kIG1hcmt1cCAoYXJyb3dzIGFuZCBiYWNrIGl0ZW1zKVxuXG4gICAgJCQxKGxpc3RTZWxlY3RvciwgZWxtKS5ub3QoJy5tYnNjLWx2JykuYWRkQ2xhc3MoJ21ic2MtbHYnKS5wcmVwZW5kKGh0bWxMZWZ0KS5wYXJlbnQoKS5hZGRDbGFzcygnbWJzYy1sdi1wYXJlbnQgbWJzYy1sdi1pdGVtLWFjdGlvbmFibGUnKS5wcmVwZW5kKGh0bWxSaWdodCk7IC8vIEFkZCBwYXJlbnQgcmVmZXJlbmNlIGZvciBiYWNrIGJ1dHRvbnNcblxuICAgICQkMSgnLm1ic2MtbHYtYmFjaycsIGVsbSkuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAkJDEodGhpcykuYXR0cignZGF0YS1iYWNrJywgJCQxKHRoaXMpLnBhcmVudCgpLnBhcmVudCgpLmF0dHIoJ2RhdGEtcmVmJykpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2hpbGRyZW4obGlzdCkge1xuICAgIHJldHVybiBsaXN0LmNoaWxkcmVuKGl0ZW1TZWxlY3Rvcikubm90KCcubWJzYy1sdi1iYWNrJykubm90KCcubWJzYy1sdi1yZW1vdmVkJykubm90KCcubWJzYy1sdi1waCcpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SXRlbUJ5SUQoaXRlbSkge1xuICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGl0ZW0gPSAkJDEoaXRlbVNlbGVjdG9yLCBjb250KS5maWx0ZXIoJ1tkYXRhLWlkPVwiJyArIGl0ZW0gKyAnXCJdJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuICQkMShpdGVtKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEl0ZW1MZXZlbChpdGVtKSB7XG4gICAgdmFyIGxldmVsID0gMCxcbiAgICAgICAgbWFwID0gdHJlZU1hcFtpdGVtLmF0dHIoJ2RhdGEtcmVmJyldO1xuXG4gICAgd2hpbGUgKG1hcCAmJiBtYXAucmVmKSB7XG4gICAgICBsZXZlbCsrO1xuICAgICAgbWFwID0gdHJlZU1hcFttYXAucmVmXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGV2ZWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXROZXh0UHJldihpdGVtLCBkaXIpIHtcbiAgICBpdGVtID0gaXRlbVtkaXJdKCk7IC8vIFJldHVybnMgbmV4dCBvciBwcmV2aW91cyBpdGVtIGZpbHRlcmluZyBvdXQgcGxhY2Vob2xkZXIgb3IgY3VycmVudGx5IGRyYWdnZWQgZWxlbWVudFxuXG4gICAgd2hpbGUgKGl0ZW0ubGVuZ3RoICYmICghaXRlbS5oYXNDbGFzcygnbWJzYy1sdi1pdGVtJykgfHwgaXRlbS5oYXNDbGFzcygnbWJzYy1sdi1waCcpIHx8IGl0ZW0uaGFzQ2xhc3MoJ21ic2MtbHYtaXRlbS1kcmFnZ2luZycpKSkge1xuICAgICAgaWYgKCF0aGF0LnNvcnRhYmxlLmdyb3VwICYmIGl0ZW0uaGFzQ2xhc3MoJ21ic2MtbHYtZ3ItdGl0bGUnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGl0ZW0gPSBpdGVtW2Rpcl0oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZpcnN0Q29sb3IocG9zKSB7XG4gICAgcmV0dXJuIChwb3MgPiAwID8gdHlwZS5yaWdodCA6IHR5cGUubGVmdCkuY29sb3IgfHwgdHJhbnNwO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TnVtU3RyKHMpIHtcbiAgICByZXR1cm4gaXNOdW1lcmljKHMpID8gcyArICcnIDogMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEFjdGlvbldpZHRoKHR5cGUsIGRpZmZYKSB7XG4gICAgcmV0dXJuICsoZGlmZlggPCAwID8gZ2V0TnVtU3RyKCh0eXBlLmFjdGlvbnNXaWR0aCB8fCAwKS5yaWdodCkgfHwgZ2V0TnVtU3RyKHR5cGUuYWN0aW9uc1dpZHRoKSB8fCBnZXROdW1TdHIocy5hY3Rpb25zV2lkdGgucmlnaHQpIHx8IGdldE51bVN0cihzLmFjdGlvbnNXaWR0aCkgOiBnZXROdW1TdHIoKHR5cGUuYWN0aW9uc1dpZHRoIHx8IDApLmxlZnQpIHx8IGdldE51bVN0cih0eXBlLmFjdGlvbnNXaWR0aCkgfHwgZ2V0TnVtU3RyKHMuYWN0aW9uc1dpZHRoLmxlZnQpIHx8IGdldE51bVN0cihzLmFjdGlvbnNXaWR0aCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2Nyb2xsVG9JdGVtKGl0ZW0sIHNjcm9sbFRvVG9wKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciBzY3JvbGxUb3AgPSB3bmQuc2Nyb2xsVG9wKCksXG4gICAgICAgICAgaXRlbUhlaWdodCA9IGl0ZW0uaXMoJy5tYnNjLWx2LWl0ZW0nKSA/IGl0ZW1bMF0ub2Zmc2V0SGVpZ2h0IDogMCxcbiAgICAgICAgICBpdGVtVG9wID0gaXRlbS5vZmZzZXQoKS50b3AgKyAoaGFzQ29udGV4dCA/IHNjcm9sbFRvcCAtIHduZFRvcCA6IDApO1xuXG4gICAgICBpZiAoc2Nyb2xsVG9Ub3ApIHtcbiAgICAgICAgaWYgKGl0ZW1Ub3AgPCBzY3JvbGxUb3AgfHwgaXRlbVRvcCArIGl0ZW1IZWlnaHQgPiBzY3JvbGxUb3AgKyB3bmRIZWlnaHQpIHtcbiAgICAgICAgICB3bmQuc2Nyb2xsVG9wKGl0ZW1Ub3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXRlbVRvcCA8IHNjcm9sbFRvcCkge1xuICAgICAgICAgIHduZC5zY3JvbGxUb3AoaXRlbVRvcCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbVRvcCArIGl0ZW1IZWlnaHQgPiBzY3JvbGxUb3AgKyB3bmRIZWlnaHQpIHtcbiAgICAgICAgICB3bmQuc2Nyb2xsVG9wKE1hdGgubWluKGl0ZW1Ub3AsIGl0ZW1Ub3AgKyBpdGVtSGVpZ2h0IC0gd25kSGVpZ2h0IC8gMikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZHJpbGwoZGlyLCBsaXN0LCBpdGVtLCBjYWxsYmFjaywgc2Nyb2xsVG9Ub3ApIHtcbiAgICB2YXIgcGFyZW50ID0gbGlzdC5wYXJlbnQoKSxcbiAgICAgICAgcGggPSBsaXN0LnByZXYoKTtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG5cbiAgICBpZiAocGhbMF0gPT09IGljb25jWzBdKSB7XG4gICAgICBwaCA9IGljb25jLnByZXYoKTtcbiAgICB9XG5cbiAgICBpZiAocy5ydGwpIHtcbiAgICAgIGRpciA9IGRpciA9PT0gJ2wnID8gJ3InIDogJ2wnO1xuICAgIH1cblxuICAgIGlmIChjdXJyTGlzdFswXSAhPT0gbGlzdFswXSkge1xuICAgICAgZXZlbnQoJ29uTmF2U3RhcnQnLCB7XG4gICAgICAgIGxldmVsOiBzbGlkZUxldmVsLFxuICAgICAgICBkaXJlY3Rpb246IGRpcixcbiAgICAgICAgbGlzdDogbGlzdFswXVxuICAgICAgfSk7XG4gICAgICBzbGlkZUNvbnQucHJlcGVuZChsaXN0LmFkZENsYXNzKCdtYnNjLWx2LXYgbWJzYy1sdi1zbC1uZXcnKSk7IC8vIElmIHRvcCBvZiB0aGUgbGlzdCBpcyBub3QgdmlzaWJsZSwgc2Nyb2xsIHRvIHRvcFxuXG4gICAgICBzY3JvbGxUb0l0ZW0oY29udCk7XG4gICAgICBhbmltYXRlKHNsaWRlQ29udCwgJ21ic2MtbHYtc2wtJyArIGRpciwgZnVuY3Rpb24gKCkge1xuICAgICAgICBjdXJyTGlzdC5yZW1vdmVDbGFzcygnbWJzYy1sdi1zbC1jdXJyJyk7XG4gICAgICAgIGxpc3QucmVtb3ZlQ2xhc3MoJ21ic2MtbHYtc2wtbmV3JykuYWRkQ2xhc3MoJ21ic2MtbHYtc2wtY3VycicpO1xuXG4gICAgICAgIGlmIChjdXJyUGggJiYgY3VyclBoLmxlbmd0aCkge1xuICAgICAgICAgIGN1cnJMaXN0LnJlbW92ZUNsYXNzKCdtYnNjLWx2LXYnKS5pbnNlcnRBZnRlcihjdXJyUGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJQYXJlbnQuYXBwZW5kKGN1cnJMaXN0LnJlbW92ZUNsYXNzKCdtYnNjLWx2LXYnKSk7XG4gICAgICAgIH0gLy8gUmVtZW1iZXIgdGhlIHByZXZpb3VzIGVsZW1lbnQgd2hlcmUgd2UgbmVlZCB0byBwdXQgYmFjayB0aGUgbGlzdCBsYXRlclxuICAgICAgICAvLyBXZSBuZWVkIHRoaXMgYmVjYXVzZSBzb21lIGZyYW1ld29ya3MgbGlrZSBlbWJlciBqcyBwdXQgYWRkaXRpb25hbCBlbGVtZW50cyAoc2NyaXB0IHRhZ3MpXG4gICAgICAgIC8vIGFuZCBhcHBlbmRpbmcgdG8gcGFyZW50IGVsZW1lbnQgaXMgbm90IG9rXG5cblxuICAgICAgICBjdXJyUGggPSBwaDtcbiAgICAgICAgY3VyclBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgY3Vyckxpc3QgPSBsaXN0O1xuICAgICAgICBzY3JvbGxUb0l0ZW0oaXRlbSwgc2Nyb2xsVG9Ub3ApO1xuICAgICAgICBjYWxsYmFjay5jYWxsKGUsIGl0ZW0pO1xuICAgICAgICBldmVudCgnb25OYXZFbmQnLCB7XG4gICAgICAgICAgbGV2ZWw6IHNsaWRlTGV2ZWwsXG4gICAgICAgICAgZGlyZWN0aW9uOiBkaXIsXG4gICAgICAgICAgbGlzdDogbGlzdFswXVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY3JvbGxUb0l0ZW0oaXRlbSwgc2Nyb2xsVG9Ub3ApO1xuICAgICAgY2FsbGJhY2suY2FsbChlLCBpdGVtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBuYXZpZ2F0ZShpdGVtLCBjYWxsYmFjaykge1xuICAgIGlmICghdHJhbnNpdGlvbikge1xuICAgICAgaWYgKGl0ZW0uaGFzQ2xhc3MoJ21ic2MtbHYtcGFyZW50JykpIHtcbiAgICAgICAgc2xpZGVMZXZlbCsrO1xuICAgICAgICBkcmlsbCgncicsIHRyZWVNYXBbaXRlbS5hdHRyKCdkYXRhLXJlZicpXS5jaGlsZCwgbnVsbCwgY2FsbGJhY2spO1xuICAgICAgfSBlbHNlIGlmIChpdGVtLmhhc0NsYXNzKCdtYnNjLWx2LWJhY2snKSkge1xuICAgICAgICBzbGlkZUxldmVsLS07XG4gICAgICAgIGRyaWxsKCdsJywgdHJlZU1hcFtpdGVtLmF0dHIoJ2RhdGEtYmFjaycpXS5wYXJlbnQsIHRyZWVNYXBbaXRlbS5hdHRyKCdkYXRhLWJhY2snKV0uaXRlbSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFuaW1hdGUoZWwsIGFuaW0sIGNhbGxiYWNrKSB7XG4gICAgdmFyIHRpbWVyO1xuXG4gICAgZnVuY3Rpb24gb25BbmltRW5kKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIHRyYW5zaXRpb24tLTtcbiAgICAgIGVsLm9mZihhbmltRW5kLCBvbkFuaW1FbmQpLnJlbW92ZUNsYXNzKGFuaW0pO1xuICAgICAgY2FsbGJhY2suY2FsbChlLCBlbCk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xuXG4gICAgaWYgKHMuYW5pbWF0aW9uICYmIGFuaW0gIT09ICdtYnNjLWx2LWl0ZW0tbm9uZScpIHtcbiAgICAgIHRyYW5zaXRpb24rKztcbiAgICAgIGVsLm9uKGFuaW1FbmQsIG9uQW5pbUVuZCkuYWRkQ2xhc3MoYW5pbSk7IC8vIGFuaW1FbmQgZXZlbnQgd2lsbCBub3QgZXhlY3V0ZSB3aXRoIHNvbWUgaW50ZWdyYXRpb24gcGx1Z2lucywgdGhpcyBpcyBhIHdvcmthcm91bmQgdG8gbWFrZSBzdXJlIGl0J3MgZXhlY3V0ZWRcblxuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KG9uQW5pbUVuZCwgMjUwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2suY2FsbChlLCBlbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZG9BY3Rpb24oZWwsIGFjdGlvbikge1xuICAgIHZhciBxdWV1ZSxcbiAgICAgICAgaWQgPSBlbC5hdHRyKCdkYXRhLXJlZicpO1xuICAgIHF1ZXVlID0gYWN0aW9uUXVldWVbaWRdID0gYWN0aW9uUXVldWVbaWRdIHx8IFtdO1xuXG4gICAgaWYgKGFjdGlvbikge1xuICAgICAgcXVldWUucHVzaChhY3Rpb24pO1xuICAgIH1cblxuICAgIGlmIChlbC5hdHRyKCdkYXRhLWFjdGlvbicpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYWN0aW9uID0gcXVldWUuc2hpZnQoKTsgLy8gQ2hlY2sgdGhpcyBmb3Igc2FmZXR5XG4gICAgLy8gVGhlcmUgd2FzIGEgY2FzZSBpbiBhbmd1bGFyIHdlcmUgdGhlIGRhdGEtcmVmIGF0dHJpYnV0ZSB3YXMgbG9zdCxcbiAgICAvLyBzbyB0aGUgcXVldWUgd2FzIGVtcHR5XG5cbiAgICBpZiAoYWN0aW9uKSB7XG4gICAgICBlbC5hdHRyKCdkYXRhLWFjdGlvbicsIDEpO1xuICAgICAgYWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cignZGF0YS1hY3Rpb24nKTtcblxuICAgICAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgZG9BY3Rpb24oZWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBhY3Rpb25RdWV1ZVtpZF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NTdGFnZXMoc3RhZ2VzLCBkaXIsIGR1cGxpY2F0ZSkge1xuICAgIHZhciBjb3VudCwgdGVtcDtcblxuICAgIGlmIChzdGFnZXMgJiYgc3RhZ2VzLmxlbmd0aCkge1xuICAgICAgY291bnQgPSAxMDAgLyAoc3RhZ2VzLmxlbmd0aCArIDIpO1xuICAgICAgJCQxLmVhY2goc3RhZ2VzLCBmdW5jdGlvbiAoaSwgc3RhZ2UpIHtcbiAgICAgICAgaWYgKHN0YWdlLmtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc3RhZ2Uua2V5ID0gc3RhZ2VOcisrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YWdlLnBlcmNlbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGlmIG5vIHBlcmNlbnQgcGFzc2VkIHRoZW4gZ2VuZXJhdGUgdG8gYm90aCBzaWRlc1xuICAgICAgICAgIHN0YWdlLnBlcmNlbnQgPSBkaXIgKiBjb3VudCAqIChpICsgMSk7XG5cbiAgICAgICAgICBpZiAoZHVwbGljYXRlKSB7XG4gICAgICAgICAgICB0ZW1wID0gZXh0ZW5kJDEoe30sIHN0YWdlKTtcbiAgICAgICAgICAgIHRlbXAua2V5ID0gc3RhZ2VOcisrO1xuICAgICAgICAgICAgdGVtcC5wZXJjZW50ID0gLWNvdW50ICogKGkgKyAxKTtcbiAgICAgICAgICAgIHN0YWdlcy5wdXNoKHRlbXApO1xuICAgICAgICAgICAgc3RhZ2VPYmpbdGVtcC5rZXldID0gdGVtcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdGFnZU9ialtzdGFnZS5rZXldID0gc3RhZ2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3RJdGVtKCRpdGVtKSB7XG4gICAgaWYgKGlzU2VsZWN0YWJsZSgkaXRlbSkpIHtcbiAgICAgICRpdGVtLmFkZENsYXNzKFNFTEVDVEVEX0NMQVNTKS5hdHRyKCdkYXRhLXNlbGVjdGVkJywgJ3RydWUnKS5hdHRyKCdhcmlhLXNlbGVjdGVkJywgJ3RydWUnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXNlbGVjdEl0ZW0oJGl0ZW0pIHtcbiAgICAkaXRlbS5yZW1vdmVDbGFzcyhTRUxFQ1RFRF9DTEFTUykucmVtb3ZlQXR0cignZGF0YS1zZWxlY3RlZCcpLnJlbW92ZUF0dHIoJ2FyaWEtc2VsZWN0ZWQnKTtcbiAgfSAvLyBDYWxsIHRoZSBwYXJlbnQgY29uc3RydWN0b3JcblxuXG4gIEJhc2UuY2FsbCh0aGlzLCBlbGVtLCBzZXR0aW5ncywgdHJ1ZSk7XG4gIC8qIFRSSUFMRlVOQyAqL1xuXG4gIC8qKlxyXG4gICAqIEFuaW1hdGUgYSBsaXN0IGl0ZW1cclxuICAgKi9cblxuICB0aGF0LmFuaW1hdGUgPSBmdW5jdGlvbiAobGksIGFuaW0sIGNhbGxiYWNrKSB7XG4gICAgYW5pbWF0ZShsaSwgJ21ic2MtbHYtaXRlbS0nICsgYW5pbSwgY2FsbGJhY2spO1xuICB9O1xuICAvKipcclxuICAgKiBBZGQgYSBuZXcgbGlzdCBpdGVtXHJcbiAgICovXG5cblxuICB0aGF0LmFkZCA9IGZ1bmN0aW9uIChpZCwgbWFya3VwLCBpbmRleCwgY2FsbGJhY2ssIHAsIGlzVW5kbykge1xuICAgIHZhciBiYWNrQnRuLFxuICAgICAgICBsZW5ndGgsXG4gICAgICAgIHNpYmxpbmdzLFxuICAgICAgICBzdWJsZXZlbCxcbiAgICAgICAgbWFwLFxuICAgICAgICBwcmVmLFxuICAgICAgICBjc3NDbGFzcyA9ICcnLFxuICAgICAgICAkcGFyZW50ID0gcCA9PT0gdW5kZWZpbmVkID8gZWxtIDogZ2V0SXRlbUJ5SUQocCksXG4gICAgICAgICRsaXN0ID0gJHBhcmVudCxcbiAgICAgICAgJGl0ZW0gPSB0eXBlb2YgbWFya3VwICE9PSAnb2JqZWN0JyA/ICQkMSgnPCcgKyBpdGVtTm9kZSArICcgZGF0YS1yZWY9XCInICsgZ3VpZCsrICsgJ1wiIGRhdGEtaWQ9XCInICsgaWQgKyAnXCI+JyArIG1hcmt1cCArICc8LycgKyBpdGVtTm9kZSArICc+JykgOiAkJDEobWFya3VwKSxcbiAgICAgICAgaXRlbSA9ICRpdGVtWzBdLFxuICAgICAgICBzdHlsZSA9IGl0ZW0uc3R5bGUsXG4gICAgICAgIGRpciA9ICRpdGVtLmF0dHIoJ2RhdGEtcG9zJykgPCAwID8gJ2xlZnQnIDogJ3JpZ2h0JyxcbiAgICAgICAgcmVmID0gJGl0ZW0uYXR0cignZGF0YS1yZWYnKTtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG5cbiAgICBpZiAoIXJlZikge1xuICAgICAgcmVmID0gZ3VpZCsrO1xuICAgICAgJGl0ZW0uYXR0cignZGF0YS1yZWYnLCByZWYpO1xuICAgIH1cblxuICAgIGluaXRJdGVtKCRpdGVtKTsgLy8gUHV0IGFjdGlvbiBpbiB1bmRvIHN0YWNrXG5cbiAgICBpZiAoIWlzVW5kbykge1xuICAgICAgdGhhdC5hZGRVbmRvQWN0aW9uKGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgIGlmIChzdWJsZXZlbCkge1xuICAgICAgICAgIHRoYXQubmF2aWdhdGUoJHBhcmVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJGxpc3QucmVtb3ZlKCk7XG4gICAgICAgICAgICAkcGFyZW50LnJlbW92ZUNsYXNzKCdtYnNjLWx2LXBhcmVudCcpLmNoaWxkcmVuKCcubWJzYy1sdi1hcnInKS5yZW1vdmUoKTtcbiAgICAgICAgICAgIG1hcC5jaGlsZCA9ICRwYXJlbnQuY2hpbGRyZW4obGlzdFNlbGVjdG9yKTtcbiAgICAgICAgICAgIHRoYXQucmVtb3ZlKCRpdGVtLCBudWxsLCBuZXh0LCB0cnVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGF0LnJlbW92ZSgkaXRlbSwgbnVsbCwgbmV4dCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRydWUpO1xuICAgIH1cblxuICAgIGRvQWN0aW9uKCRpdGVtLCBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgcmVzZXRJdGVtKCRpdGVtLmNzcygndG9wJywgJycpLnJlbW92ZUNsYXNzKCdtYnNjLWx2LWl0ZW0tdW5kbycpKTsgLy8gSWYgcGFyZW50IGlzIGEgbGlzdCBpdGVtLCBpbnNlcnQgbmV3IGVsZW1lbnQgaW4gdGhlIHN1Ymxpc3RcblxuICAgICAgaWYgKCRwYXJlbnQuaXMoaXRlbVNlbGVjdG9yKSkge1xuICAgICAgICBwcmVmID0gJHBhcmVudC5hdHRyKCdkYXRhLXJlZicpOyAvLyBJZiB0aGVyZSBpcyBubyBzdWJsaXN0IHlldCwgY3JlYXRlIGl0XG5cbiAgICAgICAgaWYgKCEkcGFyZW50LmNoaWxkcmVuKGxpc3RTZWxlY3RvcikubGVuZ3RoKSB7XG4gICAgICAgICAgc3VibGV2ZWwgPSB0cnVlO1xuICAgICAgICAgICRwYXJlbnQuYXBwZW5kKCc8JyArIGxpc3ROb2RlICsgJz48LycgKyBsaXN0Tm9kZSArICc+Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZWYgPSAkcGFyZW50LmNoaWxkcmVuKCcubWJzYy1sdi1iYWNrJykuYXR0cignZGF0YS1iYWNrJyk7XG4gICAgICB9XG5cbiAgICAgIG1hcCA9IHRyZWVNYXBbcHJlZl07XG5cbiAgICAgIGlmIChtYXApIHtcbiAgICAgICAgaWYgKCFtYXAuY2hpbGQubGVuZ3RoKSB7XG4gICAgICAgICAgJHBhcmVudC5hZGRDbGFzcygnbWJzYy1sdi1wYXJlbnQnKS5wcmVwZW5kKGh0bWxSaWdodCk7IC8vIFNldCBwYXJlbnQgdG8gYmUgdGhlIHN1Ymxpc3RcblxuICAgICAgICAgICRsaXN0ID0gJHBhcmVudC5jaGlsZHJlbihsaXN0U2VsZWN0b3IpLnByZXBlbmQoaHRtbExlZnQpLmFkZENsYXNzKCdtYnNjLWx2Jyk7XG4gICAgICAgICAgbWFwLmNoaWxkID0gJGxpc3Q7XG4gICAgICAgICAgJCQxKCcubWJzYy1sdi1iYWNrJywgJHBhcmVudCkuYXR0cignZGF0YS1iYWNrJywgcHJlZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJGxpc3QgPSBtYXAuY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHJlZU1hcFtyZWZdID0ge1xuICAgICAgICBpdGVtOiAkaXRlbSxcbiAgICAgICAgY2hpbGQ6ICRpdGVtLmNoaWxkcmVuKGxpc3RTZWxlY3RvciksXG4gICAgICAgIHBhcmVudDogJGxpc3QsXG4gICAgICAgIHJlZjogcHJlZlxuICAgICAgfTtcbiAgICAgIHNpYmxpbmdzID0gZ2V0Q2hpbGRyZW4oJGxpc3QpO1xuICAgICAgbGVuZ3RoID0gc2libGluZ3MubGVuZ3RoO1xuXG4gICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCB8fCBpbmRleCA9PT0gbnVsbCkge1xuICAgICAgICBpbmRleCA9IGxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzVW5kbykge1xuICAgICAgICBjc3NDbGFzcyA9ICdtYnNjLWx2LWl0ZW0tbmV3LScgKyAoaXNVbmRvID8gZGlyIDogJycpO1xuICAgICAgfVxuXG4gICAgICBpbml0QnJhbmNoKCRpdGVtLmFkZENsYXNzKGNzc0NsYXNzKSk7XG5cbiAgICAgIGlmIChpbmRleCAhPT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICBiYWNrQnRuID0gJCQxKCcubWJzYy1sdi1iYWNrJywgJGxpc3QpO1xuXG4gICAgICAgICAgaWYgKGJhY2tCdG4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAkaXRlbS5pbnNlcnRBZnRlcihiYWNrQnRuKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGxpc3QuYXBwZW5kKCRpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAkaXRlbS5pbnNlcnRCZWZvcmUoc2libGluZ3MuZXEoaW5kZXgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkaXRlbS5pbnNlcnRBZnRlcihzaWJsaW5ncy5lcShsZW5ndGggLSAxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29udC50cmlnZ2VyKCdtYnNjLXJlZnJlc2gnKTsgLy8gSWYgY3VycmVudCBsZXZlbCBpcyB2aXNpYmxlXG5cbiAgICAgIGlmIChzLmFuaW1hdGVBZGRSZW1vdmUgJiYgJGxpc3QuaGFzQ2xhc3MoJ21ic2MtbHYtdicpKSB7XG4gICAgICAgIC8vIERvbid0IHJ1biBleHBhbmQgYW5pbWF0aW9uIGlmIGFkZCBpcyBydW5uaW5nIG9uIHRoZSBcInVuZG9cIiBlbGVtZW50XG4gICAgICAgIHN0eWxlLmhlaWdodCA9IGl0ZW0ub2Zmc2V0SGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgdGhhdC5hbmltYXRlKCRpdGVtLCBpc1VuZG8gJiYgdW5kb1JlZiA9PT0gcmVmID8gJ25vbmUnIDogJ2V4cGFuZCcsIGZ1bmN0aW9uICgkaXRlbSkge1xuICAgICAgICAgIHRoYXQuYW5pbWF0ZSgkaXRlbSwgaXNVbmRvID8gJ2FkZC0nICsgZGlyIDogJ3BvcC1pbicsIGZ1bmN0aW9uICgkaXRlbSkge1xuICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gJyc7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKGUsICRpdGVtLnJlbW92ZUNsYXNzKGNzc0NsYXNzKSk7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbChlLCAkaXRlbS5yZW1vdmVDbGFzcyhjc3NDbGFzcykpO1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50KCdvbkl0ZW1BZGQnLCB7XG4gICAgICAgIHRhcmdldDogaXRlbVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFN3aXBlIGEgbGlzdCBpdGVtIHByb2dyYW1hdGljYWxseVxyXG4gICAqL1xuXG5cbiAgdGhhdC5zd2lwZSA9IGZ1bmN0aW9uIChsaSwgcGVyY2VudCwgdGltZSwgZGVtbywgY2FsbGJhY2spIHtcbiAgICB2YXIgcHJldlBvcztcbiAgICBsaSA9IGdldEl0ZW1CeUlEKGxpKTtcbiAgICBpdGVtID0gbGk7XG4gICAgZGVtb01vZGUgPSBkZW1vO1xuICAgIHNpbXVsYXRpbmcgPSB0cnVlO1xuICAgIGFjdGlvbiA9IHRydWU7XG4gICAgdGltZSA9IHRpbWUgPT09IHVuZGVmaW5lZCA/IDMwMCA6IHRpbWU7XG4gICAgZGlmZlggPSBwZXJjZW50ID4gMCA/IDEgOiAtMTtcbiAgICBvbkFjdGlvblN0YXJ0KCk7XG4gICAgb25Td2lwZVN0YXJ0KCk7XG4gICAgc2xpZGUobGksIHBlcmNlbnQsIHRpbWUpO1xuICAgIGNsZWFyVGltZW91dChzd2lwZVRpbWVvdXQpO1xuICAgIGNsZWFySW50ZXJ2YWwoc3dpcGVJbnRlcnZhbCk7XG4gICAgc3dpcGVJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIHByZXZQb3MgPSBhbmltUG9zO1xuICAgICAgYW5pbVBvcyA9IGdldFBvc2l0aW9uKGxpKSAvIGl0ZW13ICogMTAwO1xuICAgICAgb25Td2lwZU1vdmUocHJldlBvcyk7XG4gICAgfSwgMTApO1xuICAgIHN3aXBlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgY2xlYXJJbnRlcnZhbChzd2lwZUludGVydmFsKTtcbiAgICAgIHByZXZQb3MgPSBhbmltUG9zO1xuICAgICAgYW5pbVBvcyA9IHBlcmNlbnQ7IC8vIFdlIG5lZWQgb25lIGFkZGl0aW9uYWwgbW92ZSB3aXRoIHRoZSBmaW5hbCBwZXJjZW50IHRvIGdldCB0aGUgY29ycmVjdCBzdGFnZVxuXG4gICAgICBvblN3aXBlTW92ZShwcmV2UG9zKTtcbiAgICAgIG9uU3dpcGVFbmQoY2FsbGJhY2spO1xuICAgICAgZGVtb01vZGUgPSBmYWxzZTtcbiAgICAgIHNpbXVsYXRpbmcgPSBmYWxzZTtcbiAgICAgIGFjdGlvbiA9IGZhbHNlO1xuICAgIH0sIHRpbWUpO1xuICB9O1xuXG4gIHRoYXQub3BlblN0YWdlID0gZnVuY3Rpb24gKGxpLCBzdGFnZSwgdGltZSwgZGVtbykge1xuICAgIGlmIChzdGFnZU9ialtzdGFnZV0pIHtcbiAgICAgIHRoYXQuc3dpcGUobGksIHN0YWdlT2JqW3N0YWdlXS5wZXJjZW50LCB0aW1lLCBkZW1vKTtcbiAgICB9XG4gIH07XG5cbiAgdGhhdC5vcGVuQWN0aW9ucyA9IGZ1bmN0aW9uIChsaSwgZGlyLCB0aW1lLCBkZW1vKSB7XG4gICAgbGkgPSBnZXRJdGVtQnlJRChsaSk7XG4gICAgdmFyIHBlcmNlbnQgPSBnZXRBY3Rpb25XaWR0aCh0eXBlc1tsaS5hdHRyKCdkYXRhLXR5cGUnKSB8fCAnZGVmYXVsdHMnXSwgZGlyID09ICdsZWZ0JyA/IC0xIDogMSk7XG4gICAgdGhhdC5zd2lwZShsaSwgZGlyID09ICdsZWZ0JyA/IC1wZXJjZW50IDogcGVyY2VudCwgdGltZSwgZGVtbyk7XG4gIH07XG5cbiAgdGhhdC5jbG9zZSA9IGZ1bmN0aW9uIChsaSwgdGltZSkge1xuICAgIHRoYXQuc3dpcGUobGksIDAsIHRpbWUpO1xuICB9O1xuICAvKipcclxuICAgKiBSZW1vdmUgYSBsaXN0IGl0ZW1cclxuICAgKi9cblxuXG4gIHRoYXQucmVtb3ZlID0gZnVuY3Rpb24gKGlkLCBkaXIsIGNhbGxiYWNrLCBpc1VuZG8pIHtcbiAgICB2YXIgJGl0ZW0sICRwYXJlbnQsIGFuaW0sIGluZGV4LCByZWYsIHNob3VsZE5hdmlnYXRlLCBzdHlsZTtcblxuICAgIGZ1bmN0aW9uIGRlbGV0ZVN1YlRyZWUoJGNoaWxkKSB7XG4gICAgICBpZiAoJGNoaWxkKSB7XG4gICAgICAgIHNob3VsZE5hdmlnYXRlID0gc2hvdWxkTmF2aWdhdGUgfHwgJGNoaWxkLmhhc0NsYXNzKCdtYnNjLWx2LXYnKTtcbiAgICAgICAgJGNoaWxkLmNoaWxkcmVuKCdbZGF0YS1yZWZdJykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHJlZiA9ICQkMSh0aGlzKS5hdHRyKCdkYXRhLXJlZicpO1xuXG4gICAgICAgICAgaWYgKHRyZWVNYXBbcmVmXSkge1xuICAgICAgICAgICAgZGVsZXRlU3ViVHJlZSh0cmVlTWFwW3JlZl0uY2hpbGQpO1xuICAgICAgICAgICAgZGVsZXRlIHRyZWVNYXBbcmVmXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcbiAgICAkaXRlbSA9IGdldEl0ZW1CeUlEKGlkKTtcbiAgICByZWYgPSAkaXRlbS5hdHRyKCdkYXRhLXJlZicpO1xuXG4gICAgaWYgKCRpdGVtLmxlbmd0aCAmJiB0cmVlTWFwW3JlZl0pIHtcbiAgICAgICRwYXJlbnQgPSAkaXRlbS5wYXJlbnQoKTtcbiAgICAgIGluZGV4ID0gZ2V0Q2hpbGRyZW4oJHBhcmVudCkuaW5kZXgoJGl0ZW0pO1xuICAgICAgc3R5bGUgPSAkaXRlbVswXS5zdHlsZTtcbiAgICAgIGRlbGV0ZVN1YlRyZWUodHJlZU1hcFtyZWZdLmNoaWxkKTtcblxuICAgICAgaWYgKHNob3VsZE5hdmlnYXRlKSB7XG4gICAgICAgIGFuaW0gPSBzLmFuaW1hdGlvbjtcbiAgICAgICAgcy5hbmltYXRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhhdC5uYXZpZ2F0ZSgkaXRlbSk7XG4gICAgICAgIHMuYW5pbWF0aW9uID0gYW5pbTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIHRyZWVNYXBbcmVmXTsgLy8gUHV0IGFjdGlvbiBpbiB1bmRvIHN0YWNrXG5cbiAgICAgIGlmICghaXNVbmRvKSB7XG4gICAgICAgIC8vIElmIHVuZG8gZWxlbWVudCBpcyByZW1vdmVkLCB1bmRvIHBsYWNlaG9sZGVyIHNob3VsZCBiZSByZW1vdmVkIHdpdGggYW5pbWF0aW9uXG4gICAgICAgIGlmICgkaXRlbS5hdHRyKCdkYXRhLXJlZicpID09PSB1bmRvUmVmKSB7XG4gICAgICAgICAgdW5kb0FuaW0gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdC5hZGRVbmRvQWN0aW9uKGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgICAgdGhhdC5hZGQobnVsbCwgJGl0ZW0sIGluZGV4LCBuZXh0LCAkcGFyZW50LCB0cnVlKTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGRvQWN0aW9uKCRpdGVtLCBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgICBkaXIgPSBkaXIgfHwgKCRpdGVtLmF0dHIoJ2RhdGEtcG9zJykgPCAwID8gJ2xlZnQnIDogJ3JpZ2h0Jyk7XG5cbiAgICAgICAgaWYgKHMuYW5pbWF0ZUFkZFJlbW92ZSAmJiAkcGFyZW50Lmhhc0NsYXNzKCdtYnNjLWx2LXYnKSkge1xuICAgICAgICAgIHRoYXQuYW5pbWF0ZSgkaXRlbS5hZGRDbGFzcygnbWJzYy1sdi1yZW1vdmVkJyksIGlzVW5kbyA/ICdwb3Atb3V0JyA6ICdyZW1vdmUtJyArIGRpciwgZnVuY3Rpb24gKCRpdGVtKSB7XG4gICAgICAgICAgICBzdHlsZS5oZWlnaHQgPSAkaXRlbVswXS5vZmZzZXRIZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgdGhhdC5hbmltYXRlKCRpdGVtLCAnY29sbGFwc2UnLCBmdW5jdGlvbiAoJGl0ZW0pIHtcbiAgICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gJyc7XG4gICAgICAgICAgICAgIHJlc2V0SXRlbSgkaXRlbS5yZW1vdmVDbGFzcygnbWJzYy1sdi1yZW1vdmVkJykpO1xuXG4gICAgICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKGUsICRpdGVtKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAkaXRlbS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKGUsICRpdGVtKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICRpdGVtLnJlbW92ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50KCdvbkl0ZW1SZW1vdmUnLCB7XG4gICAgICAgICAgdGFyZ2V0OiAkaXRlbVswXVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogTW92ZXMgYW4gaXRlbSBpbiB0aGUgbGlzdFxyXG4gICAqL1xuXG5cbiAgdGhhdC5tb3ZlID0gZnVuY3Rpb24gKGxpLCBpbmRleCwgZGlyLCBjYWxsYmFjaywgcCwgaXNVbmRvKSB7XG4gICAgbGkgPSBnZXRJdGVtQnlJRChsaSk7IC8vaWYgKGdldENoaWxkcmVuKGxpLnBhcmVudCgpKS5pbmRleChsaSkgIT09IGluZGV4KSB7XG5cbiAgICBpZiAoIWlzVW5kbykge1xuICAgICAgdGhhdC5zdGFydEFjdGlvblRyYWNrKCk7XG4gICAgfVxuXG4gICAgc3RhZ2VjLmFwcGVuZChpY29uYyk7XG4gICAgdGhhdC5yZW1vdmUobGksIGRpciwgbnVsbCwgaXNVbmRvKTtcbiAgICB0aGF0LmFkZChudWxsLCBsaSwgaW5kZXgsIGNhbGxiYWNrLCBwLCBpc1VuZG8pO1xuXG4gICAgaWYgKCFpc1VuZG8pIHtcbiAgICAgIHRoYXQuZW5kQWN0aW9uVHJhY2soKTtcbiAgICB9IC8vfVxuXG4gIH07XG4gIC8qKlxyXG4gICAqIE5hdmlnYXRlIGFuZCBzY3JvbGwgdG8gdGhlIGdpdmVuIGVsZW1lbnRcclxuICAgKi9cblxuXG4gIHRoYXQubmF2aWdhdGUgPSBmdW5jdGlvbiAoaXRlbSwgY2FsbGJhY2spIHtcbiAgICB2YXIgbWFwLCBsZXZlbDtcbiAgICBpdGVtID0gZ2V0SXRlbUJ5SUQoaXRlbSk7XG4gICAgbWFwID0gdHJlZU1hcFtpdGVtLmF0dHIoJ2RhdGEtcmVmJyldO1xuICAgIGxldmVsID0gZ2V0SXRlbUxldmVsKGl0ZW0pO1xuXG4gICAgaWYgKG1hcCkge1xuICAgICAgZHJpbGwobGV2ZWwgPj0gc2xpZGVMZXZlbCA/ICdyJyA6ICdsJywgbWFwLnBhcmVudCwgaXRlbSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgc2xpZGVMZXZlbCA9IGxldmVsO1xuICAgIH1cbiAgfTtcblxuICB0aGF0LnNob3dMb2FkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIGlzTG9hZGluZyA9IHRydWU7XG4gICAgbG9hZGluZy5hZGRDbGFzcygnbWJzYy1zaG93LWx2LWxvYWRpbmcnKTtcbiAgICB3bmQuc2Nyb2xsVG9wKGhhc0NvbnRleHQgPyB3bmQwLnNjcm9sbEhlaWdodCA6ICQkMShzLmNvbnRleHQpWzBdLnNjcm9sbEhlaWdodCk7XG4gIH07XG5cbiAgdGhhdC5oaWRlTG9hZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBsb2FkaW5nLnJlbW92ZUNsYXNzKCdtYnNjLXNob3ctbHYtbG9hZGluZycpOyAvLyBOZWVkcyB0aW1lb3V0IHRvIHByZXZlbnQgdHJpZ2dlcmluZyBcbiAgICAvLyB0aGUgb25MaXN0RW5kIGV2ZW50IGZyb20gdGhlIHNjcm9sbCBsaXN0ZW5lclxuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpc0xvYWRpbmcgPSBmYWxzZTtcbiAgICB9LCAxMDApO1xuICB9O1xuXG4gIHRoYXQuc2VsZWN0ID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoIW11bHRpcGxlKSB7XG4gICAgICBkZXNlbGVjdEl0ZW0oJCQxKGl0ZW1TZWxlY3RvciwgY29udCkuZmlsdGVyKCcuJyArIFNFTEVDVEVEX0NMQVNTKSk7XG4gICAgfVxuXG4gICAgc2VsZWN0SXRlbShnZXRJdGVtQnlJRChpdGVtKSk7XG4gIH07XG5cbiAgdGhhdC5kZXNlbGVjdCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgZGVzZWxlY3RJdGVtKGdldEl0ZW1CeUlEKGl0ZW0pKTtcbiAgfTtcblxuICB0aGF0Ll9wcm9jZXNzU2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsbS5pcygnW21ic2MtZW5oYW5jZV0nKSkge1xuICAgICAgaGFkRW5oYW5jZSA9IHRydWU7XG4gICAgICBlbG0ucmVtb3ZlQXR0cignbWJzYy1lbmhhbmNlJyk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBMaXN0dmlldyBpbml0aWFsaXphdGlvbi5cclxuICAgKi9cblxuXG4gIHRoYXQuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnRDbGFzcyxcbiAgICAgICAgaGVhZGVyQ2xhc3MsXG4gICAgICAgIHNvcnRhYmxlLFxuICAgICAgICBkZWZTb3J0SGFuZGxlID0gZWxtLmZpbmQobGlzdFNlbGVjdG9yKS5sZW5ndGggPyAnbGVmdCcgOiAncmlnaHQnLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgaWNvbnMgPSAnJyxcbiAgICAgICAgaWNvbnNMZWZ0ID0gJycsXG4gICAgICAgIGljb25zUmlnaHQgPSAnJztcbiAgICBsaXN0Tm9kZSA9IHMubGlzdE5vZGU7XG4gICAgbGlzdFNlbGVjdG9yID0gcy5saXN0U2VsZWN0b3I7XG4gICAgaXRlbU5vZGUgPSBzLml0ZW1Ob2RlO1xuICAgIGl0ZW1TZWxlY3RvciA9IHMuaXRlbVNlbGVjdG9yO1xuICAgIG11bHRpcGxlID0gcy5zZWxlY3QgPT0gJ211bHRpcGxlJztcbiAgICBzZWxlY3RhYmxlID0gcy5zZWxlY3QgIT0gJ29mZic7IC8vIC0tLSBUUklBTCBTRVJWRVIgQ09ERSBTVEFSVCAtLS1cblxuICAgIHNvcnRhYmxlID0gcy5zb3J0IHx8IHMuc29ydGFibGUgfHwgZmFsc2U7IC8vIEJhY2t3YXJkIGNvbXBhdGlibGl0eSBmb3IgJ2dyb3VwJyBhbmQgc29ydEhhbmRsZSBzZXR0aW5nc1xuICAgIC8vIC0tLVxuXG4gICAgaWYgKHNvcnRhYmxlID09PSAnZ3JvdXAnKSB7XG4gICAgICBzb3J0YWJsZSA9IHtcbiAgICAgICAgZ3JvdXA6IGZhbHNlLFxuICAgICAgICBtdWx0aUxldmVsOiB0cnVlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmIChzb3J0YWJsZSA9PT0gdHJ1ZSkge1xuICAgICAgc29ydGFibGUgPSB7XG4gICAgICAgIGdyb3VwOiB0cnVlLFxuICAgICAgICBtdWx0aUxldmVsOiB0cnVlLFxuICAgICAgICBoYW5kbGU6IHMuc29ydEhhbmRsZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoc29ydGFibGUgJiYgc29ydGFibGUuaGFuZGxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHNvcnRhYmxlLmhhbmRsZSA9IHMuc29ydEhhbmRsZTtcbiAgICB9IC8vIC0tLVxuXG5cbiAgICBpZiAoc29ydGFibGUuaGFuZGxlKSB7XG4gICAgICBoYW5kbGVQb3MgPSBzb3J0YWJsZS5oYW5kbGUgPT09IHRydWUgPyBkZWZTb3J0SGFuZGxlIDogc29ydGFibGUuaGFuZGxlO1xuICAgICAgaGFuZGxlRGl2ID0gJzxkaXYgY2xhc3M9XCJtYnNjLWx2LWhhbmRsZS1jIG1ic2MtbHYtaXRlbS1oLScgKyBoYW5kbGVQb3MgKyAnIG1ic2MtbHYtaGFuZGxlXCI+PGRpdiBjbGFzcz1cIicgKyBzLmhhbmRsZUNsYXNzICsgJyBtYnNjLWx2LWhhbmRsZS1iYXItYyBtYnNjLWx2LWhhbmRsZVwiPicgKyBzLmhhbmRsZU1hcmt1cCArICc8L2Rpdj48L2Rpdj4nO1xuICAgIH1cblxuICAgIGh0bWxMZWZ0ID0gJzwnICsgaXRlbU5vZGUgKyAnIGNsYXNzPVwibWJzYy1sdi1pdGVtIG1ic2MtbHYtYmFjayBtYnNjLWx2LWl0ZW0tYWN0aW9uYWJsZVwiPicgKyBzLmJhY2tUZXh0ICsgJzxkaXYgY2xhc3M9XCJtYnNjLWx2LWFyciBtYnNjLWx2LWljIG1ic2MtaWMgJyArIHMubGVmdEFycm93Q2xhc3MgKyAnXCI+PC9kaXY+PC8nICsgaXRlbU5vZGUgKyAnPic7XG4gICAgaHRtbFJpZ2h0ID0gJzxkaXYgY2xhc3M9XCJtYnNjLWx2LWFyciBtYnNjLWx2LWljIG1ic2MtaWMgJyArIHMucmlnaHRBcnJvd0NsYXNzICsgJ1wiPjwvZGl2Pic7XG4gICAgY29udENsYXNzID0gJ21ic2Mtbm8tdG91Y2ggbWJzYy1sdi1jb250IG1ic2MtbHYtJyArIHMudGhlbWUgKyAnIG1ic2MtJyArIHMudGhlbWUgKyAoaGFsZkJvcmRlciQyID8gJyBtYnNjLWx2LWhiJyA6ICcnKSArIChzLnJ0bCA/ICcgbWJzYy1sdi1ydGwgbWJzYy1ydGwnIDogJyBtYnNjLWx0cicpICsgKHMuYmFzZVRoZW1lID8gJyBtYnNjLWx2LScgKyBzLmJhc2VUaGVtZSArICcgbWJzYy0nICsgcy5iYXNlVGhlbWUgOiAnJykgKyAocy5hbmltYXRlSWNvbnMgPyAnIG1ic2MtbHYtaWMtYW5pbScgOiAnJykgKyAocy5zdHJpcGVkID8gJyBtYnNjLWx2LWFsdC1yb3cnIDogJycpICsgKHMuZml4ZWRIZWFkZXIgPyAnIG1ic2MtbHYtaGFzLWZpeGVkLWhlYWRlcicgOiAnJykgKyAoc29ydGFibGUuaGFuZGxlID8gJyBtYnNjLWx2LWhhbmRsZS0nICsgaGFuZGxlUG9zIDogJycpOyAvLyAtLS0gVFJJQUwgU0VSVkVSIENPREUgRU5EIC0tLVxuXG4gICAgdGhhdC5zb3J0YWJsZSA9IHNvcnRhYmxlIHx8IGZhbHNlO1xuXG4gICAgaWYgKCFjb250KSB7XG4gICAgICAvLyBJY29uIG1lbnUgY29udGFpbmVyXG4gICAgICBpY29ucyArPSAnPGRpdiBjbGFzcz1cIm1ic2MtbHYtbXVsdGktY1wiPjwvZGl2Pic7IC8vIFN0YWdlIGljb25zIGNvbnRhaW5lclxuXG4gICAgICBpY29ucyArPSAnPGRpdiBjbGFzcz1cIm1ic2MtbHYtaWMtY1wiPjxkaXYgY2xhc3M9XCJtYnNjLWx2LWljLXMgbWJzYy1sdi1pYyBtYnNjLWljIG1ic2MtaWMtbm9uZVwiPjwvZGl2PjxkaXYgY2xhc3M9XCJtYnNjLWx2LWljLXRleHRcIj48L2Rpdj48L2Rpdj4nOyAvLyBBZGQgY2xhc3Nlc1xuXG4gICAgICBlbG0uYWRkQ2xhc3MoJ21ic2MtbHYgbWJzYy1sdi12IG1ic2MtbHYtcm9vdCcpLnJlbW92ZUNsYXNzKCdtYnNjLWNsb2FrJykuc2hvdygpO1xuICAgICAgc3RhZ2VjID0gJCQxKCc8ZGl2IGNsYXNzPVwibWJzYy1sdi1zdGFnZS1jXCI+JyArIGljb25zICsgJzwvZGl2PicpO1xuICAgICAgaWNvbmMgPSAkJDEoJy5tYnNjLWx2LWljLWMnLCBzdGFnZWMpO1xuICAgICAgbXVsdGljID0gJCQxKCcubWJzYy1sdi1tdWx0aS1jJywgc3RhZ2VjKTtcbiAgICAgIGljb24gPSAkJDEoJy5tYnNjLWx2LWljLXMnLCBzdGFnZWMpO1xuICAgICAgdGV4dCA9ICQkMSgnLm1ic2MtbHYtaWMtdGV4dCcsIHN0YWdlYyk7XG4gICAgICBwbGFjZWhvbGRlciA9ICQkMSgnPCcgKyBpdGVtTm9kZSArICcgY2xhc3M9XCJtYnNjLWx2LWl0ZW0gbWJzYy1sdi1waFwiPjwvJyArIGl0ZW1Ob2RlICsgJz4nKTtcbiAgICAgIGZpbGwgPSAkJDEoJzxkaXYgY2xhc3M9XCJtYnNjLWx2LWZpbGwtaXRlbVwiPjwvZGl2PicpO1xuICAgICAgY29udCA9ICQkMSgnPGRpdiBjbGFzcz1cIicgKyBjb250Q2xhc3MgKyAnXCI+PCcgKyBsaXN0Tm9kZSArICcgY2xhc3M9XCJtYnNjLWx2IG1ic2MtbHYtZHVtbXlcIj48LycgKyBsaXN0Tm9kZSArICc+PGRpdiBjbGFzcz1cIm1ic2MtbHYtc2wtY1wiPjwvZGl2PicgKyAnPGRpdiBjbGFzcz1cIm1ic2MtbHYtbG9hZGluZ1wiPjxzcGFuIGNsYXNzPVwibWJzYy1pYyBtYnNjLWljLScgKyAocy5sb2FkaW5nSWNvbiB8fCAnbG9vcDInKSArICdcIj48L3NwYW4+PC9kaXY+PC9kaXY+Jyk7XG4gICAgICBjb250MCA9IGNvbnRbMF07XG4gICAgICBkdW1teUNvbnQgPSAkJDEoJy5tYnNjLWx2LWR1bW15JywgY29udCk7XG4gICAgICBsb2FkaW5nID0gJCQxKCcubWJzYy1sdi1sb2FkaW5nJywgY29udCk7XG4gICAgICBjb250Lmluc2VydEFmdGVyKGVsbSk7XG4gICAgICBvblJlc2l6ZSgpOyAvLyBTbGlkZSBldmVudHNcblxuICAgICAgbGlzdGVuKGNvbnQwLCAnbW91c2Vkb3duJywgb25TdGFydCk7XG4gICAgICBsaXN0ZW4oZG9jdW1lbnQsICd0b3VjaHN0YXJ0Jywgb25TdGFydCwge1xuICAgICAgICBwYXNzaXZlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBsaXN0ZW4oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCBvbk1vdmUsIHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgY29udC5vbigndG91Y2hlbmQgdG91Y2hjYW5jZWwnLCAnLm1ic2MtbHYtaXRlbScsIG9uRW5kKS5vbignY2xpY2snLCAnLm1ic2MtbHYtaXRlbScsIG9uQ2xpY2spOyAvLyBQcmV2ZW50IGNsaWNrIG9uIHN3aXBlXG5cbiAgICAgIGxpc3RlbihlLCAnY2xpY2snLCBvbkxpc3RDbGljaywgdHJ1ZSk7IC8vIEluaXQgYWN0aW9uIGljb25zXG4gICAgICAvLyAtLS1cblxuICAgICAgbGlzdGVuKGNvbnQwLCAnbW91c2Vkb3duJywgb25JY29uU3RhcnQpO1xuICAgICAgbGlzdGVuKGRvY3VtZW50LCAndG91Y2hzdGFydCcsIG9uSWNvblN0YXJ0LCB7XG4gICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIGNvbnQub24oJ3RvdWNoZW5kIG1vdXNldXAnLCAnLm1ic2MtbHYtaWMtbScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICBpZiAoIWRlbW9Nb2RlKSB7XG4gICAgICAgICAgaWYgKGV2LnR5cGUgPT09ICd0b3VjaGVuZCcpIHtcbiAgICAgICAgICAgIHByZXZlbnRDbGljaygpO1xuICAgICAgICAgIH0gLy8gSWYgbW92ZW1lbnQgaXMgbGVzcyB0aGFuIDEwcHgsIGZpcmUgdGhlIGNsaWNrIGV2ZW50IGhhbmRsZXJcblxuXG4gICAgICAgICAgaWYgKGNvbmZpcm1zICYmICEkJDEodGhpcykuaGFzQ2xhc3MoJ21ic2MtbHYtaWMtZGlzYWJsZWQnKSAmJiBNYXRoLmFicyhnZXRDb29yZChldiwgJ1gnKSAtIHN0YXJ0WCkgPCAxMCAmJiBNYXRoLmFicyhnZXRDb29yZChldiwgJ1knKSAtIHN0YXJ0WSkgPCAxMCkge1xuICAgICAgICAgICAgcnVuQWN0aW9uKChhbmltUG9zIDwgMCA/IHR5cGUucmlnaHRNZW51IDogdHlwZS5sZWZ0TWVudSlbJCQxKHRoaXMpLmluZGV4KCldLCBjb25maXJtSXRlbSwgY29uZmlybUluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyAtLS1cbiAgICAgIC8vIEluaXQgaGllcmFyY2hpY2FsIG5hdmlnYXRpb25cbiAgICAgIC8vIC0tLVxuXG4gICAgICBzbGlkZUNvbnQgPSAkJDEoJy5tYnNjLWx2LXNsLWMnLCBjb250KS5hcHBlbmQoZWxtLmFkZENsYXNzKCdtYnNjLWx2LXNsLWN1cnInKSkuYXR0cignZGF0YS1yZWYnLCBndWlkKyspO1xuICAgICAgY3Vyckxpc3QgPSBlbG07XG4gICAgICBjdXJyUGFyZW50ID0gY29udDsgLy8gLS0tXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnQuYXR0cignY2xhc3MnLCBjb250Q2xhc3MpOyAvLyByZWluaXQgc29ydCBoYW5kbGVzXG5cbiAgICAgICQkMSgnLm1ic2MtbHYtaGFuZGxlLWMnLCBjb250KS5yZW1vdmUoKTsgLy8gcmVtb3ZlIHRvIHJlaW5pdCBsaXN0IGl0ZW1zXG5cbiAgICAgICQkMShpdGVtU2VsZWN0b3IsIGNvbnQpLm5vdCgnLm1ic2MtbHYtYmFjaycpLnJlbW92ZUNsYXNzKCdtYnNjLWx2LWl0ZW0nKTtcbiAgICAgIHVubGlzdGVuKHduZDAsICdvcmllbnRhdGlvbmNoYW5nZScsIG9uUmVzaXplKTtcbiAgICAgIHVubGlzdGVuKHduZDAsICdyZXNpemUnLCBvblJlc2l6ZSk7XG4gICAgICB1bmxpc3Rlbih3bmQwLCAnc2Nyb2xsJywgb25TY3JvbGxCb3R0b20pO1xuICAgICAgdW5saXN0ZW4od25kMCwgJ3RvdWNobW92ZScsIG9uU2Nyb2xsQm90dG9tLCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAob25TY3JvbGxUaHJvdHRsZSkge1xuICAgICAgICB1bmxpc3Rlbih3bmQwLCAnc2Nyb2xsJywgb25TY3JvbGxUaHJvdHRsZSk7XG4gICAgICAgIHVubGlzdGVuKHduZDAsICd0b3VjaG1vdmUnLCBvblNjcm9sbFRocm90dGxlLCB7XG4gICAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYXNDb250ZXh0ID0gcy5jb250ZXh0ICE9PSAnYm9keSc7XG4gICAgd25kID0gJCQxKGhhc0NvbnRleHQgPyBzLmNvbnRleHQgOiB3aW5kb3cpO1xuICAgIHduZDAgPSB3bmRbMF07IC8vIFJlY2FsY3VsYXRlIHNpemVzIG9uIHJlc2l6ZSAvIG9yaWVudGF0aW9uY2hhbmdlXG5cbiAgICBsaXN0ZW4od25kMCwgJ29yaWVudGF0aW9uY2hhbmdlJywgb25SZXNpemUpO1xuICAgIGxpc3Rlbih3bmQwLCAncmVzaXplJywgb25SZXNpemUpO1xuICAgIGxpc3Rlbih3bmQwLCAnc2Nyb2xsJywgb25TY3JvbGxCb3R0b20pO1xuICAgIGxpc3Rlbih3bmQwLCAndG91Y2htb3ZlJywgb25TY3JvbGxCb3R0b20sIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTsgLy8gSW5pdCBzdGFnZXMgYW5kIGFjdGlvbnNcbiAgICAvLyAtLS1cblxuICAgIHN0YWdlTnIgPSAwO1xuICAgIHR5cGVzID0gcy5pdGVtR3JvdXBzIHx8IHt9O1xuICAgIHR5cGVzLmRlZmF1bHRzID0ge1xuICAgICAgc3dpcGVsZWZ0OiBzLnN3aXBlbGVmdCxcbiAgICAgIHN3aXBlcmlnaHQ6IHMuc3dpcGVyaWdodCxcbiAgICAgIHN0YWdlczogcy5zdGFnZXMsXG4gICAgICBhY3Rpb25zOiBzLmFjdGlvbnMsXG4gICAgICBhY3Rpb25zV2lkdGg6IHMuYWN0aW9uc1dpZHRoLFxuICAgICAgYWN0aW9uYWJsZTogcy5hY3Rpb25hYmxlXG4gICAgfTtcbiAgICBpbml0QnJhbmNoKGVsbSk7XG4gICAgJCQxLmVhY2godHlwZXMsIGZ1bmN0aW9uIChuLCB2KSB7XG4gICAgICB2LnN3aXBlID0gdi5zd2lwZSAhPT0gdW5kZWZpbmVkID8gdi5zd2lwZSA6IHMuc3dpcGU7XG4gICAgICB2LmFjdGlvbmFibGUgPSB2LmFjdGlvbmFibGUgIT09IHVuZGVmaW5lZCA/IHYuYWN0aW9uYWJsZSA6IHMuYWN0aW9uYWJsZTtcbiAgICAgIHYuc3RhZ2VzID0gdi5zdGFnZXMgfHwgW107IC8vIEluaXQgc3RhZ2VzXG5cbiAgICAgIHByb2Nlc3NTdGFnZXModi5zdGFnZXMsIDEsIHRydWUpO1xuICAgICAgcHJvY2Vzc1N0YWdlcyh2LnN0YWdlcy5sZWZ0LCAxKTtcbiAgICAgIHByb2Nlc3NTdGFnZXModi5zdGFnZXMucmlnaHQsIC0xKTtcblxuICAgICAgaWYgKHYuc3RhZ2VzLmxlZnQgfHwgdi5zdGFnZXMucmlnaHQpIHtcbiAgICAgICAgdi5zdGFnZXMgPSBbXS5jb25jYXQodi5zdGFnZXMubGVmdCB8fCBbXSwgdi5zdGFnZXMucmlnaHQgfHwgW10pO1xuICAgICAgfVxuXG4gICAgICBmb3VuZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoIXYuc3RhZ2VzLmxlbmd0aCkge1xuICAgICAgICBpZiAodi5zd2lwZWxlZnQpIHtcbiAgICAgICAgICB2LnN0YWdlcy5wdXNoKHtcbiAgICAgICAgICAgIHBlcmNlbnQ6IC0zMCxcbiAgICAgICAgICAgIGFjdGlvbjogdi5zd2lwZWxlZnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2LnN3aXBlcmlnaHQpIHtcbiAgICAgICAgICB2LnN0YWdlcy5wdXNoKHtcbiAgICAgICAgICAgIHBlcmNlbnQ6IDMwLFxuICAgICAgICAgICAgYWN0aW9uOiB2LnN3aXBlcmlnaHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAkJDEuZWFjaCh2LnN0YWdlcywgZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgICAgLy8gZmluZCB0aGUgMFxuICAgICAgICBpZiAodi5wZXJjZW50ID09PSAwKSB7XG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgdi5zdGFnZXMucHVzaCh7XG4gICAgICAgICAgcGVyY2VudDogMFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdi5zdGFnZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5wZXJjZW50IC0gYi5wZXJjZW50O1xuICAgICAgfSk7XG4gICAgICAkJDEuZWFjaCh2LnN0YWdlcywgZnVuY3Rpb24gKGksIHMpIHtcbiAgICAgICAgLy8gZmluZCB0aGUgMFxuICAgICAgICBpZiAocy5wZXJjZW50ID09PSAwKSB7XG4gICAgICAgICAgdi5zdGFydCA9IGk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgIHYubGVmdCA9IHYucmlnaHQgPSB2LnN0YWdlc1t2LnN0YXJ0XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYubGVmdCA9IHYuc3RhZ2VzW3Yuc3RhcnQgLSAxXSB8fCB7fTtcbiAgICAgICAgdi5yaWdodCA9IHYuc3RhZ2VzW3Yuc3RhcnQgKyAxXSB8fCB7fTtcbiAgICAgIH0gLy8gSW5pdCBhY3Rpb25zXG5cblxuICAgICAgaWYgKHYuYWN0aW9ucykge1xuICAgICAgICB2LmxlZnRNZW51ID0gdi5hY3Rpb25zLmxlZnQgfHwgdi5hY3Rpb25zO1xuICAgICAgICB2LnJpZ2h0TWVudSA9IHYuYWN0aW9ucy5yaWdodCB8fCB2LmxlZnRNZW51O1xuICAgICAgICBpY29uc0xlZnQgPSAnJztcbiAgICAgICAgaWNvbnNSaWdodCA9ICcnO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2LmxlZnRNZW51Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWNvbnNMZWZ0ICs9ICc8ZGl2ICcgKyAodi5sZWZ0TWVudVtpXS5jb2xvciA/ICdzdHlsZT1cImJhY2tncm91bmQtY29sb3I6ICcgKyB2LmxlZnRNZW51W2ldLmNvbG9yICsgJ1wiJyA6ICcnKSArICcgY2xhc3M9XCJtYnNjLWx2LWljLW0gbWJzYy1sdi1pYyBtYnNjLWljIG1ic2MtaWMtJyArIHYubGVmdE1lbnVbaV0uaWNvbiArICdcIj4nICsgKHYubGVmdE1lbnVbaV0udGV4dCB8fCAnJykgKyAnPC9kaXY+JztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2LnJpZ2h0TWVudS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGljb25zUmlnaHQgKz0gJzxkaXYgJyArICh2LnJpZ2h0TWVudVtpXS5jb2xvciA/ICdzdHlsZT1cImJhY2tncm91bmQtY29sb3I6ICcgKyB2LnJpZ2h0TWVudVtpXS5jb2xvciArICdcIicgOiAnJykgKyAnIGNsYXNzPVwibWJzYy1sdi1pYy1tIG1ic2MtbHYtaWMgbWJzYy1pYyBtYnNjLWljLScgKyB2LnJpZ2h0TWVudVtpXS5pY29uICsgJ1wiPicgKyAodi5yaWdodE1lbnVbaV0udGV4dCB8fCAnJykgKyAnPC9kaXY+JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2LmFjdGlvbnMubGVmdCkge1xuICAgICAgICAgIHYuc3dpcGUgPSB2LmFjdGlvbnMucmlnaHQgPyB2LnN3aXBlIDogJ3JpZ2h0JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2LmFjdGlvbnMucmlnaHQpIHtcbiAgICAgICAgICB2LnN3aXBlID0gdi5hY3Rpb25zLmxlZnQgPyB2LnN3aXBlIDogJ2xlZnQnO1xuICAgICAgICB9XG5cbiAgICAgICAgdi5pY29ucyA9ICc8ZGl2IGNsYXNzPVwibWJzYy1sdi1tdWx0aSBtYnNjLWx2LW11bHRpLWljLWxlZnRcIj4nICsgaWNvbnNMZWZ0ICsgJzwvZGl2PjxkaXYgY2xhc3M9XCJtYnNjLWx2LW11bHRpIG1ic2MtbHYtbXVsdGktaWMtcmlnaHRcIj4nICsgaWNvbnNSaWdodCArICc8L2Rpdj4nO1xuICAgICAgfVxuICAgIH0pOyAvLyAtLS1cbiAgICAvLyBJbml0IGZpeGVkIGhlYWRlclxuICAgIC8vIC0tLVxuXG4gICAgaWYgKHMuZml4ZWRIZWFkZXIpIHtcbiAgICAgIGhlYWRlckNsYXNzID0gJ21ic2MtbHYtZml4ZWQtaGVhZGVyJyArIChoYXNDb250ZXh0ID8gJyBtYnNjLWx2LWZpeGVkLWhlYWRlci1jdHggbWJzYy1sdi0nICsgcy50aGVtZSArICcgbWJzYy0nICsgcy50aGVtZSArIChzLmJhc2VUaGVtZSA/ICcgbWJzYy1sdi0nICsgcy5iYXNlVGhlbWUgKyAnIG1ic2MtJyArIHMuYmFzZVRoZW1lIDogJycpIDogJycpO1xuXG4gICAgICBpZiAoIWdyb3VwSGVhZGVyKSB7XG4gICAgICAgIGdyb3VwSGVhZGVyID0gJCQxKCc8ZGl2IGNsYXNzPVwiJyArIGhlYWRlckNsYXNzICsgJ1wiPjwvZGl2PicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JvdXBIZWFkZXIuYXR0cignY2xhc3MnLCBoZWFkZXJDbGFzcyk7XG4gICAgICAgIG9uU2Nyb2xsKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICAgIHduZC5iZWZvcmUoZ3JvdXBIZWFkZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udC5wcmVwZW5kKGdyb3VwSGVhZGVyKTtcbiAgICAgIH1cblxuICAgICAgb25TY3JvbGxUaHJvdHRsZSA9IHRocm90dGxlKG9uU2Nyb2xsLCAyMDApO1xuICAgICAgbGlzdGVuKHduZDAsICdzY3JvbGwnLCBvblNjcm9sbFRocm90dGxlKTtcbiAgICAgIGxpc3Rlbih3bmQwLCAndG91Y2htb3ZlJywgb25TY3JvbGxUaHJvdHRsZSwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IC8vIC0tLVxuXG5cbiAgICBpZiAocy5ob3Zlcikge1xuICAgICAgaWYgKCFob3ZlclRpbWUpIHtcbiAgICAgICAgY29udC5vbignbW91c2VvdmVyLm1ic2MtbHYnLCAnLm1ic2MtbHYtaXRlbScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhvdmVySXRlbSB8fCBob3Zlckl0ZW1bMF0gIT0gdGhpcykge1xuICAgICAgICAgICAgb25Nb3VzZUxlYXZlKCk7XG4gICAgICAgICAgICBob3Zlckl0ZW0gPSAkJDEodGhpcyk7XG5cbiAgICAgICAgICAgIGlmICh0eXBlc1tob3Zlckl0ZW0uYXR0cignZGF0YS10eXBlJykgfHwgJ2RlZmF1bHRzJ10uYWN0aW9ucykge1xuICAgICAgICAgICAgICBob3ZlclRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2ZW50SG92ZXIpIHtcbiAgICAgICAgICAgICAgICAgIGhvdmVySXRlbU9wZW5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB0aGF0Lm9wZW5BY3Rpb25zKGhvdmVySXRlbSwgaG92ZXJEaXIsIGhvdmVyVGltZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBob3Zlckl0ZW0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgaG92ZXJUaW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLm9uKCdtb3VzZWxlYXZlLm1ic2MtbHYnLCBvbk1vdXNlTGVhdmUpO1xuICAgICAgfVxuXG4gICAgICBob3ZlclRpbWUgPSBzLmhvdmVyLnRpbWUgfHwgMjAwO1xuICAgICAgaG92ZXJUaW1lb3V0ID0gcy5ob3Zlci50aW1lb3V0IHx8IDIwMDtcbiAgICAgIGhvdmVyRGlyID0gcy5ob3Zlci5kaXJlY3Rpb24gfHwgcy5ob3ZlciB8fCAncmlnaHQnO1xuICAgIH1cblxuICAgIGlmIChoYWRFbmhhbmNlKSB7XG4gICAgICBjb250LmF0dHIoJ21ic2MtZW5oYW5jZScsICcnKTtcbiAgICB9XG5cbiAgICBjb250LnRyaWdnZXIoJ21ic2MtZW5oYW5jZScsIFt7XG4gICAgICB0aGVtZTogcy50aGVtZSxcbiAgICAgIGxhbmc6IHMubGFuZ1xuICAgIH1dKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogTGlzdHZpZXcgZGVzdHJveTogcmVtb3ZlcyBldmVudCBoYW5kbGVycywgY2xhc3NlcyBhbmQgYWRkaXRpb25hbCBtYXJrdXAuXHJcbiAgICovXG5cblxuICB0aGF0Ll9kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmb3JtO1xuICAgIGN1cnJQYXJlbnQuYXBwZW5kKGN1cnJMaXN0KTtcblxuICAgIGlmIChoYXNDb250ZXh0ICYmIGdyb3VwSGVhZGVyKSB7XG4gICAgICBncm91cEhlYWRlci5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBpZiAoaGFkRW5oYW5jZSkge1xuICAgICAgZWxtLmF0dHIoJ21ic2MtZW5oYW5jZScsICcnKTsgLy8gRGVzdHJveSBmb3JtIGluc3RhbmNlIGlmIGFueVxuXG4gICAgICBmb3JtID0gaW5zdGFuY2VzW2NvbnQwLmlkXTtcblxuICAgICAgaWYgKGZvcm0pIHtcbiAgICAgICAgZm9ybS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdW5saXN0ZW4oZG9jdW1lbnQsICd0b3VjaHN0YXJ0Jywgb25TdGFydCwge1xuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgICB1bmxpc3Rlbihkb2N1bWVudCwgJ3RvdWNoc3RhcnQnLCBvbkljb25TdGFydCwge1xuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgICB1bmxpc3Rlbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIG9uTW92ZSwge1xuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgICB1bmxpc3RlbihlLCAnY2xpY2snLCBvbkxpc3RDbGljaywgdHJ1ZSk7XG4gICAgY29udC5maW5kKCcubWJzYy1sdi10eHQsLm1ic2MtbHYtaW1nJykucmVtb3ZlQ2xhc3MoJ21ic2MtbHYtdHh0IG1ic2MtbHYtaW1nJyk7XG4gICAgY29udC5maW5kKGxpc3RTZWxlY3RvcikucmVtb3ZlQ2xhc3MoJ21ic2MtbHYgbWJzYy1sdi12IG1ic2MtbHYtcm9vdCBtYnNjLWx2LXNsLWN1cnInKS5maW5kKGl0ZW1TZWxlY3RvcikucmVtb3ZlQ2xhc3MoJ21ic2MtbHYtZ3ItdGl0bGUgbWJzYy1sdi1pdGVtIG1ic2MtbHYtaXRlbS1lbmhhbmNlZCBtYnNjLWx2LXBhcmVudCBtYnNjLWx2LWltZy1sZWZ0IG1ic2MtbHYtaW1nLXJpZ2h0IG1ic2MtbHYtaXRlbS1pYy1sZWZ0IG1ic2MtbHYtaXRlbS1pYy1yaWdodCcpLnJlbW92ZUF0dHIoJ2RhdGEtcmVmJyk7XG4gICAgJCQxKCcubWJzYy1sdi1iYWNrLC5tYnNjLWx2LWhhbmRsZS1jLC5tYnNjLWx2LWFyciwubWJzYy1sdi1pdGVtLWljJywgY29udCkucmVtb3ZlKCk7XG4gICAgZWxtLmluc2VydEFmdGVyKGNvbnQpO1xuICAgIGNvbnQucmVtb3ZlKCk7XG4gICAgc3RhZ2VjLnJlbW92ZSgpO1xuICAgIHVubGlzdGVuKHduZDAsICdvcmllbnRhdGlvbmNoYW5nZScsIG9uUmVzaXplKTtcbiAgICB1bmxpc3Rlbih3bmQwLCAncmVzaXplJywgb25SZXNpemUpO1xuICAgIHVubGlzdGVuKHduZDAsICdzY3JvbGwnLCBvblNjcm9sbEJvdHRvbSk7XG4gICAgdW5saXN0ZW4od25kMCwgJ3RvdWNobW92ZScsIG9uU2Nyb2xsQm90dG9tLCB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG5cbiAgICBpZiAob25TY3JvbGxUaHJvdHRsZSkge1xuICAgICAgdW5saXN0ZW4od25kMCwgJ3Njcm9sbCcsIG9uU2Nyb2xsVGhyb3R0bGUpO1xuICAgICAgdW5saXN0ZW4od25kMCwgJ3RvdWNobW92ZScsIG9uU2Nyb2xsVGhyb3R0bGUsIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9OyAvLyBVbmRvIG1hbmFnZXIsIG1heSBiZSByZW1vdmVkIGxhdGVyIGluIHNlcGFyYXRlIGNsYXNzXG4gIC8vIC0tLVxuXG5cbiAgdmFyIHVuZG9pbmcsXG4gICAgICB1bmRvUXVldWUgPSBbXSxcbiAgICAgIHVuZG9TdGFjayA9IFtdLFxuICAgICAgdW5kb0dyb3VwID0gW10sXG4gICAgICB1bmRvTGlzdGVuZXIgPSAwO1xuXG4gIHRoYXQuc3RhcnRBY3Rpb25UcmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTdGFydCBhIG5ldyB1bmRvIGdyb3VwIGlmIG5vdCBydW5uaW5nXG4gICAgaWYgKCF1bmRvTGlzdGVuZXIpIHtcbiAgICAgIHVuZG9Hcm91cCA9IFtdO1xuICAgIH1cblxuICAgIHVuZG9MaXN0ZW5lcisrO1xuICB9O1xuXG4gIHRoYXQuZW5kQWN0aW9uVHJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gRW5kIHVuZG8gZ3JvdXAsIGlmIHRoaXMgdGhlIG91dGVybW9zdCBsaXN0ZW5lciAodW5kb0xpc3RlbmVyIGNvdW50ZXIgaXMgMCk7XG4gICAgdW5kb0xpc3RlbmVyLS07XG5cbiAgICBpZiAoIXVuZG9MaXN0ZW5lcikge1xuICAgICAgdW5kb1N0YWNrLnB1c2godW5kb0dyb3VwKTtcbiAgICB9XG4gIH07XG5cbiAgdGhhdC5hZGRVbmRvQWN0aW9uID0gZnVuY3Rpb24gKGFjdGlvbiwgYXN5bmMpIHtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICBhc3luYzogYXN5bmNcbiAgICB9OyAvL2lmICghdW5kb2luZykge1xuXG4gICAgaWYgKHVuZG9MaXN0ZW5lcikge1xuICAgICAgLy8gQWRkIHVuZG8gYWN0aW9uIGluIGN1cnJlbnQgZ3JvdXAsIGlmIGEgbGlzdGVuZXIgaXMgcnVubmluZ1xuICAgICAgdW5kb0dyb3VwLnB1c2gob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQWRkIHVuZG8gYWN0aW9uIHdpdGhpbiBhIG5ldyBncm91cFxuICAgICAgdW5kb1N0YWNrLnB1c2goW29ial0pO1xuXG4gICAgICBpZiAodW5kb1N0YWNrLmxlbmd0aCA+IHMudW5kb0xpbWl0KSB7XG4gICAgICAgIHVuZG9TdGFjay5zaGlmdCgpO1xuICAgICAgfVxuICAgIH0gLy99XG5cbiAgfTtcblxuICB0aGF0LnVuZG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFjdGlvbiwgaSwgZ3JvdXA7XG5cbiAgICBmdW5jdGlvbiBydW4oKSB7XG4gICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgdW5kb2luZyA9IGZhbHNlOyAvLyBJZiB0aGVyZSBpcyBkYXRhIGluIHRoZSBxdWV1ZSwga2VlcCBjYWxsaW5nIHRoZSB1bmRvXG5cbiAgICAgICAgdW5kbygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aW9uID0gZ3JvdXBbaV07XG4gICAgICAgIGktLTtcblxuICAgICAgICBpZiAoYWN0aW9uLmFzeW5jKSB7XG4gICAgICAgICAgLy8gUnVuIGFjdGlvbiwgbmV4dCBhY3Rpb24gbXVzdCBiZSBjYWxsZWQgaW5zaWRlIHRoZSBhY3Rpb25cbiAgICAgICAgICBhY3Rpb24uYWN0aW9uKHJ1bik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUnVuIGFjdGlvblxuICAgICAgICAgIGFjdGlvbi5hY3Rpb24oKTsgLy8gUnVuIG5leHQgYWN0aW9uXG5cbiAgICAgICAgICBydW4oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuZG8oKSB7XG4gICAgICBncm91cCA9IHVuZG9RdWV1ZS5zaGlmdCgpO1xuXG4gICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgdW5kb2luZyA9IHRydWU7XG4gICAgICAgIGkgPSBncm91cC5sZW5ndGggLSAxOyAvLyBDYWxsIGFjdGlvbnMgZnJvbSB0aGUgZ3JvdXAgcmVjb3Vyc2l2ZWx5XG5cbiAgICAgICAgcnVuKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHVuZG9TdGFjay5sZW5ndGgpIHtcbiAgICAgIHVuZG9RdWV1ZS5wdXNoKHVuZG9TdGFjay5wb3AoKSk7XG4gICAgfSAvLyBJZiB1bmRvIGlzIGN1cnJlbnRseSBydW5uaW5nLCBkb24ndCBkbyBhbnl0aGluZyAoaXQgd2lsbCBiZSBjYWxsZWQgbGF0ZXIgZnJvbSBxdWV1ZSlcblxuXG4gICAgaWYgKCF1bmRvaW5nKSB7XG4gICAgICB1bmRvKCk7XG4gICAgfVxuICB9OyAvLyAtLS1cbiAgLy8gQ29uc3RydWN0b3JcblxuXG4gIHMgPSB0aGF0LnNldHRpbmdzO1xuICBldmVudCA9IHRoYXQudHJpZ2dlcjtcbiAgdGhhdC5pbml0KCk7XG59OyAvLyBEZWZhdWx0c1xuXG5MaXN0Vmlldy5wcm90b3R5cGUgPSB7XG4gIF9jbGFzczogJ2xpc3R2aWV3JyxcbiAgX2hhc0RlZjogdHJ1ZSxcbiAgX2hhc1RoZW1lOiB0cnVlLFxuICBfaGFzTGFuZzogdHJ1ZSxcbiAgX2RlZmF1bHRzOiB7XG4gICAgY29udGV4dDogJ2JvZHknLFxuICAgIGFjdGlvbnNXaWR0aDogOTAsXG4gICAgc29ydERlbGF5OiAyNTAsXG4gICAgdW5kb0xpbWl0OiAxMCxcbiAgICB0YXA6IGhhc0dob3N0Q2xpY2ssXG4gICAgc3dpcGU6IHRydWUsXG4gICAgcXVpY2tTd2lwZTogdHJ1ZSxcbiAgICBhbmltYXRlQWRkUmVtb3ZlOiB0cnVlLFxuICAgIGFuaW1hdGVJY29uczogdHJ1ZSxcbiAgICBhbmltYXRpb246IHRydWUsXG4gICAgcmV2ZXJ0OiB0cnVlLFxuICAgIHZpYnJhdGU6IHRydWUsXG4gICAgYWN0aW9uYWJsZTogdHJ1ZSxcbiAgICBoYW5kbGVDbGFzczogJycsXG4gICAgaGFuZGxlTWFya3VwOiAnPGRpdiBjbGFzcz1cIm1ic2MtbHYtaGFuZGxlLWJhciBtYnNjLWx2LWhhbmRsZVwiPjwvZGl2PjxkaXYgY2xhc3M9XCJtYnNjLWx2LWhhbmRsZS1iYXIgbWJzYy1sdi1oYW5kbGVcIj48L2Rpdj48ZGl2IGNsYXNzPVwibWJzYy1sdi1oYW5kbGUtYmFyIG1ic2MtbHYtaGFuZGxlXCI+PC9kaXY+JyxcbiAgICBsaXN0Tm9kZTogJ3VsJyxcbiAgICBsaXN0U2VsZWN0b3I6ICd1bCxvbCcsXG4gICAgaXRlbU5vZGU6ICdsaScsXG4gICAgaXRlbVNlbGVjdG9yOiAnbGknLFxuICAgIGxlZnRBcnJvd0NsYXNzOiAnbWJzYy1pYy1hcnJvdy1sZWZ0NCcsXG4gICAgcmlnaHRBcnJvd0NsYXNzOiAnbWJzYy1pYy1hcnJvdy1yaWdodDQnLFxuICAgIGJhY2tUZXh0OiAnQmFjaycsXG4gICAgdW5kb1RleHQ6ICdVbmRvJyxcbiAgICBzdGFnZXM6IFtdLFxuICAgIHNlbGVjdDogJ29mZidcbiAgfVxufTtcbmNsYXNzZXMuTGlzdFZpZXcgPSBMaXN0Vmlldztcbm1vYmlzY3JvbGwudGhlbWVzLmxpc3R2aWV3Lm1vYmlzY3JvbGwgPSB7XG4gIGxlZnRBcnJvd0NsYXNzOiAnbWJzYy1pYy1hcnJvdy1sZWZ0NScsXG4gIHJpZ2h0QXJyb3dDbGFzczogJ21ic2MtaWMtYXJyb3ctcmlnaHQ1J1xufTtcblxudmFyIE1ic2NMaXN0dmlld1NlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWJzY0xpc3R2aWV3U2VydmljZSgpIHtcclxuICAgICAgICB0aGlzLmFkZE9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZSgpO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlT2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKCk7XHJcbiAgICAgICAgdGhpcy5jYXJkT2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKCk7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZU9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZSgpO1xyXG4gICAgICAgIHRoaXMuaW5zdCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBNYnNjTGlzdHZpZXdTZXJ2aWNlLnByb3RvdHlwZS5ub3RpZnlJbnN0YW5jZVJlYWR5ID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XHJcbiAgICAgICAgdGhpcy5pbnN0ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZU9ic2VydmFibGUubmV4dChpbnN0YW5jZSk7XHJcbiAgICB9O1xyXG4gICAgTWJzY0xpc3R2aWV3U2VydmljZS5wcm90b3R5cGUub25JbnN0YW5jZVJlYWR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlT2JzZXJ2YWJsZTtcclxuICAgIH07XHJcbiAgICBNYnNjTGlzdHZpZXdTZXJ2aWNlLnByb3RvdHlwZS5ub3RpZnlBZGRlZCA9IGZ1bmN0aW9uIChpdGVtLCBwYXJlbnQpIHtcclxuICAgICAgICB0aGlzLmFkZE9ic2VydmFibGUubmV4dCh7IGl0ZW06IGl0ZW0sIHBhcmVudDogcGFyZW50IH0pO1xyXG4gICAgfTtcclxuICAgIE1ic2NMaXN0dmlld1NlcnZpY2UucHJvdG90eXBlLm5vdGlmeVJlbW92ZWQgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlT2JzZXJ2YWJsZS5uZXh0KGl0ZW0pO1xyXG4gICAgfTtcclxuICAgIE1ic2NMaXN0dmlld1NlcnZpY2UucHJvdG90eXBlLm5vdGlmeUNhcmRQcmVzZW5jZSA9IGZ1bmN0aW9uIChpc0NhcmQpIHtcclxuICAgICAgICB0aGlzLmNhcmRPYnNlcnZhYmxlLm5leHQoaXNDYXJkKTtcclxuICAgIH07XHJcbiAgICBNYnNjTGlzdHZpZXdTZXJ2aWNlLnByb3RvdHlwZS5vbkNhcmRDb250ZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhcmRPYnNlcnZhYmxlO1xyXG4gICAgfTtcclxuICAgIE1ic2NMaXN0dmlld1NlcnZpY2UucHJvdG90eXBlLm9uSXRlbUFkZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZE9ic2VydmFibGU7XHJcbiAgICB9O1xyXG4gICAgTWJzY0xpc3R2aWV3U2VydmljZS5wcm90b3R5cGUub25JdGVtUmVtb3ZlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVPYnNlcnZhYmxlO1xyXG4gICAgfTtcclxuICAgIE1ic2NMaXN0dmlld1NlcnZpY2UgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbmplY3RhYmxlKClcclxuICAgIF0sIE1ic2NMaXN0dmlld1NlcnZpY2UpO1xyXG4gICAgcmV0dXJuIE1ic2NMaXN0dmlld1NlcnZpY2U7XHJcbn0oKSk7XHJcbnZhciBNYnNjU3VibGlzdFNlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWJzY1N1Ymxpc3RTZXJ2aWNlKCkge1xyXG4gICAgICAgIHRoaXMuYWRkT2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKCk7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVPYnNlcmFibGUgPSBuZXcgT2JzZXJ2YWJsZSgpO1xyXG4gICAgfVxyXG4gICAgTWJzY1N1Ymxpc3RTZXJ2aWNlLnByb3RvdHlwZS5ub3RpZnlBZGRlZCA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgdGhpcy5hZGRPYnNlcnZhYmxlLm5leHQoaXRlbSk7XHJcbiAgICB9O1xyXG4gICAgTWJzY1N1Ymxpc3RTZXJ2aWNlLnByb3RvdHlwZS5ub3RpZnlSZW1vdmVkID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB0aGlzLnJlbW92ZU9ic2VyYWJsZS5uZXh0KGl0ZW0pO1xyXG4gICAgfTtcclxuICAgIE1ic2NTdWJsaXN0U2VydmljZS5wcm90b3R5cGUub25JdGVtQWRkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkT2JzZXJ2YWJsZTtcclxuICAgIH07XHJcbiAgICBNYnNjU3VibGlzdFNlcnZpY2UucHJvdG90eXBlLm9uSXRlbVJlbW92ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlT2JzZXJhYmxlO1xyXG4gICAgfTtcclxuICAgIE1ic2NTdWJsaXN0U2VydmljZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIEluamVjdGFibGUoKVxyXG4gICAgXSwgTWJzY1N1Ymxpc3RTZXJ2aWNlKTtcclxuICAgIHJldHVybiBNYnNjU3VibGlzdFNlcnZpY2U7XHJcbn0oKSk7XHJcbnZhciBNYnNjTGlzdGl0ZW1TZXJ2aWNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1ic2NMaXN0aXRlbVNlcnZpY2UoKSB7XHJcbiAgICAgICAgdGhpcy5zdWJsaXN0U3ViamVjdCA9IG5ldyBPYnNlcnZhYmxlKCk7XHJcbiAgICAgICAgdGhpcy5pbnN0ID0gbnVsbDtcclxuICAgIH1cclxuICAgIE1ic2NMaXN0aXRlbVNlcnZpY2UucHJvdG90eXBlLm5vdGlmeVN1Ymxpc3RDcmVhdGVkID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB0aGlzLnN1Ymxpc3RTdWJqZWN0Lm5leHQoaXRlbSk7XHJcbiAgICB9O1xyXG4gICAgTWJzY0xpc3RpdGVtU2VydmljZS5wcm90b3R5cGUub25TdWJsaXN0Q3JlYXRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdWJsaXN0U3ViamVjdDtcclxuICAgIH07XHJcbiAgICBNYnNjTGlzdGl0ZW1TZXJ2aWNlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5qZWN0YWJsZSgpXHJcbiAgICBdLCBNYnNjTGlzdGl0ZW1TZXJ2aWNlKTtcclxuICAgIHJldHVybiBNYnNjTGlzdGl0ZW1TZXJ2aWNlO1xyXG59KCkpO1xyXG52YXIgTWJzY0xpc3R2aWV3U3VibGlzdCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNYnNjTGlzdHZpZXdTdWJsaXN0KHBhcmVudFNlcnYsIHN1YlNlcnYsIGl0ZW1TZXJ2aWNlKSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRTZXJ2ID0gcGFyZW50U2VydjtcclxuICAgICAgICB0aGlzLnN1YlNlcnYgPSBzdWJTZXJ2O1xyXG4gICAgICAgIHRoaXMuaXRlbVNlcnZpY2UgPSBpdGVtU2VydmljZTtcclxuICAgIH1cclxuICAgIE1ic2NMaXN0dmlld1N1Ymxpc3QucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaXRlbVNlcnZpY2Uubm90aWZ5U3VibGlzdENyZWF0ZWQodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgTWJzY0xpc3R2aWV3U3VibGlzdCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1saXN0dmlldy1zdWJsaXN0JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcclxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbTWJzY1N1Ymxpc3RTZXJ2aWNlXVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTWJzY0xpc3R2aWV3U2VydmljZSwgTWJzY1N1Ymxpc3RTZXJ2aWNlLCBNYnNjTGlzdGl0ZW1TZXJ2aWNlXSlcclxuICAgIF0sIE1ic2NMaXN0dmlld1N1Ymxpc3QpO1xyXG4gICAgcmV0dXJuIE1ic2NMaXN0dmlld1N1Ymxpc3Q7XHJcbn0oKSk7XHJcbnZhciBNYnNjTGlzdHZpZXdJdGVtID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1ic2NMaXN0dmlld0l0ZW0oZWxlbSwgbHZTZXJ2aWNlLCBsdkl0ZW1TZXJ2aWNlLCBzdWJTZXJ2aWNlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmVsZW0gPSBlbGVtO1xyXG4gICAgICAgIHRoaXMubHZTZXJ2aWNlID0gbHZTZXJ2aWNlO1xyXG4gICAgICAgIHRoaXMubHZJdGVtU2VydmljZSA9IGx2SXRlbVNlcnZpY2U7XHJcbiAgICAgICAgdGhpcy5zdWJTZXJ2aWNlID0gc3ViU2VydmljZTtcclxuICAgICAgICB0aGlzLmNsb25lID0gbnVsbDtcclxuICAgICAgICB0aGlzLm1vdW50ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzUGFyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faW5zdGFuY2UgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5zdWJpdGVtT2JzZXJ2ZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgdGhpcy5zdWJsaXN0T2JzZXJ2ZXIgPSBsdkl0ZW1TZXJ2aWNlLm9uU3VibGlzdENyZWF0ZWQoKS5zdWJzY3JpYmUoZnVuY3Rpb24gKHN1Ymxpc3QpIHtcclxuICAgICAgICAgICAgX3RoaXMuaXNQYXJlbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICBfdGhpcy5zdWJsaXN0ID0gc3VibGlzdDtcclxuICAgICAgICAgICAgX3RoaXMuc3ViaXRlbU9ic2VydmVyID0gc3VibGlzdC5zdWJTZXJ2Lm9uSXRlbUFkZGVkKCkuc3Vic2NyaWJlKGZ1bmN0aW9uIChzdWJJdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMubW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmx2U2VydmljZS5ub3RpZnlBZGRlZChzdWJJdGVtLCBfdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VPYnNlcnZlciA9IHRoaXMubHZTZXJ2aWNlLm9uSW5zdGFuY2VSZWFkeSgpLnN1YnNjcmliZShmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2luc3RhbmNlID0gaW5zdGFuY2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGx2U2VydmljZS5pbnN0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gbHZTZXJ2aWNlLmluc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NMaXN0dmlld0l0ZW0ucHJvdG90eXBlLCBcIkluZGV4XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHRoaXNFbGVtID0gJCQxKHRoaXMuZWxlbS5uYXRpdmVFbGVtZW50KTtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpc0VsZW0ucGFyZW50KCkuY2hpbGRyZW4oJ21ic2MtbGlzdHZpZXctaXRlbSwgbWJzYy1saXN0dmlldy1oZWFkZXInKS5ub3QoJy5tYnNjLWx2LWJhY2snKS5pbmRleCh0aGlzRWxlbSk7XHJcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjTGlzdHZpZXdJdGVtLnByb3RvdHlwZSwgXCJFbGVtZW50XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUgfHwgJCQxKHRoaXMuZWxlbS5uYXRpdmVFbGVtZW50KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE1ic2NMaXN0dmlld0l0ZW0ucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5zdWJTZXJ2aWNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ViU2VydmljZS5ub3RpZnlBZGRlZCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubHZTZXJ2aWNlLm5vdGlmeUFkZGVkKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1vdW50ZWQgPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIE1ic2NMaXN0dmlld0l0ZW0ucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMubHZJdGVtU2VydmljZS5vblN1Ymxpc3RDcmVhdGVkKCkudW5zdWJzY3JpYmUodGhpcy5zdWJsaXN0T2JzZXJ2ZXIpO1xyXG4gICAgICAgIHRoaXMubHZTZXJ2aWNlLm9uSW5zdGFuY2VSZWFkeSgpLnVuc3Vic2NyaWJlKHRoaXMuaW5zdGFuY2VPYnNlcnZlcik7XHJcbiAgICAgICAgaWYgKHRoaXMuc3ViaXRlbU9ic2VydmVyICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3VibGlzdC5zdWJTZXJ2Lm9uSXRlbUFkZGVkKCkudW5zdWJzY3JpYmUodGhpcy5zdWJpdGVtT2JzZXJ2ZXIpO1xyXG4gICAgICAgICAgICB0aGlzLnN1Ymxpc3QgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgJGVsbSA9IHRoaXMuRWxlbWVudCwgJGNsb25lID0gJGVsbS5jbG9uZSgpO1xyXG4gICAgICAgIGlmICgkZWxtLnBhcmVudCgpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAkY2xvbmUuaW5zZXJ0QmVmb3JlKCRlbG0pO1xyXG4gICAgICAgICAgICB0aGlzLmNsb25lID0gJGNsb25lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zdWJTZXJ2aWNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ViU2VydmljZS5ub3RpZnlSZW1vdmVkKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sdlNlcnZpY2Uubm90aWZ5UmVtb3ZlZCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NMaXN0dmlld0l0ZW0ucHJvdG90eXBlLCBcInNlbGVjdGVkXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IHY7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5zdGFuY2Uuc2VsZWN0KHRoaXMuZWxlbS5uYXRpdmVFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLmRlc2VsZWN0KHRoaXMuZWxlbS5uYXRpdmVFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTWJzY0xpc3R2aWV3SXRlbS5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX3NlbGVjdGVkID0gIXRoaXMuX3NlbGVjdGVkO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2UuZW1pdCh0aGlzLl9zZWxlY3RlZCk7XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBNYnNjTGlzdHZpZXdJdGVtLnByb3RvdHlwZSwgXCJpZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjTGlzdHZpZXdJdGVtLnByb3RvdHlwZSwgXCJpY29uXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdpY29uLWFsaWduJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NMaXN0dmlld0l0ZW0ucHJvdG90eXBlLCBcImljb25BbGlnblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjTGlzdHZpZXdJdGVtLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXHJcbiAgICBdLCBNYnNjTGlzdHZpZXdJdGVtLnByb3RvdHlwZSwgXCJzZWxlY3RlZFwiLCBudWxsKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjTGlzdHZpZXdJdGVtLnByb3RvdHlwZSwgXCJzZWxlY3RlZENoYW5nZVwiLCB2b2lkIDApO1xyXG4gICAgTWJzY0xpc3R2aWV3SXRlbSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1saXN0dmlldy1pdGVtJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcclxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbTWJzY0xpc3RpdGVtU2VydmljZV0sXHJcbiAgICAgICAgICAgIGhvc3Q6IHtcclxuICAgICAgICAgICAgICAgICdbYXR0ci5kYXRhLWlkXSc6ICdpZCcsXHJcbiAgICAgICAgICAgICAgICAnW2F0dHIuZGF0YS1pY29uXSc6ICdpY29uJyxcclxuICAgICAgICAgICAgICAgICdbYXR0ci5kYXRhLWljb24tYWxpZ25dJzogJ2ljb25BbGlnbicsXHJcbiAgICAgICAgICAgICAgICAnW2F0dHIuZGF0YS1zZWxlY3RlZF0nOiAnc2VsZWN0ZWQnLFxyXG4gICAgICAgICAgICAgICAgJ1thdHRyLmRhdGEtdHlwZV0nOiAndHlwZSdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBNYnNjTGlzdHZpZXdTZXJ2aWNlLCBNYnNjTGlzdGl0ZW1TZXJ2aWNlLCBNYnNjU3VibGlzdFNlcnZpY2VdKVxyXG4gICAgXSwgTWJzY0xpc3R2aWV3SXRlbSk7XHJcbiAgICByZXR1cm4gTWJzY0xpc3R2aWV3SXRlbTtcclxufSgpKTtcclxudmFyIE1ic2NMaXN0dmlld0hlYWRlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY0xpc3R2aWV3SGVhZGVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY0xpc3R2aWV3SGVhZGVyKGVsZW0sIGx2U2VydmljZSwgaXRlbVNlcnZpY2UsIHN1YlNlcnZpY2UpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZWxlbSwgbHZTZXJ2aWNlLCBpdGVtU2VydmljZSwgc3ViU2VydmljZSkgfHwgdGhpcztcclxuICAgIH1cclxuICAgIE1ic2NMaXN0dmlld0hlYWRlciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1saXN0dmlldy1oZWFkZXInLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxyXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtNYnNjTGlzdGl0ZW1TZXJ2aWNlXSxcclxuICAgICAgICAgICAgaG9zdDoge1xyXG4gICAgICAgICAgICAgICAgJ1thdHRyLmRhdGEtaWRdJzogJ2lkJyxcclxuICAgICAgICAgICAgICAgICdkYXRhLXJvbGUnOiAnbGlzdC1kaXZpZGVyJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgzLCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE1ic2NMaXN0dmlld1NlcnZpY2UsIE1ic2NMaXN0aXRlbVNlcnZpY2UsIE1ic2NTdWJsaXN0U2VydmljZV0pXHJcbiAgICBdLCBNYnNjTGlzdHZpZXdIZWFkZXIpO1xyXG4gICAgcmV0dXJuIE1ic2NMaXN0dmlld0hlYWRlcjtcclxufShNYnNjTGlzdHZpZXdJdGVtKSk7XHJcbnZhciBNYnNjTGlzdHZpZXcgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NMaXN0dmlldywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NMaXN0dmlldyhlbGVtLCB6b25lLCBsdlNlcnZpY2UsIG9wdGlvblNlcnZpY2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBlbGVtLCB6b25lKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmVsZW0gPSBlbGVtO1xyXG4gICAgICAgIF90aGlzLmx2U2VydmljZSA9IGx2U2VydmljZTtcclxuICAgICAgICBfdGhpcy5vcHRpb25TZXJ2aWNlID0gb3B0aW9uU2VydmljZTtcclxuICAgICAgICBfdGhpcy5vbkl0ZW1UYXAgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMub25JdGVtQWRkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm9uSXRlbVJlbW92ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5vbkxpc3RFbmQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMub25OYXZFbmQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMub25OYXZTdGFydCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5vblNsaWRlRW5kID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm9uU2xpZGVTdGFydCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5vblNvcnQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMub25Tb3J0Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm9uU29ydFN0YXJ0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm9uU29ydEVuZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5vblNvcnRVcGRhdGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMub25TdGFnZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5jYXJkQ29udGVudCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmFkZE9ic2VydmVyID0gbHZTZXJ2aWNlLm9uSXRlbUFkZGVkKCkuc3Vic2NyaWJlKGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgICAgIHZhciBpdGVtID0gdC5pdGVtLCBwYXJlbnQgPSB0LnBhcmVudDtcclxuICAgICAgICAgICAgaWYgKF90aGlzLmluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5pbnN0YW5jZS5hZGQobnVsbCwgaXRlbS5FbGVtZW50LCBpdGVtLkluZGV4LCB1bmRlZmluZWQsIHBhcmVudCAmJiBwYXJlbnQuRWxlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBfdGhpcy5yZW1vdmVPYnNlcnZlciA9IGx2U2VydmljZS5vbkl0ZW1SZW1vdmVkKCkuc3Vic2NyaWJlKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIGlmIChfdGhpcy5pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuaW5zdGFuY2UucmVtb3ZlKGl0ZW0uRWxlbWVudCwgdW5kZWZpbmVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIF90aGlzLmNhcmRPYnNlcnZlciA9IGx2U2VydmljZS5vbkNhcmRDb250ZW50KCkuc3Vic2NyaWJlKGZ1bmN0aW9uIChpc0NhcmQpIHtcclxuICAgICAgICAgICAgX3RoaXMuY2FyZENvbnRlbnQgPSBpc0NhcmQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgTWJzY0xpc3R2aWV3LnByb3RvdHlwZS50YXBIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50LCBpbnN0KSB7XHJcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0IHx8IChpbnN0ICYmIGluc3Quc2V0dGluZ3Muc2VsZWN0KTtcclxuICAgICAgICBzd2l0Y2ggKHNlbGVjdGlvbikge1xyXG4gICAgICAgICAgICBjYXNlICdtdWx0aXBsZSc6IHtcclxuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5fZ2V0SXRlbShldmVudC50YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gJiYgIWl0ZW0uaXNQYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLnRvZ2dsZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAnc2luZ2xlJzoge1xyXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9nZXRJdGVtKGV2ZW50LnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSAmJiAhaXRlbS5zZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5zZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50b2dnbGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udG9nZ2xlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZXZlbnQuaW5zdCA9IGluc3Q7XHJcbiAgICAgICAgdGhpcy5vbkl0ZW1UYXAuZW1pdChldmVudCk7XHJcbiAgICB9O1xyXG4gICAgTWJzY0xpc3R2aWV3LnByb3RvdHlwZS5fZ2V0SXRlbSA9IGZ1bmN0aW9uIChuYXRpdmVFbCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmZpbmQoZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZWxlbS5uYXRpdmVFbGVtZW50ID09PSBuYXRpdmVFbDtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBNYnNjTGlzdHZpZXcucHJvdG90eXBlLmluaXRDb250cm9sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG9uSXRlbVRhcCA9IHRoaXMudGFwSGFuZGxlci5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHZhciBvbkl0ZW1UYXBVc2VyID0gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5vbkl0ZW1UYXA7XHJcbiAgICAgICAgaWYgKG9uSXRlbVRhcFVzZXIpIHtcclxuICAgICAgICAgICAgb25JdGVtVGFwID0gZnVuY3Rpb24gKGV2ZW50LCBpbnN0KSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy50YXBIYW5kbGVyKGV2ZW50LCBpbnN0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBvbkl0ZW1UYXBVc2VyKGV2ZW50LCBpbnN0KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBleHRlbmQkMSh7XHJcbiAgICAgICAgICAgIGxpc3ROb2RlOiAnbWJzYy1saXN0dmlldycsXHJcbiAgICAgICAgICAgIGxpc3RTZWxlY3RvcjogJ21ic2MtbGlzdHZpZXcsIG1ic2MtbGlzdHZpZXctc3VibGlzdCcsXHJcbiAgICAgICAgICAgIGl0ZW1Ob2RlOiAnbWJzYy1saXN0dmlldy1pdGVtJyxcclxuICAgICAgICAgICAgaXRlbVNlbGVjdG9yOiAnbWJzYy1saXN0dmlldy1pdGVtLCBtYnNjLWxpc3R2aWV3LWhlYWRlcidcclxuICAgICAgICB9LCB0aGlzLm9wdGlvblNlcnZpY2UgPyB0aGlzLm9wdGlvblNlcnZpY2Uub3B0aW9ucyA6IHt9LCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaiwgeyBvbkl0ZW1UYXA6IG9uSXRlbVRhcCB9KTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IExpc3RWaWV3KHRoaXMuZWxlbS5uYXRpdmVFbGVtZW50LCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLmx2U2VydmljZS5ub3RpZnlJbnN0YW5jZVJlYWR5KHRoaXMuaW5zdGFuY2UpO1xyXG4gICAgfTtcclxuICAgIE1ic2NMaXN0dmlldy5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5sdlNlcnZpY2Uub25DYXJkQ29udGVudCgpLnVuc3Vic2NyaWJlKHRoaXMuY2FyZE9ic2VydmVyKTtcclxuICAgICAgICB0aGlzLmx2U2VydmljZS5vbkl0ZW1BZGRlZCgpLnVuc3Vic2NyaWJlKHRoaXMuYWRkT2JzZXJ2ZXIpO1xyXG4gICAgICAgIHRoaXMubHZTZXJ2aWNlLm9uSXRlbVJlbW92ZWQoKS51bnN1YnNjcmliZSh0aGlzLnJlbW92ZU9ic2VydmVyKTtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nT25EZXN0cm95LmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjTGlzdHZpZXcucHJvdG90eXBlLCBcImFjdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgTWJzY0xpc3R2aWV3LnByb3RvdHlwZSwgXCJhY3Rpb25zV2lkdGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY0xpc3R2aWV3LnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjTGlzdHZpZXcucHJvdG90eXBlLCBcInN0cmlwZWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NMaXN0dmlldy5wcm90b3R5cGUsIFwiYW5pbWF0ZUFkZFJlbW92ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY0xpc3R2aWV3LnByb3RvdHlwZSwgXCJhY3Rpb25hYmxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjTGlzdHZpZXcucHJvdG90eXBlLCBcImFuaW1hdGVJY29uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY0xpc3R2aWV3LnByb3RvdHlwZSwgXCJlbmhhbmNlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjTGlzdHZpZXcucHJvdG90eXBlLCBcImZpbGxBbmltYXRpb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NMaXN0dmlldy5wcm90b3R5cGUsIFwiZml4ZWRIZWFkZXJcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY0xpc3R2aWV3LnByb3RvdHlwZSwgXCJob3ZlclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY0xpc3R2aWV3LnByb3RvdHlwZSwgXCJpY29uU2xpZGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY0xpc3R2aWV3LnByb3RvdHlwZSwgXCJpdGVtR3JvdXBzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NMaXN0dmlldy5wcm90b3R5cGUsIFwibG9hZGluZ0ljb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NMaXN0dmlldy5wcm90b3R5cGUsIFwibmF2aWdhdGVPbkRyb3BcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NMaXN0dmlldy5wcm90b3R5cGUsIFwicXVpY2tTd2lwZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjTGlzdHZpZXcucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjTGlzdHZpZXcucHJvdG90eXBlLCBcInNvcnRhYmxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIE1ic2NMaXN0dmlldy5wcm90b3R5cGUsIFwic29ydERlbGF5XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NMaXN0dmlldy5wcm90b3R5cGUsIFwic3RhZ2VzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NMaXN0dmlldy5wcm90b3R5cGUsIFwic3dpcGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXHJcbiAgICBdLCBNYnNjTGlzdHZpZXcucHJvdG90eXBlLCBcInN3aXBlbGVmdFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcclxuICAgIF0sIE1ic2NMaXN0dmlldy5wcm90b3R5cGUsIFwic3dpcGVyaWdodFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY0xpc3R2aWV3LnByb3RvdHlwZSwgXCJ2aWJyYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NMaXN0dmlldy5wcm90b3R5cGUsIFwidW5kb1RleHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0xpc3R2aWV3LnByb3RvdHlwZSwgXCJiYWNrVGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NMaXN0dmlldy5wcm90b3R5cGUsIFwib25JdGVtVGFwXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY0xpc3R2aWV3LnByb3RvdHlwZSwgXCJvbkl0ZW1BZGRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjTGlzdHZpZXcucHJvdG90eXBlLCBcIm9uSXRlbVJlbW92ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NMaXN0dmlldy5wcm90b3R5cGUsIFwib25MaXN0RW5kXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY0xpc3R2aWV3LnByb3RvdHlwZSwgXCJvbk5hdkVuZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NMaXN0dmlldy5wcm90b3R5cGUsIFwib25OYXZTdGFydFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NMaXN0dmlldy5wcm90b3R5cGUsIFwib25TbGlkZUVuZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NMaXN0dmlldy5wcm90b3R5cGUsIFwib25TbGlkZVN0YXJ0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY0xpc3R2aWV3LnByb3RvdHlwZSwgXCJvblNvcnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjTGlzdHZpZXcucHJvdG90eXBlLCBcIm9uU29ydENoYW5nZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NMaXN0dmlldy5wcm90b3R5cGUsIFwib25Tb3J0U3RhcnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjTGlzdHZpZXcucHJvdG90eXBlLCBcIm9uU29ydEVuZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NMaXN0dmlldy5wcm90b3R5cGUsIFwib25Tb3J0VXBkYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY0xpc3R2aWV3LnByb3RvdHlwZSwgXCJvblN0YWdlQ2hhbmdlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdvcHRpb25zJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NMaXN0dmlldy5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29udGVudENoaWxkcmVuKE1ic2NMaXN0dmlld0l0ZW0sIHsgZGVzY2VuZGFudHM6IHRydWUgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcclxuICAgIF0sIE1ic2NMaXN0dmlldy5wcm90b3R5cGUsIFwiaXRlbXNcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NMaXN0dmlldyA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1saXN0dmlldycsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxuZy1jb250ZW50PjwvbmctY29udGVudD5cIixcclxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbTWJzY0xpc3R2aWV3U2VydmljZV0sXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXHJcbiAgICAgICAgICAgIGhvc3Q6IHtcclxuICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYnNjLWNsb2FrJyxcclxuICAgICAgICAgICAgICAgICdbY2xhc3MubWJzYy1jYXJkLWxpc3RdJzogJ2NhcmRDb250ZW50J1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgzLCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZSwgTWJzY0xpc3R2aWV3U2VydmljZSwgTWJzY09wdGlvbnNTZXJ2aWNlXSlcclxuICAgIF0sIE1ic2NMaXN0dmlldyk7XHJcbiAgICByZXR1cm4gTWJzY0xpc3R2aWV3O1xyXG59KE1ic2NCYXNlKSk7XHJcbnZhciBjb21wID0gW1xyXG4gICAgTWJzY0xpc3R2aWV3LFxyXG4gICAgTWJzY0xpc3R2aWV3SXRlbSxcclxuICAgIE1ic2NMaXN0dmlld0hlYWRlcixcclxuICAgIE1ic2NMaXN0dmlld1N1Ymxpc3RcclxuXTtcclxudmFyIE1ic2NMaXN0dmlld01vZHVsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNYnNjTGlzdHZpZXdNb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBNYnNjTGlzdHZpZXdNb2R1bGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBOZ01vZHVsZSh7XHJcbiAgICAgICAgICAgIGltcG9ydHM6IFtNYnNjQmFzZU1vZHVsZV0sXHJcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogY29tcCxcclxuICAgICAgICAgICAgZXhwb3J0czogY29tcFxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBNYnNjTGlzdHZpZXdNb2R1bGUpO1xyXG4gICAgcmV0dXJuIE1ic2NMaXN0dmlld01vZHVsZTtcclxufSgpKTtcblxudmFyIE1ic2NDYXJkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjQ2FyZCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NDYXJkKGhvc3QsIG9wdGlvbnNTZXJ2aWNlLCBsdlNlcnZpY2UsIHpvbmUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBob3N0LCB6b25lKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLm9wdGlvbnNTZXJ2aWNlID0gb3B0aW9uc1NlcnZpY2U7XHJcbiAgICAgICAgX3RoaXMubHZTZXJ2aWNlID0gbHZTZXJ2aWNlO1xyXG4gICAgICAgIF90aGlzLl9jb2xsYXBzaWJsZUlucHV0ID0gbnVsbDtcclxuICAgICAgICBfdGhpcy5fb3BlbiA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChfdGhpcy5sdlNlcnZpY2UpIHtcclxuICAgICAgICAgICAgX3RoaXMubHZTZXJ2aWNlLm5vdGlmeUNhcmRQcmVzZW5jZSh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NDYXJkLnByb3RvdHlwZSwgXCJjb2xsYXBzaWJsZUlucHV0XCIsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbGxhcHNpYmxlSW5wdXQgPSB2O1xyXG4gICAgICAgICAgICB0aGlzLmlubGluZU9wdGlvbnNPYmouY29sbGFwc2libGUgPSB0aGlzLl9vcGVuO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NDYXJkLnByb3RvdHlwZSwgXCJvcGVuXCIsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcGVuICE9IHYgJiYgdGhpcy5pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNob3coKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UuaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX29wZW4gPSAhIXY7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb2xsYXBzaWJsZUlucHV0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlubGluZU9wdGlvbnNPYmouY29sbGFwc2libGUgPSB0aGlzLl9vcGVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBNYnNjQ2FyZC5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBleHRlbmQkMSh7fSwgdGhpcy5vcHRpb25zU2VydmljZSA/IHRoaXMub3B0aW9uc1NlcnZpY2Uub3B0aW9ucyA6IHt9LCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaik7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBDYXJkKHRoaXMuaW5pdGlhbEVsZW0ubmF0aXZlRWxlbWVudCwgb3B0aW9ucyk7XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnY29sbGFwc2libGUnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXHJcbiAgICBdLCBNYnNjQ2FyZC5wcm90b3R5cGUsIFwiY29sbGFwc2libGVJbnB1dFwiLCBudWxsKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcclxuICAgIF0sIE1ic2NDYXJkLnByb3RvdHlwZSwgXCJvcGVuXCIsIG51bGwpO1xyXG4gICAgTWJzY0NhcmQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBEaXJlY3RpdmUoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ1ttYnNjLWNhcmRdJyxcclxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJyxcclxuICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWJzYy1jbG9haycgfVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMSwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMiwgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBNYnNjT3B0aW9uc1NlcnZpY2UsIE1ic2NMaXN0dmlld1NlcnZpY2UsIE5nWm9uZV0pXHJcbiAgICBdLCBNYnNjQ2FyZCk7XHJcbiAgICByZXR1cm4gTWJzY0NhcmQ7XHJcbn0oTWJzY0Jhc2UpKTtcclxudmFyIE1ic2NDYXJkQ29tcG9uZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjQ2FyZENvbXBvbmVudCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NDYXJkQ29tcG9uZW50KGhvc3QsIG9wdGlvbnNTZXJ2aWNlLCBsdlNlcnZpY2UsIHpvbmUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBob3N0LCBvcHRpb25zU2VydmljZSwgbHZTZXJ2aWNlLCB6b25lKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLm9wdGlvbnNTZXJ2aWNlID0gb3B0aW9uc1NlcnZpY2U7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgTWJzY0NhcmRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtY2FyZCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXHJcbiAgICAgICAgICAgIHN0eWxlczogWyc6aG9zdCB7IGRpc3BsYXk6IGJsb2NrIH0nXVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMSwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMiwgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBNYnNjT3B0aW9uc1NlcnZpY2UsIE1ic2NMaXN0dmlld1NlcnZpY2UsIE5nWm9uZV0pXHJcbiAgICBdLCBNYnNjQ2FyZENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gTWJzY0NhcmRDb21wb25lbnQ7XHJcbn0oTWJzY0NhcmQpKTtcclxudmFyIE1ic2NDYXJkSGVhZGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1ic2NDYXJkSGVhZGVyKCkge1xyXG4gICAgfVxyXG4gICAgTWJzY0NhcmRIZWFkZXIgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtY2FyZC1oZWFkZXInLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxyXG4gICAgICAgICAgICBzdHlsZXM6IFsnOmhvc3QgeyBkaXNwbGF5OiBibG9jazsgfSddLFxyXG4gICAgICAgICAgICBob3N0OiB7XHJcbiAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWJzYy1jYXJkLWhlYWRlcidcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBNYnNjQ2FyZEhlYWRlcik7XHJcbiAgICByZXR1cm4gTWJzY0NhcmRIZWFkZXI7XHJcbn0oKSk7XHJcbnZhciBNYnNjQ2FyZENvbnRlbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWJzY0NhcmRDb250ZW50KCkge1xyXG4gICAgfVxyXG4gICAgTWJzY0NhcmRDb250ZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLWNhcmQtY29udGVudCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXHJcbiAgICAgICAgICAgIHN0eWxlczogWyc6aG9zdCB7IGRpc3BsYXk6IGJsb2NrOyB9J10sXHJcbiAgICAgICAgICAgIGhvc3Q6IHtcclxuICAgICAgICAgICAgICAgICdjbGFzcyc6ICdtYnNjLWNhcmQtY29udGVudCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBNYnNjQ2FyZENvbnRlbnQpO1xyXG4gICAgcmV0dXJuIE1ic2NDYXJkQ29udGVudDtcclxufSgpKTtcclxudmFyIE1ic2NDYXJkRm9vdGVyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1ic2NDYXJkRm9vdGVyKCkge1xyXG4gICAgfVxyXG4gICAgTWJzY0NhcmRGb290ZXIgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtY2FyZC1mb290ZXInLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxyXG4gICAgICAgICAgICBzdHlsZXM6IFsnOmhvc3QgeyBkaXNwbGF5OiBibG9jazsgfSddLFxyXG4gICAgICAgICAgICBob3N0OiB7XHJcbiAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWJzYy1jYXJkLWZvb3RlcidcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBNYnNjQ2FyZEZvb3Rlcik7XHJcbiAgICByZXR1cm4gTWJzY0NhcmRGb290ZXI7XHJcbn0oKSk7XHJcbnZhciBNYnNjQ2FyZFRpdGxlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1ic2NDYXJkVGl0bGUoKSB7XHJcbiAgICB9XHJcbiAgICBNYnNjQ2FyZFRpdGxlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLWNhcmQtdGl0bGUnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxyXG4gICAgICAgICAgICBzdHlsZXM6IFsnOmhvc3QgeyBkaXNwbGF5OiBibG9jazsgfSddLFxyXG4gICAgICAgICAgICBob3N0OiB7XHJcbiAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWJzYy1jYXJkLXRpdGxlJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIF0sIE1ic2NDYXJkVGl0bGUpO1xyXG4gICAgcmV0dXJuIE1ic2NDYXJkVGl0bGU7XHJcbn0oKSk7XHJcbnZhciBNYnNjQ2FyZFN1YnRpdGxlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1ic2NDYXJkU3VidGl0bGUoKSB7XHJcbiAgICB9XHJcbiAgICBNYnNjQ2FyZFN1YnRpdGxlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLWNhcmQtc3VidGl0bGUnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxyXG4gICAgICAgICAgICBzdHlsZXM6IFsnOmhvc3QgeyBkaXNwbGF5OiBibG9jazsgfSddLFxyXG4gICAgICAgICAgICBob3N0OiB7XHJcbiAgICAgICAgICAgICAgICAnY2xhc3MnOiAnbWJzYy1jYXJkLXN1YnRpdGxlJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIF0sIE1ic2NDYXJkU3VidGl0bGUpO1xyXG4gICAgcmV0dXJuIE1ic2NDYXJkU3VidGl0bGU7XHJcbn0oKSk7XHJcbnZhciBjb21wJDEgPSBbXHJcbiAgICBNYnNjQ2FyZCwgTWJzY0NhcmRDb21wb25lbnQsXHJcbiAgICBNYnNjQ2FyZEhlYWRlciwgTWJzY0NhcmRDb250ZW50LCBNYnNjQ2FyZEZvb3RlcixcclxuICAgIE1ic2NDYXJkVGl0bGUsIE1ic2NDYXJkU3VidGl0bGVcclxuXTtcclxudmFyIE1ic2NDYXJkTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1ic2NDYXJkTW9kdWxlKCkge1xyXG4gICAgfVxyXG4gICAgTWJzY0NhcmRNb2R1bGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBOZ01vZHVsZSh7XHJcbiAgICAgICAgICAgIGltcG9ydHM6IFtNYnNjQmFzZU1vZHVsZV0sXHJcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogY29tcCQxLFxyXG4gICAgICAgICAgICBleHBvcnRzOiBjb21wJDFcclxuICAgICAgICB9KVxyXG4gICAgXSwgTWJzY0NhcmRNb2R1bGUpO1xyXG4gICAgcmV0dXJuIE1ic2NDYXJkTW9kdWxlO1xyXG59KCkpO1xuXG4vKipcclxuICogQ29udmVydCByZ2IgY29sb3IgdG8gaGV4XHJcbiAqL1xuXG5mdW5jdGlvbiByZ2IyaGV4KHJnYikge1xuICB2YXIgaGV4ID0gW01hdGgucm91bmQocmdiLnIpLnRvU3RyaW5nKDE2KSwgTWF0aC5yb3VuZChyZ2IuZykudG9TdHJpbmcoMTYpLCBNYXRoLnJvdW5kKHJnYi5iKS50b1N0cmluZygxNildO1xuICAkJDEuZWFjaChoZXgsIGZ1bmN0aW9uIChuciwgdmFsKSB7XG4gICAgaWYgKHZhbC5sZW5ndGggPT0gMSkge1xuICAgICAgaGV4W25yXSA9ICcwJyArIHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gJyMnICsgaGV4LmpvaW4oJycpO1xufVxuLyoqXHJcbiAqIENvbnZlcnQgaGV4IGNvbG9yIHRvIHJnYlxyXG4gKi9cblxuXG5mdW5jdGlvbiBoZXgycmdiKGhleCkge1xuICBoZXggPSBwYXJzZUludChoZXguaW5kZXhPZignIycpID4gLTEgPyBoZXguc3Vic3RyaW5nKDEpIDogaGV4LCAxNik7XG4gIHJldHVybiB7XG4gICAgcjogaGV4ID4+IDE2LFxuICAgIGc6IChoZXggJiAweDAwRkYwMCkgPj4gOCxcbiAgICBiOiBoZXggJiAweDAwMDBGRixcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ3JnYignICsgdGhpcy5yICsgJywnICsgdGhpcy5nICsgJywnICsgdGhpcy5iICsgJyknO1xuICAgIH1cbiAgfTtcbn1cbi8qKlxyXG4gKiBDb252ZXJ0IGhzdiBjb2xvciB0byByZ2JcclxuICovXG5cblxuZnVuY3Rpb24gaHN2MnJnYihoc3YpIHtcbiAgdmFyIHIsXG4gICAgICBnLFxuICAgICAgYixcbiAgICAgIGggPSBoc3YuaCxcbiAgICAgIHMgPSBoc3YucyAqIDI1NSAvIDEwMCxcbiAgICAgIHYgPSBoc3YudiAqIDI1NSAvIDEwMDtcblxuICBpZiAocyA9PT0gMCkge1xuICAgIHIgPSBnID0gYiA9IHY7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHQxID0gdixcbiAgICAgICAgdDIgPSAoMjU1IC0gcykgKiB2IC8gMjU1LFxuICAgICAgICB0MyA9ICh0MSAtIHQyKSAqIChoICUgNjApIC8gNjA7XG5cbiAgICBpZiAoaCA9PSAzNjApIHtcbiAgICAgIGggPSAwO1xuICAgIH1cblxuICAgIGlmIChoIDwgNjApIHtcbiAgICAgIHIgPSB0MTtcbiAgICAgIGIgPSB0MjtcbiAgICAgIGcgPSB0MiArIHQzO1xuICAgIH0gZWxzZSBpZiAoaCA8IDEyMCkge1xuICAgICAgZyA9IHQxO1xuICAgICAgYiA9IHQyO1xuICAgICAgciA9IHQxIC0gdDM7XG4gICAgfSBlbHNlIGlmIChoIDwgMTgwKSB7XG4gICAgICBnID0gdDE7XG4gICAgICByID0gdDI7XG4gICAgICBiID0gdDIgKyB0MztcbiAgICB9IGVsc2UgaWYgKGggPCAyNDApIHtcbiAgICAgIGIgPSB0MTtcbiAgICAgIHIgPSB0MjtcbiAgICAgIGcgPSB0MSAtIHQzO1xuICAgIH0gZWxzZSBpZiAoaCA8IDMwMCkge1xuICAgICAgYiA9IHQxO1xuICAgICAgZyA9IHQyO1xuICAgICAgciA9IHQyICsgdDM7XG4gICAgfSBlbHNlIGlmIChoIDwgMzYwKSB7XG4gICAgICByID0gdDE7XG4gICAgICBnID0gdDI7XG4gICAgICBiID0gdDEgLSB0MztcbiAgICB9IGVsc2Uge1xuICAgICAgciA9IGcgPSBiID0gMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHI6IHIsXG4gICAgZzogZyxcbiAgICBiOiBiLFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAncmdiKCcgKyB0aGlzLnIgKyAnLCcgKyB0aGlzLmcgKyAnLCcgKyB0aGlzLmIgKyAnKSc7XG4gICAgfVxuICB9O1xufVxuLyoqXHJcbiAqIENvbnZlcnQgcmdiIGNvbG9yIHRvIGhzdlxyXG4gKi9cblxuXG5mdW5jdGlvbiByZ2IyaHN2KHJnYikge1xuICB2YXIgaCA9IDAsXG4gICAgICBzLFxuICAgICAgdixcbiAgICAgIG1pbiA9IE1hdGgubWluKHJnYi5yLCByZ2IuZywgcmdiLmIpLFxuICAgICAgbWF4ID0gTWF0aC5tYXgocmdiLnIsIHJnYi5nLCByZ2IuYiksXG4gICAgICBkZWx0YSA9IG1heCAtIG1pbjtcbiAgdiA9IG1heDtcbiAgcyA9IG1heCA/IDI1NSAqIGRlbHRhIC8gbWF4IDogMDtcblxuICBpZiAocykge1xuICAgIGlmIChyZ2IuciA9PSBtYXgpIHtcbiAgICAgIGggPSAocmdiLmcgLSByZ2IuYikgLyBkZWx0YTtcbiAgICB9IGVsc2UgaWYgKHJnYi5nID09IG1heCkge1xuICAgICAgaCA9IDIgKyAocmdiLmIgLSByZ2IucikgLyBkZWx0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IDQgKyAocmdiLnIgLSByZ2IuZykgLyBkZWx0YTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaCA9IC0xO1xuICB9XG5cbiAgaCAqPSA2MDtcblxuICBpZiAoaCA8IDApIHtcbiAgICBoICs9IDM2MDtcbiAgfVxuXG4gIHMgKj0gMTAwIC8gMjU1O1xuICB2ICo9IDEwMCAvIDI1NTtcbiAgcmV0dXJuIHtcbiAgICBoOiBoLFxuICAgIHM6IHMsXG4gICAgdjogdixcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ2hzdignICsgTWF0aC5yb3VuZCh0aGlzLmgpICsgJywnICsgTWF0aC5yb3VuZCh0aGlzLnMpICsgJyUsJyArIE1hdGgucm91bmQodGhpcy52KSArICclKSc7XG4gICAgfVxuICB9O1xufVxuLyoqXHJcbiAqIENvbnZlcnQgcmdiIGNvbG9yIHRvIGhzbFxyXG4gKi9cblxuXG5mdW5jdGlvbiByZ2IyaHNsKHJnYikge1xuICB2YXIgciA9IHJnYi5yIC8gMjU1LFxuICAgICAgZyA9IHJnYi5nIC8gMjU1LFxuICAgICAgYiA9IHJnYi5iIC8gMjU1LFxuICAgICAgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcbiAgICAgIGwgPSAobWF4ICsgbWluKSAvIDIsXG4gICAgICBoLFxuICAgICAgcztcblxuICBpZiAobWF4ID09IG1pbikge1xuICAgIGggPSBzID0gMDsgLy8gYWNocm9tYXRpY1xuICB9IGVsc2Uge1xuICAgIHZhciBkID0gbWF4IC0gbWluO1xuICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcblxuICAgIHN3aXRjaCAobWF4KSB7XG4gICAgICBjYXNlIHI6XG4gICAgICAgIGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgZzpcbiAgICAgICAgaCA9IChiIC0gcikgLyBkICsgMjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgYjpcbiAgICAgICAgaCA9IChyIC0gZykgLyBkICsgNDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaCAvPSA2O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBoOiBNYXRoLnJvdW5kKGggKiAzNjApLFxuICAgIHM6IE1hdGgucm91bmQocyAqIDEwMCksXG4gICAgbDogTWF0aC5yb3VuZChsICogMTAwKSxcbiAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ2hzbCgnICsgdGhpcy5oICsgJywnICsgdGhpcy5zICsgJyUsJyArIHRoaXMubCArICclKSc7XG4gICAgfVxuICB9O1xufVxuLyoqXHJcbiAqIENvbnZlcnQgaHNsIGNvbG9yIHRvIHJnYlxyXG4gKi9cblxuXG5mdW5jdGlvbiBoc2wycmdiKGhzbCkge1xuICB2YXIgcixcbiAgICAgIGcsXG4gICAgICBiLFxuICAgICAgbSxcbiAgICAgIGMsXG4gICAgICB4LFxuICAgICAgaCA9IGhzbC5oLFxuICAgICAgcyA9IGhzbC5zLFxuICAgICAgbCA9IGhzbC5sO1xuXG4gIGlmICghaXNGaW5pdGUoaCkpIHtcbiAgICBoID0gMDtcbiAgfVxuXG4gIGlmICghaXNGaW5pdGUocykpIHtcbiAgICBzID0gMDtcbiAgfVxuXG4gIGlmICghaXNGaW5pdGUobCkpIHtcbiAgICBsID0gMDtcbiAgfVxuXG4gIGggLz0gNjA7XG5cbiAgaWYgKGggPCAwKSB7XG4gICAgaCA9IDYgLSAtaCAlIDY7XG4gIH1cblxuICBoICU9IDY7XG4gIHMgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBzIC8gMTAwKSk7XG4gIGwgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBsIC8gMTAwKSk7XG4gIGMgPSAoMSAtIE1hdGguYWJzKDIgKiBsIC0gMSkpICogcztcbiAgeCA9IGMgKiAoMSAtIE1hdGguYWJzKGggJSAyIC0gMSkpO1xuXG4gIGlmIChoIDwgMSkge1xuICAgIHIgPSBjO1xuICAgIGcgPSB4O1xuICAgIGIgPSAwO1xuICB9IGVsc2UgaWYgKGggPCAyKSB7XG4gICAgciA9IHg7XG4gICAgZyA9IGM7XG4gICAgYiA9IDA7XG4gIH0gZWxzZSBpZiAoaCA8IDMpIHtcbiAgICByID0gMDtcbiAgICBnID0gYztcbiAgICBiID0geDtcbiAgfSBlbHNlIGlmIChoIDwgNCkge1xuICAgIHIgPSAwO1xuICAgIGcgPSB4O1xuICAgIGIgPSBjO1xuICB9IGVsc2UgaWYgKGggPCA1KSB7XG4gICAgciA9IHg7XG4gICAgZyA9IDA7XG4gICAgYiA9IGM7XG4gIH0gZWxzZSB7XG4gICAgciA9IGM7XG4gICAgZyA9IDA7XG4gICAgYiA9IHg7XG4gIH1cblxuICBtID0gbCAtIGMgLyAyO1xuICByZXR1cm4ge1xuICAgIHI6IE1hdGgucm91bmQoKHIgKyBtKSAqIDI1NSksXG4gICAgZzogTWF0aC5yb3VuZCgoZyArIG0pICogMjU1KSxcbiAgICBiOiBNYXRoLnJvdW5kKChiICsgbSkgKiAyNTUpLFxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAncmdiKCcgKyB0aGlzLnIgKyAnLCcgKyB0aGlzLmcgKyAnLCcgKyB0aGlzLmIgKyAnKSc7XG4gICAgfVxuICB9O1xufVxuLyoqXHJcbiAqIENvbnZlcnQgaGV4IGNvbG9yIHRvIGhzbFxyXG4gKi9cblxuXG5mdW5jdGlvbiBoZXgyaHNsKGhleCkge1xuICByZXR1cm4gcmdiMmhzbChoZXgycmdiKGhleCkpO1xufVxuLyoqXHJcbiAqIENvbnZlcnQgaHNsIGNvbG9yIHRvIGhleFxyXG4gKi9cblxuXG5mdW5jdGlvbiBoc2wyaGV4KGhzbCkge1xuICByZXR1cm4gcmdiMmhleChoc2wycmdiKGhzbCkpO1xufVxuLyoqXHJcbiAqIENvbnZlcnQgaHN2IGNvbG9yIHRvIGhleFxyXG4gKi9cblxuXG5mdW5jdGlvbiBoc3YyaGV4KGhzdikge1xuICByZXR1cm4gcmdiMmhleChoc3YycmdiKGhzdikpO1xufVxuLyoqXHJcbiAqIENvbnZlcnQgaGV4IGNvbG9yIHRvIGhzdlxyXG4gKi9cblxuXG5mdW5jdGlvbiBoZXgyaHN2KGhleCkge1xuICByZXR1cm4gcmdiMmhzdihoZXgycmdiKGhleCkpO1xufVxuXG52YXIgQ29sb3IgPSBmdW5jdGlvbiBDb2xvcihlbCwgc2V0dGluZ3MsIGluaGVyaXQpIHtcbiAgdmFyIHMsXG4gICAgICBkZWYsXG4gICAgICB0ZW1wQ29sb3JzLFxuICAgICAgdHJpZ2dlcixcbiAgICAgIHNjcm9sbFZpZXcsXG4gICAgICBwcmV2aWV3U2Nyb2xsVmlldyxcbiAgICAgIGhhc0NsZWFyLFxuICAgICAgY3VyclZhbHVlLFxuICAgICAgY3VyckhzbFZhbHVlLFxuICAgICAgaXNIb3Jpem9udGFsU2Nyb2xsLFxuICAgICAgaGFzUHJldmlldyxcbiAgICAgIHNsaWRlclRyYWNrLFxuICAgICAgcmVmaW5lTW9kZSxcbiAgICAgIHJvd0l0ZW1zLFxuICAgICAgc2xpZGVyLFxuICAgICAgY29sb3JJbmRleCxcbiAgICAgIGVuaGFuY2VJbnB1dCxcbiAgICAgIHNpbmdsZVNlbGVjdCxcbiAgICAgIG1heFNlbGVjdCxcbiAgICAgIHJldHVybk9iaixcbiAgICAgICRpbnB1dCxcbiAgICAgICRjb2xvckl0ZW1zLFxuICAgICAgJGNvbG9yUHJldmlld0l0ZW1zLFxuICAgICAgJGN1cnJJdGVtLFxuICAgICAgJHNsaWRlckVsbSxcbiAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgJGVsbSA9ICQkMShlbCksXG4gICAgICBjb2xvclByZXZpZXdJbmQgPSAwLFxuICAgICAgcHJldmlld1ZhbHVlcyA9IHt9LFxuICAgICAgdGVtcFByZXZpZXdWYWx1ZXMgPSB7fTtcblxuICBmdW5jdGlvbiBzZXRWYWx1ZShmaWxsLCBjaGFuZ2UsIHRlbXApIHtcbiAgICBpZiAoIXRlbXApIHtcbiAgICAgIHRoYXQuX3ZhbHVlID0gdGhhdC5faGFzVmFsdWUgPyB0aGF0Ll90ZW1wVmFsdWUuc2xpY2UoMCkgOiBudWxsO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlbXBDb2xvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHRlbXBDb2xvcnNbaV0udGVtcENoYW5nZWRDb2xvciAmJiB0aGF0Ll92YWx1ZSAmJiB0aGF0Ll92YWx1ZS5pbmRleE9mKHRlbXBDb2xvcnNbaV0udGVtcENoYW5nZWRDb2xvcikgIT0gLTEpIHtcbiAgICAgICAgICAvLyBzZXQgY2hhbmdlZCBjb2xvciBpZiB3YXMgc2V0XG4gICAgICAgICAgdGVtcENvbG9yc1tpXS5jaGFuZ2VkQ29sb3IgPSB0ZW1wQ29sb3JzW2ldLnRlbXBDaGFuZ2VkQ29sb3I7XG4gICAgICAgIH0gLy8gZWxzZSBpZiAodGVtcENvbG9yc1tpXS5jaGFuZ2VkQ29sb3IgJiYgdGhhdC5fdmFsdWUuaW5kZXhPZih0ZW1wQ29sb3JzW2ldLmNoYW5nZWRDb2xvcikgPT0gLTEpIHsgLy8gZGVsZXRlIGNoYW5nZWQgY29sb3IgaWYgd2FzIHVuc2V0XG4gICAgICAgIC8vICAgIGRlbGV0ZSB0ZW1wQ29sb3JzW2ldLmNoYW5nZWRDb2xvcjtcbiAgICAgICAgLy99XG5cblxuICAgICAgICBkZWxldGUgdGVtcENvbG9yc1tpXS50ZW1wQ2hhbmdlZENvbG9yO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmaWxsKSB7XG4gICAgICBpZiAodGhhdC5faXNJbnB1dCkge1xuICAgICAgICAkZWxtLnZhbCh0aGF0Ll9oYXNWYWx1ZSA/IHRoYXQuX3RlbXBWYWx1ZSA6ICcnKTtcbiAgICAgIH1cblxuICAgICAgdHJpZ2dlcignb25GaWxsJywge1xuICAgICAgICB2YWx1ZVRleHQ6IHRoYXQuX2hhc1ZhbHVlID8gdGhhdC5fdGVtcFZhbHVlIDogJycsXG4gICAgICAgIGNoYW5nZTogY2hhbmdlXG4gICAgICB9KTtcblxuICAgICAgaWYgKGNoYW5nZSkge1xuICAgICAgICBwcmV2aWV3VmFsdWVzID0gZXh0ZW5kJDEodHJ1ZSwge30sIHRlbXBQcmV2aWV3VmFsdWVzKTtcbiAgICAgICAgdGhhdC5fcHJldmVudENoYW5nZSA9IHRydWU7XG4gICAgICAgICRlbG0udHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICB9XG5cbiAgICAgIHJlZnJlc2hTZWxlY3RlZFZhbHVlcyh0aGF0Ll92YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SW5wdXRDb2xvckl0ZW0odmFsdWUsIGluZGV4KSB7XG4gICAgaW5kZXggPSBpbmRleCAhPT0gdW5kZWZpbmVkID8gaW5kZXggOiBnZXRDb2xvckluZGV4KHZhbHVlKTtcbiAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCJtYnNjLWNvbG9yLWlucHV0LWl0ZW1cIiBkYXRhLWNvbG9yPVwiJyArIChpbmRleCAhPT0gdW5kZWZpbmVkID8gaW5kZXggOiB2YWx1ZSkgKyAnXCIgc3R5bGU9XCJiYWNrZ3JvdW5kOiAnICsgdmFsdWUgKyAnO1wiPicgKyAoc2luZ2xlU2VsZWN0ID8gJycgOiAnPGRpdiBjbGFzcz1cIm1ic2MtY29sb3ItaW5wdXQtaXRlbS1jbG9zZSBtYnNjLWljIG1ic2MtaWMtbWF0ZXJpYWwtY2xvc2VcIj48L2Rpdj4nKSArICc8L2Rpdj4nO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hhbmdlU2xpZGVyU3RlcHNDb2xvcihjb2xvcikge1xuICAgIHNsaWRlclRyYWNrWzBdLnN0eWxlLmJhY2tncm91bmQgPSBjb2xvciA/IGNzc1ByZWZpeCArICdsaW5lYXItZ3JhZGllbnQobGVmdCwgJyArIChzLnJ0bCA/ICcjMDAwMDAwJyA6ICcjRkZGRkZGJykgKyAnIDAlLCAnICsgY29sb3IgKyAnIDUwJSwgJyArIChzLnJ0bCA/ICcjRkZGRkZGJyA6ICcjMDAwMDAwJykgKyAnIDEwMCUpJyA6ICcnO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q29sb3JJbmRleChjb2xvcikge1xuICAgIGlmIChPYmplY3Qua2V5cyh0ZW1wUHJldmlld1ZhbHVlcykubGVuZ3RoICYmICFpc05hTihjb2xvcikpIHtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBjIGluIHRlbXBDb2xvcnMpIHtcbiAgICAgIGlmIChjb2xvciA9PSB0ZW1wQ29sb3JzW2NdLmNvbG9yIHx8IGNvbG9yID09IHRlbXBDb2xvcnNbY10uY2hhbmdlZENvbG9yKSB7XG4gICAgICAgIHJldHVybiBjO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlSW5wdXRJdGVtcygpIHtcbiAgICBpZiAoZW5oYW5jZUlucHV0KSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICBpbnB1dENvbG9ySXRlbXMgPSAnJztcbiAgICAgICRpbnB1dC5lbXB0eSgpO1xuXG4gICAgICBpZiAodGhhdC5faGFzVmFsdWUpIHtcbiAgICAgICAgaWYgKHNpbmdsZVNlbGVjdCkge1xuICAgICAgICAgIGlucHV0Q29sb3JJdGVtcyArPSBnZXRJbnB1dENvbG9ySXRlbSh0aGF0Ll92YWx1ZSwgY29sb3JJbmRleCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoYXQuX3ZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpbnB1dENvbG9ySXRlbXMgKz0gZ2V0SW5wdXRDb2xvckl0ZW0odGhhdC5fdmFsdWVbaV0sIE9iamVjdC5rZXlzKHRlbXBQcmV2aWV3VmFsdWVzKS5sZW5ndGggJiYgdGVtcFByZXZpZXdWYWx1ZXNbaV0uY29sb3JJbmRleCA/IHRlbXBQcmV2aWV3VmFsdWVzW2ldLmNvbG9ySW5kZXggOiBnZXRDb2xvckluZGV4KHRoYXQuX3ZhbHVlW2ldKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgJGlucHV0LmFwcGVuZChpbnB1dENvbG9ySXRlbXMpO1xuICAgICAgICB0aGF0LnRhcCgkJDEoJy5tYnNjLWNvbG9yLWlucHV0LWl0ZW0nLCAkaW5wdXQpLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICBpZiAoJCQxKGV2LnRhcmdldCkuaGFzQ2xhc3MoJ21ic2MtY29sb3ItaW5wdXQtaXRlbS1jbG9zZScpKSB7XG4gICAgICAgICAgICB2YXIgaW5keCA9ICQkMSh0aGlzKS5pbmRleCgpO1xuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZiAoY29sb3JJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGNvbG9ySW5kZXggPSAkJDEoZXYudGFyZ2V0KS5wYXJlbnQoKS5hdHRyKCdkYXRhLWNvbG9yJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYXNQcmV2aWV3ICYmIHRlbXBDb2xvcnNbY29sb3JJbmRleF0pIHtcbiAgICAgICAgICAgICAgY29sb3JQcmV2aWV3SW5kID0gdGVtcENvbG9yc1tjb2xvckluZGV4XS5wcmV2aWV3SW5kO1xuICAgICAgICAgICAgICAkY29sb3JQcmV2aWV3SXRlbXMuZXEoY29sb3JQcmV2aWV3SW5kKS5wYXJlbnQoKS5yZW1vdmVDbGFzcygnbWJzYy1jb2xvci1hY3RpdmUnKTtcbiAgICAgICAgICAgICAgcHJldmlld1ZhbHVlc1tpbmR4XSA9IHt9O1xuICAgICAgICAgICAgICB0ZW1wUHJldmlld1ZhbHVlc1tpbmR4XSA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGF0Ll92YWx1ZS5zcGxpY2UoaW5keCwgMSk7XG5cbiAgICAgICAgICAgIHRoYXQuc2V0VmFsKHRoYXQuX3ZhbHVlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJlZmluZU1vZGUgJiYgcy5kaXNwbGF5ICE9PSAnaW5saW5lJykge1xuICAgICAgICAgICAgY29sb3JJbmRleCA9ICQkMShldi50YXJnZXQpLmF0dHIoJ2RhdGEtY29sb3InKTtcblxuICAgICAgICAgICAgaWYgKGlzTmFOKGNvbG9ySW5kZXgpKSB7XG4gICAgICAgICAgICAgIGNvbG9ySW5kZXggPSBnZXRDb2xvckluZGV4KGNvbG9ySW5kZXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29sb3JJbmRleCAmJiB0ZW1wQ29sb3JzW2NvbG9ySW5kZXhdKSB7XG4gICAgICAgICAgICAgIHRlbXBDb2xvcnNbY29sb3JJbmRleF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBjb2xvclByZXZpZXdJbmQgPSB0ZW1wQ29sb3JzW2NvbG9ySW5kZXhdLnByZXZpZXdJbmQ7IC8vIHNjcm9sbCB0byB2aWV3LCBpZiB0aGUgc2VsZWN0ZWQgY29sb3IgaXMgbm90IHJlc2VudCBpbiB0aGUgdmlld1xuXG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNjcm9sbFZpZXcuc2Nyb2xsKCRjb2xvckl0ZW1zLmVxKGNvbG9ySW5kZXgpLCA0MDApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGhhc1ByZXZpZXcpIHtcbiAgICAgICAgICAgICAgICAgIHByZXZpZXdTY3JvbGxWaWV3LnNjcm9sbCgkY29sb3JQcmV2aWV3SXRlbXMuZXEoY29sb3JQcmV2aWV3SW5kKSwgNDAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb252ZXJ0VG9Gb3JtYXQoY29sb3IsIHR5cGUpIHtcbiAgICB2YXIgY29sb3JIZXgsXG4gICAgICAgIGNvbG9yVmFsdWVzID0gY29sb3IubWF0Y2goL1xcZCsvZ21pKTtcblxuICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgY2FzZSBjb2xvci5pbmRleE9mKCdyZ2InKSA+IC0xOlxuICAgICAgICBjb2xvckhleCA9IHJnYjJoZXgoe1xuICAgICAgICAgIHI6IGNvbG9yVmFsdWVzWzBdLFxuICAgICAgICAgIGc6IGNvbG9yVmFsdWVzWzFdLFxuICAgICAgICAgIGI6IGNvbG9yVmFsdWVzWzJdXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBjb2xvci5pbmRleE9mKCdoc2wnKSA+IC0xOlxuICAgICAgICBjb2xvckhleCA9IGhzbDJoZXgoe1xuICAgICAgICAgIGg6IGNvbG9yVmFsdWVzWzBdLFxuICAgICAgICAgIHM6IGNvbG9yVmFsdWVzWzFdLFxuICAgICAgICAgIGw6IGNvbG9yVmFsdWVzWzJdXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBjb2xvci5pbmRleE9mKCdoc3YnKSA+IC0xOlxuICAgICAgICBjb2xvckhleCA9IGhzdjJoZXgoe1xuICAgICAgICAgIGg6IGNvbG9yVmFsdWVzWzBdLFxuICAgICAgICAgIHM6IGNvbG9yVmFsdWVzWzFdLFxuICAgICAgICAgIHY6IGNvbG9yVmFsdWVzWzJdXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBjb2xvci5pbmRleE9mKCcjJykgPiAtMTpcbiAgICAgICAgY29sb3JIZXggPSBjb2xvcjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnZlcnRGcm9tSGV4KGNvbG9ySGV4LCB0eXBlIHx8IHMuZm9ybWF0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnZlcnRGcm9tSGV4KGNvbG9yLCB0eXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdyZ2InOlxuICAgICAgICByZXR1cm4gaGV4MnJnYihjb2xvcik7XG5cbiAgICAgIGNhc2UgJ2hzbCc6XG4gICAgICAgIHJldHVybiBoZXgyaHNsKGNvbG9yKTtcblxuICAgICAgY2FzZSAnaHN2JzpcbiAgICAgICAgcmV0dXJuIGhleDJoc3YoY29sb3IpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Rmlyc3RFbXB0eVByZXZpZXdJbmRleCgpIHtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzLnNlbGVjdDsgKytpKSB7XG4gICAgICBpZiAodGVtcFByZXZpZXdWYWx1ZXNbaV0uY29sb3JJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhpZ2hsaWdodEFjdGl2ZUNvbG9yKCRjb2xvciwgY3R4KSB7XG4gICAgJCQxKCcubWJzYy1jb2xvci1hY3RpdmUnLCBjdHgpLnJlbW92ZUNsYXNzKCdtYnNjLWNvbG9yLWFjdGl2ZScpO1xuXG4gICAgaWYgKHJlZmluZU1vZGUpIHtcbiAgICAgICRjb2xvci5wYXJlbnQoKS5hZGRDbGFzcygnbWJzYy1jb2xvci1hY3RpdmUnKTtcblxuICAgICAgaWYgKGhhc1ByZXZpZXcgJiYgJGNvbG9yKSB7XG4gICAgICAgIGlmIChjb2xvclByZXZpZXdJbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICRjb2xvclByZXZpZXdJdGVtcy5lcShjb2xvclByZXZpZXdJbmQpLnBhcmVudCgpLmFkZENsYXNzKCdtYnNjLWNvbG9yLWFjdGl2ZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVmcmVzaFNlbGVjdGVkVmFsdWVzKG5ld3RlbXBDb2xvcnMsIHVwZGF0ZUlucHV0KSB7XG4gICAgdmFyIGksXG4gICAgICAgIHRlbXAsXG4gICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgcHJldkluZCA9IDAsXG4gICAgICAgIGNvbG9yVmFsdWVzID0gJCQxLm1hcCh0ZW1wQ29sb3JzLCBmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIHYuY2hhbmdlZENvbG9yIHx8IHYuY29sb3I7XG4gICAgfSk7IC8vIGNoZWNrIHRoZSBpbmRleGVzIGluIHRoZSB0ZW1wQ29sb3JzXG5cbiAgICBpZiAoc2luZ2xlU2VsZWN0KSB7XG4gICAgICBuZXd0ZW1wQ29sb3JzID0gJCQxLmlzQXJyYXkobmV3dGVtcENvbG9ycykgPyBuZXd0ZW1wQ29sb3JzWzBdIDogbmV3dGVtcENvbG9ycztcbiAgICAgIHRlbXAgPSBjb2xvclZhbHVlcy5pbmRleE9mKG5ld3RlbXBDb2xvcnMpO1xuXG4gICAgICBpZiAodGVtcCA+IC0xKSB7XG4gICAgICAgIGluZGV4ZXMucHVzaCh0ZW1wKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld3RlbXBDb2xvcnMgJiYgIWluZGV4ZXMubGVuZ3RoICYmIHJlZmluZU1vZGUpIHtcbiAgICAgICAgdmFyIGlucHV0SW5kZXggPSArJCQxKCcubWJzYy1jb2xvci1pbnB1dC1pdGVtJywgJGlucHV0KS5hdHRyKCdkYXRhLWNvbG9yJyk7XG5cbiAgICAgICAgaWYgKGlzTmFOKGlucHV0SW5kZXgpKSB7XG4gICAgICAgICAgaW5wdXRJbmRleCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRleGVzLnB1c2goaW5wdXRJbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb2xvckluZGV4ID0gaW5wdXRJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5ld3RlbXBDb2xvcnMpIHtcbiAgICAgIGlmIChoYXNQcmV2aWV3ICYmIHJlZmluZU1vZGUpIHtcbiAgICAgICAgZm9yICh2YXIgYyBpbiBwcmV2aWV3VmFsdWVzKSB7XG4gICAgICAgICAgaWYgKHByZXZpZXdWYWx1ZXNbY10uY29sb3JJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpbmRleGVzLnB1c2goK3ByZXZpZXdWYWx1ZXNbY10uY29sb3JJbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbmV3dGVtcENvbG9ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHRlbXAgPSBjb2xvclZhbHVlcy5pbmRleE9mKG5ld3RlbXBDb2xvcnNbaV0pO1xuXG4gICAgICAgICAgaWYgKHRlbXAgPiAtMSkge1xuICAgICAgICAgICAgaW5kZXhlcy5wdXNoKHRlbXApO1xuICAgICAgICAgICAgY29sb3JWYWx1ZXNbdGVtcF0gPSAndGVtcCcgKyBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gbG9vcCB0cm91Z2ggbmV3IGNvbG9yIGluZGV4ZXMgYW5kIGNoZWNrIHRoZSBjb2xvcnNcblxuXG4gICAgZm9yIChpID0gMDsgaSA8IGluZGV4ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICh0ZW1wQ29sb3JzW2luZGV4ZXNbaV1dKSB7XG4gICAgICAgIHRvZ2dsZUNvbG9yKHRydWUsIGluZGV4ZXNbaV0sIHByZXZJbmQrKywgdGVtcENvbG9yc1tpbmRleGVzW2ldXS5jaGFuZ2VkQ29sb3IgfHwgdGVtcENvbG9yc1tpbmRleGVzW2ldXS5jb2xvciwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSAvLyBsb29wIHRyb3VnaCBvdGhlciBjb2xvciBpbmRleGVzIGFuZCB1bmNoZWNrIHRoZSBjb2xvcnNcblxuXG4gICAgZm9yIChpID0gMDsgaSA8IHRlbXBDb2xvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChpbmRleGVzLmluZGV4T2YoaSkgPT0gLTEpIHtcbiAgICAgICAgdG9nZ2xlQ29sb3IoZmFsc2UsIGksIHVuZGVmaW5lZCwgdGVtcENvbG9yc1tpXS5jaGFuZ2VkQ29sb3IgfHwgdGVtcENvbG9yc1tpXS5jb2xvciwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0gLy8gZ2VuZXJhdGUgbmV3IHByZXZpZXcgb2JqZWN0XG5cblxuICAgIGlmIChoYXNQcmV2aWV3KSB7XG4gICAgICBmb3IgKGkgPSBwcmV2SW5kOyBpIDwgcy5zZWxlY3Q7ICsraSkge1xuICAgICAgICB0ZW1wUHJldmlld1ZhbHVlc1tpXSA9IHt9O1xuXG4gICAgICAgIGlmICgkY29sb3JQcmV2aWV3SXRlbXMpIHtcbiAgICAgICAgICAkY29sb3JQcmV2aWV3SXRlbXMuZXEoaSkuYWRkQ2xhc3MoJ21ic2MtY29sb3ItcHJldmlldy1pdGVtLWVtcHR5JykuY3NzKHtcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ICd0cmFuc3BhcmVudCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHByZXZpZXdWYWx1ZXMgPSBleHRlbmQkMSh0cnVlLCB7fSwgdGVtcFByZXZpZXdWYWx1ZXMpO1xuXG4gICAgaWYgKHVwZGF0ZUlucHV0ICE9PSBmYWxzZSkge1xuICAgICAgZ2VuZXJhdGVJbnB1dEl0ZW1zKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG9nZ2xlQ29sb3IoYWRkLCBjb2xvckluZGV4LCBjb2xvclByZXZpZXdJbmQsIGN1cnJWYWx1ZSwgdXBkYXRlUHJldmlldywgdXBkYXRlVmFsdWUpIHtcbiAgICBpZiAoaGFzUHJldmlldyAmJiB1cGRhdGVQcmV2aWV3KSB7XG4gICAgICB0ZW1wUHJldmlld1ZhbHVlc1tjb2xvclByZXZpZXdJbmRdLmNvbG9ySW5kZXggPSBhZGQgPyBjb2xvckluZGV4IDogdW5kZWZpbmVkO1xuICAgICAgdGVtcFByZXZpZXdWYWx1ZXNbY29sb3JQcmV2aWV3SW5kXS5jb2xvciA9IGFkZCA/IGN1cnJWYWx1ZSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKCRjb2xvclByZXZpZXdJdGVtcykge1xuICAgICAgICB2YXIgY29sb3JQcmV2SXRlbSA9ICRjb2xvclByZXZpZXdJdGVtcy5lcShjb2xvclByZXZpZXdJbmQpO1xuICAgICAgICBjb2xvclByZXZJdGVtLnJlbW92ZUNsYXNzKCdtYnNjLWNvbG9yLXByZXZpZXctaXRlbS1lbXB0eScpLmNzcyh7XG4gICAgICAgICAgYmFja2dyb3VuZDogYWRkID8gY3VyclZhbHVlIDogJ3RyYW5zcGFyZW50J1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWFkZCkge1xuICAgICAgICAgIGNvbG9yUHJldkl0ZW0uYWRkQ2xhc3MoJ21ic2MtY29sb3ItcHJldmlldy1pdGVtLWVtcHR5JykucGFyZW50KCkucmVtb3ZlQ2xhc3MoJ21ic2MtY29sb3ItYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodXBkYXRlVmFsdWUpIHtcbiAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgdGhhdC5fdGVtcFZhbHVlLnNwbGljZShjb2xvclByZXZpZXdJbmQsIDAsIGN1cnJWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGF0Ll90ZW1wVmFsdWUuc3BsaWNlKHRoYXQuX3RlbXBWYWx1ZS5pbmRleE9mKGN1cnJWYWx1ZSksIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgkY29sb3JJdGVtcykge1xuICAgICAgaWYgKGFkZCkge1xuICAgICAgICAkY29sb3JJdGVtcy5lcShjb2xvckluZGV4KS5hZGRDbGFzcygnbWJzYy1jb2xvci1zZWxlY3RlZCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGNvbG9ySXRlbXMuZXEoY29sb3JJbmRleCkucmVtb3ZlQ2xhc3MoJ21ic2MtY29sb3Itc2VsZWN0ZWQnKS5wYXJlbnQoKS5yZW1vdmVDbGFzcygnbWJzYy1jb2xvci1hY3RpdmUnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0ZW1wQ29sb3JzW2NvbG9ySW5kZXhdLnByZXZpZXdJbmQgPSBhZGQgPyBjb2xvclByZXZpZXdJbmQgOiB1bmRlZmluZWQ7XG4gICAgdGVtcENvbG9yc1tjb2xvckluZGV4XS5zZWxlY3RlZCA9IGFkZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldERlZmF1bHRWYWx1ZXMoY29sb3JJbmQsIGN0eCkge1xuICAgIGlmIChjb2xvckluZCAhPT0gdW5kZWZpbmVkICYmIChzaW5nbGVTZWxlY3QgfHwgdGVtcENvbG9yc1tjb2xvckluZF0gJiYgdGVtcENvbG9yc1tjb2xvckluZF0uc2VsZWN0ZWQpKSB7XG4gICAgICBjb2xvckluZGV4ID0gY29sb3JJbmQ7XG5cbiAgICAgIGlmICh0ZW1wQ29sb3JzW2NvbG9ySW5kXSkge1xuICAgICAgICBjdXJyVmFsdWUgPSB0ZW1wQ29sb3JzW2NvbG9ySW5kXS5jaGFuZ2VkQ29sb3IgfHwgdGVtcENvbG9yc1tjb2xvckluZF0uY29sb3I7XG4gICAgICAgICRjdXJySXRlbSA9ICRjb2xvckl0ZW1zLmVxKGNvbG9ySW5kKTsgLy8gcmVmcmVzaCBzbGlkZXIgdGVtcENvbG9yc1xuXG4gICAgICAgIGlmIChyZWZpbmVNb2RlKSB7XG4gICAgICAgICAgaGlnaGxpZ2h0QWN0aXZlQ29sb3IoJGNvbG9ySXRlbXMuZXEoY29sb3JJbmQpLCBjdHggfHwgJycpO1xuICAgICAgICAgIGN1cnJIc2xWYWx1ZSA9IGNvbnZlcnRUb0Zvcm1hdCh0ZW1wQ29sb3JzW2NvbG9ySW5kXS5jb2xvciwgJ2hzbCcpO1xuICAgICAgICAgIGN1cnJIc2xWYWx1ZS5sID0gY29udmVydFRvRm9ybWF0KGN1cnJWYWx1ZSwgJ2hzbCcpLmw7XG4gICAgICAgICAgY2hhbmdlU2xpZGVyU3RlcHNDb2xvcih0ZW1wQ29sb3JzW2NvbG9ySW5kXS5jb2xvcik7XG4gICAgICAgICAgc2xpZGVyLnNldFZhbCgxMDAgLSBjdXJySHNsVmFsdWUubCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVmaW5lTW9kZSkge1xuICAgICAgY2hhbmdlU2xpZGVyU3RlcHNDb2xvcigpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENvbG9yT2JqZWN0cygpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgYXJyID0gW107XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGVtcENvbG9ycy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHRlbXBDb2xvcnNbaV0uc2VsZWN0ZWQpIHtcbiAgICAgICAgYXJyLnB1c2godGVtcENvbG9yc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbG9yUHJldmlld1RhcChldiwgJG0pIHtcbiAgICB2YXIgaW5kZXggPSAkJDEoZXYudGFyZ2V0KS5pbmRleCgpO1xuICAgIGNvbG9ySW5kZXggPSB0ZW1wUHJldmlld1ZhbHVlc1tpbmRleF0uY29sb3JJbmRleDtcbiAgICAkY3Vyckl0ZW0gPSAkY29sb3JJdGVtcy5lcShjb2xvckluZGV4KTsgLy8gcmVmcmVzaCB2YWx1ZXNcblxuICAgIGNvbG9yUHJldmlld0luZCA9IGluZGV4O1xuICAgIHNldERlZmF1bHRWYWx1ZXMoY29sb3JJbmRleCwgJG0pO1xuICAgIHNjcm9sbFZpZXcuc2Nyb2xsKCRjdXJySXRlbSwgMjUwKTtcbiAgICB0cmlnZ2VyKCdvblByZXZpZXdJdGVtVGFwJywge1xuICAgICAgdGFyZ2V0OiBldi50YXJnZXQsXG4gICAgICB2YWx1ZTogdGVtcFByZXZpZXdWYWx1ZXNbaW5kZXhdLmNvbG9yLFxuICAgICAgaW5kZXg6IGluZGV4XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjb2xvclRhcChldiwgJG0pIHtcbiAgICB2YXIgaGFzU2VsZWN0ID0gZmFsc2UsXG4gICAgICAgICRzZWxlY3RlZHRlbXBDb2xvcnMgPSAkJDEoJy5tYnNjLWNvbG9yLXNlbGVjdGVkJywgJG0pO1xuICAgICRjdXJySXRlbSA9ICQkMShldi50YXJnZXQpO1xuXG4gICAgaWYgKCRjdXJySXRlbS5oYXNDbGFzcygnbWJzYy1jb2xvci1jbGVhci1pdGVtJykpIHtcbiAgICAgIGN1cnJWYWx1ZSA9ICcnO1xuICAgICAgdGhhdC5jbGVhcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzaW5nbGVTZWxlY3QgfHwgbWF4U2VsZWN0ID4gKyRzZWxlY3RlZHRlbXBDb2xvcnMubGVuZ3RoIHx8ICRjdXJySXRlbS5oYXNDbGFzcygnbWJzYy1jb2xvci1zZWxlY3RlZCcpKVxuICAgICAgLyogVFJJQUxDT05EICovXG4gICAgICB7XG4gICAgICAgIGNvbG9ySW5kZXggPSAkY3Vyckl0ZW0uYXR0cignZGF0YS1pbmRleCcpO1xuXG4gICAgICAgIGlmIChoYXNQcmV2aWV3KSB7XG4gICAgICAgICAgY29sb3JQcmV2aWV3SW5kID0gdGVtcENvbG9yc1tjb2xvckluZGV4XS5wcmV2aWV3SW5kICE9PSB1bmRlZmluZWQgPyB0ZW1wQ29sb3JzW2NvbG9ySW5kZXhdLnByZXZpZXdJbmQgOiBnZXRGaXJzdEVtcHR5UHJldmlld0luZGV4KCk7XG4gICAgICAgICAgaGFzU2VsZWN0ID0gcmVmaW5lTW9kZSAmJiAkY3Vyckl0ZW0uaGFzQ2xhc3MoJ21ic2MtY29sb3Itc2VsZWN0ZWQnKSAmJiAhJGN1cnJJdGVtLnBhcmVudCgpLmhhc0NsYXNzKCdtYnNjLWNvbG9yLWFjdGl2ZScpOyAvLyBzY3JvbGwgdG8gdGhlIHByZXZpZXcgY29sb3JcblxuICAgICAgICAgIGlmICgkY29sb3JQcmV2aWV3SXRlbXMubGVuZ3RoID4gNikge1xuICAgICAgICAgICAgcHJldmlld1Njcm9sbFZpZXcuc2Nyb2xsKCRjb2xvclByZXZpZXdJdGVtcy5lcShjb2xvclByZXZpZXdJbmQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyVmFsdWUgPSB0ZW1wQ29sb3JzW2NvbG9ySW5kZXhdLmNoYW5nZWRDb2xvciB8fCB0ZW1wQ29sb3JzW2NvbG9ySW5kZXhdLmNvbG9yO1xuXG4gICAgICAgIGlmIChzaW5nbGVTZWxlY3QpIHtcbiAgICAgICAgICAkc2VsZWN0ZWR0ZW1wQ29sb3JzLnJlbW92ZUNsYXNzKCdtYnNjLWNvbG9yLXNlbGVjdGVkJyk7XG4gICAgICAgICAgdGhhdC5fdGVtcFZhbHVlID0gY3VyclZhbHVlO1xuXG4gICAgICAgICAgaWYgKGN1cnJWYWx1ZSkge1xuICAgICAgICAgICAgJGN1cnJJdGVtLnRvZ2dsZUNsYXNzKCdtYnNjLWNvbG9yLXNlbGVjdGVkJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaGlnaGxpZ2h0QWN0aXZlQ29sb3IoJGN1cnJJdGVtLCAkbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGlnaGxpZ2h0QWN0aXZlQ29sb3IoJGN1cnJJdGVtLCAkbSk7XG5cbiAgICAgICAgICBpZiAoIWhhc1NlbGVjdCkge1xuICAgICAgICAgICAgdG9nZ2xlQ29sb3IoIXRlbXBDb2xvcnNbY29sb3JJbmRleF0uc2VsZWN0ZWQsIGNvbG9ySW5kZXgsIGNvbG9yUHJldmlld0luZCwgY3VyclZhbHVlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZXREZWZhdWx0VmFsdWVzKGNvbG9ySW5kZXgsICRtKTtcblxuICAgICAgICBpZiAodGhhdC5saXZlKSB7XG4gICAgICAgICAgdGhhdC5fZmlsbFZhbHVlKCk7XG5cbiAgICAgICAgICB0cmlnZ2VyKCdvblNldCcsIHtcbiAgICAgICAgICAgIHZhbHVlOiB0aGF0Ll92YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJpZ2dlcignb25JdGVtVGFwJywge1xuICAgICAgICAgIHRhcmdldDogZXYudGFyZ2V0LFxuICAgICAgICAgIHZhbHVlOiBjdXJyVmFsdWUsXG4gICAgICAgICAgc2VsZWN0ZWQ6IHRlbXBDb2xvcnNbY29sb3JJbmRleF0uc2VsZWN0ZWQsXG4gICAgICAgICAgaW5kZXg6IGNvbG9ySW5kZXhcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhhdC5fdXBkYXRlSGVhZGVyKCk7XG4gICAgICB9XG4gIH0gLy8gQ2FsbCB0aGUgcGFyZW50IGNvbnN0cnVjdG9yXG5cblxuICBGcmFtZS5jYWxsKHRoaXMsIGVsLCBzZXR0aW5ncywgdHJ1ZSk7IC8vIFB1YmxpYyBmdW5jdGlvbnNcblxuICAvKiBUUklBTEZVTkMgKi9cblxuICAvKipcclxuICAgKiBTZXRzIHRoZSB2YWx1ZVxyXG4gICAqL1xuXG4gIHRoYXQuc2V0VmFsID0gdGhhdC5fc2V0VmFsID0gZnVuY3Rpb24gKHZhbCwgZmlsbCwgY2hhbmdlLCB0ZW1wKSB7XG4gICAgdGhhdC5faGFzVmFsdWUgPSB2YWwgIT09IG51bGwgJiYgdmFsICE9PSB1bmRlZmluZWQ7XG4gICAgdGhhdC5fdGVtcFZhbHVlID0gc2luZ2xlU2VsZWN0ID8gJCQxLmlzQXJyYXkodmFsKSA/IHZhbFswXSA6IHZhbCA6ICQkMS5pc0FycmF5KHZhbCkgPyB2YWwgOiB2YWwgPyBbdmFsXSA6IFtdO1xuICAgIHNldFZhbHVlKGZpbGwsIGNoYW5nZSA9PT0gdW5kZWZpbmVkID8gZmlsbCA6IGNoYW5nZSwgdGVtcCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHNlbGVjdGVkIHZhbHVlXHJcbiAgICovXG5cblxuICB0aGF0LmdldFZhbCA9IHRoYXQuX2dldFZhbCA9IGZ1bmN0aW9uICh0ZW1wKSB7XG4gICAgcmV0dXJuIHRoYXQuX2hhc1ZhbHVlIHx8IHRlbXAgPyByZXR1cm5PYmogPyBnZXRDb2xvck9iamVjdHMoKSA6IHRoYXRbdGVtcCA/ICdfdGVtcFZhbHVlJyA6ICdfdmFsdWUnXSA6IG51bGw7XG4gIH07XG5cbiAgdGhhdC5fcmVhZFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2ID0gJGVsbS52YWwoKSB8fCAnJztcbiAgICB0aGF0Ll9oYXNWYWx1ZSA9IGZhbHNlO1xuXG4gICAgaWYgKHYubGVuZ3RoICE9PSAwICYmIHYgIT09ICcnKSB7XG4gICAgICB0aGF0Ll9oYXNWYWx1ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoYXQuX2hhc1ZhbHVlKSB7XG4gICAgICB0aGF0Ll90ZW1wVmFsdWUgPSBzaW5nbGVTZWxlY3QgPyB2IDogcy5mb3JtYXQgPT0gJ2hleCcgPyB2LnNwbGl0KCcsJykgOiB2Lm1hdGNoKC9bYS16XXszfVxcKChcXGQrXFwuP1xcZHswLH0/KSxcXHMqKFtcXGQuXSspJXswLH0sXFxzKihbXFxkLl0rKSV7MCx9XFwpL2dtaSk7XG4gICAgICBzZXRWYWx1ZSh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhhdC5fdGVtcFZhbHVlID0gW107XG4gICAgfVxuXG4gICAgcmVmcmVzaFNlbGVjdGVkVmFsdWVzKHRoYXQuX3RlbXBWYWx1ZSwgdGhhdC5faGFzVmFsdWUpO1xuICB9O1xuXG4gIHRoYXQuX2ZpbGxWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGF0Ll9oYXNWYWx1ZSA9IHRydWU7XG4gICAgc2V0VmFsdWUodHJ1ZSwgdHJ1ZSk7XG4gIH07XG5cbiAgdGhhdC5fZ2VuZXJhdGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpLFxuICAgICAgICBodG1sLFxuICAgICAgICBjdXJyQ29sb3IsXG4gICAgICAgIGNvbG9yT2Zmc2V0ID0gaGFzQ2xlYXIgPyAxIDogMDtcbiAgICByb3dJdGVtcyA9IGlzSG9yaXpvbnRhbFNjcm9sbCA/IE1hdGguY2VpbCgodGVtcENvbG9ycy5sZW5ndGggKyBjb2xvck9mZnNldCkgLyBzLnJvd3MpIDogcy5yb3dzOyAvLyBnZW5lcmF0ZSBjb2xvciBjb250ZW50XG5cbiAgICBodG1sID0gJzxkaXYgY2xhc3M9XCJtYnNjLWNvbG9yLXNjcm9sbC1jb250IG1ic2Mtdy1wICcgKyAoaXNIb3Jpem9udGFsU2Nyb2xsID8gJycgOiAnbWJzYy1jb2xvci12ZXJ0aWNhbCcpICsgJ1wiPjxkaXYgY2xhc3M9XCJtYnNjLWNvbG9yLWNvbnRcIj4nICsgKGlzSG9yaXpvbnRhbFNjcm9sbCA/ICc8ZGl2IGNsYXNzPVwibWJzYy1jb2xvci1yb3dcIj4nIDogJycpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHRlbXBDb2xvcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGN1cnJDb2xvciA9IHRlbXBDb2xvcnNbaV0uY2hhbmdlZENvbG9yIHx8IHRlbXBDb2xvcnNbaV0uY29sb3I7XG5cbiAgICAgIGlmIChoYXNDbGVhciAmJiBpID09PSAwKSB7XG4gICAgICAgIGh0bWwgKz0gJzxkaXYgY2xhc3M9XCJtYnNjLWNvbG9yLWl0ZW0tY1wiPjxkaXYgdGFiaW5kZXg9XCIwXCIgY2xhc3M9XCJtYnNjLWNvbG9yLWNsZWFyLWl0ZW0gbWJzYy1idG4tZSBtYnNjLWNvbG9yLXNlbGVjdGVkXCI+PGRpdiBjbGFzcz1cIm1ic2MtY29sb3ItY2xlYXItY3Jvc3NcIj48L2Rpdj48L2Rpdj48L2Rpdj4nO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSAhPT0gMCAmJiAoaSArIGNvbG9yT2Zmc2V0KSAlIHJvd0l0ZW1zID09PSAwKSB7XG4gICAgICAgIGh0bWwgKz0gaXNIb3Jpem9udGFsU2Nyb2xsID8gJzwvZGl2PjxkaXYgY2xhc3M9XCJtYnNjLWNvbG9yLXJvd1wiPicgOiAnJztcbiAgICAgIH1cblxuICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cIm1ic2MtY29sb3ItaXRlbS1jXCI+PGRpdiB0YWJpbmRleD1cIjBcIiBkYXRhLWluZGV4PVwiJyArIGkgKyAnXCIgY2xhc3M9XCJtYnNjLWNvbG9yLWl0ZW0gbWJzYy1idG4tZSBtYnNjLWljIG1ic2MtaWMtbWF0ZXJpYWwtY2hlY2sgbWJzYy1jb2xvci1idG4tZSAnICsgKHRlbXBDb2xvcnNbaV0uc2VsZWN0ZWQgPyAnbWJzYy1jb2xvci1zZWxlY3RlZCcgOiAnJykgKyAnXCIgIHN0eWxlPVwiYmFja2dyb3VuZDonICsgY3VyckNvbG9yICsgJ1wiPjwvZGl2PidcbiAgICAgIC8qIFRSSUFMICovXG4gICAgICArICc8L2Rpdj4nO1xuICAgIH1cblxuICAgIGh0bWwgKz0gJzwvZGl2PjwvZGl2PicgKyAoaXNIb3Jpem9udGFsU2Nyb2xsID8gJzwvZGl2PicgOiAnJyk7XG5cbiAgICBpZiAocmVmaW5lTW9kZSkge1xuICAgICAgLy8gYWRkIHJlZmluZSBzbGlkZXIgXG4gICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwibWJzYy1jb2xvci1zbGlkZXItY29udFwiPjxpbnB1dCBjbGFzcz1cIm1ic2MtY29sb3Itc2xpZGVyXCIgdHlwZT1cInJhbmdlXCIgZGF0YS1oaWdobGlnaHQ9XCJmYWxzZVwiIHZhbHVlPVwiNTBcIiBtaW49XCIwXCIgbWF4PVwiMTAwXCIvPjwvZGl2Pic7XG4gICAgfSAvLyBhZGQgcHJldmlldyBjb250YWluZXIgXG5cblxuICAgIGlmIChoYXNQcmV2aWV3KSB7XG4gICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwibWJzYy1jb2xvci1wcmV2aWV3LWNvbnRcIj48ZGl2IGNsYXNzPVwibWJzYy1jb2xvci1yZWZpbmUtcHJldmlld1wiPic7XG5cbiAgICAgIGZvciAodmFyIGMgaW4gcHJldmlld1ZhbHVlcykge1xuICAgICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwibWJzYy1jb2xvci1wcmV2aWV3LWl0ZW0tYyBtYnNjLWJ0bi1lIG1ic2MtY29sb3ItYnRuLWVcIiB0YWJpbmRleD1cIjBcIj48ZGl2IGNsYXNzPVwibWJzYy1jb2xvci1wcmV2aWV3LWl0ZW0gJyArIChwcmV2aWV3VmFsdWVzW2NdLmNvbG9yID8gJycgOiAnbWJzYy1jb2xvci1wcmV2aWV3LWl0ZW0tZW1wdHknKSArICdcIiBzdHlsZT1cImJhY2tncm91bmQ6ICcgKyAocHJldmlld1ZhbHVlc1tjXS5jb2xvciB8fCAnaW5pdGlhbCcpICsgJztcIj48L2Rpdj48L2Rpdj4nO1xuICAgICAgfVxuXG4gICAgICBodG1sICs9ICc8L2Rpdj48L2Rpdj4nO1xuICAgIH1cblxuICAgIHJldHVybiBodG1sO1xuICB9O1xuXG4gIHRoYXQuX3Bvc2l0aW9uID0gZnVuY3Rpb24gKCRtKSB7XG4gICAgdmFyIGNvbG9yQ29udCwgY29sb3JJdGVtV2lkdGg7XG5cbiAgICBpZiAoIWlzSG9yaXpvbnRhbFNjcm9sbCkge1xuICAgICAgY29sb3JDb250ID0gJG0uZmluZCgnLm1ic2MtY29sb3ItY29udCcpO1xuICAgICAgY29sb3JJdGVtV2lkdGggPSBNYXRoLmNlaWwoY29sb3JDb250LmZpbmQoJy5tYnNjLWNvbG9yLWl0ZW0tYycpWzBdLm9mZnNldFdpZHRoKTtcbiAgICAgIGNvbG9yQ29udC53aWR0aChNYXRoLm1pbihNYXRoLmZsb29yKCRtLmZpbmQoJy5tYnNjLWZyLWMnKS53aWR0aCgpIC8gY29sb3JJdGVtV2lkdGgpLCBNYXRoLnJvdW5kKHRlbXBDb2xvcnMubGVuZ3RoIC8gcy5yb3dzKSkgKiBjb2xvckl0ZW1XaWR0aCArIDEpO1xuICAgIH1cblxuICAgIGlmIChzY3JvbGxWaWV3KSB7XG4gICAgICBzY3JvbGxWaWV3LnJlZnJlc2goKTtcbiAgICB9XG5cbiAgICBpZiAocHJldmlld1Njcm9sbFZpZXcpIHtcbiAgICAgIHByZXZpZXdTY3JvbGxWaWV3LnJlZnJlc2goKTtcbiAgICB9XG4gIH07XG5cbiAgdGhhdC5fbWFya3VwSW5zZXJ0ZWQgPSBmdW5jdGlvbiAoJG1hcmt1cCkge1xuICAgIGlmICghaXNIb3Jpem9udGFsU2Nyb2xsKSB7XG4gICAgICAkbWFya3VwLmZpbmQoJy5tYnNjLWNvbG9yLXNjcm9sbC1jb250JykuY3NzKCdtYXgtaGVpZ2h0JywgJG1hcmt1cC5maW5kKCcubWJzYy1jb2xvci1pdGVtLWMnKVswXS5vZmZzZXRIZWlnaHQgKiBzLnJvd3MpO1xuICAgIH0gLy8gaW5pdCBjb2xvciBzY3JvbGxWaWV3XG5cblxuICAgIHNjcm9sbFZpZXcgPSBuZXcgU2Nyb2xsVmlld0Jhc2UoJG1hcmt1cC5maW5kKCcubWJzYy1jb2xvci1zY3JvbGwtY29udCcpWzBdLCB7XG4gICAgICBheGlzOiBpc0hvcml6b250YWxTY3JvbGwgPyAnWCcgOiAnWScsXG4gICAgICBydGw6IHMucnRsLFxuICAgICAgZWxhc3RpYzogNjAsXG4gICAgICBzdG9wUHJvcDogZmFsc2UsXG4gICAgICBtb3VzZXdoZWVsOiBzLm1vdXNld2hlZWwsXG4gICAgICBvbkJ0blRhcDogZnVuY3Rpb24gb25CdG5UYXAoZXYpIHtcbiAgICAgICAgY29sb3JUYXAoZXYsICRtYXJrdXApO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHRoYXQuX2F0dGFjaEV2ZW50cyA9IGZ1bmN0aW9uICgkbWFya3VwKSB7XG4gICAgdmFyIG1vZGlmaWVkQ29sb3I7XG4gICAgJGNvbG9ySXRlbXMgPSAkJDEoJy5tYnNjLWNvbG9yLWl0ZW0nLCAkbWFya3VwKTsgLy8gaGFuZGxlIGNvbG9yIHNlbGVjdGlvbiB3aXRoIHNwYWNlXG5cbiAgICAkbWFya3VwLm9uKCdrZXlkb3duJywgJy5tYnNjLWNvbG9yLWJ0bi1lJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgaWYgKGV2LmtleUNvZGUgPT0gMzIpIHtcbiAgICAgICAgLy8gU3BhY2UgXG4gICAgICAgIGlmIChldi50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdtYnNjLWNvbG9yLWl0ZW0nKSkge1xuICAgICAgICAgIGNvbG9yVGFwKGV2LCAkbWFya3VwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2xvclByZXZpZXdUYXAoZXYsICRtYXJrdXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoaGFzUHJldmlldykge1xuICAgICAgJGNvbG9yUHJldmlld0l0ZW1zID0gJCQxKCcubWJzYy1jb2xvci1wcmV2aWV3LWl0ZW0nLCAkbWFya3VwKTtcbiAgICB9IC8vIHJlZmluZSBtb2RlIFxuXG5cbiAgICBpZiAocmVmaW5lTW9kZSkge1xuICAgICAgJG1hcmt1cC5hZGRDbGFzcygnbWJzYy1jb2xvci1yZWZpbmUnKTtcbiAgICAgICRzbGlkZXJFbG0gPSAkJDEoJy5tYnNjLWNvbG9yLXNsaWRlcicsICRtYXJrdXApO1xuICAgICAgc2xpZGVyID0gbmV3IFNsaWRlcigkc2xpZGVyRWxtWzBdLCB7XG4gICAgICAgIHRoZW1lOiBzLnRoZW1lLFxuICAgICAgICBydGw6IHMucnRsXG4gICAgICB9KTtcbiAgICAgIHNsaWRlclRyYWNrID0gJG1hcmt1cC5maW5kKCcubWJzYy1wcm9ncmVzcy10cmFjaycpOyAvLyBjaGFuZ2Ugc2xpZGVyIHRyYWNrIHN0ZXAgY29sb3JcblxuICAgICAgaWYgKGNvbG9ySW5kZXggJiYgdGhhdC5fdmFsdWUpIHtcbiAgICAgICAgc2V0RGVmYXVsdFZhbHVlcyhjb2xvckluZGV4LCAkbWFya3VwKTtcbiAgICAgIH1cblxuICAgICAgJHNsaWRlckVsbS5vbignY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY29sb3JJbmRleCAhPT0gdW5kZWZpbmVkICYmIChzaW5nbGVTZWxlY3QgfHwgdGVtcENvbG9yc1tjb2xvckluZGV4XSAmJiB0ZW1wQ29sb3JzW2NvbG9ySW5kZXhdLnNlbGVjdGVkKSkge1xuICAgICAgICAgIGN1cnJIc2xWYWx1ZS5sID0gMTAwIC0gdGhpcy52YWx1ZTtcbiAgICAgICAgICBtb2RpZmllZENvbG9yID0gY29udmVydFRvRm9ybWF0KGN1cnJIc2xWYWx1ZS50b1N0cmluZygpKS50b1N0cmluZygpO1xuXG4gICAgICAgICAgaWYgKHNpbmdsZVNlbGVjdCkge1xuICAgICAgICAgICAgdGhhdC5fdGVtcFZhbHVlID0gbW9kaWZpZWRDb2xvcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhhdC5fdGVtcFZhbHVlW2NvbG9yUHJldmlld0luZCAhPT0gdW5kZWZpbmVkID8gY29sb3JQcmV2aWV3SW5kIDogdGhhdC5fdGVtcFZhbHVlLmxlbmd0aF0gPSBtb2RpZmllZENvbG9yO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRlbXBDb2xvcnNbY29sb3JJbmRleF0udGVtcENoYW5nZWRDb2xvciA9IG1vZGlmaWVkQ29sb3I7XG4gICAgICAgICAgJGNvbG9ySXRlbXMuZXEoY29sb3JJbmRleCkuY3NzKCdiYWNrZ3JvdW5kJywgbW9kaWZpZWRDb2xvcik7XG5cbiAgICAgICAgICBpZiAoaGFzUHJldmlldykge1xuICAgICAgICAgICAgdGVtcFByZXZpZXdWYWx1ZXNbY29sb3JQcmV2aWV3SW5kXS5jb2xvciA9IG1vZGlmaWVkQ29sb3I7XG4gICAgICAgICAgICAkY29sb3JQcmV2aWV3SXRlbXMuZXEoY29sb3JQcmV2aWV3SW5kKS5yZW1vdmVDbGFzcygnbWJzYy1jb2xvci1wcmV2aWV3LWl0ZW0tZW1wdHknKS5jc3Moe1xuICAgICAgICAgICAgICAnYmFja2dyb3VuZCc6IG1vZGlmaWVkQ29sb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGF0LmxpdmUpIHtcbiAgICAgICAgICAgIHRocm90dGxlKHRoYXQuX2ZpbGxWYWx1ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChoYXNQcmV2aWV3KSB7XG4gICAgICAvLyBpbml0IGNvbG9ycHJldmlyZXcgc2Nyb2xsdmlld1xuICAgICAgcHJldmlld1Njcm9sbFZpZXcgPSBuZXcgU2Nyb2xsVmlld0Jhc2UoJG1hcmt1cC5maW5kKCcubWJzYy1jb2xvci1wcmV2aWV3LWNvbnQnKVswXSwge1xuICAgICAgICBheGlzOiAnWCcsXG4gICAgICAgIHJ0bDogcy5ydGwsXG4gICAgICAgIHN0b3BQcm9wOiBmYWxzZSxcbiAgICAgICAgbW91c2V3aGVlbDogcy5tb3VzZXdoZWVsLFxuICAgICAgICBvbkJ0blRhcDogZnVuY3Rpb24gb25CdG5UYXAoZXYpIHtcbiAgICAgICAgICBjb2xvclByZXZpZXdUYXAoZXYsICRtYXJrdXApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGF0Ll91cGRhdGVIZWFkZXIoKTtcbiAgfTtcblxuICB0aGF0Ll9tYXJrdXBSZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNjcm9sbFZpZXcpIHtcbiAgICAgIHNjcm9sbFZpZXcuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIGlmIChzbGlkZXIpIHtcbiAgICAgIHNsaWRlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgaWYgKHByZXZpZXdTY3JvbGxWaWV3KSB7XG4gICAgICBwcmV2aWV3U2Nyb2xsVmlldy5kZXN0cm95KCk7XG4gICAgfVxuICB9O1xuXG4gIHRoYXQuX19wcm9jZXNzU2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGksIGRhdGE7XG4gICAgcyA9IHRoYXQuc2V0dGluZ3M7XG4gICAgdHJpZ2dlciA9IHRoYXQudHJpZ2dlcjtcbiAgICBpc0hvcml6b250YWxTY3JvbGwgPSBzLm5hdmlnYXRpb24gPT0gJ2hvcml6b250YWwnO1xuICAgIHRoYXQuX3ZhbHVlID0gW107XG4gICAgdGhhdC5fdGVtcFZhbHVlID0gW107XG4gICAgc2luZ2xlU2VsZWN0ID0gcy5zZWxlY3QgPT0gJ3NpbmdsZSc7XG4gICAgaGFzQ2xlYXIgPSBzLmNsZWFyICE9PSB1bmRlZmluZWQgPyBzLmNsZWFyIDogc2luZ2xlU2VsZWN0O1xuICAgIGRhdGEgPSBzLmRhdGEgfHwgW107XG5cbiAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICBzd2l0Y2ggKHMuZm9ybWF0KSB7XG4gICAgICAgIGNhc2UgJ3JnYic6XG4gICAgICAgICAgZGF0YSA9IFtcInJnYigyNTUsMjM1LDYwKVwiLCBcInJnYigyNTUsMTUzLDApXCIsIFwicmdiKDI0NCw2OCw1NSlcIiwgXCJyZ2IoMjM0LDMwLDk5KVwiLCBcInJnYigxNTYsMzgsMTc2KVwiLCBcInJnYigxMDQsNTgsMTgzKVwiLCBcInJnYig2Myw4MSwxODEpXCIsIFwicmdiKDMzLDE1MCwyNDMpXCIsIFwicmdiKDAsMTUxLDEzNilcIiwgXCJyZ2IoNzUsMTc1LDc5KVwiLCBcInJnYigxMjYsOTMsNzgpXCIsIFwicmdiKDE1OCwxNTgsMTU4KVwiXTtcblxuICAgICAgICAgIGlmIChoYXNDbGVhcikge1xuICAgICAgICAgICAgZGF0YS5zcGxpY2UoMTAsIDAsICdyZ2IoODMsIDcxLCA2NSknKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdoc2wnOlxuICAgICAgICAgIGRhdGEgPSBbXCJoc2woNTQsMTAwJSw2MiUpXCIsIFwiaHNsKDM2LDEwMCUsNTAlKVwiLCBcImhzbCg0LDkwJSw1OSUpXCIsIFwiaHNsKDM0MCw4MyUsNTIlKVwiLCBcImhzbCgyOTEsNjQlLDQyJSlcIiwgXCJoc2woMjYyLDUyJSw0NyUpXCIsIFwiaHNsKDIzMSw0OCUsNDglKVwiLCBcImhzbCgyMDcsOTAlLDU0JSlcIiwgXCJoc2woMTc0LDEwMCUsMzAlKVwiLCBcImhzbCgxMjIsNDAlLDQ5JSlcIiwgXCJoc2woMTksMjQlLDQwJSlcIiwgXCJoc2woMCwwJSw2MiUpXCJdO1xuXG4gICAgICAgICAgaWYgKGhhc0NsZWFyKSB7XG4gICAgICAgICAgICBkYXRhLnNwbGljZSgxMCwgMCwgJ2hzbCgyMCwgMTIlLCAyOSUpJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBkYXRhID0gWycjZmZlYjNjJywgJyNmZjk5MDAnLCAnI2Y0NDQzNycsICcjZWExZTYzJywgJyM5YzI2YjAnLCAnIzY4M2FiNycsICcjM2Y1MWI1JywgJyMyMTk2ZjMnLCAnIzAwOTc4OCcsICcjNGJhZjRmJywgJyM3ZTVkNGUnLCAnIzllOWU5ZSddO1xuXG4gICAgICAgICAgaWYgKGhhc0NsZWFyKSB7XG4gICAgICAgICAgICBkYXRhLnNwbGljZSgxMCwgMCwgJyM1MzQ3NDEnKTtcbiAgICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZWZpbmVNb2RlID0gcy5tb2RlID09ICdyZWZpbmUnO1xuICAgIGhhc1ByZXZpZXcgPSAhaXNOYU4ocy5zZWxlY3QpO1xuICAgIG1heFNlbGVjdCA9IGlzTmFOKHMuc2VsZWN0KSA/IHNpbmdsZVNlbGVjdCA/IDIgOiBkYXRhLmxlbmd0aCA6IHMuc2VsZWN0O1xuICAgIHJldHVybk9iaiA9ICQkMS5pc1BsYWluT2JqZWN0KGRhdGFbMF0pOyAvLyBnZW5lcmF0ZSBwcmV2aWV3IG9iamVjdFxuXG4gICAgaWYgKGhhc1ByZXZpZXcgJiYgIU9iamVjdC5rZXlzKHByZXZpZXdWYWx1ZXMpLmxlbmd0aCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHMuc2VsZWN0OyArK2kpIHtcbiAgICAgICAgcHJldmlld1ZhbHVlc1tpXSA9IHt9O1xuICAgICAgICB0ZW1wUHJldmlld1ZhbHVlc1tpXSA9IHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHRlbXBDb2xvcnMgPSBkYXRhLnNsaWNlKDApOyAvLyBjb252ZXJ0IHRlbXBDb2xvcnMgaW50byBvYmplY3RzXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGVtcENvbG9ycy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKCEkJDEuaXNQbGFpbk9iamVjdChkYXRhW2ldKSkge1xuICAgICAgICBkYXRhW2ldID0gZGF0YVtpXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB0ZW1wQ29sb3JzW2ldID0ge1xuICAgICAgICAgIGtleTogaSxcbiAgICAgICAgICBuYW1lOiBkYXRhW2ldLFxuICAgICAgICAgIGNvbG9yOiBkYXRhW2ldXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wQ29sb3JzW2ldLmNvbG9yID0gZGF0YVtpXS5jb2xvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWYgPSBzLmRlZmF1bHRWYWx1ZSB8fCB0ZW1wQ29sb3JzWzBdLmNvbG9yO1xuICAgIGN1cnJWYWx1ZSA9IGRlZjtcbiAgICBjdXJySHNsVmFsdWUgPSBjb252ZXJ0VG9Gb3JtYXQoY3VyclZhbHVlLCAnaHNsJyk7XG4gICAgZW5oYW5jZUlucHV0ID0gcy5lbmhhbmNlICYmICRlbG0uaXMoJ2lucHV0Jyk7IC8vIENyZWF0ZSBkdW1teSBpbnB1dFxuXG4gICAgaWYgKGVuaGFuY2VJbnB1dCkge1xuICAgICAgaWYgKCRlbG0uaGFzQ2xhc3MoJ21ic2MtY29sb3ItaW5wdXQtaGRuJykpIHtcbiAgICAgICAgJGlucHV0ID0gJGVsbS5wcmV2KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkaW5wdXQgPSAkJDEoJzxkaXYgJyArIChlbC5wbGFjZWhvbGRlciA/ICdkYXRhLXBsYWNlaG9sZGVyPVwiJyArIGVsLnBsYWNlaG9sZGVyICsgJ1wiJyA6ICcnKSArICcgY2xhc3M9XCJtYnNjLWNvbnRyb2wgbWJzYy1jb2xvci1pbnB1dCAnICsgKHMuaW5wdXRDbGFzcyB8fCAnJykgKyAnXCIgcmVhZG9ubHkgPjwvZGl2PicpO1xuICAgICAgICAkaW5wdXQuaW5zZXJ0QmVmb3JlKCRlbG0pO1xuICAgICAgICAkZWxtLmFkZENsYXNzKCdtYnNjLWNvbG9yLWlucHV0LWhkbicpLmF0dHIoJ3RhYmluZGV4JywgLTEpO1xuICAgICAgfVxuXG4gICAgICBzLmFuY2hvciA9ICRpbnB1dDtcbiAgICAgIHRoYXQuYXR0YWNoU2hvdygkaW5wdXQpO1xuICAgIH1cbiAgfTtcblxuICB0aGF0Ll9fZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZW5oYW5jZUlucHV0KSB7XG4gICAgICAkZWxtLnJlbW92ZUNsYXNzKCdtYnNjLWNvbG9yLWlucHV0LWhkbicpO1xuICAgICAgJGlucHV0LnJlbW92ZSgpO1xuICAgIH1cbiAgfTtcblxuICB0aGF0Ll9jaGVja1NpemUgPSB0cnVlOyAvLyBDb25zdHJ1Y3RvclxuXG4gIGlmICghaW5oZXJpdCkge1xuICAgIHRoYXQuaW5pdCgpO1xuICB9XG59OyAvLyBFeHRlbmQgZGVmYXVsdHNcblxuQ29sb3IucHJvdG90eXBlID0ge1xuICBfaGFzRGVmOiB0cnVlLFxuICBfaGFzVGhlbWU6IHRydWUsXG4gIF9oYXNMYW5nOiB0cnVlLFxuICBfY2xhc3M6ICdjb2xvcicsXG4gIF9kZWZhdWx0czogZXh0ZW5kJDEoe30sIEZyYW1lLnByb3RvdHlwZS5fZGVmYXVsdHMsIHtcbiAgICBoZWFkZXJUZXh0OiBmYWxzZSxcbiAgICB2YWxpZGF0ZTogbm9vcCxcbiAgICBwYXJzZVZhbHVlOiBub29wLFxuICAgIGVuaGFuY2U6IHRydWUsXG4gICAgcm93czogMixcbiAgICBzZWxlY3Q6ICdzaW5nbGUnLFxuICAgIGZvcm1hdDogJ2hleCcsXG4gICAgbmF2aWdhdGlvbjogJ2hvcml6b250YWwnLFxuICAgIGNvbXBDbGFzczogJ21ic2MtY29sb3InXG4gIH0pXG59O1xuY2xhc3Nlcy5Db2xvciA9IENvbG9yO1xubW9iaXNjcm9sbC50aGVtZXMuY29sb3IgPSBtb2Jpc2Nyb2xsLnRoZW1lcy5mcmFtZTsgLy8gRXhwb3NlIHV0aWxpdHkgZnVuY3Rpb25zXG5cbnV0aWwuY29sb3IgPSB7XG4gIGhzdjJoZXg6IGhzdjJoZXgsXG4gIGhzdjJyZ2I6IGhzdjJyZ2IsXG4gIHJnYjJoc3Y6IHJnYjJoc3YsXG4gIHJnYjJoZXg6IHJnYjJoZXgsXG4gIHJnYjJoc2w6IHJnYjJoc2wsXG4gIGhleDJyZ2I6IGhleDJyZ2IsXG4gIGhleDJoc3Y6IGhleDJoc3YsXG4gIGhleDJoc2w6IGhleDJoc2xcbn07XG5cbnZhciBNYnNjQ29sb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NDb2xvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NDb2xvcihpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgdmlldykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5vcHRpb25TZXJ2aWNlID0gb3B0aW9uU2VydmljZTtcclxuICAgICAgICBfdGhpcy5lbmhhbmNlID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMub25TZXQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMub25DbGVhciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5vbkl0ZW1UYXAgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMub25QcmV2aWV3SXRlbVRhcCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5vcHRpb25zID0ge307XHJcbiAgICAgICAgX3RoaXMub25DaGFuZ2VFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjQ29sb3IucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE1ic2NDb2xvci5wcm90b3R5cGUucmVmcmVzaERhdGEgPSBmdW5jdGlvbiAobmV3RGF0YSkge1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2Uub3B0aW9uKCdkYXRhJywgbmV3RGF0YSk7XHJcbiAgICB9O1xyXG4gICAgTWJzY0NvbG9yLnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHt9LCB0aGlzLm9wdGlvblNlcnZpY2UgPyB0aGlzLm9wdGlvblNlcnZpY2Uub3B0aW9ucyA6IHt9LCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaiwgdGhpcy5vcHRpb25FeHRlbnNpb25zKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IENvbG9yKHRoaXMuZWxlbWVudCwgb3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodGhpcy5pbml0aWFsVmFsdWUsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTWJzY0NvbG9yLnByb3RvdHlwZS5zZXROZXdWYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgdmFyIGNoYW5nZWQgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTXVsdGkpIHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSAhZGVlcEVxdWFsc0FycmF5KHYsIHRoaXMuaW5zdGFuY2UuZ2V0VmFsKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlubmVyVmFsdWUgPSB0aGlzLmluc3RhbmNlLmdldFZhbCgpO1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9IGlubmVyVmFsdWUgIT09IHY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0VmFsKHYsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbnB1dFNlcnZpY2UgJiYgdGhpcy5faW5wdXRTZXJ2aWNlLmlucHV0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5wdXRTZXJ2aWNlLmlucHV0LmlubmVyVmFsdWUgPSB0aGlzLmluc3RhbmNlLl92YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNYnNjQ29sb3IucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaXNNdWx0aSA9IHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuc2VsZWN0ICYmIHRoaXMub3B0aW9ucy5zZWxlY3QgIT09ICdzaW5nbGUnO1xyXG4gICAgICAgIHRoaXMuY2xvbmVEaWN0aW9uYXJ5LmRhdGEgPSBbXTtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nT25Jbml0LmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY0NvbG9yLnByb3RvdHlwZSwgXCJjbGVhclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnbWJzYy1kYXRhJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgTWJzY0NvbG9yLnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NDb2xvci5wcm90b3R5cGUsIFwiZGVmYXVsdFZhbHVlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjQ29sb3IucHJvdG90eXBlLCBcImVuaGFuY2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0NvbG9yLnByb3RvdHlwZSwgXCJmb3JtYXRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0NvbG9yLnByb3RvdHlwZSwgXCJpbnB1dENsYXNzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NDb2xvci5wcm90b3R5cGUsIFwibW9kZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjQ29sb3IucHJvdG90eXBlLCBcIm5hdmlnYXRpb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NDb2xvci5wcm90b3R5cGUsIFwicHJldmlld1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY0NvbG9yLnByb3RvdHlwZSwgXCJwcmV2aWV3VGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBNYnNjQ29sb3IucHJvdG90eXBlLCBcInJvd3NcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0NvbG9yLnByb3RvdHlwZSwgXCJ2YWx1ZVRleHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY0NvbG9yLnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjQ29sb3IucHJvdG90eXBlLCBcIm9uU2V0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY0NvbG9yLnByb3RvdHlwZSwgXCJvbkNsZWFyXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY0NvbG9yLnByb3RvdHlwZSwgXCJvbkl0ZW1UYXBcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjQ29sb3IucHJvdG90eXBlLCBcIm9uUHJldmlld0l0ZW1UYXBcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ21ic2Mtb3B0aW9ucycpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjQ29sb3IucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ21ic2MtY29sb3InKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXHJcbiAgICBdLCBNYnNjQ29sb3IucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCdtYnNjLWNvbG9yQ2hhbmdlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NDb2xvci5wcm90b3R5cGUsIFwib25DaGFuZ2VFbWl0dGVyXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjQ29sb3IgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBEaXJlY3RpdmUoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ1ttYnNjLWNvbG9yXScsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCdcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDIsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDMsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDQsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLCBOZ0NvbnRyb2wsIE1ic2NJbnB1dFNlcnZpY2UsIE1ic2NPcHRpb25zU2VydmljZSwgVmlld0NvbnRhaW5lclJlZl0pXHJcbiAgICBdLCBNYnNjQ29sb3IpO1xyXG4gICAgcmV0dXJuIE1ic2NDb2xvcjtcclxufShNYnNjRnJhbWVCYXNlKSk7XHJcbnZhciBNYnNjQ29sb3JDb21wb25lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NDb2xvckNvbXBvbmVudCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NDb2xvckNvbXBvbmVudChpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgbnVsbCkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5lcnJvck1lc3NhZ2UgPSAnJztcclxuICAgICAgICBfdGhpcy5wbGFjZWhvbGRlciA9ICcnO1xyXG4gICAgICAgIF90aGlzLmVuaGFuY2UgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE1ic2NDb2xvckNvbXBvbmVudC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0LmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zZXRUaGVtZUNsYXNzZXMoKTtcclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdpY29uJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NDb2xvckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5wdXRJY29uXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdpY29uLWFsaWduJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NDb2xvckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaWNvbkFsaWduXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NDb2xvckNvbXBvbmVudC5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY0NvbG9yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlcnJvclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjQ29sb3JDb21wb25lbnQucHJvdG90eXBlLCBcImVycm9yTWVzc2FnZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjQ29sb3JDb21wb25lbnQucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0NvbG9yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwbGFjZWhvbGRlclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIE1ic2NDb2xvckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY0NvbG9yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlbmhhbmNlXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjQ29sb3JDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtY29sb3InLFxyXG4gICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogSU5QVVRfVEVNUExBVEVcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDIsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDMsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDQsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLCBOZ0NvbnRyb2wsIE1ic2NJbnB1dFNlcnZpY2UsIE1ic2NPcHRpb25zU2VydmljZV0pXHJcbiAgICBdLCBNYnNjQ29sb3JDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIE1ic2NDb2xvckNvbXBvbmVudDtcclxufShNYnNjQ29sb3IpKTtcclxudmFyIE1ic2NDb2xvck1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNYnNjQ29sb3JNb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBNYnNjQ29sb3JNb2R1bGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBOZ01vZHVsZSh7XHJcbiAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIE1ic2NGcmFtZUJhc2VNb2R1bGUsIE1ic2NJbnB1dE1vZHVsZV0sXHJcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01ic2NDb2xvciwgTWJzY0NvbG9yQ29tcG9uZW50XSxcclxuICAgICAgICAgICAgZXhwb3J0czogW01ic2NDb2xvciwgTWJzY0NvbG9yQ29tcG9uZW50XVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBNYnNjQ29sb3JNb2R1bGUpO1xyXG4gICAgcmV0dXJuIE1ic2NDb2xvck1vZHVsZTtcclxufSgpKTtcblxudmFyIERhdGVUaW1lJDEgPSBTY3JvbGxlcjtcbnByZXNldHMuZGF0ZSA9IERhdGVUaW1lO1xucHJlc2V0cy50aW1lID0gRGF0ZVRpbWU7XG5wcmVzZXRzLmRhdGV0aW1lID0gRGF0ZVRpbWU7XG5cbnZhciBNYnNjRGF0ZUJhc2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NEYXRlQmFzZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NEYXRlQmFzZShpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgdmlldykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5vcHRpb25TZXJ2aWNlID0gb3B0aW9uU2VydmljZTtcclxuICAgICAgICBfdGhpcy5vcHRpb25zID0ge307XHJcbiAgICAgICAgX3RoaXMucHJlc2V0ID0gJ2RhdGUnO1xyXG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY0RhdGVCYXNlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB0aGlzLnNldE5ld1ZhbHVlUHJveHkodik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBNYnNjRGF0ZUJhc2UucHJvdG90eXBlLnNldE5ld1ZhbHVlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB2YXIgaW5uZXJWYWx1ZSA9IHRoaXMuaW5zdGFuY2UuZ2V0VmFsKCk7XHJcbiAgICAgICAgICAgIGlmICgoIWlubmVyVmFsdWUgJiYgdikgfHxcclxuICAgICAgICAgICAgICAgIChpbm5lclZhbHVlICYmICF2KSB8fFxyXG4gICAgICAgICAgICAgICAgKGlubmVyVmFsdWUgJiYgdiAmJiBpbm5lclZhbHVlLnRvU3RyaW5nKCkgIT09IHYudG9TdHJpbmcoKSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0VmFsKHYsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbnB1dFNlcnZpY2UgJiYgdGhpcy5faW5wdXRTZXJ2aWNlLmlucHV0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5wdXRTZXJ2aWNlLmlucHV0LmlubmVyVmFsdWUgPSB0aGlzLmluc3RhbmNlLl92YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNYnNjRGF0ZUJhc2UucHJvdG90eXBlLmluaXRDb250cm9sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gZXh0ZW5kJDEoeyBwcmVzZXQ6IHRoaXMucHJlc2V0IH0sIHRoaXMub3B0aW9uU2VydmljZSA/IHRoaXMub3B0aW9uU2VydmljZS5vcHRpb25zIDoge30sIHRoaXMub3B0aW9ucywgdGhpcy5pbmxpbmVPcHRpb25zT2JqLCB0aGlzLm9wdGlvbkV4dGVuc2lvbnMpO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgRGF0ZVRpbWUkMSh0aGlzLmVsZW1lbnQsIG9wdGlvbnMpO1xyXG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuaW5pdGlhbFZhbHVlICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0VmFsKHRoaXMuaW5pdGlhbFZhbHVlLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ21ic2Mtb3B0aW9ucycpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjRGF0ZUJhc2UucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ21ic2MtZGF0ZScpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEYXRlKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0RhdGVdKVxyXG4gICAgXSwgTWJzY0RhdGVCYXNlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCBudWxsKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgnbWJzYy1kYXRlQ2hhbmdlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NEYXRlQmFzZS5wcm90b3R5cGUsIFwib25DaGFuZ2VFbWl0dGVyXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjRGF0ZUJhc2UgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1ttYnNjLWR0LWJdJyB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZSwgTmdDb250cm9sLCBNYnNjSW5wdXRTZXJ2aWNlLCBNYnNjT3B0aW9uc1NlcnZpY2UsIFZpZXdDb250YWluZXJSZWZdKVxyXG4gICAgXSwgTWJzY0RhdGVCYXNlKTtcclxuICAgIHJldHVybiBNYnNjRGF0ZUJhc2U7XHJcbn0oTWJzY0RhdGV0aW1lQmFzZSkpO1xyXG52YXIgTWJzY0RhdGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NEYXRlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY0RhdGUoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMucHJlc2V0ID0gJ2RhdGUnO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE1ic2NEYXRlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgRGlyZWN0aXZlKHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWJzYy1kYXRlXScsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCdcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDIsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDMsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDQsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLCBOZ0NvbnRyb2wsIE1ic2NJbnB1dFNlcnZpY2UsIE1ic2NPcHRpb25zU2VydmljZSwgVmlld0NvbnRhaW5lclJlZl0pXHJcbiAgICBdLCBNYnNjRGF0ZSk7XHJcbiAgICByZXR1cm4gTWJzY0RhdGU7XHJcbn0oTWJzY0RhdGVCYXNlKSk7XHJcbnZhciBNYnNjRGF0ZUNvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY0RhdGVDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjRGF0ZUNvbXBvbmVudChpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgbnVsbCkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5lcnJvck1lc3NhZ2UgPSAnJztcclxuICAgICAgICBfdGhpcy5wbGFjZWhvbGRlciA9ICcnO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE1ic2NEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnNldFRoZW1lQ2xhc3NlcygpO1xyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ2ljb24nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0RhdGVDb21wb25lbnQucHJvdG90eXBlLCBcImlucHV0SWNvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnaWNvbi1hbGlnbicpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiaWNvbkFsaWduXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NEYXRlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZXJyb3JcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0RhdGVDb21wb25lbnQucHJvdG90eXBlLCBcImVycm9yTWVzc2FnZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUsIFwicGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NEYXRlQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLWRhdGUnLFxyXG4gICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogSU5QVVRfVEVNUExBVEVcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDIsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDMsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDQsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLCBOZ0NvbnRyb2wsIE1ic2NJbnB1dFNlcnZpY2UsIE1ic2NPcHRpb25zU2VydmljZV0pXHJcbiAgICBdLCBNYnNjRGF0ZUNvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gTWJzY0RhdGVDb21wb25lbnQ7XHJcbn0oTWJzY0RhdGUpKTtcclxudmFyIE1ic2NUaW1lID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjVGltZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NUaW1lKGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIHZpZXcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5wcmVzZXQgPSAndGltZSc7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NUaW1lLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB0aGlzLnNldE5ld1ZhbHVlUHJveHkodik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdtYnNjLXRpbWUnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEYXRlXSlcclxuICAgIF0sIE1ic2NUaW1lLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCBudWxsKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgnbWJzYy10aW1lQ2hhbmdlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NUaW1lLnByb3RvdHlwZSwgXCJvbkNoYW5nZUVtaXR0ZXJcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NUaW1lID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgRGlyZWN0aXZlKHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWJzYy10aW1lXScsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCdcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDIsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDMsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDQsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLCBOZ0NvbnRyb2wsIE1ic2NJbnB1dFNlcnZpY2UsIE1ic2NPcHRpb25zU2VydmljZSwgVmlld0NvbnRhaW5lclJlZl0pXHJcbiAgICBdLCBNYnNjVGltZSk7XHJcbiAgICByZXR1cm4gTWJzY1RpbWU7XHJcbn0oTWJzY0RhdGVCYXNlKSk7XHJcbnZhciBNYnNjVGltZUNvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY1RpbWVDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjVGltZUNvbXBvbmVudChpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgbnVsbCkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5lcnJvck1lc3NhZ2UgPSAnJztcclxuICAgICAgICBfdGhpcy5wbGFjZWhvbGRlciA9ICcnO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE1ic2NUaW1lQ29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnNldFRoZW1lQ2xhc3NlcygpO1xyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ2ljb24nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1RpbWVDb21wb25lbnQucHJvdG90eXBlLCBcImlucHV0SWNvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnaWNvbi1hbGlnbicpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjVGltZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiaWNvbkFsaWduXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NUaW1lQ29tcG9uZW50LnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjVGltZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZXJyb3JcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1RpbWVDb21wb25lbnQucHJvdG90eXBlLCBcImVycm9yTWVzc2FnZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjVGltZUNvbXBvbmVudC5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjVGltZUNvbXBvbmVudC5wcm90b3R5cGUsIFwicGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NUaW1lQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLXRpbWUnLFxyXG4gICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogSU5QVVRfVEVNUExBVEVcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDIsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDMsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDQsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLCBOZ0NvbnRyb2wsIE1ic2NJbnB1dFNlcnZpY2UsIE1ic2NPcHRpb25zU2VydmljZV0pXHJcbiAgICBdLCBNYnNjVGltZUNvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gTWJzY1RpbWVDb21wb25lbnQ7XHJcbn0oTWJzY1RpbWUpKTtcclxudmFyIE1ic2NEYXRldGltZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY0RhdGV0aW1lLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY0RhdGV0aW1lKGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIHZpZXcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5wcmVzZXQgPSAnZGF0ZXRpbWUnO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjRGF0ZXRpbWUucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ21ic2MtZGF0ZXRpbWUnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEYXRlXSlcclxuICAgIF0sIE1ic2NEYXRldGltZS5wcm90b3R5cGUsIFwidmFsdWVcIiwgbnVsbCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoJ21ic2MtZGF0ZXRpbWVDaGFuZ2UnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY0RhdGV0aW1lLnByb3RvdHlwZSwgXCJvbkNoYW5nZUVtaXR0ZXJcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NEYXRldGltZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIERpcmVjdGl2ZSh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW21ic2MtZGF0ZXRpbWVdJyxcclxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJ1xyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMiwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksIF9fcGFyYW0oNCwgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBOZ1pvbmUsIE5nQ29udHJvbCwgTWJzY0lucHV0U2VydmljZSwgTWJzY09wdGlvbnNTZXJ2aWNlLCBWaWV3Q29udGFpbmVyUmVmXSlcclxuICAgIF0sIE1ic2NEYXRldGltZSk7XHJcbiAgICByZXR1cm4gTWJzY0RhdGV0aW1lO1xyXG59KE1ic2NEYXRlQmFzZSkpO1xyXG52YXIgTWJzY0RhdGV0aW1lQ29tcG9uZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjRGF0ZXRpbWVDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjRGF0ZXRpbWVDb21wb25lbnQoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIG51bGwpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZXJyb3JNZXNzYWdlID0gJyc7XHJcbiAgICAgICAgX3RoaXMucGxhY2Vob2xkZXIgPSAnJztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBNYnNjRGF0ZXRpbWVDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2V0VGhlbWVDbGFzc2VzKCk7XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnaWNvbicpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjRGF0ZXRpbWVDb21wb25lbnQucHJvdG90eXBlLCBcImlucHV0SWNvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnaWNvbi1hbGlnbicpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjRGF0ZXRpbWVDb21wb25lbnQucHJvdG90eXBlLCBcImljb25BbGlnblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjRGF0ZXRpbWVDb21wb25lbnQucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NEYXRldGltZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZXJyb3JcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0RhdGV0aW1lQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlcnJvck1lc3NhZ2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY0RhdGV0aW1lQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvcHRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NEYXRldGltZUNvbXBvbmVudC5wcm90b3R5cGUsIFwicGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NEYXRldGltZUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1kYXRldGltZScsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBJTlBVVF9URU1QTEFURVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMiwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksIF9fcGFyYW0oNCwgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBOZ1pvbmUsIE5nQ29udHJvbCwgTWJzY0lucHV0U2VydmljZSwgTWJzY09wdGlvbnNTZXJ2aWNlXSlcclxuICAgIF0sIE1ic2NEYXRldGltZUNvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gTWJzY0RhdGV0aW1lQ29tcG9uZW50O1xyXG59KE1ic2NEYXRldGltZSkpO1xyXG52YXIgY29tcCQyID0gW01ic2NEYXRlQmFzZSwgTWJzY0RhdGUsIE1ic2NEYXRlQ29tcG9uZW50LCBNYnNjVGltZSwgTWJzY1RpbWVDb21wb25lbnQsIE1ic2NEYXRldGltZSwgTWJzY0RhdGV0aW1lQ29tcG9uZW50XTtcclxudmFyIE1ic2NEYXRldGltZU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNYnNjRGF0ZXRpbWVNb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBNYnNjRGF0ZXRpbWVNb2R1bGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBOZ01vZHVsZSh7XHJcbiAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIE1ic2NEYXRldGltZUJhc2VNb2R1bGUsIE1ic2NJbnB1dE1vZHVsZV0sXHJcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogY29tcCQyLFxyXG4gICAgICAgICAgICBleHBvcnRzOiBjb21wJDJcclxuICAgICAgICB9KVxyXG4gICAgXSwgTWJzY0RhdGV0aW1lTW9kdWxlKTtcclxuICAgIHJldHVybiBNYnNjRGF0ZXRpbWVNb2R1bGU7XHJcbn0oKSk7XG5cbnZhciBQb3B1cCA9IGZ1bmN0aW9uIFBvcHVwKGVsLCBzZXR0aW5ncywgaW5oZXJpdCkge1xuICBmdW5jdGlvbiBhZGRDb250ZW50KCRtKSB7XG4gICAgLyogVFJJQUwgKi9cbiAgICBpZiAoISQkMSgnLm1ic2MtZnItYycsICRtKS5oYXNDbGFzcygnbWJzYy13ZGctYycpXG4gICAgLyogVFJJQUxDT05EICovXG4gICAgKSB7XG4gICAgICAgICQkMSgnLm1ic2MtZnItYycsICRtKS5hZGRDbGFzcygnbWJzYy13ZGctYycpLmFwcGVuZCgkZWxtLnNob3coKSk7XG5cbiAgICAgICAgaWYgKCEkJDEoJy5tYnNjLXctcCcsICRtKS5sZW5ndGgpIHtcbiAgICAgICAgICAkJDEoJy5tYnNjLWZyLWMnLCAkbSkuYWRkQ2xhc3MoJ21ic2Mtdy1wJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxuXG4gIHZhciBzLFxuICAgICAgJHByZXYsXG4gICAgICAkZWxtID0gJCQxKGVsKSxcbiAgICAgIHRoYXQgPSB0aGlzOyAvLyBDYWxsIHRoZSBwYXJlbnQgY29uc3RydWN0b3JcblxuICBGcmFtZS5jYWxsKHRoaXMsIGVsLCBzZXR0aW5ncywgdHJ1ZSk7XG4gIC8qIFRSSUFMRlVOQyAqL1xuXG4gIHRoYXQuX2dlbmVyYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH07XG5cbiAgdGhhdC5fbWFya3VwUmVhZHkgPSBmdW5jdGlvbiAoJG0pIHtcbiAgICBpZiAocy5kaXNwbGF5ICE9ICdpbmxpbmUnKSB7XG4gICAgICBhZGRDb250ZW50KCRtKTtcbiAgICB9XG4gIH07XG5cbiAgdGhhdC5fbWFya3VwSW5zZXJ0ZWQgPSBmdW5jdGlvbiAoJG0pIHtcbiAgICBpZiAocy5kaXNwbGF5ID09ICdpbmxpbmUnKSB7XG4gICAgICBhZGRDb250ZW50KCRtKTtcbiAgICB9XG5cbiAgICAkbS50cmlnZ2VyKCdtYnNjLWVuaGFuY2UnLCBbe1xuICAgICAgdGhlbWU6IHMudGhlbWUsXG4gICAgICBsYW5nOiBzLmxhbmdcbiAgICB9XSk7XG4gIH07XG5cbiAgdGhhdC5fbWFya3VwUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICRlbG0uaGlkZSgpO1xuXG4gICAgaWYgKCRwcmV2ICYmICRwcmV2LnBhcmVudCgpLmxlbmd0aCkge1xuICAgICAgJHByZXYuYWZ0ZXIoJGVsbSk7XG4gICAgfVxuICB9O1xuXG4gIHRoYXQuX19wcm9jZXNzU2V0dGluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgcyA9IHRoYXQuc2V0dGluZ3M7XG4gICAgdGhhdC5idXR0b25zLm9rID0ge1xuICAgICAgdGV4dDogcy5va1RleHQsXG4gICAgICBpY29uOiBzLm9rSWNvbixcbiAgICAgIGhhbmRsZXI6ICdzZXQnXG4gICAgfTtcbiAgICBzLmJ1dHRvbnMgPSBzLmJ1dHRvbnMgfHwgKHMuZGlzcGxheSA9PSAnaW5saW5lJyA/IFtdIDogWydvayddKTtcblxuICAgIGlmICghJHByZXYgJiYgJGVsbS5wYXJlbnQoKS5sZW5ndGgpIHtcbiAgICAgICRwcmV2ID0gJCQxKGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJ3BvcHVwJykpO1xuICAgICAgJGVsbS5iZWZvcmUoJHByZXYpO1xuICAgIH1cblxuICAgICRlbG0uaGlkZSgpO1xuICB9OyAvLyBDb25zdHJ1Y3RvclxuXG5cbiAgaWYgKCFpbmhlcml0KSB7XG4gICAgdGhhdC5pbml0KCk7XG4gIH1cbn07XG5Qb3B1cC5wcm90b3R5cGUgPSB7XG4gIF9oYXNEZWY6IHRydWUsXG4gIF9oYXNUaGVtZTogdHJ1ZSxcbiAgX2hhc0NvbnRlbnQ6IHRydWUsXG4gIF9oYXNMYW5nOiB0cnVlLFxuICBfcmVzcG9uc2l2ZTogdHJ1ZSxcbiAgX2NsYXNzOiAncG9wdXAnLFxuICBfZGVmYXVsdHM6IGV4dGVuZCQxKHt9LCBGcmFtZS5wcm90b3R5cGUuX2RlZmF1bHRzLCB7XG4gICAgY29tcENsYXNzOiAnbWJzYy13ZGcnLFxuICAgIG9rVGV4dDogJ09LJyxcbiAgICBoZWFkZXJUZXh0OiBmYWxzZVxuICB9KVxufTtcbmNsYXNzZXMuUG9wdXAgPSBQb3B1cDtcbmNsYXNzZXMuV2lkZ2V0ID0gUG9wdXA7XG5tb2Jpc2Nyb2xsLnRoZW1lcy5wb3B1cCA9IG1vYmlzY3JvbGwudGhlbWVzLmZyYW1lO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbnZhciBFdmVudGNhbGVuZGFyID0gU2Nyb2xsZXI7XG5cbmZ1bmN0aW9uIGdldEhlaWdodChlbCkge1xuICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgcmV0dXJuIGVsLmlubmVySGVpZ2h0IHx8IGVsLmNsaWVudEhlaWdodCAtIHBhcnNlRmxvYXQoc3R5bGUucGFkZGluZ1RvcCkgLSBwYXJzZUZsb2F0KHN0eWxlLnBhZGRpbmdCb3R0b20pO1xufVxuXG52YXIgZGVmYXVsdHMkNCA9IHtcbiAgdmlldzoge1xuICAgIGNhbGVuZGFyOiB7XG4gICAgICB0eXBlOiAnbW9udGgnLFxuICAgICAgcG9wb3ZlcjogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgLy8gTG9jYWxpemF0aW9uXG4gIGFsbERheVRleHQ6ICdBbGwtZGF5JyxcbiAgbGFiZWxzU2hvcnQ6IFsnWXJzJywgJ010aHMnLCAnRGF5cycsICdIcnMnLCAnTWlucycsICdTZWNzJ10sXG4gIGV2ZW50VGV4dDogJ2V2ZW50JyxcbiAgZXZlbnRzVGV4dDogJ2V2ZW50cycsXG4gIG5vRXZlbnRzVGV4dDogJ05vIGV2ZW50cydcbn0sXG4gICAgb3ZlcnJpZGVzID0ge1xuICB5ZWFyQ2hhbmdlOiBmYWxzZSxcbiAgd2Vla0RheXM6ICdzaG9ydCdcbn07XG5cbnByZXNldHMuZXZlbnRjYWxlbmRhciA9IGZ1bmN0aW9uIChpbnN0LCBzZXR0aW5ncykge1xuICAvLyBQcml2YXRlIGZ1bmN0aW9uc1xuICAvLyAtLS1cbiAgZnVuY3Rpb24gcHJvY2Vzc1NldHRpbmdzKCkge1xuICAgIHZhciB2aWV3ID0gcy52aWV3LFxuICAgICAgICBjYWxlbmRhciA9IHZpZXcuY2FsZW5kYXIsXG4gICAgICAgIGxpc3QgPSB2aWV3LmV2ZW50TGlzdCxcbiAgICAgICAgbW9udGhzID0gcy5tb250aHMsXG4gICAgICAgIHdlZWtzID0gcy53ZWVrcztcblxuICAgIGlmIChjYWxlbmRhcikge1xuICAgICAgaWYgKGNhbGVuZGFyLnR5cGUgPT0gJ3dlZWsnKSB7XG4gICAgICAgIHdlZWtzID0gY2FsZW5kYXIuc2l6ZSB8fCAxO1xuICAgICAgfSBlbHNlIGlmIChjYWxlbmRhci5zaXplKSB7XG4gICAgICAgIG1vbnRocyA9IGNhbGVuZGFyLnNpemU7XG4gICAgICB9XG5cbiAgICAgIGlzTGlzdE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2Vla3MgPSAwO1xuICAgICAgaXNMaXN0T25seSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxpc3QpIHtcbiAgICAgIGxpc3RUeXBlID0gbGlzdC50eXBlO1xuICAgICAgbGlzdFNpemUgPSBsaXN0LnNpemUgfHwgMTtcbiAgICB9XG5cbiAgICBtdWx0aUxhYmVsID0gY2FsZW5kYXIgJiYgY2FsZW5kYXIubGFiZWxzO1xuICAgIHNjcm9sbEV2ZW50TGlzdCA9IGxpc3QgJiYgbGlzdC5zY3JvbGxhYmxlO1xuICAgIHNob3dFdmVudExpc3QgPSB2aWV3LmV2ZW50TGlzdDtcbiAgICBzaG93RXZlbnRCdWJibGUgPSBzLmV2ZW50QnViYmxlID09PSB1bmRlZmluZWQgPyBjYWxlbmRhciAmJiBjYWxlbmRhci5wb3BvdmVyIDogcy5ldmVudEJ1YmJsZTtcbiAgICBzLndlZWtzID0gd2Vla3M7XG4gICAgcy5tb250aHMgPSBtb250aHM7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVUaXRsZShmaXJzdERheSwgbGFzdERheSkge1xuICAgIHZhciB0aXRsZSxcbiAgICAgICAgbW9udGhJbmRleCA9IChzLmRhdGVXaGVlbHMgfHwgcy5kYXRlRm9ybWF0KS5zZWFyY2goL20vaSksXG4gICAgICAgIHllYXJJbmRleCA9IChzLmRhdGVXaGVlbHMgfHwgcy5kYXRlRm9ybWF0KS5zZWFyY2goL3kvaSksXG4gICAgICAgIGZpcnN0WWVhciA9IHMuZ2V0WWVhcihmaXJzdERheSksXG4gICAgICAgIGZpcnN0TW9udGggPSBzLmdldE1vbnRoKGZpcnN0RGF5KSxcbiAgICAgICAgbGFzdFllYXIgPSBzLmdldFllYXIobGFzdERheSksXG4gICAgICAgIGxhc3RNb250aCA9IHMuZ2V0TW9udGgobGFzdERheSk7XG5cbiAgICBpbnN0Ll9jaGVja0J0bigkJDEoJy5tYnNjLWNhbC1wcmV2LW0nLCAkY3R4KSwgZ2V0RGF0ZU9ubHkoZmlyc3REYXkpIDw9IGluc3QuX21pbkRhdGUpO1xuXG4gICAgaW5zdC5fY2hlY2tCdG4oJCQxKCcubWJzYy1jYWwtbmV4dC1tJywgJGN0eCksIGdldERhdGVPbmx5KGxhc3REYXkpID49IGluc3QuX21heERhdGUpO1xuXG4gICAgaWYgKGxpc3RUeXBlID09ICdkYXknKSB7XG4gICAgICB0aXRsZSA9IGZvcm1hdERhdGUocy5kYXRlRm9ybWF0LCBmaXJzdERheSwgcykgKyAobGlzdFNpemUgPiAxID8gJyAtICcgKyBmb3JtYXREYXRlKHMuZGF0ZUZvcm1hdCwgbGFzdERheSwgcykgOiAnJyk7XG4gICAgfSBlbHNlIGlmIChsaXN0VHlwZSA9PSAnd2VlaycpIHtcbiAgICAgIHRpdGxlID0gZm9ybWF0RGF0ZShzLmRhdGVGb3JtYXQsIGZpcnN0RGF5LCBzKSArICcgLSAnICsgZm9ybWF0RGF0ZShzLmRhdGVGb3JtYXQsIGxhc3REYXksIHMpO1xuICAgIH0gZWxzZSBpZiAobGlzdFR5cGUgPT0gJ21vbnRoJykge1xuICAgICAgaWYgKGxpc3RTaXplID09IDEpIHtcbiAgICAgICAgdGl0bGUgPSB5ZWFySW5kZXggPCBtb250aEluZGV4ID8gZmlyc3RZZWFyICsgJyAnICsgcy5tb250aE5hbWVzW2ZpcnN0TW9udGhdIDogcy5tb250aE5hbWVzW2ZpcnN0TW9udGhdICsgJyAnICsgZmlyc3RZZWFyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGl0bGUgPSB5ZWFySW5kZXggPCBtb250aEluZGV4ID8gZmlyc3RZZWFyICsgJyAnICsgcy5tb250aE5hbWVzU2hvcnRbZmlyc3RNb250aF0gKyAnIC0gJyArIGxhc3RZZWFyICsgJyAnICsgcy5tb250aE5hbWVzU2hvcnRbbGFzdE1vbnRoXSA6IHMubW9udGhOYW1lc1Nob3J0W2ZpcnN0TW9udGhdICsgJyAnICsgZmlyc3RZZWFyICsgJyAtICcgKyBzLm1vbnRoTmFtZXNTaG9ydFtsYXN0TW9udGhdICsgJyAnICsgbGFzdFllYXI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsaXN0VHlwZSA9PSAneWVhcicpIHtcbiAgICAgIHRpdGxlID0gZmlyc3RZZWFyICsgKGxpc3RTaXplID4gMSA/IFwiIC0gXCIgKyBsYXN0WWVhciA6ICcnKTtcbiAgICB9XG5cbiAgICAkdmlld1RpdGxlLmh0bWwodGl0bGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRXZlbnRMaXN0KGZpcnN0RGF5LCBsYXN0RGF5LCBldmVudE9iaikge1xuICAgIHZhciBkLFxuICAgICAgICBpLFxuICAgICAgICBqLFxuICAgICAgICBldixcbiAgICAgICAgJGl0ZW1zLFxuICAgICAgICBjb3VudCA9IDAsXG4gICAgICAgIGFsbEV2ZW50cyA9IFtdLFxuICAgICAgICBldmVudEh0bWwgPSAnJyxcbiAgICAgICAgZXZlbnRzID0gW107XG5cbiAgICBpZiAoIWV2ZW50T2JqKSB7XG4gICAgICBldmVudE9iaiA9IGluc3QuX3ByZXBhcmVPYmooZXZlbnRMaXN0LCBmaXJzdERheSwgbGFzdERheSk7XG4gICAgfVxuXG4gICAgZm9yIChkID0gZ2V0RGF0ZU9ubHkoZmlyc3REYXkpOyBkIDw9IGxhc3REYXk7IGQuc2V0RGF0ZShkLmdldERhdGUoKSArIDEpKSB7XG4gICAgICBldiA9IGV2ZW50T2JqW2dldERhdGVPbmx5KGQpXTtcblxuICAgICAgaWYgKGV2ICYmIGV2Lmxlbmd0aCkge1xuICAgICAgICBldmVudHMucHVzaCh7XG4gICAgICAgICAgZDogbmV3IERhdGUoZCksXG4gICAgICAgICAgbGlzdDogc29ydEV2ZW50cyhldilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGV2ID0gZXZlbnRzW2ldO1xuICAgICAgICBldmVudEh0bWwgKz0gJzxkaXY+PGRpdiBjbGFzcz1cIm1ic2MtbHYtZ3ItdGl0bGUgbWJzYy1ldmVudC1kYXlcIiBkYXRhLWZ1bGw9XCInICsgZ2V0RGF0ZVN0cihldi5kKSArICdcIj4nICsgZm9ybWF0RGF0ZShzLmRhdGVGb3JtYXQsIGV2LmQsIHMpICsgJzwvZGl2Pic7XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGV2Lmxpc3QubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICB2YXIgZXZlbnQgPSBldi5saXN0W2pdLFxuICAgICAgICAgICAgICBzdGFydCA9IGV2ZW50LnN0YXJ0ID8gbWFrZURhdGUoZXZlbnQuc3RhcnQpIDogbnVsbCxcbiAgICAgICAgICAgICAgZW5kID0gZXZlbnQuZW5kID8gbWFrZURhdGUoZXZlbnQuZW5kKSA6IG51bGwsXG4gICAgICAgICAgICAgIGNvbG9yID0gZXZlbnQuY29sb3IsXG4gICAgICAgICAgICAgIGlzUmVwZWF0aW5nID0gREFZX09GX1dFRUsudGVzdChldmVudC5kKSB8fCBEQVlfT0ZfTU9OVEgudGVzdChldmVudC5kKSxcbiAgICAgICAgICAgICAgaXNNdWx0aURheSA9IHN0YXJ0ICYmIGVuZCAmJiAhaXNTYW1lRGF5KHN0YXJ0LCBlbmQpLFxuICAgICAgICAgICAgICBpc0ZpcnN0RGF5ID0gaXNNdWx0aURheSA/IGlzU2FtZURheShzdGFydCwgZXYuZCkgOiB0cnVlLFxuICAgICAgICAgICAgICBpc0xhc3REYXkgPSBpc011bHRpRGF5ID8gaXNTYW1lRGF5KGVuZCwgZXYuZCkgOiB0cnVlLFxuICAgICAgICAgICAgICBkdCA9IGV2ZW50LmQgPyBpc1JlcGVhdGluZyA/IGV2ZW50LmQgOiBtYWtlRGF0ZShldmVudC5kKSA6IHN0YXJ0LFxuICAgICAgICAgICAgICBhbGxEYXkgPSBldmVudC5hbGxEYXkgfHwgaXNSZXBlYXRpbmcgfHwgaXNNdWx0aURheSAmJiAhaXNGaXJzdERheSAmJiAhaXNMYXN0RGF5O1xuICAgICAgICAgIGFsbEV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIGQ6IGV2LmQsXG4gICAgICAgICAgICBlOiBldmVudFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGV2ZW50SHRtbCArPSAnPGRpdiB0YWJpbmRleD1cIjBcIiByb2xlPVwiYnV0dG9uXCIgY2xhc3M9XCJtYnNjLWx2LWl0ZW0gbWJzYy1sdi1pdGVtLWFjdGlvbmFibGVcIiBkYXRhLWluZGV4PVwiJyArIGNvdW50ICsgJ1wiPjxkaXYgY2xhc3M9XCJtYnNjLWV2ZW50LXRpbWVcIj4nICsgKGFsbERheSA/IHMuYWxsRGF5VGV4dCA6IGlzRmlyc3REYXkgJiYgZHQgJiYgZHQuZ2V0VGltZSA/IGZvcm1hdERhdGUocy50aW1lRm9ybWF0LCBkdCkgOiBpc011bHRpRGF5ICYmIGlzTGFzdERheSA/IHMudG9UZXh0IDogJycpICsgKCFhbGxEYXkgJiYgaXNMYXN0RGF5ICYmIGVuZCAmJiBlbmQuZ2V0VGltZSA/ICc8YnIvPicgKyBmb3JtYXREYXRlKHMudGltZUZvcm1hdCwgZW5kKSA6ICcnKSArICc8L2Rpdj4nICsgJzxkaXYgY2xhc3M9XCJtYnNjLWV2ZW50LWNvbG9yXCInICsgKGNvbG9yID8gJyBzdHlsZT1cImJhY2tncm91bmQ6JyArIGNvbG9yICsgJztcIicgOiAnJykgKyAnPjwvZGl2PicgKyAnPGRpdiBjbGFzcz1cIm1ic2MtZXZlbnQtdHh0XCI+JyArIGV2ZW50LnRleHQgKyAnPC9kaXY+J1xuICAgICAgICAgIC8qIFRSSUFMICovXG4gICAgICAgICAgKyAnPC9kaXY+JztcbiAgICAgICAgICBjb3VudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnRIdG1sICs9ICc8L2Rpdj4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBldmVudEh0bWwgKz0gJzxkaXYgY2xhc3M9XCJtYnNjLWx2LWdyLXRpdGxlIG1ic2MtZXZlbnQtZW1wdHlcIj48ZGl2IGNsYXNzPVwibWJzYy1lbXB0eVwiPjxoMz4nICsgcy5ub0V2ZW50c1RleHQgKyAnPC9oMz48L2Rpdj48L2Rpdj4nO1xuICAgIH1cblxuICAgIHByZXZlbnRTY3JvbGxXYXRjaCsrO1xuICAgICRldmVudExpc3RDb250Lmh0bWwoJzxkaXYgY2xhc3M9XCJtYnNjLWx2IG1ic2MtbHYtdlwiPicgKyBldmVudEh0bWwgKyAnPC9kaXY+Jykuc2Nyb2xsVG9wKDApO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gTmVlZCBzZXRUaW1lb3V0IHNpbmNlIHNjcm9sbCBsaXN0ZW5lciBpcyB0aHJvdHRlbGVkXG4gICAgICBwcmV2ZW50U2Nyb2xsV2F0Y2gtLTtcbiAgICB9LCAxNTApO1xuICAgICRpdGVtcyA9ICQkMSgnLm1ic2MtbHYtaXRlbScsICRldmVudExpc3RDb250KTsgLy8gQXNzaWduIGV2ZW50IGNsaWNrXG5cbiAgICBpbnN0LnRhcCgkaXRlbXMsIGZ1bmN0aW9uIChlKSB7XG4gICAgICB2YXIgZGF0YSA9IGFsbEV2ZW50c1skJDEodGhpcykuYXR0cignZGF0YS1pbmRleCcpXTtcbiAgICAgIHRyaWdnZXIoJ29uRXZlbnRTZWxlY3QnLCB7XG4gICAgICAgIGRvbUV2ZW50OiBlLFxuICAgICAgICBldmVudDogZGF0YS5lLFxuICAgICAgICBkYXRlOiBkYXRhLmRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGhhbmRsZUZvY3VzKCRpdGVtcyk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVGb2N1cygkaXRlbXMpIHtcbiAgICAkaXRlbXMub24oJ2tleWRvd24nLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIGlmIChldi5rZXlDb2RlID09PSAxMyB8fCBldi5rZXlDb2RlID09PSAzMikge1xuICAgICAgICB0aGlzLmNsaWNrKCk7XG4gICAgICB9XG4gICAgfSkub24oJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHdpbmRvdy5fX21ic2NGb2N1c1Zpc2libGUpIHtcbiAgICAgICAgJCQxKHRoaXMpLmFkZENsYXNzKCdtYnNjLWZvY3VzJyk7XG4gICAgICB9XG4gICAgfSkub24oJ2JsdXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAkJDEodGhpcykucmVtb3ZlQ2xhc3MoJ21ic2MtZm9jdXMnKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUV2ZW50UG9wb3ZlcigpIHtcbiAgICBpZiAocG9wb3ZlckRhdGEpIHtcbiAgICAgIHZhciBkID0gZ2V0RGF0ZU9ubHkocG9wb3ZlckRhdGEuZCksXG4gICAgICAgICAgZXZlbnRzID0gcG9wb3ZlckRhdGEuZXZlbnRzIHx8IGV2ZW50T2JqW2RdLFxuICAgICAgICAgIGNlbGwgPSBwb3BvdmVyRGF0YS5jZWxsIHx8ICQkMSgnLm1ic2MtY2FsLXNsaWRlLWEgLm1ic2MtY2FsLWRheVtkYXRhLWZ1bGw9XCInICsgZ2V0RGF0ZVN0cihkKSArICdcIl0nLCBpbnN0Ll9tYXJrdXApWzBdO1xuICAgICAgc2hvd0V2ZW50cyhldmVudHMsIGQsIGNlbGwpO1xuICAgICAgcG9wb3ZlckRhdGEgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdER1cmF0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgbGJsID0gcy5sYWJlbHNTaG9ydCxcbiAgICAgICAgdGltZSA9IGVuZCAtIHN0YXJ0LFxuICAgICAgICBzZWNvbmRzID0gTWF0aC5hYnModGltZSkgLyAxMDAwLFxuICAgICAgICBtaW51dGVzID0gc2Vjb25kcyAvIDYwLFxuICAgICAgICBob3VycyA9IG1pbnV0ZXMgLyA2MCxcbiAgICAgICAgZGF5cyA9IGhvdXJzIC8gMjQsXG4gICAgICAgIHllYXJzID0gZGF5cyAvIDM2NTtcbiAgICByZXR1cm4gc2Vjb25kcyA8IDQ1ICYmIE1hdGgucm91bmQoc2Vjb25kcykgKyAnICcgKyBsYmxbNV0udG9Mb3dlckNhc2UoKSB8fCAvL3NlY29uZHMgPCA5MCAmJiAnMSBtaW51dGUnIHx8XG4gICAgbWludXRlcyA8IDQ1ICYmIE1hdGgucm91bmQobWludXRlcykgKyAnICcgKyBsYmxbNF0udG9Mb3dlckNhc2UoKSB8fCAvL21pbnV0ZXMgPCA5MCAmJiAnMSBob3VyJyB8fFxuICAgIGhvdXJzIDwgMjQgJiYgTWF0aC5yb3VuZChob3VycykgKyAnICcgKyBsYmxbM10udG9Mb3dlckNhc2UoKSB8fCAvL2hvdXJzIDwgNDIgJiYgJzEgZGF5JyB8fFxuICAgIGRheXMgPCAzMCAmJiBNYXRoLnJvdW5kKGRheXMpICsgJyAnICsgbGJsWzJdLnRvTG93ZXJDYXNlKCkgfHwgLy9kYXlzIDwgNDUgJiYgJzEgbW9udGgnIHx8XG4gICAgZGF5cyA8IDM2NSAmJiBNYXRoLnJvdW5kKGRheXMgLyAzMCkgKyAnICcgKyBsYmxbMV0udG9Mb3dlckNhc2UoKSB8fCAvL3llYXJzIDwgMS41ICYmICcxIHllYXInIHx8XG4gICAgTWF0aC5yb3VuZCh5ZWFycykgKyAnICcgKyBsYmxbMF0udG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNvcnRFdmVudHMoZXZlbnRzKSB7XG4gICAgcmV0dXJuIGV2ZW50cy5zbGljZSgwKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICB2YXIgc3RhcnQxID0gYS5zdGFydCA/IG1ha2VEYXRlKGEuc3RhcnQpIDogbnVsbCxcbiAgICAgICAgICBzdGFydDIgPSBiLnN0YXJ0ID8gbWFrZURhdGUoYi5zdGFydCkgOiBudWxsLFxuICAgICAgICAgIGVuZDEgPSBhLmVuZCA/IG1ha2VEYXRlKGEuZW5kKSA6IG51bGwsXG4gICAgICAgICAgZW5kMiA9IGIuZW5kID8gbWFrZURhdGUoYi5lbmQpIDogbnVsbCxcbiAgICAgICAgICBpc1JlcGVhdGluZzEgPSBEQVlfT0ZfV0VFSy50ZXN0KGEuZCkgfHwgREFZX09GX01PTlRILnRlc3QoYS5kKSxcbiAgICAgICAgICBpc1JlcGVhdGluZzIgPSBEQVlfT0ZfV0VFSy50ZXN0KGIuZCkgfHwgREFZX09GX01PTlRILnRlc3QoYi5kKSxcbiAgICAgICAgICBkdDEgPSBhLmQgPyBpc1JlcGVhdGluZzEgPyBhLmQgOiBtYWtlRGF0ZShhLmQpIDogc3RhcnQxLFxuICAgICAgICAgIGR0MiA9IGIuZCA/IGlzUmVwZWF0aW5nMiA/IGIuZCA6IG1ha2VEYXRlKGIuZCkgOiBzdGFydDIsXG4gICAgICAgICAgd2VpZ2h0MSA9ICFkdDEuZ2V0VGltZSA/IDAgOiBzdGFydDEgJiYgZW5kMSAmJiBzdGFydDEudG9EYXRlU3RyaW5nKCkgIT09IGVuZDEudG9EYXRlU3RyaW5nKCkgPyAxIDogYS5hbGxEYXkgPyAyIDogZHQxLmdldFRpbWUoKSxcbiAgICAgICAgICB3ZWlnaHQyID0gIWR0Mi5nZXRUaW1lID8gMCA6IHN0YXJ0MiAmJiBlbmQyICYmIHN0YXJ0Mi50b0RhdGVTdHJpbmcoKSAhPT0gZW5kMi50b0RhdGVTdHJpbmcoKSA/IDEgOiBiLmFsbERheSA/IDIgOiBkdDIuZ2V0VGltZSgpO1xuXG4gICAgICBpZiAod2VpZ2h0MSA9PSB3ZWlnaHQyKSB7XG4gICAgICAgIHJldHVybiBhLnRleHQgPiBiLnRleHQgPyAxIDogLTE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3ZWlnaHQxIC0gd2VpZ2h0MjtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3dFdmVudHMoZXZlbnRzLCBkLCBjZWxsKSB7XG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgdmFyICRldmVudENvbnQsXG4gICAgICAgICAgJGV2ZW50Q29udElubmVyLFxuICAgICAgICAgICRldmVudFNjcm9sbGVyLFxuICAgICAgICAgIGV2ZW50U2Nyb2xsZXIsXG4gICAgICAgICAgJGl0ZW1zLFxuICAgICAgICAgIGh0bWwgPSAnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLWV2ZW50LWxpc3RcIj4nO1xuICAgICAgJGV2ZW50Q29udCA9ICQkMSgnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLWV2ZW50cyAnICsgKHMuZXZlbnRCdWJibGVDbGFzcyB8fCAnJykgKyAnXCI+JyArICc8ZGl2IGNsYXNzPVwibWJzYy1jYWwtZXZlbnRzLWlcIj48ZGl2IGNsYXNzPVwibWJzYy1jYWwtZXZlbnRzLXNjXCI+JyArICc8L2Rpdj48ZGl2IGNsYXNzPVwibWJzYy1zYy1iYXItY1wiPjxkaXYgY2xhc3M9XCJtYnNjLXNjLWJhclwiPjwvZGl2PjwvZGl2PjwvZGl2PjwvZGl2PicpO1xuICAgICAgJGV2ZW50Q29udElubmVyID0gJCQxKCcubWJzYy1jYWwtZXZlbnRzLWknLCAkZXZlbnRDb250KTtcbiAgICAgICRldmVudFNjcm9sbGVyID0gJCQxKCcubWJzYy1jYWwtZXZlbnRzLXNjJywgJGV2ZW50Q29udCk7XG4gICAgICBpbnN0LnRhcCgkZXZlbnRDb250SW5uZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFldmVudFNjcm9sbGVyLnNjcm9sbGVkKSB7XG4gICAgICAgICAgaGlkZUV2ZW50cygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHBvcHVwID0gbmV3IFBvcHVwKCRldmVudENvbnRbMF0sIHtcbiAgICAgICAgZGlzcGxheTogJ2J1YmJsZScsXG4gICAgICAgIHRoZW1lOiBzLnRoZW1lLFxuICAgICAgICBsYW5nOiBzLmxhbmcsXG4gICAgICAgIGNvbnRleHQ6IHMuY29udGV4dCxcbiAgICAgICAgYnV0dG9uczogW10sXG4gICAgICAgIGFuY2hvcjogY2VsbCxcbiAgICAgICAgc2hvd092ZXJsYXk6IGZhbHNlLFxuICAgICAgICBjc3NDbGFzczogJ21ic2Mtbm8tcGFkZGluZyBtYnNjLWNhbC1ldmVudHMtcG9wdXAnLFxuICAgICAgICBvblNob3c6IGZ1bmN0aW9uIG9uU2hvdygpIHtcbiAgICAgICAgICBldmVudFNjcm9sbGVyID0gbmV3IFNjcm9sbFZpZXdCYXNlKCRldmVudENvbnRJbm5lclswXSwge1xuICAgICAgICAgICAgc2Nyb2xsYmFyOiAkJDEoJy5tYnNjLXNjLWJhci1jJywgJGV2ZW50Q29udCksXG4gICAgICAgICAgICBzdG9wUHJvcDogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAkJDEoZG9jdW1lbnQpLm9uKCdjbGljaycsIGhpZGVFdmVudHNPbkNsaWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25DbG9zZTogZnVuY3Rpb24gb25DbG9zZShldmVudCwgaW5zdCkge1xuICAgICAgICAgIGluc3QuZGVzdHJveSgpO1xuXG4gICAgICAgICAgaWYgKGV2ZW50U2Nyb2xsZXIpIHtcbiAgICAgICAgICAgIGV2ZW50U2Nyb2xsZXIuZGVzdHJveSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICQkMShkb2N1bWVudCkub2ZmKCdjbGljaycsIGhpZGVFdmVudHNPbkNsaWNrKTtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIFN0b3JlIHRoZSBwb3B1cCBvbiB0aGUgaW5zdGFuY2UsIHdlIG5lZWQgdG8gZGVzdHJveSBpdCBpbiBjYXNlIG9mIGFuIG9wdGlvbiBjYWxsIG9yIHJlLWluaXRcblxuICAgICAgaW5zdC5fcG9wdXAgPSBwb3B1cDtcbiAgICAgIGV2ZW50RGF5ID0gY2VsbDtcbiAgICAgIGV2ZW50cyA9IHNvcnRFdmVudHMoZXZlbnRzKTtcbiAgICAgICQkMS5lYWNoKGV2ZW50cywgZnVuY3Rpb24gKGksIGUpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gZS5zdGFydCA/IG1ha2VEYXRlKGUuc3RhcnQpIDogbnVsbCxcbiAgICAgICAgICAgIGVuZCA9IGUuZW5kID8gbWFrZURhdGUoZS5lbmQpIDogbnVsbCxcbiAgICAgICAgICAgIGlzUmVwZWF0aW5nID0gREFZX09GX1dFRUsudGVzdChlLmQpIHx8IERBWV9PRl9NT05USC50ZXN0KGUuZCksXG4gICAgICAgICAgICBkdCA9IGUuZCA/IGlzUmVwZWF0aW5nID8gZS5kIDogbWFrZURhdGUoZS5kKSA6IHN0YXJ0LFxuICAgICAgICAgICAgaXNNdWx0aURheSA9IHN0YXJ0ICYmIGVuZCAmJiAhaXNTYW1lRGF5KHN0YXJ0LCBlbmQpLFxuICAgICAgICAgICAgaXNGaXJzdERheSA9IGlzTXVsdGlEYXkgPyBpc1NhbWVEYXkoc3RhcnQsIGQpIDogdHJ1ZSxcbiAgICAgICAgICAgIGlzTGFzdERheSA9IGlzTXVsdGlEYXkgPyBpc1NhbWVEYXkoZW5kLCBkKSA6IHRydWUsXG4gICAgICAgICAgICBhbGxEYXkgPSBlLmFsbERheSB8fCBpc1JlcGVhdGluZyB8fCBpc011bHRpRGF5ICYmICFpc0ZpcnN0RGF5ICYmICFpc0xhc3REYXksXG4gICAgICAgICAgICBiZyA9IGUuY29sb3IsXG4gICAgICAgICAgICBhcmlhRnJvbSA9ICcnLFxuICAgICAgICAgICAgYXJpYVRvID0gJycsXG4gICAgICAgICAgICBhcmlhTGFiZWwgPSAkJDEoJzxkaXY+JyArIGUudGV4dCArICc8L2Rpdj4nKS50ZXh0KCk7XG5cbiAgICAgICAgaWYgKGR0LmdldFRpbWUpIHtcbiAgICAgICAgICBhcmlhRnJvbSA9IGZvcm1hdERhdGUoKGlzTXVsdGlEYXkgPyAnTU0gZCB5eSAnIDogJycpICsgcy50aW1lRm9ybWF0LCBkdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kKSB7XG4gICAgICAgICAgYXJpYVRvID0gZm9ybWF0RGF0ZSgoaXNNdWx0aURheSA/ICdNTSBkIHl5ICcgOiAnJykgKyBzLnRpbWVGb3JtYXQsIGVuZCk7XG4gICAgICAgIH1cblxuICAgICAgICBodG1sICs9ICc8ZGl2IHRhYmluZGV4PVwiMFwiIHJvbGU9XCJidXR0b25cIiB0aXRsZT1cIicgKyBhcmlhTGFiZWwgKyAnXCIgYXJpYS1sYWJlbD1cIicgKyBhcmlhTGFiZWwgKyAoYXJpYUZyb20gPyAnLCAnICsgcy5mcm9tVGV4dCArICc6ICcgKyBhcmlhRnJvbSA6ICcnKSArIChhcmlhVG8gPyAnLCAnICsgcy50b1RleHQgKyAnOiAnICsgYXJpYVRvIDogJycpICsgJ1wiIGNsYXNzPVwibWJzYy1jYWwtZXZlbnQgbWJzYy1sdi1pdGVtIG1ic2MtbHYtaXRlbS1hY3Rpb25hYmxlXCI+JyArICc8ZGl2IGNsYXNzPVwibWJzYy1jYWwtZXZlbnQtY29sb3JcIiBzdHlsZT1cIicgKyAoYmcgPyAnYmFja2dyb3VuZDonICsgYmcgKyAnOycgOiAnJykgKyAnXCI+PC9kaXY+JyArICc8ZGl2IGNsYXNzPVwibWJzYy1jYWwtZXZlbnQtdGV4dFwiPicgKyAnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLWV2ZW50LXRpbWVcIj4nICsgKGFsbERheSA/IHMuYWxsRGF5VGV4dCA6IGlzRmlyc3REYXkgJiYgZHQuZ2V0VGltZSA/IGZvcm1hdERhdGUocy50aW1lRm9ybWF0LCBkdCkgOiAnJykgKyAnPC9kaXY+JyArIGUudGV4dCArICc8L2Rpdj4nICsgKHN0YXJ0ICYmIGVuZCAmJiAhZS5hbGxEYXkgPyAnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLWV2ZW50LWR1clwiPicgKyBzLmZvcm1hdER1cmF0aW9uKHN0YXJ0LCBlbmQsIGUpICsgJzwvZGl2PicgOiAnJykgKyAnPC9kaXY+JztcbiAgICAgIH0pO1xuICAgICAgaHRtbCArPSAnPC9kaXY+JztcbiAgICAgICRldmVudFNjcm9sbGVyLmh0bWwoaHRtbCk7XG4gICAgICBwb3B1cC5zaG93KCk7XG4gICAgICB0cmlnZ2VyKCdvbkV2ZW50QnViYmxlU2hvdycsIHtcbiAgICAgICAgdGFyZ2V0OiBldmVudERheSxcbiAgICAgICAgZXZlbnRMaXN0OiAkZXZlbnRDb250WzBdXG4gICAgICB9KTtcbiAgICAgICRpdGVtcyA9ICQkMSgnLm1ic2MtY2FsLWV2ZW50JywgJGV2ZW50U2Nyb2xsZXIpOyAvLyBBc3NpZ24gZXZlbnQgY2xpY2tcblxuICAgICAgaW5zdC50YXAoJGl0ZW1zLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoIWV2ZW50U2Nyb2xsZXIuc2Nyb2xsZWQpIHtcbiAgICAgICAgICB0cmlnZ2VyKCdvbkV2ZW50U2VsZWN0Jywge1xuICAgICAgICAgICAgZG9tRXZlbnQ6IGUsXG4gICAgICAgICAgICBldmVudDogZXZlbnRzWyQkMSh0aGlzKS5pbmRleCgpXSxcbiAgICAgICAgICAgIGRhdGU6IGRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBoYW5kbGVGb2N1cygkaXRlbXMpO1xuICAgICAgaGFzRXZlbnRCdWJibGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uU2Nyb2xsKCkge1xuICAgIHZhciBkLCB0b3AsIHBhcnRzO1xuXG4gICAgaWYgKCFwcmV2ZW50U2Nyb2xsV2F0Y2gpIHtcbiAgICAgICQkMSgnLm1ic2MtZXZlbnQtZGF5JywgdGhpcykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRvcCA9IHRoaXMub2Zmc2V0VG9wIC0gZXZlbnRMaXN0Q29udC5zY3JvbGxUb3A7XG5cbiAgICAgICAgaWYgKHRvcCA+PSAwICYmIHRvcCA8IDM1KSB7XG4gICAgICAgICAgcGFydHMgPSAkJDEodGhpcykuYXR0cignZGF0YS1mdWxsJykuc3BsaXQoJy0nKTtcbiAgICAgICAgICBkID0gYWRqdXN0ZWREYXRlKHBhcnRzWzBdLCBwYXJ0c1sxXSAtIDEsIHBhcnRzWzJdKTtcblxuICAgICAgICAgIGlmICghaXNTYW1lRGF5KGQsIGN1cnJEYXkpKSB7XG4gICAgICAgICAgICBwcmV2ZW50RXZlbnRTY3JvbGwgPSB0cnVlO1xuICAgICAgICAgICAgaW5zdC5zZXRWYWwoZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoaWRlRXZlbnRzKCkge1xuICAgIGlmIChwb3B1cCAmJiBoYXNFdmVudEJ1YmJsZSkge1xuICAgICAgcG9wdXAuaGlkZSgpO1xuICAgIH1cblxuICAgIGV2ZW50RGF5ID0gbnVsbDtcbiAgICBoYXNFdmVudEJ1YmJsZSA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGlkZUV2ZW50c09uQ2xpY2soZSkge1xuICAgIGlmICgkJDEoZS50YXJnZXQpLmNsb3Nlc3QoJy5tYnNjLWNhbC1kYXknKS5sZW5ndGggPT0gMCkge1xuICAgICAgaGlkZUV2ZW50cygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgaGlkZUV2ZW50cygpO1xuICAgIGluc3QucmVkcmF3KCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRGaXJzdExhc3QoZGF5KSB7XG4gICAgdmFyIHkgPSBzLmdldFllYXIoZGF5KSxcbiAgICAgICAgbSA9IHMuZ2V0TW9udGgoZGF5KSxcbiAgICAgICAgZCA9IHMuZ2V0RGF5KGRheSk7XG4gICAgY3VyckZpcnN0RGF5ID0gZGF5O1xuXG4gICAgaWYgKGxpc3RUeXBlID09ICdkYXknKSB7XG4gICAgICBjdXJyTGFzdERheSA9IHMuZ2V0RGF0ZSh5LCBtLCBkICsgbGlzdFNpemUgLSAxKTtcbiAgICB9IGVsc2UgaWYgKGxpc3RUeXBlID09ICd3ZWVrJykge1xuICAgICAgLy8gZ2V0IGZpcnN0IGRheSBvZiB3ZWVrXG4gICAgICB2YXIgZGlmZixcbiAgICAgICAgICB3ZWVrRGF5ID0gY3VyckZpcnN0RGF5LmdldERheSgpO1xuICAgICAgZGlmZiA9IGQgKyBzLmZpcnN0RGF5IC0gKHMuZmlyc3REYXkgLSB3ZWVrRGF5ID4gMCA/IDcgOiAwKSAtIHdlZWtEYXk7XG4gICAgICBjdXJyRmlyc3REYXkgPSBzLmdldERhdGUoeSwgbSwgZGlmZik7XG4gICAgICBjdXJyTGFzdERheSA9IHMuZ2V0RGF0ZSh5LCBtLCBkaWZmICsgbGlzdFNpemUgKiA3IC0gMSk7XG4gICAgfSBlbHNlIGlmIChsaXN0VHlwZSA9PSAnbW9udGgnKSB7XG4gICAgICBjdXJyRmlyc3REYXkgPSBzLmdldERhdGUoeSwgbSwgMSk7XG4gICAgICBjdXJyTGFzdERheSA9IHMuZ2V0RGF0ZSh5LCBtICsgbGlzdFNpemUsIDApO1xuICAgIH0gZWxzZSBpZiAobGlzdFR5cGUgPT0gJ3llYXInKSB7XG4gICAgICBjdXJyRmlyc3REYXkgPSBzLmdldERhdGUoeSwgMCwgMSk7XG4gICAgICBjdXJyTGFzdERheSA9IHMuZ2V0RGF0ZSh5ICsgbGlzdFNpemUsIDAsIDApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjcm9sbFRvRGF5KGQsIHByZXZBbmltKSB7XG4gICAgLy8gU2Nyb2xsIHRvIHRoZSBkYXkgaW4gdGhlIGxpc3QsIGlmIGFueVxuICAgIGlmIChzaG93RXZlbnRMaXN0ICYmICFwcmV2ZW50RXZlbnRTY3JvbGwpIHtcbiAgICAgIHZhciAkZGF5ID0gJCQxKCcubWJzYy1ldmVudC1kYXlbZGF0YS1mdWxsPVwiJyArIGdldERhdGVTdHIoZCkgKyAnXCJdJywgJGV2ZW50TGlzdENvbnQpO1xuXG4gICAgICBpZiAoJGRheS5sZW5ndGgpIHtcbiAgICAgICAgcHJldmVudFNjcm9sbFdhdGNoKys7XG4gICAgICAgIHNtb290aFNjcm9sbChldmVudExpc3RDb250LCAkZGF5LnBhcmVudCgpWzBdLm9mZnNldFRvcCwgcHJldkFuaW0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBOZWVkIHNldFRpbWVvdXQgc2luY2Ugc2Nyb2xsIGxpc3RlbmVyIGlzIHRocm90dGVsZWRcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGxXYXRjaC0tO1xuICAgICAgICAgIH0sIDE1MCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRyaWdnZXJMb2FkaW5nKGNoYW5nZSwgcmVuZGVyKSB7XG4gICAgaWYgKGNoYW5nZSkge1xuICAgICAgdHJpZ2dlcignb25QYWdlQ2hhbmdlJywge1xuICAgICAgICBmaXJzdERheTogY3VyckZpcnN0RGF5LFxuICAgICAgICBsYXN0RGF5OiBjdXJyTGFzdERheVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFyZW5kZXIpIHtcbiAgICAgIHRyaWdnZXIoJ29uUGFnZUxvYWRpbmcnLCB7XG4gICAgICAgIGZpcnN0RGF5OiBjdXJyRmlyc3REYXksXG4gICAgICAgIGxhc3REYXk6IGN1cnJMYXN0RGF5XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0cmlnZ2VyKCdvblBhZ2VMb2FkZWQnLCB7XG4gICAgICBmaXJzdERheTogY3VyckZpcnN0RGF5LFxuICAgICAgbGFzdERheTogY3Vyckxhc3REYXlcbiAgICB9KTtcbiAgfSAvLyAtLS1cblxuXG4gIHZhciBiYXNlLFxuICAgICAgJGN0eCxcbiAgICAgICRldmVudExpc3RDb250LFxuICAgICAgJHZpZXdUaXRsZSxcbiAgICAgIGN1cnJEYXksXG4gICAgICBjdXJyRmlyc3REYXksXG4gICAgICBjdXJyTGFzdERheSxcbiAgICAgIGV2ZW50RGF5LFxuICAgICAgZXZlbnRMaXN0Q29udCxcbiAgICAgIGV2ZW50T2JqLFxuICAgICAgaGFzRXZlbnRCdWJibGUsXG4gICAgICBpc0NoYW5naW5nLFxuICAgICAgaXNMYWJlbFRhcCxcbiAgICAgIGlzTGlzdE9ubHksXG4gICAgICBsaXN0VHlwZSxcbiAgICAgIGxpc3RTaXplLFxuICAgICAgbXVsdGlMYWJlbCxcbiAgICAgIHBvcG92ZXJEYXRhLFxuICAgICAgcG9wdXAsXG4gICAgICBwcmV2ZW50RXZlbnRTY3JvbGwsXG4gICAgICBwcmV2ZW50U2Nyb2xsQW5pbSxcbiAgICAgIHByZXZGaXJzdERheSxcbiAgICAgIHByZXZMYXN0RGF5LFxuICAgICAgc2Nyb2xsRXZlbnRMaXN0LFxuICAgICAgc2hvd0V2ZW50TGlzdCxcbiAgICAgIHNob3dFdmVudEJ1YmJsZSxcbiAgICAgIHNob3dNb3JlLFxuICAgICAgZWxtID0gdGhpcyxcbiAgICAgIG9yaWcgPSBleHRlbmQkMSh7fSwgaW5zdC5zZXR0aW5ncyksXG4gICAgICBzID0gZXh0ZW5kJDEoaW5zdC5zZXR0aW5ncywgZGVmYXVsdHMkNCwgb3JpZywgb3ZlcnJpZGVzLCBzZXR0aW5ncyksXG4gICAgICBwcmV2ZW50U2Nyb2xsV2F0Y2ggPSAwLFxuICAgICAgZXZlbnRJRCA9IDAsXG4gICAgICBldmVudExpc3QgPSBleHRlbmQkMSh0cnVlLCBbXSwgcy5kYXRhKSxcbiAgICAgIGZpcnN0TG9hZCA9IHRydWUsXG4gICAgICB0cmlnZ2VyID0gaW5zdC50cmlnZ2VyOyAvLyBLZWVwIHRyYWNraW5nIGV2ZW50cyBpbiBzZXR0aW5ncyxcbiAgLy8gb3RoZXJ3aXNlIGNoYW5nZXMgd2lsbCBiZSBsb3N0IG9uIGFuIGV2ZW50dWFsIG9wdGlvbiBjYWxsXG5cbiAgcy5kYXRhID0gZXZlbnRMaXN0O1xuICAkJDEuZWFjaChldmVudExpc3QsIGZ1bmN0aW9uIChpLCBlKSB7XG4gICAgaWYgKGUuX2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGUuX2lkID0gZXZlbnRJRCsrO1xuICAgIH1cbiAgfSk7XG4gIHByb2Nlc3NTZXR0aW5ncygpO1xuICBiYXNlID0gQ2FsZW5kYXJCYXNlLmNhbGwodGhpcywgaW5zdCk7IC8vIEV4dGVuZGVkIG1ldGhvZHNcbiAgLy8gLS0tXG5cbiAgaW5zdC5fb25HZW5Nb250aCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgZXZlbnRPYmogPSBpbnN0Ll9wcmVwYXJlT2JqKGV2ZW50TGlzdCwgc3RhcnQsIGVuZCk7XG4gICAgaW5zdC5fbGFiZWxzID0gbXVsdGlMYWJlbCA/IGV2ZW50T2JqIDogbnVsbDtcbiAgfTtcblxuICBpbnN0Ll9vblJlZnJlc2ggPSBmdW5jdGlvbiAocmVuZGVyKSB7XG4gICAgcHJldmVudFNjcm9sbEFuaW0gPSB0cnVlOyAvLyBXaWxsIHJlLWNyZWF0ZSB0aGUgbGlzdFxuXG4gICAgcHJldkZpcnN0RGF5ID0gbnVsbDtcbiAgICBwcmV2TGFzdERheSA9IG51bGw7XG5cbiAgICBpZiAoaXNMaXN0T25seSkge1xuICAgICAgdHJpZ2dlckxvYWRpbmcoZmFsc2UsIHJlbmRlcik7XG4gICAgfVxuICB9O1xuXG4gIGluc3QuX29uU2V0RGF0ZSA9IGZ1bmN0aW9uIChkLCBkaWZmKSB7XG4gICAgY3VyckRheSA9IGQ7XG5cbiAgICBpZiAoaXNMaXN0T25seSkge1xuICAgICAgaWYgKCFwcmV2ZW50RXZlbnRTY3JvbGwgJiYgIWlzQ2hhbmdpbmcpIHtcbiAgICAgICAgZ2V0Rmlyc3RMYXN0KGQpO1xuXG4gICAgICAgIGlmICghcHJldkZpcnN0RGF5IHx8ICFwcmV2TGFzdERheSB8fCAhaXNTYW1lRGF5KHByZXZGaXJzdERheSwgY3VyckZpcnN0RGF5KSB8fCAhaXNTYW1lRGF5KHByZXZMYXN0RGF5LCBjdXJyTGFzdERheSkpIHtcbiAgICAgICAgICB0cmlnZ2VyTG9hZGluZyh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWRpZmYgJiYgIWlzQ2hhbmdpbmcpIHtcbiAgICAgIGhpZGVFdmVudHMoKTtcblxuICAgICAgaWYgKHNob3dFdmVudExpc3QgJiYgbGlzdFR5cGUgPT0gJ2RheScpIHtcbiAgICAgICAgLy8gTGlzdCBldmVudHMgZm9yIHRoZSBkYXlcbiAgICAgICAgY3JlYXRlRXZlbnRMaXN0KGQsIGQsIGV2ZW50T2JqKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChzaG93RXZlbnRCdWJibGUgfHwgc2hvd01vcmUpICYmICFpc0xhYmVsVGFwKSB7XG4gICAgICAgIC8vIFNob3cgZXZlbnQgcG9wb3ZlclxuICAgICAgICBjcmVhdGVFdmVudFBvcG92ZXIoKTtcbiAgICAgIH1cblxuICAgICAgc2Nyb2xsVG9EYXkoZCk7XG4gICAgfVxuXG4gICAgcHJldmVudEV2ZW50U2Nyb2xsID0gZmFsc2U7XG4gICAgc2hvd01vcmUgPSBmYWxzZTtcbiAgICBpc0xhYmVsVGFwID0gZmFsc2U7XG4gIH07XG5cbiAgaW5zdC5fZ2V0RGF5UHJvcHMgPSBmdW5jdGlvbiAoZCkge1xuICAgIHZhciBldmVudHMgPSBldmVudE9ialtkXSxcbiAgICAgICAgcmV0ID0ge1xuICAgICAgZXZlbnRzOiBldmVudHNcbiAgICB9O1xuXG4gICAgaWYgKCFzLm1hcmtlZCAmJiAhcy5sYWJlbHMgJiYgIW11bHRpTGFiZWwpIHtcbiAgICAgIGlmIChldmVudHMpIHtcbiAgICAgICAgcmV0LmJhY2tncm91bmQgPSBldmVudHNbMF0gJiYgZXZlbnRzWzBdLmJhY2tncm91bmQ7XG4gICAgICAgIHJldC5tYXJrZWQgPSBldmVudHM7IC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cbiAgICAgICAgcmV0Lm1hcmt1cCA9IHMuc2hvd0V2ZW50Q291bnQgPyAnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLXR4dFwiPicgKyBldmVudHMubGVuZ3RoICsgJyAnICsgKGV2ZW50cy5sZW5ndGggPiAxID8gcy5ldmVudHNUZXh0IDogcy5ldmVudFRleHQpICsgJzwvZGl2PicgOiAnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLW1hcmtzXCI+PGRpdiBjbGFzcz1cIm1ic2MtY2FsLW1hcmtcIj48L2Rpdj48L2Rpdj4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0Lm1hcmt1cCA9IHMuc2hvd0V2ZW50Q291bnQgPyAnPGRpdiBjbGFzcz1cIm1ic2MtY2FsLXR4dC1waFwiPjwvZGl2PicgOiAnJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIGluc3QuYWRkRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnRzKSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGV2ZW50cyA9IGV4dGVuZCQxKHRydWUsIFtdLCAkJDEuaXNBcnJheShldmVudHMpID8gZXZlbnRzIDogW2V2ZW50c10pO1xuICAgICQkMS5lYWNoKGV2ZW50cywgZnVuY3Rpb24gKGksIGUpIHtcbiAgICAgIGlmIChlLl9pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGUuX2lkID0gZXZlbnRJRCsrO1xuICAgICAgfVxuXG4gICAgICBldmVudExpc3QucHVzaChlKTtcbiAgICAgIHJldC5wdXNoKGUuX2lkKTtcbiAgICB9KTtcbiAgICByZWZyZXNoKCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBpbnN0LnVwZGF0ZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgJCQxLmVhY2goZXZlbnRMaXN0LCBmdW5jdGlvbiAoaiwgZSkge1xuICAgICAgaWYgKGUuX2lkID09PSBldmVudC5faWQpIHtcbiAgICAgICAgZXZlbnRMaXN0LnNwbGljZShqLCAxLCBldmVudCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZWZyZXNoKCk7XG4gIH07XG5cbiAgaW5zdC5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uIChlaWRzKSB7XG4gICAgZWlkcyA9ICQkMS5pc0FycmF5KGVpZHMpID8gZWlkcyA6IFtlaWRzXTtcbiAgICAkJDEuZWFjaChlaWRzLCBmdW5jdGlvbiAoaSwgZWlkKSB7XG4gICAgICAkJDEuZWFjaChldmVudExpc3QsIGZ1bmN0aW9uIChqLCBlKSB7XG4gICAgICAgIGlmIChlLl9pZCA9PT0gZWlkKSB7XG4gICAgICAgICAgZXZlbnRMaXN0LnNwbGljZShqLCAxKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJlZnJlc2goKTtcbiAgfTtcblxuICBpbnN0LmdldEV2ZW50cyA9IGZ1bmN0aW9uIChkKSB7XG4gICAgdmFyIG9iajtcblxuICAgIGlmIChkKSB7XG4gICAgICBkLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgb2JqID0gaW5zdC5fcHJlcGFyZU9iaihldmVudExpc3QsIGQsIGQpO1xuICAgICAgcmV0dXJuIG9ialtkXSA/IHNvcnRFdmVudHMob2JqW2RdKSA6IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBleHRlbmQkMSh0cnVlLCBbXSwgZXZlbnRMaXN0KTtcbiAgfTtcblxuICBpbnN0LnNldEV2ZW50cyA9IGZ1bmN0aW9uIChldmVudHMpIHtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgcy5kYXRhID0gZXZlbnRMaXN0ID0gZXh0ZW5kJDEodHJ1ZSwgW10sIGV2ZW50cyk7XG4gICAgJCQxLmVhY2goZXZlbnRMaXN0LCBmdW5jdGlvbiAoaSwgZSkge1xuICAgICAgaWYgKGUuX2lkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZS5faWQgPSBldmVudElEKys7XG4gICAgICB9XG5cbiAgICAgIHJldC5wdXNoKGUuX2lkKTtcbiAgICB9KTtcbiAgICByZWZyZXNoKCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICBpbnN0Lm5hdmlnYXRlID0gZnVuY3Rpb24gKGQsIGFuaW0sIHBvcCkge1xuICAgIGQgPSBtYWtlRGF0ZShkLCBpbnN0Ll9mb3JtYXQsIHMpO1xuICAgIHBvcG92ZXJEYXRhID0gcG9wID8ge1xuICAgICAgZDogZFxuICAgIH0gOiBudWxsO1xuICAgIGluc3Quc2V0VmFsKGQsIHRydWUsIHRydWUsIGZhbHNlLCBhbmltID8gMjAwIDogMCk7XG4gIH07IC8vIC0tLVxuXG5cbiAgcmV0dXJuIGV4dGVuZCQxKHt9LCBiYXNlLCB7XG4gICAgbXVsdGlMYWJlbDogbXVsdGlMYWJlbCxcbiAgICBoZWFkZXJUZXh0OiBmYWxzZSxcbiAgICBidXR0b25zOiBzLmRpc3BsYXkgIT09ICdpbmxpbmUnID8gWydjbG9zZSddIDogcy5idXR0b25zLFxuICAgIGNvbXBDbGFzczogJ21ic2MtZXYtY2FsIG1ic2MtY2FsZW5kYXIgbWJzYy1kdCBtYnNjLXNjJyxcbiAgICBmb3JtYXREdXJhdGlvbjogZm9ybWF0RHVyYXRpb24sXG4gICAgb25NYXJrdXBSZWFkeTogZnVuY3Rpb24gb25NYXJrdXBSZWFkeShldiwgaW5zdCkge1xuICAgICAgJGN0eCA9ICQkMShldi50YXJnZXQpO1xuICAgICAgY3VyckRheSA9IGluc3QuZ2V0RGF0ZSh0cnVlKTtcblxuICAgICAgaWYgKHNob3dFdmVudExpc3QpIHtcbiAgICAgICAgJGV2ZW50TGlzdENvbnQgPSAkJDEoJzxkaXYgY2xhc3M9XCJtYnNjLWx2LWNvbnQgbWJzYy1sdi0nICsgcy50aGVtZSArIChzLmJhc2VUaGVtZSA/ICcgbWJzYy1sdi0nICsgcy5iYXNlVGhlbWUgOiAnJykgKyAoc2Nyb2xsRXZlbnRMaXN0ID8gJyBtYnNjLWV2ZW50LWxpc3QtaCcgOiAnJykgKyAnIG1ic2MtZXZlbnQtbGlzdFwiPjwvZGl2PicpLmFwcGVuZFRvKCQkMSgnLm1ic2MtZnItdycsICRjdHgpKTtcbiAgICAgICAgJGV2ZW50TGlzdENvbnQub24oJ3Njcm9sbCcsIHRocm90dGxlKG9uU2Nyb2xsKSk7XG4gICAgICAgIGV2ZW50TGlzdENvbnQgPSAkZXZlbnRMaXN0Q29udFswXTtcbiAgICAgIH1cblxuICAgICAgYmFzZS5vbk1hcmt1cFJlYWR5LmNhbGwodGhpcywgZXYpO1xuICAgICAgJHZpZXdUaXRsZSA9ICQkMSgnLm1ic2MtY2FsLW1vbnRoJywgJGN0eCk7XG4gICAgICBoYXNFdmVudEJ1YmJsZSA9IGZhbHNlO1xuICAgICAgZ2V0Rmlyc3RMYXN0KGN1cnJEYXkpO1xuXG4gICAgICBpZiAoc2hvd0V2ZW50TGlzdCAmJiBpc0xpc3RPbmx5KSB7XG4gICAgICAgIHRyaWdnZXJMb2FkaW5nKCk7IC8vIEluaXQgbmF2aWdhdGlvbiBhcnJvd3NcblxuICAgICAgICBjcmVhdGVTdGVwcGVyKCQkMSgnLm1ic2MtY2FsLWJ0bicsICRjdHgpLCBmdW5jdGlvbiAoaSwgZGlmZikge1xuICAgICAgICAgIHZhciB5ID0gcy5nZXRZZWFyKGN1cnJGaXJzdERheSksXG4gICAgICAgICAgICAgIG0gPSBzLmdldE1vbnRoKGN1cnJGaXJzdERheSksXG4gICAgICAgICAgICAgIGQgPSBzLmdldERheShjdXJyRmlyc3REYXkpO1xuXG4gICAgICAgICAgaWYgKGxpc3RUeXBlID09ICdkYXknKSB7XG4gICAgICAgICAgICBjdXJyRmlyc3REYXkgPSBzLmdldERhdGUoeSwgbSwgZCArIGRpZmYgKiBsaXN0U2l6ZSk7XG4gICAgICAgICAgICBjdXJyTGFzdERheSA9IHMuZ2V0RGF0ZSh5LCBtLCBkICsgKGRpZmYgKyAxKSAqIGxpc3RTaXplIC0gMSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaXN0VHlwZSA9PSAnd2VlaycpIHtcbiAgICAgICAgICAgIGN1cnJGaXJzdERheSA9IHMuZ2V0RGF0ZSh5LCBtLCBkICsgZGlmZiAqIGxpc3RTaXplICogNyk7XG4gICAgICAgICAgICBjdXJyTGFzdERheSA9IHMuZ2V0RGF0ZSh5LCBtLCBkICsgKGRpZmYgKyAxKSAqIGxpc3RTaXplICogNyAtIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGlzdFR5cGUgPT0gJ21vbnRoJykge1xuICAgICAgICAgICAgY3VyckZpcnN0RGF5ID0gcy5nZXREYXRlKHksIG0gKyBkaWZmICogbGlzdFNpemUsIDEpO1xuICAgICAgICAgICAgY3Vyckxhc3REYXkgPSBzLmdldERhdGUoeSwgbSArIChkaWZmICsgMSkgKiBsaXN0U2l6ZSwgMCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaXN0VHlwZSA9PSAneWVhcicpIHtcbiAgICAgICAgICAgIGN1cnJGaXJzdERheSA9IHMuZ2V0RGF0ZSh5ICsgZGlmZiAqIGxpc3RTaXplLCAwLCAxKTtcbiAgICAgICAgICAgIGN1cnJMYXN0RGF5ID0gcy5nZXREYXRlKHkgKyAoZGlmZiArIDEpICogbGlzdFNpemUsIDAsIDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyaWdnZXJMb2FkaW5nKHRydWUpO1xuICAgICAgICB9LCAyMDApO1xuICAgICAgfVxuXG4gICAgICBhZGRXaW5kb3dGb2N1cygpO1xuICAgIH0sXG4gICAgb25EYXlDaGFuZ2U6IGZ1bmN0aW9uIG9uRGF5Q2hhbmdlKGRheSkge1xuICAgICAgdmFyIGNlbGwgPSBkYXkudGFyZ2V0LFxuICAgICAgICAgIHNob3cgPSBjZWxsICE9PSBldmVudERheTtcblxuICAgICAgaWYgKHNob3cpIHtcbiAgICAgICAgc2hvd01vcmUgPSBzaG93RXZlbnRCdWJibGUgIT09IGZhbHNlICYmICQkMSgnLm1ic2MtY2FsLXR4dC1tb3JlJywgY2VsbCkubGVuZ3RoO1xuICAgICAgICBwb3BvdmVyRGF0YSA9IHtcbiAgICAgICAgICBkOiBkYXkuZGF0ZSxcbiAgICAgICAgICBjZWxsOiBzLm91dGVyTW9udGhDaGFuZ2UgJiYgJCQxKGNlbGwpLmhhc0NsYXNzKCdtYnNjLWNhbC1kYXktZGlmZicpID8gbnVsbCA6IGNlbGwsXG4gICAgICAgICAgZXZlbnRzOiBkYXkuZXZlbnRzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkxhYmVsVGFwOiBmdW5jdGlvbiBvbkxhYmVsVGFwKGV2KSB7XG4gICAgICBpZiAoZXYubGFiZWwpIHtcbiAgICAgICAgdHJpZ2dlcignb25FdmVudFNlbGVjdCcsIHtcbiAgICAgICAgICBkb21FdmVudDogZXYuZG9tRXZlbnQsXG4gICAgICAgICAgZXZlbnQ6IGV2LmxhYmVsLFxuICAgICAgICAgIGRhdGU6IGV2LmRhdGVcbiAgICAgICAgfSk7XG4gICAgICAgIGlzTGFiZWxUYXAgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25QYWdlQ2hhbmdlOiBmdW5jdGlvbiBvblBhZ2VDaGFuZ2UoZXYpIHtcbiAgICAgIGhpZGVFdmVudHMoKTtcbiAgICAgIGlzQ2hhbmdpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoIWluc3QuX2lzU2V0RGF0ZSkge1xuICAgICAgICBpbnN0LnNldFZhbChldi5maXJzdERheSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvblBhZ2VMb2FkZWQ6IGZ1bmN0aW9uIG9uUGFnZUxvYWRlZChldikge1xuICAgICAgdmFyIGZpcnN0RGF5ID0gZXYuZmlyc3REYXksXG4gICAgICAgICAgbGFzdERheSA9IGV2Lmxhc3REYXk7XG5cbiAgICAgIGlmIChzaG93RXZlbnRMaXN0KSB7XG4gICAgICAgIGlmIChpc0xpc3RPbmx5KSB7XG4gICAgICAgICAgaWYgKCFwcmV2Rmlyc3REYXkgfHwgIXByZXZMYXN0RGF5IHx8ICFpc1NhbWVEYXkocHJldkZpcnN0RGF5LCBmaXJzdERheSkgfHwgIWlzU2FtZURheShwcmV2TGFzdERheSwgbGFzdERheSkpIHtcbiAgICAgICAgICAgIHByZXZGaXJzdERheSA9IGZpcnN0RGF5O1xuICAgICAgICAgICAgcHJldkxhc3REYXkgPSBsYXN0RGF5O1xuICAgICAgICAgICAgY3JlYXRlRXZlbnRMaXN0KGZpcnN0RGF5LCBsYXN0RGF5KTtcbiAgICAgICAgICAgIHVwZGF0ZVRpdGxlKGZpcnN0RGF5LCBsYXN0RGF5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGxpc3RUeXBlID09ICdtb250aCcpIHtcbiAgICAgICAgICAgIC8vIG1vbnRoIHZpZXdcbiAgICAgICAgICAgIGxhc3REYXkgPSBzLmdldERhdGUocy5nZXRZZWFyKGZpcnN0RGF5KSwgcy5nZXRNb250aChmaXJzdERheSkgKyBsaXN0U2l6ZSwgMCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaXN0VHlwZSA9PSAnd2VlaycpIHtcbiAgICAgICAgICAgIC8vIHdlZWsgdmlld1xuICAgICAgICAgICAgbGFzdERheSA9IHMuZ2V0RGF0ZShzLmdldFllYXIoZmlyc3REYXkpLCBzLmdldE1vbnRoKGZpcnN0RGF5KSwgcy5nZXREYXkoZmlyc3REYXkpICsgbGlzdFNpemUgKiA3IC0gMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpcnN0RGF5ID0gaW5zdC5nZXRWYWwodHJ1ZSk7XG4gICAgICAgICAgICBsYXN0RGF5ID0gZmlyc3REYXk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3JlYXRlRXZlbnRMaXN0KGZpcnN0RGF5LCBsYXN0RGF5LCBldmVudE9iaik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZpcnN0TG9hZCAmJiAhaXNTYW1lRGF5KGN1cnJEYXksIGZpcnN0RGF5KSkge1xuICAgICAgICAgIHNjcm9sbFRvRGF5KGN1cnJEYXksIHByZXZlbnRTY3JvbGxBbmltKTtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsQW5pbSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG93RXZlbnRCdWJibGUpIHtcbiAgICAgICAgY3JlYXRlRXZlbnRQb3BvdmVyKCk7XG4gICAgICB9XG5cbiAgICAgIGlzQ2hhbmdpbmcgPSBmYWxzZTtcbiAgICB9LFxuICAgIG9uUG9zaXRpb246IGZ1bmN0aW9uIG9uUG9zaXRpb24oZXYpIHtcbiAgICAgIGJhc2Uub25Qb3NpdGlvbi5jYWxsKHRoaXMsIGV2KTtcblxuICAgICAgaWYgKHBvcHVwKSB7XG4gICAgICAgIHBvcHVwLnBvc2l0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG93RXZlbnRMaXN0ICYmIHNjcm9sbEV2ZW50TGlzdCkge1xuICAgICAgICAkZXZlbnRMaXN0Q29udC5hZGRDbGFzcygnbWJzYy1ldmVudC1saXN0LWgnKTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBzLmRpc3BsYXkgPT0gJ2lubGluZScgPyBlbG0ucGFyZW50Tm9kZSA6IHdpbmRvdyxcbiAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCA9IGdldEhlaWdodChjb250ZXh0KSxcbiAgICAgICAgICAgIGxpc3RIZWlnaHQgPSBhdmFpbGFibGVIZWlnaHQgLSBldi5wb3B1cC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGV2ZW50TGlzdENvbnQuc3R5bGUuaGVpZ2h0ID0gbGlzdEhlaWdodCA+IDIwMCA/IGxpc3RIZWlnaHQgKyAncHgnIDogJyc7XG4gICAgICAgICRldmVudExpc3RDb250LnJlbW92ZUNsYXNzKCdtYnNjLWV2ZW50LWxpc3QtaCcpO1xuXG4gICAgICAgIGlmIChmaXJzdExvYWQgJiYgbGlzdEhlaWdodCkge1xuICAgICAgICAgIHNjcm9sbFRvRGF5KGN1cnJEYXksIHRydWUpO1xuICAgICAgICAgIGZpcnN0TG9hZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkhpZGU6IGZ1bmN0aW9uIG9uSGlkZSgpIHtcbiAgICAgIGJhc2Uub25IaWRlLmNhbGwodGhpcyk7IC8vIERlc3Ryb3kgdGhlIHBvcHVwIHN0b3JlZCBvbiB0aGUgaW5zdGFuY2UsXG4gICAgICAvLyB0aGUgbG9jYWwgdmFyaWFibGUgaXMgbG9zdCBpbiBjYXNlIG9mIG9wdGlvbiBjYWxsIG9yIHJlLWluaXRcblxuICAgICAgaWYgKGluc3QuX3BvcHVwKSB7XG4gICAgICAgIGluc3QuX3BvcHVwLmRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgcmVtb3ZlV2luZG93Rm9jdXMoKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIE1ic2NFdmVudGNhbGVuZGFyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjRXZlbnRjYWxlbmRhciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NFdmVudGNhbGVuZGFyKGluaXRpYWxFbGVtLCB6b25lLCBvcHRpb25TZXJ2aWNlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIG51bGwsIG51bGwsIG51bGwpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMub3B0aW9uU2VydmljZSA9IG9wdGlvblNlcnZpY2U7XHJcbiAgICAgICAgX3RoaXMub25FdmVudFNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5vbkNlbGxIb3ZlckluID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm9uQ2VsbEhvdmVyT3V0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm9uRGF5Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm9uU2V0RGF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5vcHRpb25zID0ge307XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgTWJzY0V2ZW50Y2FsZW5kYXIucHJvdG90eXBlLnJlZnJlc2hEYXRhID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcclxuICAgICAgICB0aGlzLmluc3RhbmNlLnNldEV2ZW50cyhuZXdEYXRhKTtcclxuICAgIH07XHJcbiAgICBNYnNjRXZlbnRjYWxlbmRhci5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBleHRlbmQkMSh7IHByZXNldDogJ2V2ZW50Y2FsZW5kYXInIH0sIHRoaXMub3B0aW9uU2VydmljZSA/IHRoaXMub3B0aW9uU2VydmljZS5vcHRpb25zIDoge30sIHRoaXMub3B0aW9ucywgdGhpcy5pbmxpbmVPcHRpb25zT2JqLCB0aGlzLm9wdGlvbkV4dGVuc2lvbnMpO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgRXZlbnRjYWxlbmRhcih0aGlzLmVsZW1lbnQsIG9wdGlvbnMpO1xyXG4gICAgfTtcclxuICAgIE1ic2NFdmVudGNhbGVuZGFyLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNsb25lRGljdGlvbmFyeS5kYXRhID0gW107XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ09uSW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIE1ic2NFdmVudGNhbGVuZGFyLnByb3RvdHlwZS5zZXROZXdWYWx1ZSA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ21ic2MtZGF0YScpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIE1ic2NFdmVudGNhbGVuZGFyLnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NFdmVudGNhbGVuZGFyLnByb3RvdHlwZSwgXCJsYXlvdXRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NFdmVudGNhbGVuZGFyLnByb3RvdHlwZSwgXCJzaG93RXZlbnRDb3VudFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY0V2ZW50Y2FsZW5kYXIucHJvdG90eXBlLCBcImV2ZW50QnViYmxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxyXG4gICAgXSwgTWJzY0V2ZW50Y2FsZW5kYXIucHJvdG90eXBlLCBcImZvcm1hdER1cmF0aW9uXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NFdmVudGNhbGVuZGFyLnByb3RvdHlwZSwgXCJ2aWV3XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NFdmVudGNhbGVuZGFyLnByb3RvdHlwZSwgXCJhbGxEYXlUZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NFdmVudGNhbGVuZGFyLnByb3RvdHlwZSwgXCJldmVudFRleHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0V2ZW50Y2FsZW5kYXIucHJvdG90eXBlLCBcImV2ZW50c1RleHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBNYnNjRXZlbnRjYWxlbmRhci5wcm90b3R5cGUsIFwibGFiZWxzU2hvcnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0V2ZW50Y2FsZW5kYXIucHJvdG90eXBlLCBcIm5vRXZlbnRzVGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NFdmVudGNhbGVuZGFyLnByb3RvdHlwZSwgXCJvbkV2ZW50U2VsZWN0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY0V2ZW50Y2FsZW5kYXIucHJvdG90eXBlLCBcIm9uQ2VsbEhvdmVySW5cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjRXZlbnRjYWxlbmRhci5wcm90b3R5cGUsIFwib25DZWxsSG92ZXJPdXRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjRXZlbnRjYWxlbmRhci5wcm90b3R5cGUsIFwib25EYXlDaGFuZ2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjRXZlbnRjYWxlbmRhci5wcm90b3R5cGUsIFwib25TZXREYXRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdtYnNjLW9wdGlvbnMnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY0V2ZW50Y2FsZW5kYXIucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NFdmVudGNhbGVuZGFyID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgRGlyZWN0aXZlKHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWJzYy1ldmVudGNhbGVuZGFyXScsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCdcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDIsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLCBNYnNjT3B0aW9uc1NlcnZpY2VdKVxyXG4gICAgXSwgTWJzY0V2ZW50Y2FsZW5kYXIpO1xyXG4gICAgcmV0dXJuIE1ic2NFdmVudGNhbGVuZGFyO1xyXG59KE1ic2NDYWxCYXNlKSk7XHJcbnZhciBNYnNjRXZlbnRjYWxlbmRhckNvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY0V2ZW50Y2FsZW5kYXJDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjRXZlbnRjYWxlbmRhckNvbXBvbmVudChpbml0aWFsRWxlbSwgem9uZSwgb3B0aW9uU2VydmljZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBvcHRpb25TZXJ2aWNlKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSB7fTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBNYnNjRXZlbnRjYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRpc3BsYXkgPSB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmRpc3BsYXkgfHwgdGhpcy5kaXNwbGF5O1xyXG4gICAgICAgIGlmICghZGlzcGxheSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BsYXkgPSAnaW5saW5lJztcclxuICAgICAgICAgICAgdGhpcy5pbmxpbmVPcHRpb25zT2JqLmRpc3BsYXkgPSAnaW5saW5lJztcclxuICAgICAgICB9XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ09uSW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIE1ic2NFdmVudGNhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnNldFRoZW1lQ2xhc3NlcygpO1xyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBNYnNjRXZlbnRjYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjRXZlbnRjYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgTWJzY0V2ZW50Y2FsZW5kYXJDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtZXZlbnRjYWxlbmRhcicsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnPGRpdj48L2Rpdj4nXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgyLCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZSwgTWJzY09wdGlvbnNTZXJ2aWNlXSlcclxuICAgIF0sIE1ic2NFdmVudGNhbGVuZGFyQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBNYnNjRXZlbnRjYWxlbmRhckNvbXBvbmVudDtcclxufShNYnNjRXZlbnRjYWxlbmRhcikpO1xyXG52YXIgTWJzY0V2ZW50Y2FsZW5kYXJNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWJzY0V2ZW50Y2FsZW5kYXJNb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBNYnNjRXZlbnRjYWxlbmRhck1vZHVsZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE5nTW9kdWxlKHtcclxuICAgICAgICAgICAgaW1wb3J0czogW01ic2NDYWxCYXNlTW9kdWxlXSxcclxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWJzY0V2ZW50Y2FsZW5kYXIsIE1ic2NFdmVudGNhbGVuZGFyQ29tcG9uZW50XSxcclxuICAgICAgICAgICAgZXhwb3J0czogW01ic2NFdmVudGNhbGVuZGFyLCBNYnNjRXZlbnRjYWxlbmRhckNvbXBvbmVudF1cclxuICAgICAgICB9KVxyXG4gICAgXSwgTWJzY0V2ZW50Y2FsZW5kYXJNb2R1bGUpO1xyXG4gICAgcmV0dXJuIE1ic2NFdmVudGNhbGVuZGFyTW9kdWxlO1xyXG59KCkpO1xuXG52YXIgaGFzUHJvbWlzZSA9IGlzQnJvd3NlciAmJiAhIXdpbmRvdy5Qcm9taXNlO1xudmFyIHBvcHVwUXVldWUgPSBbXTtcbnZhciBub3RpZmljYXRpb25RdWV1ZSA9IFtdO1xudmFyIGFjdGl2ZU5vdGlmaWNhdGlvbjtcblxuZnVuY3Rpb24gc2hvd1BvcHVwKHBvcHVwKSB7XG4gIGlmICghcG9wdXBRdWV1ZS5sZW5ndGgpIHtcbiAgICBwb3B1cC5zaG93KCk7XG4gIH1cblxuICBwb3B1cFF1ZXVlLnB1c2gocG9wdXApO1xufVxuXG5mdW5jdGlvbiBzaG93Tm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbikge1xuICB2YXIgaXNBbnkgPSBub3RpZmljYXRpb25RdWV1ZS5sZW5ndGg7XG4gIG5vdGlmaWNhdGlvblF1ZXVlLnB1c2gobm90aWZpY2F0aW9uKTsgLy8gT25seSBzaG93IG5vdGlmaWNhdGlvbiBpZiBubyBwb3B1cCBpcyB2aXNpYmxlXG4gIC8vIG90aGVyd2lzZSBwb3N0cG9uZSBpdCB1bnRpbCBwb3B1cCBpcyBjbG9zZWRcblxuICBpZiAoIXBvcHVwUXVldWUubGVuZ3RoKSB7XG4gICAgLy8gSWYgdGhlcmUncyBhIHZpc2libGUgbm90aWZpY2F0aW9uLCBoaWRlIGl0LlxuICAgIC8vIFRoZSBub3RpZmljYXRpb24gd2lsbCBiZSBzaG93biBhZnRlciBoaWRlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZVxuICAgIGlmIChpc0FueSkge1xuICAgICAgbm90aWZpY2F0aW9uUXVldWVbMF0uaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQcmV2ZW50IGZvY3VzIG9uIHNob3cgZm9yIG5vdGlmaWNhdGlvbnNcbiAgICAgIG5vdGlmaWNhdGlvbi5zaG93KGZhbHNlLCB0cnVlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2V0dGluZ3MocXVldWUsIHNldHRpbmdzLCByZXNvbHZlLCBtb3JlKSB7XG4gIC8vY29uc3QgYWN0aXZlID0gbW9iaXNjcm9sbC5hY3RpdmVJbnN0YW5jZTtcbiAgcmV0dXJuIGV4dGVuZCQxKHtcbiAgICBkaXNwbGF5OiBzZXR0aW5ncy5kaXNwbGF5IHx8ICdjZW50ZXInLFxuICAgIGNzc0NsYXNzOiAnbWJzYy1hbGVydCcsXG4gICAgb2tUZXh0OiBzZXR0aW5ncy5va1RleHQsXG4gICAgY2FuY2VsVGV4dDogc2V0dGluZ3MuY2FuY2VsVGV4dCxcbiAgICBjb250ZXh0OiBzZXR0aW5ncy5jb250ZXh0LFxuICAgIHRoZW1lOiBzZXR0aW5ncy50aGVtZSxcbiAgICBjbG9zZU9uT3ZlcmxheVRhcDogZmFsc2UsXG4gICAgb25CZWZvcmVDbG9zZTogZnVuY3Rpb24gb25CZWZvcmVDbG9zZSgpIHtcbiAgICAgIHF1ZXVlLnNoaWZ0KCk7XG4gICAgfSxcbiAgICBvbkhpZGU6IGZ1bmN0aW9uIG9uSGlkZShldiwgaW5zdCkge1xuICAgICAgLy9tb2Jpc2Nyb2xsLmFjdGl2ZUluc3RhbmNlID0gYWN0aXZlO1xuICAgICAgaWYgKHJlc29sdmUpIHtcbiAgICAgICAgcmVzb2x2ZShpbnN0Ll9yZXNvbHZlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNldHRpbmdzLmNhbGxiYWNrKSB7XG4gICAgICAgIHNldHRpbmdzLmNhbGxiYWNrKGluc3QuX3Jlc29sdmUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5zdCkge1xuICAgICAgICBpbnN0LmRlc3Ryb3koKTtcbiAgICAgIH0gLy8gU2hvdyBuZXh0XG5cblxuICAgICAgaWYgKHBvcHVwUXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHBvcHVwUXVldWVbMF0uc2hvdygpO1xuICAgICAgfSBlbHNlIGlmIChub3RpZmljYXRpb25RdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgLy8gUHJldmVudCBmb2N1cyBvbiBzaG93IGZvciBub3RpZmljYXRpb25zXG4gICAgICAgIG5vdGlmaWNhdGlvblF1ZXVlWzBdLnNob3coZmFsc2UsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgbW9yZSk7XG59XG5cbmZ1bmN0aW9uIGdldE1lc3NhZ2Uoc2V0dGluZ3MpIHtcbiAgcmV0dXJuIChzZXR0aW5ncy50aXRsZSA/ICc8aDI+JyArIHNldHRpbmdzLnRpdGxlICsgJzwvaDI+JyA6ICcnKSArICc8cD4nICsgKHNldHRpbmdzLm1lc3NhZ2UgfHwgJycpICsgJzwvcD4nO1xufVxuXG5mdW5jdGlvbiBzaG93QWxlcnQocG9wdXAsIHNldHRpbmdzLCByZXNvbHZlKSB7XG4gIHZhciBpbnN0ID0gbmV3IFBvcHVwKHBvcHVwLCBnZXRTZXR0aW5ncyhwb3B1cFF1ZXVlLCBzZXR0aW5ncywgcmVzb2x2ZSkpO1xuICBzaG93UG9wdXAoaW5zdCk7XG59XG5cbmZ1bmN0aW9uIHNob3dDb25maXJtKHBvcHVwLCBzZXR0aW5ncywgcmVzb2x2ZSkge1xuICB2YXIgaW5zdCA9IG5ldyBQb3B1cChwb3B1cCwgZ2V0U2V0dGluZ3MocG9wdXBRdWV1ZSwgc2V0dGluZ3MsIHJlc29sdmUsIHtcbiAgICBidXR0b25zOiBbJ2NhbmNlbCcsICdvayddLFxuICAgIG9uU2V0OiBmdW5jdGlvbiBvblNldCgpIHtcbiAgICAgIGluc3QuX3Jlc29sdmUgPSB0cnVlO1xuICAgIH1cbiAgfSkpO1xuICBpbnN0Ll9yZXNvbHZlID0gZmFsc2U7XG4gIHNob3dQb3B1cChpbnN0KTtcbn1cblxuZnVuY3Rpb24gc2hvd1Byb21wdChwb3B1cCwgc2V0dGluZ3MsIHJlc29sdmUpIHtcbiAgdmFyIGlucHV0LCBsYWJlbDtcbiAgdmFyIGluc3QgPSBuZXcgUG9wdXAocG9wdXAsIGdldFNldHRpbmdzKHBvcHVwUXVldWUsIHNldHRpbmdzLCByZXNvbHZlLCB7XG4gICAgYnV0dG9uczogWydjYW5jZWwnLCAnb2snXSxcbiAgICBvbk1hcmt1cFJlYWR5OiBmdW5jdGlvbiBvbk1hcmt1cFJlYWR5KGV2ZW50LCBpbnN0KSB7XG4gICAgICB2YXIgcyA9IGluc3Quc2V0dGluZ3M7XG4gICAgICBsYWJlbCA9IGluc3QuX21hcmt1cC5maW5kKCdsYWJlbCcpO1xuICAgICAgbGFiZWwuYWRkQ2xhc3MoJ21ic2MtJyArIHMudGhlbWUgKyAocy5iYXNlVGhlbWUgPyAnIG1ic2MtJyArIHMuYmFzZVRoZW1lIDogJycpKTtcbiAgICAgIGlucHV0ID0gaW5zdC5fbWFya3VwLmZpbmQoJ2lucHV0JylbMF07XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UoMCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICAgIH0sIDMwMCk7XG4gICAgfSxcbiAgICBvblNldDogZnVuY3Rpb24gb25TZXQoKSB7XG4gICAgICBpbnN0Ll9yZXNvbHZlID0gaW5wdXQudmFsdWU7XG4gICAgfVxuICB9KSk7XG4gIGluc3QuX3Jlc29sdmUgPSBudWxsO1xuICBzaG93UG9wdXAoaW5zdCk7XG59XG5cbmZ1bmN0aW9uIHNob3dTbmFja2Jhcihwb3B1cCwgc2V0dGluZ3MsIHJlc29sdmUsIGNzc0NsYXNzLCBhbmltYXRpb24pIHtcbiAgdmFyIG5vdGlmaWNhdGlvblRpbWVyO1xuICB2YXIgaW5zdCA9IG5ldyBQb3B1cChwb3B1cCwgZ2V0U2V0dGluZ3Mobm90aWZpY2F0aW9uUXVldWUsIHNldHRpbmdzLCByZXNvbHZlLCB7XG4gICAgZGlzcGxheTogc2V0dGluZ3MuZGlzcGxheSB8fCAnYm90dG9tJyxcbiAgICBhbmltYXRlOiBhbmltYXRpb24sXG4gICAgY3NzQ2xhc3M6IChjc3NDbGFzcyB8fCAnbWJzYy1zbmFja2JhcicpICsgKHNldHRpbmdzLmNvbG9yID8gJyBtYnNjLScgKyBzZXR0aW5ncy5jb2xvciA6ICcnKSxcbiAgICBzY3JvbGxMb2NrOiBmYWxzZSxcbiAgICBmb2N1c1RyYXA6IGZhbHNlLFxuICAgIGJ1dHRvbnM6IFtdLFxuICAgIG9uTWFya3VwUmVhZHk6IGZ1bmN0aW9uIG9uTWFya3VwUmVhZHkoZXZlbnQsIGluc3QpIHtcbiAgICAgIHZhciBzID0gaW5zdC5zZXR0aW5ncztcblxuICAgICAgdmFyIGJ1dHRvbiA9IGluc3QuX21hcmt1cC5maW5kKCdidXR0b24nKTtcblxuICAgICAgYnV0dG9uLmFkZENsYXNzKCdtYnNjLScgKyBzLnRoZW1lICsgKHMuYmFzZVRoZW1lID8gJyBtYnNjLScgKyBzLmJhc2VUaGVtZSA6ICcnKSk7XG4gICAgfSxcbiAgICBvblNob3c6IGZ1bmN0aW9uIG9uU2hvdyhldiwgaW5zdCkge1xuICAgICAgYWN0aXZlTm90aWZpY2F0aW9uID0gaW5zdDtcblxuICAgICAgaWYgKHNldHRpbmdzLmR1cmF0aW9uICE9PSBmYWxzZSkge1xuICAgICAgICBub3RpZmljYXRpb25UaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChpbnN0KSB7XG4gICAgICAgICAgICBpbnN0LmhpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHNldHRpbmdzLmR1cmF0aW9uIHx8IDMwMDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2V0dGluZ3MuYnV0dG9uKSB7XG4gICAgICAgIGluc3QudGFwKCQkMSgnLm1ic2Mtc25hY2tiYXItYnRuJywgZXYudGFyZ2V0KSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGluc3QuaGlkZSgpO1xuXG4gICAgICAgICAgaWYgKHNldHRpbmdzLmJ1dHRvbi5hY3Rpb24pIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmJ1dHRvbi5hY3Rpb24uY2FsbCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25DbG9zZTogZnVuY3Rpb24gb25DbG9zZSgpIHtcbiAgICAgIGFjdGl2ZU5vdGlmaWNhdGlvbiA9IG51bGw7XG4gICAgICBjbGVhclRpbWVvdXQobm90aWZpY2F0aW9uVGltZXIpO1xuICAgIH1cbiAgfSkpO1xuICBzaG93Tm90aWZpY2F0aW9uKGluc3QpO1xufVxuXG5mdW5jdGlvbiBzaG93VG9hc3QocG9wdXAsIHNldHRpbmdzLCByZXNvbHZlKSB7XG4gIHNob3dTbmFja2Jhcihwb3B1cCwgc2V0dGluZ3MsIHJlc29sdmUsICdtYnNjLXRvYXN0JywgJ2ZhZGUnKTtcbn1cblxuZnVuY3Rpb24gc2hvdyhmdW5jLCBwb3B1cCwgc2V0dGluZ3MpIHtcbiAgdmFyIHA7XG5cbiAgaWYgKGhhc1Byb21pc2UpIHtcbiAgICBwID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIGZ1bmMocG9wdXAsIHNldHRpbmdzLCByZXNvbHZlKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBmdW5jKHBvcHVwLCBzZXR0aW5ncyk7XG4gIH1cblxuICByZXR1cm4gcDtcbn1cblxubW9iaXNjcm9sbC5hbGVydCA9IGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICB2YXIgcG9wdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgcG9wdXAuaW5uZXJIVE1MID0gZ2V0TWVzc2FnZShzZXR0aW5ncyk7XG4gIHJldHVybiBzaG93KHNob3dBbGVydCwgcG9wdXAsIHNldHRpbmdzKTtcbn07XG5cbm1vYmlzY3JvbGwuY29uZmlybSA9IGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICB2YXIgcG9wdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgcG9wdXAuaW5uZXJIVE1MID0gZ2V0TWVzc2FnZShzZXR0aW5ncyk7XG4gIHJldHVybiBzaG93KHNob3dDb25maXJtLCBwb3B1cCwgc2V0dGluZ3MpO1xufTtcblxubW9iaXNjcm9sbC5wcm9tcHQgPSBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgdmFyIHBvcHVwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHBvcHVwLmlubmVySFRNTCA9IGdldE1lc3NhZ2Uoc2V0dGluZ3MpICsgJzxsYWJlbCBjbGFzcz1cIm1ic2MtaW5wdXRcIj4nICsgKHNldHRpbmdzLmxhYmVsID8gJzxzcGFuIGNsYXNzPVwibWJzYy1sYWJlbFwiPicgKyBzZXR0aW5ncy5sYWJlbCArICc8L3NwYW4+JyA6ICcnKSArICc8aW5wdXQgY2xhc3M9XCJtYnNjLWNvbnRyb2xcIiB0YWJpbmRleD1cIjBcIiB0eXBlPVwiJyArIChzZXR0aW5ncy5pbnB1dFR5cGUgfHwgJ3RleHQnKSArICdcIiBwbGFjZWhvbGRlcj1cIicgKyAoc2V0dGluZ3MucGxhY2Vob2xkZXIgfHwgJycpICsgJ1wiIHZhbHVlPVwiJyArIChzZXR0aW5ncy52YWx1ZSB8fCAnJykgKyAnXCI+JyArICc8L2xhYmVsPic7XG4gIHJldHVybiBzaG93KHNob3dQcm9tcHQsIHBvcHVwLCBzZXR0aW5ncyk7XG59O1xuXG5tb2Jpc2Nyb2xsLnNuYWNrYmFyID0gZnVuY3Rpb24gKHNldHRpbmdzKSB7XG4gIHZhciBwb3B1cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgYnRuID0gc2V0dGluZ3MuYnV0dG9uO1xuICBwb3B1cC5pbm5lckhUTUwgPSAnPGRpdiBjbGFzcz1cIm1ic2Mtc25hY2tiYXItY29udFwiPjxkaXYgY2xhc3M9XCJtYnNjLXNuYWNrYmFyLW1zZ1wiPicgKyAoc2V0dGluZ3MubWVzc2FnZSB8fCAnJykgKyAnPC9kaXY+JyArIChidG4gPyAnPGJ1dHRvbiBjbGFzcz1cIm1ic2Mtc25hY2tiYXItYnRuIG1ic2MtYnRuIG1ic2MtYnRuLWZsYXRcIj4nICsgKGJ0bi5pY29uID8gJzxzcGFuIGNsYXNzPVwibWJzYy1pYyAnICsgKGJ0bi50ZXh0ID8gJ21ic2MtYnRuLWljICcgOiAnJykgKyAnbWJzYy1pYy0nICsgYnRuLmljb24gKyAnXCI+PC9zcGFuPicgOiAnJykgKyAoYnRuLnRleHQgfHwgJycpICsgJzwvYnV0dG9uPicgOiAnJykgKyAnPC9kaXY+JztcbiAgcmV0dXJuIHNob3coc2hvd1NuYWNrYmFyLCBwb3B1cCwgc2V0dGluZ3MpO1xufTtcblxubW9iaXNjcm9sbC50b2FzdCA9IGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICB2YXIgcG9wdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgcG9wdXAuaW5uZXJIVE1MID0gJzxkaXYgY2xhc3M9XCJtYnNjLXRvYXN0LW1zZ1wiPicgKyAoc2V0dGluZ3MubWVzc2FnZSB8fCAnJykgKyAnPC9kaXY+JztcbiAgcmV0dXJuIHNob3coc2hvd1RvYXN0LCBwb3B1cCwgc2V0dGluZ3MpO1xufTtcblxubW9iaXNjcm9sbC5ub3RpZmljYXRpb24gPSB7XG4gIGRpc21pc3M6IGZ1bmN0aW9uIGRpc21pc3MoKSB7XG4gICAgaWYgKGFjdGl2ZU5vdGlmaWNhdGlvbikge1xuICAgICAgYWN0aXZlTm90aWZpY2F0aW9uLmhpZGUoKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBoYWxmQm9yZGVyJDMgPSBvcyA9PSAnaW9zJyAmJiBtYWpvclZlcnNpb24gPiA3O1xudmFyIEZvcm0gPSBmdW5jdGlvbiBGb3JtKGVsLCBzZXR0aW5ncykge1xuICB2YXIgcyxcbiAgICAgIGNzc0NsYXNzID0gJycsXG4gICAgICAkY3R4ID0gJCQxKGVsKSxcbiAgICAgIGNvbnRyb2xzID0ge30sXG4gICAgICB0aGF0ID0gdGhpcztcblxuICBmdW5jdGlvbiB0b3VjaGVkKCkge1xuICAgICRjdHgucmVtb3ZlQ2xhc3MoJ21ic2Mtbm8tdG91Y2gnKTtcbiAgfSAvLyBDYWxsIHRoZSBwYXJlbnQgY29uc3RydWN0b3JcblxuXG4gIEJhc2UuY2FsbCh0aGlzLCBlbCwgc2V0dGluZ3MsIHRydWUpO1xuXG4gIHRoYXQucmVmcmVzaCA9IGZ1bmN0aW9uIChzaGFsbG93KSB7XG4gICAgaWYgKHMuZW5oYW5jZSkge1xuICAgICAgaW5pdENvbnRyb2xzKCRjdHgsIGNvbnRyb2xzLCBzLCBzaGFsbG93KTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIEZvcm0gaW5pdGlhbGl6YXRpb24uXHJcbiAgICovXG5cblxuICB0aGF0Ll9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghbW9iaXNjcm9sbC50aGVtZXMuZm9ybVtzLnRoZW1lXSkge1xuICAgICAgcy50aGVtZSA9ICdtb2Jpc2Nyb2xsJztcbiAgICB9XG5cbiAgICBpZiAoISRjdHguaGFzQ2xhc3MoJ21ic2MtZm9ybScpKSB7XG4gICAgICAkY3R4LnNob3coKTtcbiAgICAgIGxpc3RlbigkY3R4WzBdLCAndG91Y2hzdGFydCcsIHRvdWNoZWQsIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGNzc0NsYXNzKSB7XG4gICAgICAkY3R4LnJlbW92ZUNsYXNzKGNzc0NsYXNzKTtcbiAgICB9IC8vIC0tLSBUUklBTCBTRVJWRVIgQ09ERSBTVEFSVCAtLS1cblxuXG4gICAgY3NzQ2xhc3MgPSAnbWJzYy1mb3JtIG1ic2Mtbm8tdG91Y2ggbWJzYy0nICsgcy50aGVtZSArIChoYWxmQm9yZGVyJDMgPyAnIG1ic2MtZm9ybS1oYicgOiAnJykgKyAocy5iYXNlVGhlbWUgPyAnIG1ic2MtJyArIHMuYmFzZVRoZW1lIDogJycpICsgKHMucnRsID8gJyBtYnNjLXJ0bCcgOiAnIG1ic2MtbHRyJykgKyAocy5pbnB1dFN0eWxlID09ICdib3gnID8gJyBtYnNjLWZvcm0tYm94JyA6ICcnKSArIChzLmlucHV0U3R5bGUgPT0gJ291dGxpbmUnID8gJyBtYnNjLWZvcm0tb3V0bGluZScgOiAnJyk7IC8vIC0tLSBUUklBTCBTRVJWRVIgQ09ERSBFTkQgLS0tXG5cbiAgICAkY3R4LmFkZENsYXNzKGNzc0NsYXNzKS5yZW1vdmVDbGFzcygnbWJzYy1jbG9haycpO1xuICAgIHRoYXQucmVmcmVzaCgpO1xuICB9O1xuICAvKipcclxuICAgKiBEZXN0cm95cyB0aGUgbW9iaXNjcm9sbCBpbnN0YW5jZS5cclxuICAgKi9cblxuXG4gIHRoYXQuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgJGN0eC5yZW1vdmVDbGFzcyhjc3NDbGFzcyk7XG4gICAgdW5saXN0ZW4oJGN0eFswXSwgJ3RvdWNoc3RhcnQnLCB0b3VjaGVkLCB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpZCBpbiBjb250cm9scykge1xuICAgICAgY29udHJvbHNbaWRdLmRlc3Ryb3koKTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIE9iamVjdCB3aXRoIHRoZSB1bmRlcmx5aW5nIGZvcm0gY29udHJvbCBpbnN0YW5jZXNcclxuICAgKiBrZXlzIGFyZSB0aGUgZWxlbWVudCBpZCdzXHJcbiAgICovXG5cblxuICB0aGF0LmNvbnRyb2xzID0gY29udHJvbHM7IC8vIENvbnN0cnVjdG9yXG5cbiAgcyA9IHRoYXQuc2V0dGluZ3M7XG4gIHRoYXQuaW5pdCgpO1xufTsgLy8gRXh0ZW5kIGRlZmF1bHRzXG5cbkZvcm0ucHJvdG90eXBlID0ge1xuICBfaGFzRGVmOiB0cnVlLFxuICBfaGFzVGhlbWU6IHRydWUsXG4gIF9oYXNMYW5nOiB0cnVlLFxuICBfY2xhc3M6ICdmb3JtJyxcbiAgX2RlZmF1bHRzOiB7XG4gICAgdGFwOiBoYXNHaG9zdENsaWNrLFxuICAgIHN0b3BQcm9wOiB0cnVlLFxuICAgIHJ0bDogZmFsc2UsXG4gICAgZW5oYW5jZTogdHJ1ZVxuICB9XG59O1xuY2xhc3Nlcy5Gb3JtID0gRm9ybTsgLy8gSW5pdCBtYnNjLWZvcm0gZWxlbWVudHMgb24gcGFnZSBsb2FkXG5cbmF1dG9Jbml0KCdbbWJzYy1lbmhhbmNlXSxbbWJzYy1mb3JtXScsIEZvcm0sIHRydWUpO1xuXG52YXIgTWJzY0Zvcm0gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NGb3JtLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY0Zvcm0oaW5pdGlhbEVsZW0sIF9mb3JtU2VydmljZSwgem9uZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLl9mb3JtU2VydmljZSA9IF9mb3JtU2VydmljZTtcclxuICAgICAgICBfdGhpcy5lbmhhbmNlID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgTWJzY0Zvcm0ucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMub3B0aW9uc09iaiA9IGV4dGVuZCQxKHt9LCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaik7XHJcbiAgICAgICAgdGhpcy5fZm9ybVNlcnZpY2Uub3B0aW9ucyA9IHRoaXMub3B0aW9uc09iajtcclxuICAgIH07XHJcbiAgICBNYnNjRm9ybS5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcclxuICAgICAgICBpZiAob3B0ICYmIG9wdC5lbmhhbmNlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgb3B0LmVuaGFuY2UgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBleHRlbmQkMSh7fSwgb3B0LCB0aGlzLmlubGluZU9wdGlvbnNPYmopO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgRm9ybSh0aGlzLnJvb3RFbGVtLm5hdGl2ZUVsZW1lbnQsIG9wdGlvbnMpO1xyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ29wdGlvbnMnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY0Zvcm0ucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NGb3JtLnByb3RvdHlwZSwgXCJlbmhhbmNlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NGb3JtLnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdpbnB1dC1zdHlsZScpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjRm9ybS5wcm90b3R5cGUsIFwiaW5wdXRTdHlsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnbGFiZWwtc3R5bGUnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0Zvcm0ucHJvdG90eXBlLCBcImxhYmVsU3R5bGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIFZpZXdDaGlsZCgncm9vdEVsZW1lbnQnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXHJcbiAgICBdLCBNYnNjRm9ybS5wcm90b3R5cGUsIFwicm9vdEVsZW1cIiwgdm9pZCAwKTtcclxuICAgIE1ic2NGb3JtID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLWZvcm0nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2ICNyb290RWxlbWVudD48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9kaXY+XCIsXHJcbiAgICAgICAgICAgIHByb3ZpZGVyczogW01ic2NPcHRpb25zU2VydmljZV0sXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCdcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE1ic2NPcHRpb25zU2VydmljZSwgTmdab25lXSlcclxuICAgIF0sIE1ic2NGb3JtKTtcclxuICAgIHJldHVybiBNYnNjRm9ybTtcclxufShNYnNjQmFzZSkpO1xyXG52YXIgTWJzY1RleHRhcmVhID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjVGV4dGFyZWEsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjVGV4dGFyZWEoaW5pdGlhbEVsZW0sIF9mb3JtU2VydmljZSwgX2lucHV0U2VydmljZSwgX2NvbnRyb2wsIHpvbmUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgX2Zvcm1TZXJ2aWNlLCBfaW5wdXRTZXJ2aWNlLCBfY29udHJvbCwgem9uZSkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5faW5wdXRTZXJ2aWNlID0gX2lucHV0U2VydmljZTtcclxuICAgICAgICBfaW5wdXRTZXJ2aWNlLmlucHV0ID0gX3RoaXM7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgTWJzY1RleHRhcmVhLnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHt9LCB0aGlzLl9pbmhlcml0ZWRPcHRpb25zLCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaik7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBUZXh0QXJlYSh0aGlzLl9pbml0RWxlbS5uYXRpdmVFbGVtZW50LCBvcHRpb25zKTtcclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NUZXh0YXJlYS5wcm90b3R5cGUsIFwicm93c1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjVGV4dGFyZWEucHJvdG90eXBlLCBcIndyYXBcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NUZXh0YXJlYSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy10ZXh0YXJlYScsXHJcbiAgICAgICAgICAgIGhvc3Q6IHsgJ2NsYXNzJzogJ21ic2MtY29udHJvbC1uZycgfSxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiXFxuICAgICAgICAgICAgPGxhYmVsIFxcbiAgICAgICAgICAgICAgICBbY2xhc3MubWJzYy1lcnJdPVxcXCJlcnJvclxcXCJcXG4gICAgICAgICAgICAgICAgW2NsYXNzLm1ic2MtaW5wdXQtYm94XT1cXFwiaW5wdXRTdHlsZSA9PSAnYm94J1xcXCJcXG4gICAgICAgICAgICAgICAgW2NsYXNzLm1ic2MtaW5wdXQtb3V0bGluZV09XFxcImlucHV0U3R5bGUgPT0gJ291dGxpbmUnXFxcIlxcbiAgICAgICAgICAgICAgICBbY2xhc3MubWJzYy1sYWJlbC1zdGFja2VkXT1cXFwibGFiZWxTdHlsZSA9PSAnc3RhY2tlZCdcXFwiXFxuICAgICAgICAgICAgICAgIFtjbGFzcy5tYnNjLWxhYmVsLWlubGluZV09XFxcImxhYmVsU3R5bGUgPT0gJ2lubGluZSdcXFwiXFxuICAgICAgICAgICAgICAgIFtjbGFzcy5tYnNjLWxhYmVsLWZsb2F0aW5nXT1cXFwibGFiZWxTdHlsZSA9PSAnZmxvYXRpbmcnXFxcIlxcbiAgICAgICAgICAgID5cXG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XFxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XFxcIm1ic2MtaW5wdXQtd3JhcFxcXCI+XFxuICAgICAgICAgICAgICAgIDx0ZXh0YXJlYSAjaW5pdEVsZW1lbnQgW3BsYWNlaG9sZGVyXT1cXFwicGxhY2Vob2xkZXJcXFwiIFsobmdNb2RlbCldPVxcXCJpbm5lclZhbHVlXFxcIiAoYmx1cik9XFxcIm9uVG91Y2goJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLm5hbWVdPVxcXCJuYW1lXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIucm93c109XFxcInJvd3NcXFwiXFxuICAgICAgICAgICAgICAgICAgICBbYXR0ci53cmFwXT1cXFwid3JhcFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLm1pbmxlbmd0aF09XFxcIm1pbmxlbmd0aFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLm1heGxlbmd0aF09XFxcIm1heGxlbmd0aFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmF1dG9jb21wbGV0ZV09XFxcImF1dG9jb21wbGV0ZVxcXCIgXFxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hdXRvY2FwaXRhbGl6ZV09XFxcImF1dG9jYXBpdGFsaXplXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXV0b2NvcnJlY3RdPVxcXCJhdXRvY29ycmVjdFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLnNwZWxsY2hlY2tdPVxcXCJzcGVsbGNoZWNrXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXV0b2ZvY3VzXT1cXFwiYXV0b2ZvY3VzXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIucmVxdWlyZWRdPVxcXCJyZXF1aXJlZFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtaWNvbl09XFxcImljb24gPyBpY29uIDogbnVsbFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtaWNvbi1hbGlnbl09XFxcImljb25BbGlnbiA/IGljb25BbGlnbiA6IG51bGxcXFwiXFxuICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIFtyZWFkb25seV09XFxcIl9yZWFkb25seVxcXCI+PC90ZXh0YXJlYT5cXG4gICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XFxcImVycm9yICYmIGVycm9yTWVzc2FnZVxcXCIgY2xhc3M9XFxcIm1ic2MtZXJyLW1zZ1xcXCI+e3tlcnJvck1lc3NhZ2V9fTwvc3Bhbj5cXG4gICAgICAgICAgICA8L3NwYW4+XFxuICAgICAgICA8L2xhYmVsPlxcbiAgICBcIixcclxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbTWJzY0lucHV0U2VydmljZV1cclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDEsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDMsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTWJzY09wdGlvbnNTZXJ2aWNlLCBNYnNjSW5wdXRTZXJ2aWNlLCBOZ0NvbnRyb2wsIE5nWm9uZV0pXHJcbiAgICBdLCBNYnNjVGV4dGFyZWEpO1xyXG4gICAgcmV0dXJuIE1ic2NUZXh0YXJlYTtcclxufShNYnNjSW5wdXRCYXNlKSk7XHJcbnZhciBNYnNjRHJvcGRvd24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NEcm9wZG93biwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NEcm9wZG93bihob3N0RWxlbSwgZm9ybVNlcnZpY2UsIF9pbnB1dFNlcnZpY2UsIGNvbnRyb2wsIHpvbmUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBob3N0RWxlbSwgZm9ybVNlcnZpY2UsIF9pbnB1dFNlcnZpY2UsIGNvbnRyb2wsIHpvbmUpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuX2lucHV0U2VydmljZSA9IF9pbnB1dFNlcnZpY2U7XHJcbiAgICAgICAgX2lucHV0U2VydmljZS5pbnB1dCA9IF90aGlzO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjRHJvcGRvd24ucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdjtcclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5pbnN0YW5jZS5fc2V0VGV4dCgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE1ic2NEcm9wZG93bi5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBleHRlbmQkMSh7fSwgdGhpcy5faW5oZXJpdGVkT3B0aW9ucywgdGhpcy5vcHRpb25zLCB0aGlzLmlubGluZU9wdGlvbnNPYmopO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgU2VsZWN0KHRoaXMuX2luaXRFbGVtLm5hdGl2ZUVsZW1lbnQsIG9wdGlvbnMpO1xyXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhhdC5pbnN0YW5jZS5fc2V0VGV4dCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE1ic2NEcm9wZG93bi5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2O1xyXG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGF0XzEgPSB0aGlzO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoYXRfMS5pbnN0YW5jZS5fc2V0VGV4dCgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjRHJvcGRvd24ucHJvdG90eXBlLCBcImxhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NEcm9wZG93bi5wcm90b3R5cGUsIFwiaWNvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnaWNvbi1hbGlnbicpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjRHJvcGRvd24ucHJvdG90eXBlLCBcImljb25BbGlnblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcclxuICAgIF0sIE1ic2NEcm9wZG93bi5wcm90b3R5cGUsIFwidmFsdWVcIiwgbnVsbCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdpbnB1dC1zdHlsZScpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjRHJvcGRvd24ucHJvdG90eXBlLCBcImlucHV0U3R5bGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ2xhYmVsLXN0eWxlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NEcm9wZG93bi5wcm90b3R5cGUsIFwibGFiZWxTdHlsZVwiLCB2b2lkIDApO1xyXG4gICAgTWJzY0Ryb3Bkb3duID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLWRyb3Bkb3duJyxcclxuICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWJzYy1jb250cm9sLW5nJyB9LFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgICAgICA8bGFiZWwgXFxuICAgICAgICAgICAgICAgIFtjbGFzcy5tYnNjLWVycl09XFxcImVycm9yXFxcIlxcbiAgICAgICAgICAgICAgICBbY2xhc3MubWJzYy1pbnB1dC1ib3hdPVxcXCJpbnB1dFN0eWxlID09ICdib3gnXFxcIlxcbiAgICAgICAgICAgICAgICBbY2xhc3MubWJzYy1pbnB1dC1vdXRsaW5lXT1cXFwiaW5wdXRTdHlsZSA9PSAnb3V0bGluZSdcXFwiXFxuICAgICAgICAgICAgICAgIFtjbGFzcy5tYnNjLWxhYmVsLXN0YWNrZWRdPVxcXCJsYWJlbFN0eWxlID09ICdzdGFja2VkJ1xcXCJcXG4gICAgICAgICAgICAgICAgW2NsYXNzLm1ic2MtbGFiZWwtaW5saW5lXT1cXFwibGFiZWxTdHlsZSA9PSAnaW5saW5lJ1xcXCJcXG4gICAgICAgICAgICAgICAgW2NsYXNzLm1ic2MtbGFiZWwtZmxvYXRpbmddPVxcXCJsYWJlbFN0eWxlID09ICdmbG9hdGluZydcXFwiXFxuICAgICAgICAgICAgPlxcbiAgICAgICAgICAgIHt7bGFiZWx9fVxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJtYnNjLWlucHV0LXdyYXBcXFwiPlxcbiAgICAgICAgICAgICAgICA8c2VsZWN0ICNpbml0RWxlbWVudFxcbiAgICAgICAgICAgICAgICAgICAgWyhuZ01vZGVsKV09XFxcImlubmVyVmFsdWVcXFwiIFxcbiAgICAgICAgICAgICAgICAgICAgW2F0dHIubmFtZV09XFxcIm5hbWVcXFwiXFxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLWljb25dPVxcXCJpY29uID8gaWNvbiA6IG51bGxcXFwiXFxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLWljb24tYWxpZ25dPVxcXCJpY29uQWxpZ24gPyBpY29uQWxpZ24gOiBudWxsXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgICAgICAgICAoYmx1cik9XFxcIm9uVG91Y2goJGV2ZW50KVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XFxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxcbiAgICAgICAgICAgICAgICA8c3BhbiAqbmdJZj1cXFwiZXJyb3IgJiYgZXJyb3JNZXNzYWdlXFxcIiBjbGFzcz1cXFwibWJzYy1lcnItbXNnXFxcIj57e2Vycm9yTWVzc2FnZX19PC9zcGFuPlxcbiAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgIDwvbGFiZWw+XFxuICAgIFwiLFxyXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtNYnNjSW5wdXRTZXJ2aWNlXVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMSwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBNYnNjT3B0aW9uc1NlcnZpY2UsIE1ic2NJbnB1dFNlcnZpY2UsIE5nQ29udHJvbCwgTmdab25lXSlcclxuICAgIF0sIE1ic2NEcm9wZG93bik7XHJcbiAgICByZXR1cm4gTWJzY0Ryb3Bkb3duO1xyXG59KE1ic2NGb3JtVmFsdWVCYXNlKSk7XHJcbnZhciBNYnNjQnV0dG9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjQnV0dG9uLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY0J1dHRvbihob3N0RWxlbSwgZm9ybVNlcnZpY2UsIHpvbmUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBob3N0RWxlbSwgZm9ybVNlcnZpY2UsIHpvbmUpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuX2ZsYXQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5fYmxvY2sgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5fb3V0bGluZSA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLl9jbGFzc2VzT2JqID0ge307XHJcbiAgICAgICAgX3RoaXMudHlwZSA9ICdidXR0b24nO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjQnV0dG9uLnByb3RvdHlwZSwgXCJjc3NDbGFzc2VzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgayBpbiB0aGlzLl9jbGFzc2VzT2JqKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fY2xhc3Nlc09ialtrXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9jbGFzc2VzT2JqWydtYnNjLWJ0bi1mbGF0J10gPSB0aGlzLl9mbGF0O1xyXG4gICAgICAgICAgICB0aGlzLl9jbGFzc2VzT2JqWydtYnNjLWJ0bi1ibG9jayddID0gdGhpcy5fYmxvY2s7XHJcbiAgICAgICAgICAgIHRoaXMuX2NsYXNzZXNPYmpbJ21ic2MtYnRuLW91dGxpbmUnXSA9IHRoaXMuX291dGxpbmU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNsYXNzZXMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjc3NDbGFzc2VzID0gdGhpcy5jbGFzc2VzLnNwbGl0KCcgJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3NzQ2xhc3Nlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNzc0NsYXNzZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNzc0NsYXNzZXNbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NsYXNzZXNPYmpbY3NzQ2xhc3Nlc1tpXV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGFzc2VzT2JqWydtYnNjLWJ0bi0nICsgdGhpcy5jb2xvcl0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jbGFzc2VzT2JqO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NCdXR0b24ucHJvdG90eXBlLCBcImZsYXRcIiwge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9mbGF0ID0gZW1wdHlPclRydWUodmFsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjQnV0dG9uLnByb3RvdHlwZSwgXCJibG9ja1wiLCB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Jsb2NrID0gZW1wdHlPclRydWUodmFsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjQnV0dG9uLnByb3RvdHlwZSwgXCJvdXRsaW5lXCIsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICAgICAgdGhpcy5fb3V0bGluZSA9IGVtcHR5T3JUcnVlKHZhbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBNYnNjQnV0dG9uLnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHt9LCB0aGlzLl9pbmhlcml0ZWRPcHRpb25zLCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaik7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBCdXR0b24odGhpcy5faW5pdEVsZW0ubmF0aXZlRWxlbWVudCwgb3B0aW9ucyk7XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnY2xhc3MnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0J1dHRvbi5wcm90b3R5cGUsIFwiY2xhc3Nlc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjQnV0dG9uLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NCdXR0b24ucHJvdG90eXBlLCBcImljb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXHJcbiAgICBdLCBNYnNjQnV0dG9uLnByb3RvdHlwZSwgXCJmbGF0XCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcclxuICAgIF0sIE1ic2NCdXR0b24ucHJvdG90eXBlLCBcImJsb2NrXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcclxuICAgIF0sIE1ic2NCdXR0b24ucHJvdG90eXBlLCBcIm91dGxpbmVcIiwgbnVsbCk7XHJcbiAgICBNYnNjQnV0dG9uID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLWJ1dHRvbicsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgPGJ1dHRvbiAjaW5pdEVsZW1lbnQgXFxuICAgICAgICAgICAgW3R5cGVdPVxcXCJ0eXBlXFxcIlxcbiAgICAgICAgICAgIFtuZ0NsYXNzXT1cXFwiY3NzQ2xhc3Nlc1xcXCJcXG4gICAgICAgICAgICBbYXR0ci5uYW1lXT1cXFwibmFtZVxcXCJcXG4gICAgICAgICAgICBbYXR0ci5kYXRhLWljb25dPVxcXCJpY29uID8gaWNvbiA6IG51bGxcXFwiXFxuICAgICAgICAgICAgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiPlxcbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cXG4gICAgICAgIDwvYnV0dG9uPlxcbiAgICBcIixcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDEsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTWJzY09wdGlvbnNTZXJ2aWNlLCBOZ1pvbmVdKVxyXG4gICAgXSwgTWJzY0J1dHRvbik7XHJcbiAgICByZXR1cm4gTWJzY0J1dHRvbjtcclxufShNYnNjRm9ybUJhc2UpKTtcclxudmFyIE1ic2NDaGVja2JveCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY0NoZWNrYm94LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY0NoZWNrYm94KGhvc3RFbGVtLCBjZHIsIGZvcm1TZXJ2aWNlLCBfaW5wdXRTZXJ2aWNlLCBjb250cm9sLCB6b25lKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaG9zdEVsZW0sIGZvcm1TZXJ2aWNlLCBfaW5wdXRTZXJ2aWNlLCBjb250cm9sLCB6b25lKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmNkciA9IGNkcjtcclxuICAgICAgICBfdGhpcy5fY29sb3JDbGFzcyA9IHt9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjQ2hlY2tib3gucHJvdG90eXBlLCBcImNvbG9yQ2xhc3NcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIHRoaXMuX2NvbG9yQ2xhc3MpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jb2xvckNsYXNzW2tdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xvckNsYXNzWydtYnNjLWNoZWNrYm94LScgKyB0aGlzLmNvbG9yXSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbG9yQ2xhc3NbJ21ic2MtZXJyJ10gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xvckNsYXNzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTWJzY0NoZWNrYm94LnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHt9LCB0aGlzLl9pbmhlcml0ZWRPcHRpb25zLCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaik7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBDaGVja0JveCh0aGlzLl9pbml0RWxlbS5uYXRpdmVFbGVtZW50LCBvcHRpb25zKTtcclxuICAgIH07XHJcbiAgICBNYnNjQ2hlY2tib3gucHJvdG90eXBlLndyaXRlVmFsdWUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdjtcclxuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjQ2hlY2tib3gucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdpbnB1dC1zdHlsZScpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjQ2hlY2tib3gucHJvdG90eXBlLCBcImlucHV0U3R5bGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ2xhYmVsLXN0eWxlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NDaGVja2JveC5wcm90b3R5cGUsIFwibGFiZWxTdHlsZVwiLCB2b2lkIDApO1xyXG4gICAgTWJzY0NoZWNrYm94ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLWNoZWNrYm94JyxcclxuICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWJzYy1jb250cm9sLW5nJyB9LFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxsYWJlbCBbbmdDbGFzc109XFxcImNvbG9yQ2xhc3NcXFwiPlxcbiAgICAgICAgICAgIDxpbnB1dCAjaW5pdEVsZW1lbnQgXFxuICAgICAgICAgICAgICAgIHR5cGU9XFxcImNoZWNrYm94XFxcIlxcbiAgICAgICAgICAgICAgICBbYXR0ci5uYW1lXT1cXFwibmFtZVxcXCJcXG4gICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtbGFiZWwtc3R5bGVdPVxcXCJsYWJlbFN0eWxlXFxcIlxcbiAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLWlucHV0LXN0eWxlXT1cXFwiaW5wdXRTdHlsZVxcXCJcXG4gICAgICAgICAgICAgICAgWyhuZ01vZGVsKV09XFxcImlubmVyVmFsdWVcXFwiXFxuICAgICAgICAgICAgICAgIChibHVyKT1cXFwib25Ub3VjaCgkZXZlbnQpXFxcIiAvPlxcbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cXG4gICAgICAgICAgICA8c3BhbiAqbmdJZj1cXFwiZXJyb3IgJiYgZXJyb3JNZXNzYWdlXFxcIiBjbGFzcz1cXFwibWJzYy1lcnItbXNnXFxcIj57e2Vycm9yTWVzc2FnZX19PC9zcGFuPlxcbiAgICAgICAgPC9sYWJlbD5cXG4gICAgXCIsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgyLCBPcHRpb25hbCgpKSwgX19wYXJhbSgzLCBPcHRpb25hbCgpKSwgX19wYXJhbSg0LCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIENoYW5nZURldGVjdG9yUmVmLCBNYnNjT3B0aW9uc1NlcnZpY2UsIE1ic2NJbnB1dFNlcnZpY2UsIE5nQ29udHJvbCwgTmdab25lXSlcclxuICAgIF0sIE1ic2NDaGVja2JveCk7XHJcbiAgICByZXR1cm4gTWJzY0NoZWNrYm94O1xyXG59KE1ic2NGb3JtVmFsdWVCYXNlKSk7XHJcbnZhciBNYnNjU3dpdGNoID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjU3dpdGNoLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY1N3aXRjaChob3N0RWxlbSwgem9uZSwgX2Zvcm1TZXJ2aWNlLCBjb250cm9sKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaG9zdEVsZW0sIHpvbmUsIGNvbnRyb2wsIG51bGwsIG51bGwpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuX2Zvcm1TZXJ2aWNlID0gX2Zvcm1TZXJ2aWNlO1xyXG4gICAgICAgIF90aGlzLmRpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMub25DaGFuZ2VFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLl9jb2xvckNsYXNzID0ge307XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NTd2l0Y2gucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjU3dpdGNoLnByb3RvdHlwZSwgXCJjb2xvckNsYXNzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgayBpbiB0aGlzLl9jb2xvckNsYXNzKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fY29sb3JDbGFzc1trXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29sb3JDbGFzc1snbWJzYy1zd2l0Y2gtJyArIHRoaXMuY29sb3JdID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5lcnJvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29sb3JDbGFzc1snbWJzYy1lcnInXSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yQ2xhc3M7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBNYnNjU3dpdGNoLnByb3RvdHlwZS5zZXROZXdWYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UuZ2V0VmFsKCkgIT09IHYpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0VmFsKHYsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNYnNjU3dpdGNoLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9pbmhlcml0ZWRPcHRpb25zID0gdGhpcy5fZm9ybVNlcnZpY2UgPyB0aGlzLl9mb3JtU2VydmljZS5vcHRpb25zIDoge307XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ09uSW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIE1ic2NTd2l0Y2gucHJvdG90eXBlLmluaXRDb250cm9sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gZXh0ZW5kJDEoe30sIHRoaXMuX2luaGVyaXRlZE9wdGlvbnMsIHRoaXMub3B0aW9ucywgdGhpcy5pbmxpbmVPcHRpb25zT2JqKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IFN3aXRjaCh0aGlzLl9pbml0RWxlbS5uYXRpdmVFbGVtZW50LCBvcHRpb25zKTtcclxuICAgICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNldFZhbCh0aGlzLmluaXRpYWxWYWx1ZSwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdvcHRpb25zJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NTd2l0Y2gucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NTd2l0Y2gucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NTd2l0Y2gucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1N3aXRjaC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NTd2l0Y2gucHJvdG90eXBlLCBcImVycm9yXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NTd2l0Y2gucHJvdG90eXBlLCBcImVycm9yTWVzc2FnZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgndmFsdWUnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcclxuICAgIF0sIE1ic2NTd2l0Y2gucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCd2YWx1ZUNoYW5nZScpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjU3dpdGNoLnByb3RvdHlwZSwgXCJvbkNoYW5nZUVtaXR0ZXJcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIFZpZXdDaGlsZCgnaW5pdEVsZW1lbnQnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXHJcbiAgICBdLCBNYnNjU3dpdGNoLnByb3RvdHlwZSwgXCJfaW5pdEVsZW1cIiwgdm9pZCAwKTtcclxuICAgIE1ic2NTd2l0Y2ggPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ21ic2Mtc3dpdGNoJyxcclxuICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWJzYy1jb250cm9sLW5nJyB9LFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxsYWJlbCBbbmdDbGFzc109XFxcImNvbG9yQ2xhc3NcXFwiPlxcbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cXG4gICAgICAgICAgICA8c3BhbiAqbmdJZj1cXFwiZXJyb3IgJiYgZXJyb3JNZXNzYWdlXFxcIiBjbGFzcz1cXFwibWJzYy1lcnItbXNnXFxcIj57e2Vycm9yTWVzc2FnZX19PC9zcGFuPlxcbiAgICAgICAgICAgIDxpbnB1dCAjaW5pdEVsZW1lbnQgXFxuICAgICAgICAgICAgICAgIHR5cGU9XFxcImNoZWNrYm94XFxcIlxcbiAgICAgICAgICAgICAgICBkYXRhLXJvbGU9XFxcInN3aXRjaFxcXCJcXG4gICAgICAgICAgICAgICAgW2F0dHIubmFtZV09XFxcIm5hbWVcXFwiXFxuICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtbGFiZWwtc3R5bGVdPVxcXCJsYWJlbFN0eWxlXFxcIlxcbiAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLWlucHV0LXN0eWxlXT1cXFwiaW5wdXRTdHlsZVxcXCJcXG4gICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgICAgIChibHVyKT1cXFwib25Ub3VjaCgkZXZlbnQpXFxcIiAvPlxcbiAgICAgICAgPC9sYWJlbD5cXG4gICAgXCIsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXHJcbiAgICAgICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgyLCBPcHRpb25hbCgpKSwgX19wYXJhbSgzLCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZSwgTWJzY09wdGlvbnNTZXJ2aWNlLCBOZ0NvbnRyb2xdKVxyXG4gICAgXSwgTWJzY1N3aXRjaCk7XHJcbiAgICByZXR1cm4gTWJzY1N3aXRjaDtcclxufShNYnNjQ29udHJvbEJhc2UpKTtcclxudmFyIE1ic2NTdGVwcGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjU3RlcHBlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NTdGVwcGVyKGhvc3RFbGVtZW50LCB6b25lLCBfZm9ybVNlcnZpY2UsIGNvbnRyb2wpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBob3N0RWxlbWVudCwgem9uZSwgY29udHJvbCwgbnVsbCwgbnVsbCkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5fZm9ybVNlcnZpY2UgPSBfZm9ybVNlcnZpY2U7XHJcbiAgICAgICAgX3RoaXMubWluID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIF90aGlzLm1heCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBfdGhpcy5zdGVwID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIF90aGlzLnZhbCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBfdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLl9jb2xvckNsYXNzID0ge307XHJcbiAgICAgICAgX3RoaXMub25DaGFuZ2VFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjU3RlcHBlci5wcm90b3R5cGUsIFwicmVhZG9ubHlcIiwge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZWFkb25seSA9IGVtcHR5T3JUcnVlKHZhbCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY1N0ZXBwZXIucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjU3RlcHBlci5wcm90b3R5cGUsIFwiY29sb3JDbGFzc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gdGhpcy5fY29sb3JDbGFzcykge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NvbG9yQ2xhc3Nba107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbG9yQ2xhc3NbJ21ic2Mtc3RlcHBlci0nICsgdGhpcy5jb2xvcl0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xvckNsYXNzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTWJzY1N0ZXBwZXIucHJvdG90eXBlLnNldE5ld1ZhbHVlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSAmJiB0aGlzLmluc3RhbmNlLmdldFZhbCgpICE9PSB2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0VmFsKHYsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTWJzY1N0ZXBwZXIucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX2luaGVyaXRlZE9wdGlvbnMgPSB0aGlzLl9mb3JtU2VydmljZSA/IHRoaXMuX2Zvcm1TZXJ2aWNlLm9wdGlvbnMgOiB7fTtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nT25Jbml0LmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgTWJzY1N0ZXBwZXIucHJvdG90eXBlLmluaXRDb250cm9sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gZXh0ZW5kJDEoe30sIHRoaXMuX2luaGVyaXRlZE9wdGlvbnMsIHRoaXMub3B0aW9ucywgdGhpcy5pbmxpbmVPcHRpb25zT2JqKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IFN0ZXBwZXIodGhpcy5faW5pdEVsZW0ubmF0aXZlRWxlbWVudCwgb3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodGhpcy5pbml0aWFsVmFsdWUsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcclxuICAgIF0sIE1ic2NTdGVwcGVyLnByb3RvdHlwZSwgXCJyZWFkb25seVwiLCBudWxsKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ29wdGlvbnMnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY1N0ZXBwZXIucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW051bWJlcl0pXHJcbiAgICBdLCBNYnNjU3RlcHBlci5wcm90b3R5cGUsIFwidmFsdWVcIiwgbnVsbCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NTdGVwcGVyLnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIE1ic2NTdGVwcGVyLnByb3RvdHlwZSwgXCJtaW5cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgTWJzY1N0ZXBwZXIucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBNYnNjU3RlcHBlci5wcm90b3R5cGUsIFwic3RlcFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjU3RlcHBlci5wcm90b3R5cGUsIFwidmFsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjU3RlcHBlci5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1N0ZXBwZXIucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoJ3ZhbHVlQ2hhbmdlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NTdGVwcGVyLnByb3RvdHlwZSwgXCJvbkNoYW5nZUVtaXR0ZXJcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIFZpZXdDaGlsZCgnaW5pdEVsZW1lbnQnLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXHJcbiAgICBdLCBNYnNjU3RlcHBlci5wcm90b3R5cGUsIFwiX2luaXRFbGVtXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjU3RlcHBlciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1zdGVwcGVyJyxcclxuICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWJzYy1jb250cm9sLW5nJyB9LFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxkaXYgW25nQ2xhc3NdPVxcXCJjb2xvckNsYXNzXFxcIj5cXG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XFxuICAgICAgICAgICAgPGlucHV0ICNpbml0RWxlbWVudFxcbiAgICAgICAgICAgICAgICBkYXRhLXJvbGU9XFxcInN0ZXBwZXJcXFwiXFxuICAgICAgICAgICAgICAgIFthdHRyLm5hbWVdPVxcXCJuYW1lXFxcIlxcbiAgICAgICAgICAgICAgICBbYXR0ci5taW5dPVxcXCJtaW4gIT09IHVuZGVmaW5lZCA/IG1pbiA6IG51bGxcXFwiXFxuICAgICAgICAgICAgICAgIFthdHRyLm1heF09XFxcIm1heCAhPT0gdW5kZWZpbmVkID8gbWF4IDogbnVsbFxcXCJcXG4gICAgICAgICAgICAgICAgW2F0dHIuc3RlcF09XFxcInN0ZXAgIT09IHVuZGVmaW5lZCA/IHN0ZXAgOiBudWxsXFxcIlxcbiAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLXZhbF09XFxcInZhbCA/IHZhbCA6IG51bGxcXFwiXFxuICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtbGFiZWwtc3R5bGVdPVxcXCJsYWJlbFN0eWxlXFxcIlxcbiAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLWlucHV0LXN0eWxlXT1cXFwiaW5wdXRTdHlsZVxcXCJcXG4gICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiIFxcbiAgICAgICAgICAgICAgICBbcmVhZG9ubHldPVxcXCJfcmVhZG9ubHlcXFwiLz5cXG4gICAgICAgIDwvZGl2PlxcbiAgICBcIixcclxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJyxcclxuICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDIsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDMsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLCBNYnNjT3B0aW9uc1NlcnZpY2UsIE5nQ29udHJvbF0pXHJcbiAgICBdLCBNYnNjU3RlcHBlcik7XHJcbiAgICByZXR1cm4gTWJzY1N0ZXBwZXI7XHJcbn0oTWJzY0NvbnRyb2xCYXNlKSk7XHJcbnZhciBNYnNjUHJvZ3Jlc3MgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NQcm9ncmVzcywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NQcm9ncmVzcyhob3N0RWxlbWVudCwgem9uZSwgX2Zvcm1TZXJ2aWNlLCBjb250cm9sKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaG9zdEVsZW1lbnQsIHpvbmUsIGNvbnRyb2wsIG51bGwsIG51bGwpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuX2Zvcm1TZXJ2aWNlID0gX2Zvcm1TZXJ2aWNlO1xyXG4gICAgICAgIF90aGlzLm1heCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBfdGhpcy5pY29uID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIF90aGlzLmljb25BbGlnbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICBfdGhpcy52YWwgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgX3RoaXMuZGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5fY29sb3JDbGFzcyA9IHt9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjUHJvZ3Jlc3MucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjUHJvZ3Jlc3MucHJvdG90eXBlLCBcImRhdGFTdGVwTGFiZWxzXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiAodGhpcy5zdGVwTGFiZWxzKSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0ZXBMYWJlbHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NQcm9ncmVzcy5wcm90b3R5cGUsIFwiY29sb3JDbGFzc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gdGhpcy5fY29sb3JDbGFzcykge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NvbG9yQ2xhc3Nba107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbG9yQ2xhc3NbJ21ic2MtcHJvZ3Jlc3MtJyArIHRoaXMuY29sb3JdID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29sb3JDbGFzcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE1ic2NQcm9ncmVzcy5wcm90b3R5cGUuc2V0TmV3VmFsdWUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlICYmIHRoaXMuaW5zdGFuY2UuZ2V0VmFsKCkgIT09IHYpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodiwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNYnNjUHJvZ3Jlc3MucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX2luaGVyaXRlZE9wdGlvbnMgPSB0aGlzLl9mb3JtU2VydmljZSA/IHRoaXMuX2Zvcm1TZXJ2aWNlLm9wdGlvbnMgOiB7fTtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nT25Jbml0LmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgTWJzY1Byb2dyZXNzLnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHt9LCB0aGlzLl9pbmhlcml0ZWRPcHRpb25zLCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaik7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBQcm9ncmVzcyh0aGlzLl9pbml0RWxlbS5uYXRpdmVFbGVtZW50LCBvcHRpb25zKTtcclxuICAgICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNldFZhbCh0aGlzLmluaXRpYWxWYWx1ZSwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdvcHRpb25zJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NQcm9ncmVzcy5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTnVtYmVyXSlcclxuICAgIF0sIE1ic2NQcm9ncmVzcy5wcm90b3R5cGUsIFwidmFsdWVcIiwgbnVsbCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIE1ic2NQcm9ncmVzcy5wcm90b3R5cGUsIFwibWF4XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NQcm9ncmVzcy5wcm90b3R5cGUsIFwiaWNvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnaWNvbi1hbGlnbicpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjUHJvZ3Jlc3MucHJvdG90eXBlLCBcImljb25BbGlnblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjUHJvZ3Jlc3MucHJvdG90eXBlLCBcInZhbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY1Byb2dyZXNzLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnc3RlcC1sYWJlbHMnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBNYnNjUHJvZ3Jlc3MucHJvdG90eXBlLCBcInN0ZXBMYWJlbHNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1Byb2dyZXNzLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgVmlld0NoaWxkKCdpbml0RWxlbWVudCcsIHsgc3RhdGljOiBmYWxzZSB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcclxuICAgIF0sIE1ic2NQcm9ncmVzcy5wcm90b3R5cGUsIFwiX2luaXRFbGVtXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjUHJvZ3Jlc3MgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtcHJvZ3Jlc3MnLFxyXG4gICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYnNjLWNvbnRyb2wtbmcnIH0sXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgPGxhYmVsIFtuZ0NsYXNzXT1cXFwiY29sb3JDbGFzc1xcXCI+XFxuICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxcbiAgICAgICAgICAgIDxwcm9ncmVzcyAjaW5pdEVsZW1lbnRcXG4gICAgICAgICAgICAgICAgW2F0dHIuZGF0YS1zdGVwLWxhYmVsc109XFxcImRhdGFTdGVwTGFiZWxzXFxcIlxcbiAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLWljb25dPVxcXCJpY29uID8gaWNvbiA6IG51bGxcXFwiXFxuICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtaWNvbi1hbGlnbl09XFxcImljb25BbGlnbiA/IGljb25BbGlnbiA6IG51bGxcXFwiXFxuICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtbGFiZWwtc3R5bGVdPVxcXCJsYWJlbFN0eWxlXFxcIlxcbiAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLWlucHV0LXN0eWxlXT1cXFwiaW5wdXRTdHlsZVxcXCJcXG4gICAgICAgICAgICAgICAgW2F0dHIubWF4XT1cXFwibWF4ICE9PSB1bmRlZmluZWQgPyBtYXggOiBudWxsXFxcIlxcbiAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLXZhbF09XFxcInZhbCAhPT0gdW5kZWZpbmVkID8gdmFsIDogbnVsbFxcXCJcXG4gICAgICAgICAgICA+XFxuICAgICAgICAgICAgPC9wcm9ncmVzcz5cXG4gICAgICAgIDwvbGFiZWw+XFxuICAgIFwiLFxyXG4gICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnLFxyXG4gICAgICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMiwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBOZ1pvbmUsIE1ic2NPcHRpb25zU2VydmljZSwgTmdDb250cm9sXSlcclxuICAgIF0sIE1ic2NQcm9ncmVzcyk7XHJcbiAgICByZXR1cm4gTWJzY1Byb2dyZXNzO1xyXG59KE1ic2NDb250cm9sQmFzZSkpO1xyXG52YXIgZ3JvdXBOYW1lID0gMTtcclxudmFyIE1ic2NSYWRpb1NlcnZpY2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWJzY1JhZGlvU2VydmljZSgpIHtcclxuICAgICAgICB0aGlzLl9sYXN0VmFsdWUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlT2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlKCk7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY1JhZGlvU2VydmljZS5wcm90b3R5cGUsIFwibmFtZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbmFtZSA9ICdtYnNjLXJhZGlvLWdyb3VwLScgKyAoZ3JvdXBOYW1lKyspO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICB0aGlzLl9uYW1lID0gbjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjUmFkaW9TZXJ2aWNlLnByb3RvdHlwZSwgXCJtdWx0aVNlbGVjdFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tdWx0aVNlbGVjdDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgdGhpcy5fbXVsdGlTZWxlY3QgPSB2O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTWJzY1JhZGlvU2VydmljZS5wcm90b3R5cGUub25WYWx1ZUNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlT2JzZXJ2YWJsZTtcclxuICAgIH07XHJcbiAgICBNYnNjUmFkaW9TZXJ2aWNlLnByb3RvdHlwZS5jaGFuZ2VWYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdGhpcy5fdmFsdWVPYnNlcnZhYmxlLm5leHQodik7XHJcbiAgICAgICAgdGhpcy5fbGFzdFZhbHVlID0gdjtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY1JhZGlvU2VydmljZS5wcm90b3R5cGUsIFwiZ2V0TGFzdFZhbHVlXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xhc3RWYWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjUmFkaW9TZXJ2aWNlLnByb3RvdHlwZSwgXCJjb2xvclwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xvcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgdGhpcy5fY29sb3IgPSB2O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTWJzY1JhZGlvU2VydmljZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIEluamVjdGFibGUoKVxyXG4gICAgXSwgTWJzY1JhZGlvU2VydmljZSk7XHJcbiAgICByZXR1cm4gTWJzY1JhZGlvU2VydmljZTtcclxufSgpKTtcclxudmFyIE1ic2NSYWRpb0dyb3VwQmFzZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY1JhZGlvR3JvdXBCYXNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY1JhZGlvR3JvdXBCYXNlKGhvc3RFbGVtZW50LCBmb3JtU2VydmljZSwgX2lucHV0U2VydmljZSwgX3JhZGlvU2VydmljZSwgY29udHJvbCwgem9uZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGhvc3RFbGVtZW50LCBmb3JtU2VydmljZSwgX2lucHV0U2VydmljZSwgY29udHJvbCwgem9uZSkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5fcmFkaW9TZXJ2aWNlID0gX3JhZGlvU2VydmljZTtcclxuICAgICAgICBfdGhpcy52YWx1ZU9ic2VydmVyID0gX3RoaXMuX3JhZGlvU2VydmljZS5vblZhbHVlQ2hhbmdlZCgpLnN1YnNjcmliZShmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICBfdGhpcy5pbm5lclZhbHVlID0gdjtcclxuICAgICAgICAgICAgX3RoaXMub25Ub3VjaCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjUmFkaW9Hcm91cEJhc2UucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdjtcclxuICAgICAgICAgICAgdGhpcy5fcmFkaW9TZXJ2aWNlLmNoYW5nZVZhbHVlKHYpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTWJzY1JhZGlvR3JvdXBCYXNlLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nT25Jbml0LmNhbGwodGhpcyk7XHJcbiAgICAgICAgaWYgKHRoaXMubmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yYWRpb1NlcnZpY2UubmFtZSA9IHRoaXMubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY29sb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmFkaW9TZXJ2aWNlLmNvbG9yID0gdGhpcy5jb2xvcjtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTWJzY1JhZGlvR3JvdXBCYXNlLnByb3RvdHlwZS53cml0ZVZhbHVlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICB0aGlzLl92YWx1ZSA9IHY7XHJcbiAgICAgICAgdGhpcy5fcmFkaW9TZXJ2aWNlLmNoYW5nZVZhbHVlKHYpO1xyXG4gICAgfTtcclxuICAgIE1ic2NSYWRpb0dyb3VwQmFzZS5wcm90b3R5cGUudXBkYXRlT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgIE1ic2NSYWRpb0dyb3VwQmFzZS5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fcmFkaW9TZXJ2aWNlLm9uVmFsdWVDaGFuZ2VkKCkudW5zdWJzY3JpYmUodGhpcy52YWx1ZU9ic2VydmVyKTtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nT25EZXN0cm95LmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjUmFkaW9Hcm91cEJhc2UucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXHJcbiAgICBdLCBNYnNjUmFkaW9Hcm91cEJhc2UucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xyXG4gICAgTWJzY1JhZGlvR3JvdXBCYXNlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbWJzYy1yZy1iXScgfSksXHJcbiAgICAgICAgX19wYXJhbSgxLCBPcHRpb25hbCgpKSwgX19wYXJhbSgyLCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE1ic2NPcHRpb25zU2VydmljZSwgTWJzY0lucHV0U2VydmljZSwgTWJzY1JhZGlvU2VydmljZSwgTmdDb250cm9sLCBOZ1pvbmVdKVxyXG4gICAgXSwgTWJzY1JhZGlvR3JvdXBCYXNlKTtcclxuICAgIHJldHVybiBNYnNjUmFkaW9Hcm91cEJhc2U7XHJcbn0oTWJzY0Zvcm1WYWx1ZUJhc2UpKTtcclxudmFyIE1ic2NSYWRpb0dyb3VwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjUmFkaW9Hcm91cCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NSYWRpb0dyb3VwKGhvc3RFbGVtZW50LCBmb3JtU2VydmljZSwgX2lucHV0U2VydmljZSwgcmFkaW9TZXJ2aWNlLCBjb250cm9sLCB6b25lKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGhvc3RFbGVtZW50LCBmb3JtU2VydmljZSwgX2lucHV0U2VydmljZSwgcmFkaW9TZXJ2aWNlLCBjb250cm9sLCB6b25lKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgTWJzY1JhZGlvR3JvdXAgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtcmFkaW8tZ3JvdXAnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8bmctY29udGVudD48L25nLWNvbnRlbnQ+XCIsXHJcbiAgICAgICAgICAgIHByb3ZpZGVyczogW01ic2NSYWRpb1NlcnZpY2VdXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgxLCBPcHRpb25hbCgpKSwgX19wYXJhbSgyLCBPcHRpb25hbCgpKSwgX19wYXJhbSg0LCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE1ic2NPcHRpb25zU2VydmljZSwgTWJzY0lucHV0U2VydmljZSwgTWJzY1JhZGlvU2VydmljZSwgTmdDb250cm9sLCBOZ1pvbmVdKVxyXG4gICAgXSwgTWJzY1JhZGlvR3JvdXApO1xyXG4gICAgcmV0dXJuIE1ic2NSYWRpb0dyb3VwO1xyXG59KE1ic2NSYWRpb0dyb3VwQmFzZSkpO1xyXG52YXIgTWJzY1JhZGlvID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjUmFkaW8sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjUmFkaW8oaG9zdEVsZW1lbnQsIGZvcm1TZXJ2aWNlLCBfcmFkaW9TZXJ2aWNlLCB6b25lKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaG9zdEVsZW1lbnQsIGZvcm1TZXJ2aWNlLCB6b25lKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLl9yYWRpb1NlcnZpY2UgPSBfcmFkaW9TZXJ2aWNlO1xyXG4gICAgICAgIF90aGlzLl9jb2xvckNsYXNzID0ge307XHJcbiAgICAgICAgdmFyIHYgPSBfdGhpcy5fcmFkaW9TZXJ2aWNlLmdldExhc3RWYWx1ZTtcclxuICAgICAgICBpZiAodiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBfdGhpcy5tb2RlbFZhbHVlID0gdjtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3RoaXMudmFsdWVPYnNlcnZlciA9IF90aGlzLl9yYWRpb1NlcnZpY2Uub25WYWx1ZUNoYW5nZWQoKS5zdWJzY3JpYmUoZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgX3RoaXMubW9kZWxWYWx1ZSA9IHY7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NSYWRpby5wcm90b3R5cGUsIFwiY2hlY2tlZFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09IHRoaXMubW9kZWxWYWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjUmFkaW8ucHJvdG90eXBlLCBcImNvbG9yQ2xhc3NcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIHRoaXMuX2NvbG9yQ2xhc3MpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jb2xvckNsYXNzW2tdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xvckNsYXNzWydtYnNjLXJhZGlvLScgKyB0aGlzLmNvbG9yXSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbG9yQ2xhc3NbJ21ic2MtZXJyJ10gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xvckNsYXNzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTWJzY1JhZGlvLnByb3RvdHlwZS5jbGlja2VkID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICB0aGlzLl9yYWRpb1NlcnZpY2UuY2hhbmdlVmFsdWUodGhpcy52YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgTWJzY1JhZGlvLnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHt9LCB0aGlzLl9pbmhlcml0ZWRPcHRpb25zLCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaik7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBSYWRpbyh0aGlzLl9pbml0RWxlbS5uYXRpdmVFbGVtZW50LCBvcHRpb25zKTtcclxuICAgIH07XHJcbiAgICBNYnNjUmFkaW8ucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdPbkluaXQuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLl9yYWRpb1NlcnZpY2UubmFtZTtcclxuICAgICAgICB0aGlzLmNvbG9yID0gdGhpcy5fcmFkaW9TZXJ2aWNlLmNvbG9yO1xyXG4gICAgfTtcclxuICAgIE1ic2NSYWRpby5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fcmFkaW9TZXJ2aWNlLm9uVmFsdWVDaGFuZ2VkKCkudW5zdWJzY3JpYmUodGhpcy52YWx1ZU9ic2VydmVyKTtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nT25EZXN0cm95LmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjUmFkaW8ucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjUmFkaW8ucHJvdG90eXBlLCBcImVycm9yXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NSYWRpby5wcm90b3R5cGUsIFwiZXJyb3JNZXNzYWdlXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjUmFkaW8gPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtcmFkaW8nLFxyXG4gICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYnNjLWNvbnRyb2wtbmcnIH0sXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgPGxhYmVsIFtuZ0NsYXNzXT1cXFwiY29sb3JDbGFzc1xcXCI+XFxuICAgICAgICAgICAgPGlucHV0ICNpbml0RWxlbWVudCBcXG4gICAgICAgICAgICAgICAgdHlwZT1cXFwicmFkaW9cXFwiIFxcbiAgICAgICAgICAgICAgICBbYXR0ci5uYW1lXT1cXFwibmFtZVxcXCIgXFxuICAgICAgICAgICAgICAgIFthdHRyLnZhbHVlXT1cXFwidmFsdWVcXFwiXFxuICAgICAgICAgICAgICAgIFt2YWx1ZV09XFxcInZhbHVlXFxcIiBcXG4gICAgICAgICAgICAgICAgW2NoZWNrZWRdPVxcXCJjaGVja2VkXFxcIlxcbiAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCJcXG4gICAgICAgICAgICAgICAgKGNsaWNrKT1cXFwiY2xpY2tlZCgkZXZlbnQpXFxcIiAvPlxcbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cXG4gICAgICAgICAgICA8c3BhbiAqbmdJZj1cXFwiZXJyb3IgJiYgZXJyb3JNZXNzYWdlXFxcIiBjbGFzcz1cXFwibWJzYy1lcnItbXNnXFxcIj57e2Vycm9yTWVzc2FnZX19PC9zcGFuPlxcbiAgICAgICAgPC9sYWJlbD5cXG4gICAgXCJcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDEsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTWJzY09wdGlvbnNTZXJ2aWNlLCBNYnNjUmFkaW9TZXJ2aWNlLCBOZ1pvbmVdKVxyXG4gICAgXSwgTWJzY1JhZGlvKTtcclxuICAgIHJldHVybiBNYnNjUmFkaW87XHJcbn0oTWJzY0Zvcm1CYXNlKSk7XHJcbnZhciBNYnNjU2VnbWVudGVkR3JvdXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NTZWdtZW50ZWRHcm91cCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NTZWdtZW50ZWRHcm91cChob3N0RWxlbWVudCwgZm9ybVNlcnZpY2UsIF9pbnB1dFNlcnZpY2UsIHJhZGlvU2VydmljZSwgY29udHJvbCwgem9uZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGhvc3RFbGVtZW50LCBmb3JtU2VydmljZSwgX2lucHV0U2VydmljZSwgcmFkaW9TZXJ2aWNlLCBjb250cm9sLCB6b25lKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnNlbGVjdCA9ICdzaW5nbGUnO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjU2VnbWVudGVkR3JvdXAucHJvdG90eXBlLCBcIm11bHRpU2VsZWN0XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ID09ICdtdWx0aXBsZSc7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBNYnNjU2VnbWVudGVkR3JvdXAucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdPbkluaXQuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9yYWRpb1NlcnZpY2UubXVsdGlTZWxlY3QgPSB0aGlzLm11bHRpU2VsZWN0O1xyXG4gICAgICAgIGlmICh0aGlzLmNvbG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JhZGlvU2VydmljZS5jb2xvciA9IHRoaXMuY29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1NlZ21lbnRlZEdyb3VwLnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NTZWdtZW50ZWRHcm91cCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1zZWdtZW50ZWQtZ3JvdXAnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2IGNsYXNzPVxcXCJtYnNjLXNlZ21lbnRlZCBtYnNjLW5vLXRvdWNoXFxcIj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9kaXY+XCIsXHJcbiAgICAgICAgICAgIHByb3ZpZGVyczogW01ic2NSYWRpb1NlcnZpY2VdXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgxLCBPcHRpb25hbCgpKSwgX19wYXJhbSgyLCBPcHRpb25hbCgpKSwgX19wYXJhbSg0LCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE1ic2NPcHRpb25zU2VydmljZSwgTWJzY0lucHV0U2VydmljZSwgTWJzY1JhZGlvU2VydmljZSwgTmdDb250cm9sLCBOZ1pvbmVdKVxyXG4gICAgXSwgTWJzY1NlZ21lbnRlZEdyb3VwKTtcclxuICAgIHJldHVybiBNYnNjU2VnbWVudGVkR3JvdXA7XHJcbn0oTWJzY1JhZGlvR3JvdXBCYXNlKSk7XHJcbnZhciBNYnNjU2VnbWVudGVkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjU2VnbWVudGVkLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY1NlZ21lbnRlZChob3N0RWxlbWVudCwgZm9ybVNlcnZpY2UsIF9yYWRpb1NlcnZpY2UsIHpvbmUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBob3N0RWxlbWVudCwgZm9ybVNlcnZpY2UsIHpvbmUpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuX3JhZGlvU2VydmljZSA9IF9yYWRpb1NlcnZpY2U7XHJcbiAgICAgICAgX3RoaXMuY2hlY2tlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICB2YXIgdiA9IF90aGlzLl9yYWRpb1NlcnZpY2UuZ2V0TGFzdFZhbHVlO1xyXG4gICAgICAgIGlmICh2ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIF90aGlzLm1vZGVsVmFsdWUgPSB2O1xyXG4gICAgICAgIH1cclxuICAgICAgICBfdGhpcy52YWx1ZU9ic2VydmVyID0gX3RoaXMuX3JhZGlvU2VydmljZS5vblZhbHVlQ2hhbmdlZCgpLnN1YnNjcmliZShmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICBfdGhpcy5tb2RlbFZhbHVlID0gdjtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY1NlZ21lbnRlZC5wcm90b3R5cGUsIFwiaXNDaGVja2VkXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubXVsdGlTZWxlY3QpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrZWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoZWNrZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tb2RlbFZhbHVlICYmIHRoaXMubW9kZWxWYWx1ZS5pbmNsdWRlcyh0aGlzLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09IHRoaXMubW9kZWxWYWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTWJzY1NlZ21lbnRlZC5wcm90b3R5cGUuY2xpY2tlZCA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubXVsdGlTZWxlY3QgJiYgdGhpcy5jaGVja2VkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5jaGVja2VkQ2hhbmdlLmVtaXQoISghIXRoaXMuY2hlY2tlZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubXVsdGlTZWxlY3QpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1vZGVsVmFsdWUuaW5jbHVkZXModGhpcy52YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IHRoaXMubW9kZWxWYWx1ZS5pbmRleE9mKHRoaXMudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWxWYWx1ZS5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGVsVmFsdWUucHVzaCh0aGlzLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3JhZGlvU2VydmljZS5jaGFuZ2VWYWx1ZSh0aGlzLm1vZGVsVmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmFkaW9TZXJ2aWNlLmNoYW5nZVZhbHVlKHRoaXMudmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjU2VnbWVudGVkLnByb3RvdHlwZSwgXCJjc3NDbGFzc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBjbCA9ICdtYnNjLXNlZ21lbnRlZC1pdGVtJztcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3IpIHtcclxuICAgICAgICAgICAgICAgIGNsICs9ICcgbWJzYy1zZWdtZW50ZWQtJyArIHRoaXMuY29sb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTWJzY1NlZ21lbnRlZC5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBleHRlbmQkMSh7fSwgdGhpcy5faW5oZXJpdGVkT3B0aW9ucywgdGhpcy5vcHRpb25zLCB0aGlzLmlubGluZU9wdGlvbnNPYmopO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgU2VnbWVudGVkSXRlbSh0aGlzLl9pbml0RWxlbS5uYXRpdmVFbGVtZW50LCBvcHRpb25zKTtcclxuICAgIH07XHJcbiAgICBNYnNjU2VnbWVudGVkLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nT25Jbml0LmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5fcmFkaW9TZXJ2aWNlLm5hbWU7XHJcbiAgICAgICAgdGhpcy5tdWx0aVNlbGVjdCA9IHRoaXMuX3JhZGlvU2VydmljZS5tdWx0aVNlbGVjdDtcclxuICAgICAgICB0aGlzLmNvbG9yID0gdGhpcy5fcmFkaW9TZXJ2aWNlLmNvbG9yO1xyXG4gICAgfTtcclxuICAgIE1ic2NTZWdtZW50ZWQucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuX3JhZGlvU2VydmljZS5vblZhbHVlQ2hhbmdlZCgpLnVuc3Vic2NyaWJlKHRoaXMudmFsdWVPYnNlcnZlcik7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ09uRGVzdHJveS5jYWxsKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1NlZ21lbnRlZC5wcm90b3R5cGUsIFwiaWNvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjU2VnbWVudGVkLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjU2VnbWVudGVkLnByb3RvdHlwZSwgXCJjaGVja2VkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY1NlZ21lbnRlZC5wcm90b3R5cGUsIFwiY2hlY2tlZENoYW5nZVwiLCB2b2lkIDApO1xyXG4gICAgTWJzY1NlZ21lbnRlZCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1zZWdtZW50ZWQnLFxyXG4gICAgICAgICAgICBob3N0OiB7ICdbY2xhc3NdJzogJ2Nzc0NsYXNzJyB9LFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCJcXG4gICAgICAgIDxsYWJlbCBjbGFzcz1cXFwibWJzYy1zZWdtZW50ZWQtaXRlbS1yZWFkeVxcXCI+XFxuICAgICAgICAgICAgPGlucHV0ICNpbml0RWxlbWVudCBcXG4gICAgICAgICAgICAgICAgZGF0YS1yb2xlPVxcXCJzZWdtZW50ZWRcXFwiXFxuICAgICAgICAgICAgICAgIFt0eXBlXT1cXFwibXVsdGlTZWxlY3QgPyAnY2hlY2tib3gnIDogJ3JhZGlvJ1xcXCIgXFxuICAgICAgICAgICAgICAgIFt2YWx1ZV09XFxcInZhbHVlXFxcIiBcXG4gICAgICAgICAgICAgICAgW2NoZWNrZWRdPVxcXCJpc0NoZWNrZWRcXFwiXFxuICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XFxcImRpc2FibGVkXFxcIlxcbiAgICAgICAgICAgICAgICBbYXR0ci5uYW1lXT1cXFwibmFtZVxcXCIgXFxuICAgICAgICAgICAgICAgIFthdHRyLnZhbHVlXT1cXFwidmFsdWVcXFwiXFxuICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtaWNvbl09XFxcImljb24gPyBpY29uIDogbnVsbFxcXCJcXG4gICAgICAgICAgICAgICAgKGNsaWNrKT1cXFwiY2xpY2tlZCgkZXZlbnQpXFxcIiAvPlxcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJtYnNjLXNlZ21lbnRlZC1jb250ZW50XFxcIj5cXG4gICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XFxcImljb25cXFwiIGNsYXNzPVxcXCJ7eydtYnNjLWljIG1ic2MtaWMtJyArIGljb24gfX1cXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxcbiAgICAgICAgICAgIDwvc3Bhbj5cXG4gICAgICAgIDwvbGFiZWw+XFxuICAgIFwiXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgxLCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE1ic2NPcHRpb25zU2VydmljZSwgTWJzY1JhZGlvU2VydmljZSwgTmdab25lXSlcclxuICAgIF0sIE1ic2NTZWdtZW50ZWQpO1xyXG4gICAgcmV0dXJuIE1ic2NTZWdtZW50ZWQ7XHJcbn0oTWJzY0Zvcm1CYXNlKSk7XHJcbnZhciBNYnNjU2xpZGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjU2xpZGVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY1NsaWRlcihob3N0RWxlbWVudCwgX2Zvcm1TZXJ2aWNlLCB6b25lLCBjb250cm9sKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaG9zdEVsZW1lbnQsIHpvbmUsIGNvbnRyb2wsIG51bGwsIG51bGwpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuX2Zvcm1TZXJ2aWNlID0gX2Zvcm1TZXJ2aWNlO1xyXG4gICAgICAgIF90aGlzLl9kdW1teSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBfdGhpcy5fbmVlZHNUaW1lb3V0ID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuZGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5fY29sb3JDbGFzcyA9IHt9O1xyXG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY1NsaWRlci5wcm90b3R5cGUsIFwiaXNNdWx0aVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXN0VmFsdWUgaW5zdGFuY2VvZiBBcnJheTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjU2xpZGVyLnByb3RvdHlwZSwgXCJkdW1teUFycmF5XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9kdW1teSB8fCAodGhpcy5pc011bHRpICYmIHRoaXMuX2xhc3RWYWx1ZSAmJiB0aGlzLl9sYXN0VmFsdWUubGVuZ3RoICYmIHRoaXMuX2R1bW15Lmxlbmd0aCAhPT0gdGhpcy5fbGFzdFZhbHVlLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2R1bW15ID0gQXJyYXkodGhpcy5pc011bHRpID8gdGhpcy5fbGFzdFZhbHVlLmxlbmd0aCA6IDEpLmZpbGwoMCkubWFwKGZ1bmN0aW9uICh4LCBpKSB7IHJldHVybiBpOyB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZHVtbXk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY1NsaWRlci5wcm90b3R5cGUsIFwiZGF0YVN0ZXBMYWJlbHNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mICh0aGlzLnN0ZXBMYWJlbHMpID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RlcExhYmVscztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY1NsaWRlci5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXROZXdWYWx1ZVByb3h5KHYpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NTbGlkZXIucHJvdG90eXBlLCBcImNvbG9yQ2xhc3NcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIHRoaXMuX2NvbG9yQ2xhc3MpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jb2xvckNsYXNzW2tdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xvckNsYXNzWydtYnNjLXNsaWRlci0nICsgdGhpcy5jb2xvcl0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2xvckNsYXNzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTWJzY1NsaWRlci5wcm90b3R5cGUucmVJbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZS5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5zZXRFbGVtZW50KCk7XHJcbiAgICAgICAgdGhpcy5pbnB1dEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGlucHV0LCBpbmRleCkge1xyXG4gICAgICAgICAgICBpZiAoaW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZUNoYW5nZShpbnB1dC5uYXRpdmVFbGVtZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gZXh0ZW5kJDEoe30sIHRoaXMuX2luaGVyaXRlZE9wdGlvbnMsIHRoaXMub3B0aW9ucywgdGhpcy5pbmxpbmVPcHRpb25zT2JqKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IFNsaWRlcih0aGlzLmlucHV0RWxlbWVudHMuZmlyc3QubmF0aXZlRWxlbWVudCwgb3B0aW9ucyk7XHJcbiAgICB9O1xyXG4gICAgTWJzY1NsaWRlci5wcm90b3R5cGUuc2V0TmV3VmFsdWUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fbGFzdFZhbHVlID0gdjtcclxuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB2YXIgaW5uZXJWYWx1ZSA9IHRoaXMuaW5zdGFuY2UuZ2V0VmFsKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTXVsdGkgJiYgKCFpbm5lclZhbHVlIHx8IGlubmVyVmFsdWUubGVuZ3RoICE9IHYubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVJbml0aWFsaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5zdGFuY2Uuc2V0VmFsKF90aGlzLl9sYXN0VmFsdWUsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNoYW5nZWQgPSAodGhpcy5pc011bHRpICYmICFkZWVwRXF1YWxzQXJyYXkoaW5uZXJWYWx1ZSwgdikpIHx8ICghdGhpcy5pc011bHRpICYmIGlubmVyVmFsdWUgIT09IHYpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNldFZhbCh2LCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTWJzY1NsaWRlci5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5faW5oZXJpdGVkT3B0aW9ucyA9IHRoaXMuX2Zvcm1TZXJ2aWNlID8gdGhpcy5fZm9ybVNlcnZpY2Uub3B0aW9ucyA6IHt9O1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdPbkluaXQuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICBNYnNjU2xpZGVyLnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuaW5wdXRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCwgaW5kZXgpIHtcclxuICAgICAgICAgICAgaWYgKGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVDaGFuZ2UoaW5wdXQubmF0aXZlRWxlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHt9LCB0aGlzLl9pbmhlcml0ZWRPcHRpb25zLCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaik7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBTbGlkZXIodGhpcy5pbnB1dEVsZW1lbnRzLmZpcnN0Lm5hdGl2ZUVsZW1lbnQsIG9wdGlvbnMpO1xyXG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuaW5pdGlhbFZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0VmFsKHRoaXMuaW5pdGlhbFZhbHVlLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ29wdGlvbnMnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY1NsaWRlci5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjU2xpZGVyLnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjU2xpZGVyLnByb3RvdHlwZSwgXCJ0b29sdGlwXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjU2xpZGVyLnByb3RvdHlwZSwgXCJoaWdobGlnaHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NTbGlkZXIucHJvdG90eXBlLCBcImxpdmVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ3ZhbHVlLXRlbXBsYXRlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NTbGlkZXIucHJvdG90eXBlLCBcInZhbHVlVGVtcGxhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1NsaWRlci5wcm90b3R5cGUsIFwiaWNvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjU2xpZGVyLnByb3RvdHlwZSwgXCJ2YWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgTWJzY1NsaWRlci5wcm90b3R5cGUsIFwibWF4XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIE1ic2NTbGlkZXIucHJvdG90eXBlLCBcIm1pblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBNYnNjU2xpZGVyLnByb3RvdHlwZSwgXCJzdGVwXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjU2xpZGVyLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnc3RlcC1sYWJlbHMnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY1NsaWRlci5wcm90b3R5cGUsIFwic3RlcExhYmVsc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgndmFsdWUnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXHJcbiAgICBdLCBNYnNjU2xpZGVyLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCBudWxsKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1NsaWRlci5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgndmFsdWVDaGFuZ2UnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY1NsaWRlci5wcm90b3R5cGUsIFwib25DaGFuZ2VFbWl0dGVyXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBWaWV3Q2hpbGRyZW4oJ2lucHV0RWxlbWVudHMnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxyXG4gICAgXSwgTWJzY1NsaWRlci5wcm90b3R5cGUsIFwiaW5wdXRFbGVtZW50c1wiLCB2b2lkIDApO1xyXG4gICAgTWJzY1NsaWRlciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1zbGlkZXInLFxyXG4gICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYnNjLWNvbnRyb2wtbmcnIH0sXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIlxcbiAgICAgICAgPGxhYmVsIFtuZ0NsYXNzXT1cXFwiY29sb3JDbGFzc1xcXCI+XFxuICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxcbiAgICAgICAgICAgIDxpbnB1dCAjaW5wdXRFbGVtZW50cyAqbmdGb3I9XFxcImxldCB2IG9mIGR1bW15QXJyYXlcXFwiIFxcbiAgICAgICAgICAgICAgICB0eXBlPVxcXCJyYW5nZVxcXCJcXG4gICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cXFwiZGlzYWJsZWRcXFwiXFxuICAgICAgICAgICAgICAgIFthdHRyLnZhbHVlXT1cXFwiZHVtbXlBcnJheS5sZW5ndGggPiAxICYmIGluaXRpYWxWYWx1ZSA/IGluaXRpYWxWYWx1ZVt2XTogaW5pdGlhbFZhbHVlXFxcIlxcbiAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLXN0ZXAtbGFiZWxzXT1cXFwiZGF0YVN0ZXBMYWJlbHNcXFwiXFxuICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtdGVtcGxhdGVdPVxcXCJ2YWx1ZVRlbXBsYXRlXFxcIlxcbiAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLXRvb2x0aXBdPVxcXCJ0b29sdGlwID8gJ3RydWUnIDogbnVsbFxcXCJcXG4gICAgICAgICAgICAgICAgW2F0dHIuZGF0YS1oaWdobGlnaHRdPVxcXCJoaWdobGlnaHRcXFwiXFxuICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtbGl2ZV09XFxcImxpdmVcXFwiXFxuICAgICAgICAgICAgICAgIFthdHRyLmRhdGEtaWNvbl09XFxcImljb24gPyBpY29uIDogbnVsbFxcXCJcXG4gICAgICAgICAgICAgICAgW2F0dHIuZGF0YS12YWxdPVxcXCJ2YWwgPyB2YWwgOiBudWxsXFxcIlxcbiAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLWxhYmVsLXN0eWxlXT1cXFwibGFiZWxTdHlsZVxcXCJcXG4gICAgICAgICAgICAgICAgW2F0dHIuZGF0YS1pbnB1dC1zdHlsZV09XFxcImlucHV0U3R5bGVcXFwiXFxuICAgICAgICAgICAgICAgIFthdHRyLm5hbWVdPVxcXCJuYW1lXFxcIlxcbiAgICAgICAgICAgICAgICBbYXR0ci5tYXhdPVxcXCJtYXggIT09IHVuZGVmaW5lZCA/IG1heCA6IG51bGxcXFwiXFxuICAgICAgICAgICAgICAgIFthdHRyLm1pbl09XFxcIm1pbiAhPT0gdW5kZWZpbmVkID8gbWluIDogbnVsbFxcXCJcXG4gICAgICAgICAgICAgICAgW2F0dHIuc3RlcF09XFxcInN0ZXAgIT09IHVuZGVmaW5lZCA/IHN0ZXAgOiBudWxsXFxcIlxcbiAgICAgICAgICAgICAgICAoYmx1cik9XFxcIm9uVG91Y2goJGV2ZW50KVxcXCIgLz5cXG4gICAgICAgIDwvbGFiZWw+XFxuICAgIFwiLFxyXG4gICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgxLCBPcHRpb25hbCgpKSwgX19wYXJhbSgzLCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE1ic2NPcHRpb25zU2VydmljZSwgTmdab25lLCBOZ0NvbnRyb2xdKVxyXG4gICAgXSwgTWJzY1NsaWRlcik7XHJcbiAgICByZXR1cm4gTWJzY1NsaWRlcjtcclxufShNYnNjQ29udHJvbEJhc2UpKTtcclxudmFyIE1ic2NSYXRpbmcgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NSYXRpbmcsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjUmF0aW5nKGhvc3RFbGVtLCB6b25lLCBmb3JtU2VydmljZSwgY29udHJvbCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGhvc3RFbGVtLCB6b25lLCBjb250cm9sLCBudWxsLCBudWxsKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmZvcm1TZXJ2aWNlID0gZm9ybVNlcnZpY2U7XHJcbiAgICAgICAgX3RoaXMubWluID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIF90aGlzLm1heCA9IHVuZGVmaW5lZDtcclxuICAgICAgICBfdGhpcy5zdGVwID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIF90aGlzLmRpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMudmFsID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5fY29sb3JDbGFzcyA9IHt9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjUmF0aW5nLnByb3RvdHlwZSwgXCJyZWFkb25seVwiLCB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlYWRvbmx5ID0gZW1wdHlPclRydWUodmFsKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjUmF0aW5nLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB0aGlzLnNldE5ld1ZhbHVlUHJveHkodik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY1JhdGluZy5wcm90b3R5cGUsIFwiY29sb3JDbGFzc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gdGhpcy5fY29sb3JDbGFzcykge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NvbG9yQ2xhc3Nba107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbG9yQ2xhc3NbJ21ic2MtcmF0aW5nLScgKyB0aGlzLmNvbG9yXSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yQ2xhc3M7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBNYnNjUmF0aW5nLnByb3RvdHlwZS5zZXROZXdWYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UuZ2V0VmFsKCkgIT09IHYpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0VmFsKHYsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNYnNjUmF0aW5nLnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9pbmhlcml0ZWRPcHRpb25zID0gdGhpcy5mb3JtU2VydmljZSA/IHRoaXMuZm9ybVNlcnZpY2Uub3B0aW9ucyA6IHt9O1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdPbkluaXQuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICBNYnNjUmF0aW5nLnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHt9LCB0aGlzLl9pbmhlcml0ZWRPcHRpb25zLCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaik7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBSYXRpbmcodGhpcy5lbGVtZW50LCBvcHRpb25zKTtcclxuICAgICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNldFZhbCh0aGlzLmluaXRpYWxWYWx1ZSwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NSYXRpbmcucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1JhdGluZy5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBNYnNjUmF0aW5nLnByb3RvdHlwZSwgXCJtaW5cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgTWJzY1JhdGluZy5wcm90b3R5cGUsIFwibWF4XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIE1ic2NSYXRpbmcucHJvdG90eXBlLCBcInN0ZXBcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NSYXRpbmcucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NSYXRpbmcucHJvdG90eXBlLCBcImVtcHR5XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NSYXRpbmcucHJvdG90eXBlLCBcImZpbGxlZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcclxuICAgIF0sIE1ic2NSYXRpbmcucHJvdG90eXBlLCBcInJlYWRvbmx5XCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjUmF0aW5nLnByb3RvdHlwZSwgXCJ2YWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1JhdGluZy5wcm90b3R5cGUsIFwidGVtcGxhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ3ZhbHVlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOdW1iZXJdKVxyXG4gICAgXSwgTWJzY1JhdGluZy5wcm90b3R5cGUsIFwidmFsdWVcIiwgbnVsbCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoJ3ZhbHVlQ2hhbmdlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NSYXRpbmcucHJvdG90eXBlLCBcIm9uQ2hhbmdlRW1pdHRlclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjUmF0aW5nLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xyXG4gICAgTWJzY1JhdGluZyA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1yYXRpbmcnLFxyXG4gICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYnNjLWNvbnRyb2wtbmcnIH0sXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxsYWJlbCBbbmdDbGFzc109XFxcImNvbG9yQ2xhc3NcXFwiPlxcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxcbiAgICAgICAgPGlucHV0IHR5cGU9XFxcInJhdGluZ1xcXCIgZGF0YS1yb2xlPVxcXCJyYXRpbmdcXFwiIFxcbiAgICAgICAgICAgIFthdHRyLm5hbWVdPVxcXCJuYW1lXFxcIlxcbiAgICAgICAgICAgIFthdHRyLm1pbl09XFxcIm1pbiAhPT0gdW5kZWZpbmVkID8gbWluIDogbnVsbFxcXCJcXG4gICAgICAgICAgICBbYXR0ci5tYXhdPVxcXCJtYXggIT09IHVuZGVmaW5lZCA/IG1heCA6IG51bGxcXFwiXFxuICAgICAgICAgICAgW2F0dHIuc3RlcF09XFxcInN0ZXAgIT09IHVuZGVmaW5lZCA/IHN0ZXAgOiBudWxsXFxcIlxcbiAgICAgICAgICAgIFthdHRyLmRhdGEtdmFsXT1cXFwidmFsID8gdmFsIDogbnVsbFxcXCJcXG4gICAgICAgICAgICBbYXR0ci5kYXRhLXRlbXBsYXRlXT1cXFwidGVtcGxhdGUgPyB0ZW1wbGF0ZSA6IG51bGxcXFwiXFxuICAgICAgICAgICAgW2F0dHIuZGF0YS1lbXB0eV09XFxcImVtcHR5XFxcIlxcbiAgICAgICAgICAgIFthdHRyLmRhdGEtZmlsbGVkXT1cXFwiZmlsbGVkXFxcIlxcbiAgICAgICAgICAgIFthdHRyLmRhdGEtbGFiZWwtc3R5bGVdPVxcXCJsYWJlbFN0eWxlXFxcIlxcbiAgICAgICAgICAgIFthdHRyLmRhdGEtaW5wdXQtc3R5bGVdPVxcXCJpbnB1dFN0eWxlXFxcIlxcbiAgICAgICAgICAgIFtkaXNhYmxlZF09XFxcImRpc2FibGVkXFxcIlxcbiAgICAgICAgICAgIFtyZWFkb25seV09XFxcIl9yZWFkb25seVxcXCJcXG4gICAgICAgICAgICAoYmx1cik9XFxcIm9uVG91Y2goJGV2ZW50KVxcXCIgLz5cXG4gICAgPC9sYWJlbD5cIlxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMiwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBOZ1pvbmUsIE1ic2NPcHRpb25zU2VydmljZSwgTmdDb250cm9sXSlcclxuICAgIF0sIE1ic2NSYXRpbmcpO1xyXG4gICAgcmV0dXJuIE1ic2NSYXRpbmc7XHJcbn0oTWJzY0NvbnRyb2xCYXNlKSk7XHJcbnZhciBNYnNjRm9ybUdyb3VwID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1ic2NGb3JtR3JvdXAoaW5pdGlhbEVsZW0pIHtcclxuICAgICAgICB0aGlzLmluaXRpYWxFbGVtID0gaW5pdGlhbEVsZW07XHJcbiAgICAgICAgdGhpcy5jb2xsYXBzaWJsZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fb3BlbiA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gaW5pdGlhbEVsZW07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY0Zvcm1Hcm91cC5wcm90b3R5cGUsIFwib3BlblwiLCB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fb3BlbiAhPSB2ICYmIHRoaXMuaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlLmhpZGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9vcGVuID0gdjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE1ic2NGb3JtR3JvdXAucHJvdG90eXBlLmVtcHR5T3JUcnVlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICByZXR1cm4gZW1wdHlPclRydWUodik7XHJcbiAgICB9O1xyXG4gICAgTWJzY0Zvcm1Hcm91cC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbGxhcHNpYmxlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgQ29sbGFwc2libGVCYXNlKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCB7IGlzT3BlbjogdGhpcy5fb3BlbiAhPT0gZmFsc2UgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1ic2NGb3JtR3JvdXAucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NGb3JtR3JvdXAucHJvdG90eXBlLCBcImNvbGxhcHNpYmxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXHJcbiAgICBdLCBNYnNjRm9ybUdyb3VwLnByb3RvdHlwZSwgXCJvcGVuXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjRm9ybUdyb3VwLnByb3RvdHlwZSwgXCJpbnNldFwiLCB2b2lkIDApO1xyXG4gICAgTWJzY0Zvcm1Hcm91cCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1mb3JtLWdyb3VwJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcclxuICAgICAgICAgICAgaG9zdDoge1xyXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYnNjLWZvcm0tZ3JvdXAtaW5zZXRdJzogJ2VtcHR5T3JUcnVlKGluc2V0KScsXHJcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1ic2MtZm9ybS1ncm91cF0nOiAnIWVtcHR5T3JUcnVlKGluc2V0KSdcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGVzOiBbJzpob3N0IHsgZGlzcGxheTogYmxvY2s7IH0nXVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZl0pXHJcbiAgICBdLCBNYnNjRm9ybUdyb3VwKTtcclxuICAgIHJldHVybiBNYnNjRm9ybUdyb3VwO1xyXG59KCkpO1xyXG52YXIgTWJzY0Zvcm1Hcm91cFRpdGxlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1ic2NGb3JtR3JvdXBUaXRsZSgpIHtcclxuICAgIH1cclxuICAgIE1ic2NGb3JtR3JvdXBUaXRsZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1mb3JtLWdyb3VwLXRpdGxlJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcclxuICAgICAgICAgICAgaG9zdDoge1xyXG4gICAgICAgICAgICAgICAgJ1tjbGFzcy5tYnNjLWZvcm0tZ3JvdXAtdGl0bGVdJzogJ3RydWUnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlczogWyc6aG9zdCB7IGRpc3BsYXk6IGJsb2NrOyB9J11cclxuICAgICAgICB9KVxyXG4gICAgXSwgTWJzY0Zvcm1Hcm91cFRpdGxlKTtcclxuICAgIHJldHVybiBNYnNjRm9ybUdyb3VwVGl0bGU7XHJcbn0oKSk7XHJcbnZhciBNYnNjRm9ybUdyb3VwQ29udGVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNYnNjRm9ybUdyb3VwQ29udGVudCgpIHtcclxuICAgIH1cclxuICAgIE1ic2NGb3JtR3JvdXBDb250ZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLWZvcm0tZ3JvdXAtY29udGVudCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXHJcbiAgICAgICAgICAgIGhvc3Q6IHtcclxuICAgICAgICAgICAgICAgICdbY2xhc3MubWJzYy1mb3JtLWdyb3VwLWNvbnRlbnRdJzogJ3RydWUnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlczogWyc6aG9zdCB7IGRpc3BsYXk6IGJsb2NrOyB9J11cclxuICAgICAgICB9KVxyXG4gICAgXSwgTWJzY0Zvcm1Hcm91cENvbnRlbnQpO1xyXG4gICAgcmV0dXJuIE1ic2NGb3JtR3JvdXBDb250ZW50O1xyXG59KCkpO1xyXG52YXIgTWJzY0FjY29yZGlvbiA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNYnNjQWNjb3JkaW9uKCkge1xyXG4gICAgfVxyXG4gICAgTWJzY0FjY29yZGlvbiA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1hY2NvcmRpb24nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxyXG4gICAgICAgICAgICBob3N0OiB7XHJcbiAgICAgICAgICAgICAgICAnW2NsYXNzLm1ic2MtYWNjb3JkaW9uXSc6ICd0cnVlJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZXM6IFsnOmhvc3QgeyBkaXNwbGF5OiBibG9jazsgfSddXHJcbiAgICAgICAgfSlcclxuICAgIF0sIE1ic2NBY2NvcmRpb24pO1xyXG4gICAgcmV0dXJuIE1ic2NBY2NvcmRpb247XHJcbn0oKSk7XHJcbnZhciBjb21wJDMgPSBbXHJcbiAgICBNYnNjRm9ybSxcclxuICAgIE1ic2NUZXh0YXJlYSxcclxuICAgIE1ic2NEcm9wZG93bixcclxuICAgIE1ic2NCdXR0b24sXHJcbiAgICBNYnNjQ2hlY2tib3gsXHJcbiAgICBNYnNjU3dpdGNoLFxyXG4gICAgTWJzY1N0ZXBwZXIsXHJcbiAgICBNYnNjUHJvZ3Jlc3MsXHJcbiAgICBNYnNjUmFkaW9Hcm91cCxcclxuICAgIE1ic2NSYWRpb0dyb3VwQmFzZSxcclxuICAgIE1ic2NSYWRpbyxcclxuICAgIE1ic2NTZWdtZW50ZWRHcm91cCxcclxuICAgIE1ic2NTZWdtZW50ZWQsXHJcbiAgICBNYnNjU2xpZGVyLFxyXG4gICAgTWJzY1JhdGluZyxcclxuICAgIE1ic2NGb3JtR3JvdXAsXHJcbiAgICBNYnNjRm9ybUdyb3VwVGl0bGUsXHJcbiAgICBNYnNjRm9ybUdyb3VwQ29udGVudCxcclxuICAgIE1ic2NBY2NvcmRpb25cclxuXTtcclxudmFyIE1ic2NGb3Jtc01vZHVsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNYnNjRm9ybXNNb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBNYnNjRm9ybXNNb2R1bGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBOZ01vZHVsZSh7XHJcbiAgICAgICAgICAgIGltcG9ydHM6IFtGb3Jtc01vZHVsZSwgQ29tbW9uTW9kdWxlLCBNYnNjQmFzZU1vZHVsZSwgTWJzY0lucHV0TW9kdWxlXSxcclxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBjb21wJDMsXHJcbiAgICAgICAgICAgIGV4cG9ydHM6IFtjb21wJDMsIE1ic2NJbnB1dE1vZHVsZSwgTWJzY0lucHV0XVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBNYnNjRm9ybXNNb2R1bGUpO1xyXG4gICAgcmV0dXJuIE1ic2NGb3Jtc01vZHVsZTtcclxufSgpKTtcblxudmFyIGRlZmF1bHRzJDUgPSB7XG4gIGludmFsaWQ6IFtdLFxuICBzaG93SW5wdXQ6IHRydWUsXG4gIGlucHV0Q2xhc3M6ICcnLFxuICBpdGVtU2VsZWN0b3I6ICdsaSdcbn07XG52YXIgTGlzdCA9IGZ1bmN0aW9uIExpc3QoaW5zdCkge1xuICB2YXIgY3VyckxldmVsLFxuICAgICAgaW5wdXQsXG4gICAgICBwcmV2ZW50LFxuICAgICAgdyxcbiAgICAgIG9yaWcgPSBleHRlbmQkMSh7fSwgaW5zdC5zZXR0aW5ncyksXG4gICAgICBzID0gZXh0ZW5kJDEoaW5zdC5zZXR0aW5ncywgZGVmYXVsdHMkNSwgb3JpZyksXG4gICAgICBsYXlvdXQgPSBzLmxheW91dCB8fCAoL3RvcHxib3R0b20vLnRlc3Qocy5kaXNwbGF5KSA/ICdsaXF1aWQnIDogJycpLFxuICAgICAgaXNMaXF1aWQgPSBsYXlvdXQgPT0gJ2xpcXVpZCcsXG4gICAgICBvcmlnUmVhZE9ubHkgPSBzLnJlYWRvbmx5LFxuICAgICAgZWxtID0gJCQxKHRoaXMpLFxuICAgICAgaWQgPSB0aGlzLmlkICsgJ19kdW1teScsXG4gICAgICBsdmwgPSAwLFxuICAgICAgY3VycldoZWVsVmVjdG9yID0gW10sXG4gICAgICB3YSA9IHMud2hlZWxBcnJheSB8fCBjcmVhdGVXaGVlbEFycmF5KGVsbSksXG4gICAgICBmd3YgPSBmaXJzdFdoZWVsVmVjdG9yKHdhKTtcblxuICBmdW5jdGlvbiBnZXREZXB0aCh0cmVlLCBsKSB7XG4gICAgdmFyIGk7XG4gICAgbHZsID0gbCA+IGx2bCA/IGwgOiBsdmw7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyZWVbaV0uY2hpbGRyZW4pIHtcbiAgICAgICAgZ2V0RGVwdGgodHJlZVtpXS5jaGlsZHJlbiwgbCArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBEaXNhYmxlcyB0aGUgaW52YWxpZCBpdGVtcyBvbiB0aGUgd2hlZWxzXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGR3IC0gdGhlIGpRdWVyeSBtb2Jpc2Nyb2xsIG9iamVjdFxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBucldoZWVscyAtIHRoZSBudW1iZXIgb2YgdGhlIGN1cnJlbnQgd2hlZWxzXHJcbiAgICogQHBhcmFtIHtBcnJheX0gd2hBcnJheSAtIFRoZSB3aGVlbCBhcnJheSBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIHdoZWVsIHRyZWVcclxuICAgKiBAcGFyYW0ge0FycmF5fSB3aFZlY3RvciAtIHRoZSB3aGVlbCB2ZWN0b3IgY29udGFpbmluZyB0aGUgY3VycmVudCBrZXlzXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXREaXNhYmxlZChucldoZWVscywgd2hBcnJheSwgd2hWZWN0b3IpIHtcbiAgICB2YXIgaSA9IDAsXG4gICAgICAgIGRpc2FibGVkID0gW107XG5cbiAgICB3aGlsZSAoaSA8IG5yV2hlZWxzKSB7XG4gICAgICBkaXNhYmxlZFtpXSA9IGdldEludmFsaWRLZXlzKHdoVmVjdG9yLCBpLCB3aEFycmF5KTtcbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4gZGlzYWJsZWQ7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgaW52YWxpZCBrZXlzIG9mIG9uZSB3aGVlbCBhcyBhbiBhcnJheVxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IHdoVmVjdG9yIC0gdGhlIHdoZWVsIHZlY3RvciB1c2VkIHRvIHNlYXJjaCBmb3IgdGhlIHdoZWVsIGluIHRoZSB3aGVlbCBhcnJheVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIGluZGV4IG9mIHRoZSB3aGVlbCBpbiB0aGUgd2hlZWwgdmVjdG9yLCB0aGF0IHdlIGFyZSBpbnRlcmVzdGVkIGluXHJcbiAgICogQHBhcmFtIHtBcnJheX0gd2hBcnJheSAtIHRoZSB3aGVlbCBhcnJheSB3ZSBhcmUgc2VhcmNoaW5nIGluXHJcbiAgICogQHJldHVybiB7QXJyYXl9IC0gbGlzdCBvZiBpbnZhbGlkIGtleXNcclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldEludmFsaWRLZXlzKHdoVmVjdG9yLCBpbmRleCwgd2hBcnJheSkge1xuICAgIHZhciBpID0gMCxcbiAgICAgICAgbixcbiAgICAgICAgd2hPYmpBID0gd2hBcnJheSxcbiAgICAgICAgaW52YWxpZHMgPSBbXTtcblxuICAgIHdoaWxlIChpIDwgaW5kZXgpIHtcbiAgICAgIHZhciBpaSA9IHdoVmVjdG9yW2ldO1xuXG4gICAgICBmb3IgKG4gaW4gd2hPYmpBKSB7XG4gICAgICAgIGlmICh3aE9iakFbbl0ua2V5ID09IGlpKSB7XG4gICAgICAgICAgd2hPYmpBID0gd2hPYmpBW25dLmNoaWxkcmVuO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgd2hPYmpBLmxlbmd0aCkge1xuICAgICAgaWYgKHdoT2JqQVtpXS5pbnZhbGlkKSB7XG4gICAgICAgIGludmFsaWRzLnB1c2god2hPYmpBW2ldLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGkrKztcbiAgICB9XG5cbiAgICByZXR1cm4gaW52YWxpZHM7XG4gIH1cbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIEJvb2xlYW4gdmVjdG9yIHdpdGggdHJ1ZSB2YWx1ZXMgKGV4Y2VwdCBvbmUpIHRoYXQgY2FuIGJlIHVzZWQgYXMgdGhlIHJlYWRvbmx5IHZlY3RvclxyXG4gICAqIG4gLSB0aGUgbGVuZ3RoIG9mIHRoZSB2ZWN0b3JcclxuICAgKiBpIC0gdGhlIGluZGV4IG9mIHRoZSB2YWx1ZSB0aGF0J3MgZ29pbmcgdG8gYmUgZmFsc2VcclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJPVmVjdG9yKG4sIGkpIHtcbiAgICB2YXIgYSA9IFtdO1xuXG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGFbLS1uXSA9IHRydWU7XG4gICAgfVxuXG4gICAgYVtpXSA9IGZhbHNlO1xuICAgIHJldHVybiBhO1xuICB9XG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgdGhlIHdoZWVsIGFycmF5IGZyb20gdGhlIHZlY3RvciBwcm92aWRlZFxyXG4gICAqIHd2IC0gd2hlZWwgdmVjdG9yIGNvbnRhaW5pbmcgdGhlIHZhbHVlcyB0aGF0IHNob3VsZCBiZSBzZWxlY3RlZCBvbiB0aGUgd2hlZWxzXHJcbiAgICogbCAtIHRoZSBsZW5ndGggb2YgdGhlIHdoZWVsIGFycmF5XHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBnZW5lcmF0ZVdoZWVsc0Zyb21WZWN0b3Iod3YsIGwsIGluZGV4KSB7XG4gICAgdmFyIG5leHRMZXZlbCxcbiAgICAgICAgaixcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGhhc0NoaWxkcmVuID0gdHJ1ZSxcbiAgICAgICAgdyA9IFtbXV0sXG4gICAgICAgIHd0T2JqQSA9IHdhO1xuXG4gICAgaWYgKGwpIHtcbiAgICAgIC8vIGlmIGxlbmd0aCBpcyBkZWZpbmVkIHdlIG5lZWQgdG8gZ2VuZXJhdGUgdGhhdCBtYW55IHdoZWVscyAoZXZlbiBpZiB0aGV5IGFyZSBlbXB0eSlcbiAgICAgIGZvciAoaiA9IDA7IGogPCBsOyBqKyspIHtcbiAgICAgICAgaWYgKGlzTGlxdWlkKSB7XG4gICAgICAgICAgd1swXVtqXSA9IHt9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdbal0gPSBbe31dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUgKGhhc0NoaWxkcmVuKSB7XG4gICAgICBpZiAoaXNMaXF1aWQpIHtcbiAgICAgICAgd1swXVtpXSA9IGdldFdoZWVsRnJvbU9iakEod3RPYmpBLCBpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdbaV0gPSBbZ2V0V2hlZWxGcm9tT2JqQSh3dE9iakEsIGkpXTtcbiAgICAgIH1cblxuICAgICAgaiA9IDA7XG4gICAgICBuZXh0TGV2ZWwgPSBudWxsO1xuXG4gICAgICB3aGlsZSAoaiA8IHd0T2JqQS5sZW5ndGggJiYgIW5leHRMZXZlbCkge1xuICAgICAgICBpZiAod3RPYmpBW2pdLmtleSA9PSB3dltpXSAmJiAoaW5kZXggIT09IHVuZGVmaW5lZCAmJiBpIDw9IGluZGV4IHx8IGluZGV4ID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgbmV4dExldmVsID0gd3RPYmpBW2pdO1xuICAgICAgICB9XG5cbiAgICAgICAgaisrO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW5leHRMZXZlbCkge1xuICAgICAgICBuZXh0TGV2ZWwgPSBnZXRGaXJzdFZhbGlkSXRlbU9iak9ySW5kKHd0T2JqQSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0TGV2ZWwgJiYgbmV4dExldmVsLmNoaWxkcmVuKSB7XG4gICAgICAgIHd0T2JqQSA9IG5leHRMZXZlbC5jaGlsZHJlbjtcbiAgICAgICAgaSsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFzQ2hpbGRyZW4gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdztcbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCB2YWxpZCBXaGVlbCBOb2RlIE9iamVjdCBvciBpdHMgaW5kZXggZnJvbSBhIFdoZWVsIE5vZGUgT2JqZWN0IEFycmF5XHJcbiAgICogZ2V0SW5kIC0gaWYgaXQgaXMgdHJ1ZSB0aGVuIHRoZSByZXR1cm4gdmFsdWUgaXMgZ29pbmcgdG8gYmUgdGhlIGluZGV4LCBvdGhlcndpc2UgdGhlIG9iamVjdCBpdHNlbGZcclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldEZpcnN0VmFsaWRJdGVtT2JqT3JJbmQod3RPYmpBLCBnZXRJbmQpIHtcbiAgICBpZiAoIXd0T2JqQSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpID0gMCxcbiAgICAgICAgb2JqO1xuXG4gICAgd2hpbGUgKGkgPCB3dE9iakEubGVuZ3RoKSB7XG4gICAgICBpZiAoIShvYmogPSB3dE9iakFbaSsrXSkuaW52YWxpZCkge1xuICAgICAgICByZXR1cm4gZ2V0SW5kID8gaSAtIDEgOiBvYmo7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0V2hlZWxGcm9tT2JqQShvYmpBLCBpKSB7XG4gICAgdmFyIHdoZWVsID0ge1xuICAgICAgZGF0YTogW10sXG4gICAgICBsYWJlbDogcy5sYWJlbHMgJiYgcy5sYWJlbHNbaV0gPyBzLmxhYmVsc1tpXSA6IGlcbiAgICB9LFxuICAgICAgICBqID0gMDtcblxuICAgIHdoaWxlIChqIDwgb2JqQS5sZW5ndGgpIHtcbiAgICAgIHdoZWVsLmRhdGEucHVzaCh7XG4gICAgICAgIHZhbHVlOiBvYmpBW2pdLmtleSxcbiAgICAgICAgZGlzcGxheTogb2JqQVtqXS52YWx1ZVxuICAgICAgfSk7XG4gICAgICBqKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdoZWVsO1xuICB9XG4gIC8qKlxyXG4gICAqIEhpZGVzIHRoZSBsYXN0IGkgbnVtYmVyIG9mIHdoZWVsc1xyXG4gICAqIGkgLSB0aGUgbGFzdCBudW1iZXIgb2Ygd2hlZWxzIHRoYXQgaGFzIHRvIGJlIGhpZGRlblxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaGlkZVdoZWVscyhpKSB7XG4gICAgaWYgKGluc3QuX2lzVmlzaWJsZSkge1xuICAgICAgJCQxKCcubWJzYy1zYy13aGwtdycsIGluc3QuX21hcmt1cCkuY3NzKCdkaXNwbGF5JywgJycpLnNsaWNlKGkpLmhpZGUoKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogR2VuZXJhdGVzIHRoZSBmaXJzdCB3aGVlbCB2ZWN0b3IgZnJvbSB0aGUgd2hlZWx0cmVlXHJcbiAgICogd3QgLSB0aGUgd2hlZWwgdHJlZSBvYmplY3RcclxuICAgKiB1c2VzIHRoZSBsdmwgZ2xvYmFsIHZhcmlhYmxlIHRvIGRldGVybWluZSB0aGUgbGVuZ3RoIG9mIHRoZSB2ZWN0b3JcclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGZpcnN0V2hlZWxWZWN0b3Iod2EpIHtcbiAgICB2YXIgdCA9IFtdLFxuICAgICAgICBuZE9iakEgPSB3YSxcbiAgICAgICAgb2JqLFxuICAgICAgICBvayA9IHRydWUsXG4gICAgICAgIGkgPSAwO1xuXG4gICAgd2hpbGUgKG9rKSB7XG4gICAgICBvYmogPSBnZXRGaXJzdFZhbGlkSXRlbU9iak9ySW5kKG5kT2JqQSk7XG4gICAgICB0W2krK10gPSBvYmoua2V5O1xuICAgICAgb2sgPSBvYmouY2hpbGRyZW47XG5cbiAgICAgIGlmIChvaykge1xuICAgICAgICBuZE9iakEgPSBvaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbiAgfVxuICAvKipcclxuICAgKiBDYWxjdWxhdGVzIHRoZSBsZXZlbCBvZiBhIHdoZWVsIHZlY3RvciBhbmQgdGhlIG5ldyB3aGVlbCB2ZWN0b3IsIGRlcGVuZGluZyBvbiBjdXJyZW50IHdoZWVsIHZlY3RvciBhbmQgdGhlIGluZGV4IG9mIHRoZSBjaGFuZ2VkIHdoZWVsXHJcbiAgICogd3YgLSBjdXJyZW50IHdoZWVsIHZlY3RvclxyXG4gICAqIGluZGV4IC0gaW5kZXggb2YgdGhlIGNoYW5nZWQgd2hlZWxcclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGNhbGNMZXZlbE9mVmVjdG9yMih3diwgaW5kZXgpIHtcbiAgICB2YXIgY2hpbGRJZHgsXG4gICAgICAgIGNoaWxkTmFtZSxcbiAgICAgICAgaSxcbiAgICAgICAgbGV2ZWwgPSAwLFxuICAgICAgICBuZE9iakEgPSB3YSxcbiAgICAgICAgbmV4dCA9IHRydWUsXG4gICAgICAgIHQgPSBbXTtcblxuICAgIHdoaWxlIChuZXh0KSB7XG4gICAgICBpZiAod3ZbbGV2ZWxdICE9PSB1bmRlZmluZWQgJiYgbGV2ZWwgPD0gaW5kZXgpIHtcbiAgICAgICAgaSA9IDA7XG4gICAgICAgIGNoaWxkTmFtZSA9IHd2W2xldmVsXTtcbiAgICAgICAgY2hpbGRJZHggPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBuZE9iakEubGVuZ3RoICYmIGNoaWxkSWR4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAobmRPYmpBW2ldLmtleSA9PSB3dltsZXZlbF0gJiYgIW5kT2JqQVtpXS5pbnZhbGlkKSB7XG4gICAgICAgICAgICBjaGlsZElkeCA9IGk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZElkeCA9IGdldEZpcnN0VmFsaWRJdGVtT2JqT3JJbmQobmRPYmpBLCB0cnVlKTtcbiAgICAgICAgY2hpbGROYW1lID0gbmRPYmpBW2NoaWxkSWR4XSAmJiBuZE9iakFbY2hpbGRJZHhdLmtleTtcbiAgICAgIH1cblxuICAgICAgdFtsZXZlbF0gPSBjaGlsZE5hbWU7XG4gICAgICBsZXZlbCsrO1xuICAgICAgbmV4dCA9IG5kT2JqQVtjaGlsZElkeF0gPyBuZE9iakFbY2hpbGRJZHhdLmNoaWxkcmVuIDogZmFsc2U7XG4gICAgICBuZE9iakEgPSBuZE9iakFbY2hpbGRJZHhdICYmIG5kT2JqQVtjaGlsZElkeF0uY2hpbGRyZW47XG4gICAgfSAvLyByZXR1cm4gdGhlIGNhbGN1bGF0ZWQgbGV2ZWwgYW5kIHRoZSB3aGVlbCB2ZWN0b3IgYXMgYW4gb2JqZWN0XG5cblxuICAgIHJldHVybiB7XG4gICAgICBsdmw6IGxldmVsLFxuICAgICAgblZlY3RvcjogdFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVXaGVlbEFycmF5KHVsKSB7XG4gICAgdmFyIHdoZWVsQXJyYXkgPSBbXTtcbiAgICB2YXIgY2hpbGRyZW4gPSB1bC5sZW5ndGggPiAxID8gdWwgOiB1bC5jaGlsZHJlbihzLml0ZW1TZWxlY3Rvcik7XG4gICAgY2hpbGRyZW4uZWFjaChmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgIHZhciB0aGF0ID0gJCQxKHRoaXMpLFxuICAgICAgICAgIGMgPSB0aGF0LmNsb25lKCk7XG4gICAgICBjLmNoaWxkcmVuKCd1bCxvbCcpLnJlbW92ZSgpO1xuICAgICAgYy5jaGlsZHJlbihzLml0ZW1TZWxlY3RvcikucmVtb3ZlKCk7XG4gICAgICB2YXIgdiA9IGluc3QuX3Byb2Nlc3NNYXJrdXAgPyBpbnN0Ll9wcm9jZXNzTWFya3VwKGMpIDogYy5odG1sKCkucmVwbGFjZSgvXlxcc1xccyovLCAnJykucmVwbGFjZSgvXFxzXFxzKiQvLCAnJyksXG4gICAgICAgICAgaW52ID0gdGhhdC5hdHRyKCdkYXRhLWludmFsaWQnKSA/IHRydWUgOiBmYWxzZSxcbiAgICAgICAgICB3aGVlbE9iaiA9IHtcbiAgICAgICAga2V5OiB0aGF0LmF0dHIoJ2RhdGEtdmFsJykgPT09IHVuZGVmaW5lZCB8fCB0aGF0LmF0dHIoJ2RhdGEtdmFsJykgPT09IG51bGwgPyBpbmRleCA6IHRoYXQuYXR0cignZGF0YS12YWwnKSxcbiAgICAgICAgdmFsdWU6IHYsXG4gICAgICAgIGludmFsaWQ6IGludixcbiAgICAgICAgY2hpbGRyZW46IG51bGxcbiAgICAgIH0sXG4gICAgICAgICAgbmVzdCA9IHMuaXRlbVNlbGVjdG9yID09PSAnbGknID8gdGhhdC5jaGlsZHJlbigndWwsb2wnKSA6IHRoYXQuY2hpbGRyZW4ocy5pdGVtU2VsZWN0b3IpO1xuXG4gICAgICBpZiAobmVzdC5sZW5ndGgpIHtcbiAgICAgICAgd2hlZWxPYmouY2hpbGRyZW4gPSBjcmVhdGVXaGVlbEFycmF5KG5lc3QpO1xuICAgICAgfVxuXG4gICAgICB3aGVlbEFycmF5LnB1c2god2hlZWxPYmopO1xuICAgIH0pO1xuICAgIHJldHVybiB3aGVlbEFycmF5O1xuICB9XG5cbiAgZnVuY3Rpb24gY2hhbmdlV2hlZWxzKHZhbHVlcywgaW5kZXgsIG8pIHtcbiAgICB2YXIgaixcbiAgICAgICAgaSA9IChpbmRleCB8fCAwKSArIDEsXG4gICAgICAgIGFyZ3MgPSBbXSxcbiAgICAgICAgdyA9IHt9LFxuICAgICAgICB3aGVlbHMgPSB7fTtcbiAgICB3ID0gZ2VuZXJhdGVXaGVlbHNGcm9tVmVjdG9yKHZhbHVlcywgbnVsbCwgaW5kZXgpO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgaW5zdC5fdGVtcFdoZWVsQXJyYXlbal0gPSB2YWx1ZXNbal0gPSBvLm5WZWN0b3Jbal0gfHwgMDtcbiAgICB9XG5cbiAgICB3aGlsZSAoaSA8IG8ubHZsKSB7XG4gICAgICB3aGVlbHNbaV0gPSBpc0xpcXVpZCA/IHdbMF1baV0gOiB3W2ldWzBdO1xuICAgICAgYXJncy5wdXNoKGkrKyk7XG4gICAgfVxuXG4gICAgaGlkZVdoZWVscyhvLmx2bCk7XG4gICAgY3VycldoZWVsVmVjdG9yID0gdmFsdWVzLnNsaWNlKDApO1xuXG4gICAgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBwcmV2ZW50ID0gdHJ1ZTtcbiAgICAgIGluc3QuY2hhbmdlV2hlZWwod2hlZWxzKTtcbiAgICB9XG4gIH0gLy8gQ2FsY3VsYXRlIHRoZSBtYXhpbXVtIGRlcHRoIG9mIHRoZSB0cmVlXG5cblxuICBnZXREZXB0aCh3YSwgMSk7XG4gIHcgPSBnZW5lcmF0ZVdoZWVsc0Zyb21WZWN0b3IoZnd2LCBsdmwpOyAvLyBSZW1vdmUgaW5wdXQgaWYgZXhpc3RzXG5cbiAgJCQxKCcjJyArIGlkKS5yZW1vdmUoKTtcblxuICBpZiAocy5pbnB1dCkge1xuICAgIGlucHV0ID0gJCQxKHMuaW5wdXQpO1xuICB9IGVsc2UgaWYgKHMuc2hvd0lucHV0KSB7XG4gICAgaW5wdXQgPSAkJDEoJzxpbnB1dCB0eXBlPVwidGV4dFwiIGlkPVwiJyArIGlkICsgJ1wiIHZhbHVlPVwiXCIgY2xhc3M9XCInICsgcy5pbnB1dENsYXNzICsgJ1wiIHBsYWNlaG9sZGVyPVwiJyArIChzLnBsYWNlaG9sZGVyIHx8ICcnKSArICdcIiByZWFkb25seSAvPicpLmluc2VydEJlZm9yZShlbG0pO1xuICB9XG5cbiAgaWYgKGlucHV0KSB7XG4gICAgaW5zdC5hdHRhY2hTaG93KGlucHV0KTtcbiAgfVxuXG4gIGlmICghcy53aGVlbEFycmF5KSB7XG4gICAgZWxtLmhpZGUoKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2hlZWxzOiB3LFxuICAgIGFuY2hvcjogaW5wdXQsXG4gICAgbGF5b3V0OiBsYXlvdXQsXG4gICAgaGVhZGVyVGV4dDogZmFsc2UsXG4gICAgc2V0T25UYXA6IGx2bCA9PSAxLFxuICAgIGZvcm1hdFZhbHVlOiBmdW5jdGlvbiBmb3JtYXRWYWx1ZShkKSB7XG4gICAgICBpZiAoY3VyckxldmVsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3VyckxldmVsID0gY2FsY0xldmVsT2ZWZWN0b3IyKGQsIGQubGVuZ3RoKS5sdmw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkLnNsaWNlKDAsIGN1cnJMZXZlbCkuam9pbignICcpO1xuICAgIH0sXG4gICAgcGFyc2VWYWx1ZTogZnVuY3Rpb24gcGFyc2VWYWx1ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID8gKHZhbHVlICsgJycpLnNwbGl0KCcgJykgOiAocy5kZWZhdWx0VmFsdWUgfHwgZnd2KS5zbGljZSgwKTtcbiAgICB9LFxuICAgIG9uQmVmb3JlU2hvdzogZnVuY3Rpb24gb25CZWZvcmVTaG93KCkge1xuICAgICAgdmFyIHQgPSBpbnN0LmdldEFycmF5VmFsKHRydWUpO1xuICAgICAgY3VycldoZWVsVmVjdG9yID0gdC5zbGljZSgwKTtcbiAgICAgIHMud2hlZWxzID0gZ2VuZXJhdGVXaGVlbHNGcm9tVmVjdG9yKHQsIGx2bCwgbHZsKTtcbiAgICAgIHByZXZlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgb25XaGVlbEdlc3R1cmVTdGFydDogZnVuY3Rpb24gb25XaGVlbEdlc3R1cmVTdGFydChldikge1xuICAgICAgcy5yZWFkb25seSA9IGNyZWF0ZVJPVmVjdG9yKGx2bCwgZXYuaW5kZXgpO1xuICAgIH0sXG4gICAgb25XaGVlbEFuaW1hdGlvbkVuZDogZnVuY3Rpb24gb25XaGVlbEFuaW1hdGlvbkVuZChldikge1xuICAgICAgdmFyIGluZGV4ID0gZXYuaW5kZXgsXG4gICAgICAgICAgdmFsdWVzID0gaW5zdC5nZXRBcnJheVZhbCh0cnVlKSxcbiAgICAgICAgICBvID0gY2FsY0xldmVsT2ZWZWN0b3IyKHZhbHVlcywgaW5kZXgpO1xuICAgICAgY3VyckxldmVsID0gby5sdmw7XG4gICAgICBzLnJlYWRvbmx5ID0gb3JpZ1JlYWRPbmx5O1xuXG4gICAgICBpZiAodmFsdWVzW2luZGV4XSAhPSBjdXJyV2hlZWxWZWN0b3JbaW5kZXhdKSB7XG4gICAgICAgIGNoYW5nZVdoZWVscyh2YWx1ZXMsIGluZGV4LCBvKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uRmlsbDogZnVuY3Rpb24gb25GaWxsKGV2KSB7XG4gICAgICBjdXJyTGV2ZWwgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICBpbnB1dC52YWwoZXYudmFsdWVUZXh0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShkYXRhKSB7XG4gICAgICB2YXIgdmFsdWVzID0gZGF0YS52YWx1ZXMsXG4gICAgICAgICAgaW5kZXggPSBkYXRhLmluZGV4LFxuICAgICAgICAgIG8gPSBjYWxjTGV2ZWxPZlZlY3RvcjIodmFsdWVzLCB2YWx1ZXMubGVuZ3RoKTtcbiAgICAgIGN1cnJMZXZlbCA9IG8ubHZsO1xuXG4gICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBoaWRlV2hlZWxzKG8ubHZsKTtcblxuICAgICAgICBpZiAoIXByZXZlbnQpIHtcbiAgICAgICAgICBjaGFuZ2VXaGVlbHModmFsdWVzLCBpbmRleCwgbyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJldmVudCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzYWJsZWQ6IGdldERpc2FibGVkKGN1cnJMZXZlbCwgd2EsIHZhbHVlcylcbiAgICAgIH07XG4gICAgfSxcbiAgICBvbkRlc3Ryb3k6IGZ1bmN0aW9uIG9uRGVzdHJveSgpIHtcbiAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAkJDEoJyMnICsgaWQpLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBlbG0uc2hvdygpO1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBJbWFnZVNjcm9sbGVyID0gU2Nyb2xsZXI7XG5cbnByZXNldHMuaW1hZ2UgPSBmdW5jdGlvbiAoaW5zdCkge1xuICBpZiAoaW5zdC5zZXR0aW5ncy5lbmhhbmNlKSB7XG4gICAgaW5zdC5fcHJvY2Vzc01hcmt1cCA9IGZ1bmN0aW9uIChsaSkge1xuICAgICAgdmFyIGhhc0ljb24gPSBsaS5hdHRyKCdkYXRhLWljb24nKTtcbiAgICAgIGxpLmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbiAoaSwgdikge1xuICAgICAgICB2ID0gJCQxKHYpO1xuXG4gICAgICAgIGlmICh2LmlzKCdpbWcnKSkge1xuICAgICAgICAgICQkMSgnPGRpdiBjbGFzcz1cIm1ic2MtaW1nLWNcIj48L2Rpdj4nKS5pbnNlcnRBZnRlcih2KS5hcHBlbmQodi5hZGRDbGFzcygnbWJzYy1pbWcnKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodi5pcygncCcpKSB7XG4gICAgICAgICAgdi5hZGRDbGFzcygnbWJzYy1pbWctdHh0Jyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaGFzSWNvbikge1xuICAgICAgICBsaS5wcmVwZW5kKCc8ZGl2IGNsYXNzPVwibWJzYy1pYyBtYnNjLWljLScgKyBoYXNJY29uICsgJ1wiPjwvZGl2Jyk7XG4gICAgICB9XG5cbiAgICAgIGxpLmh0bWwoJzxkaXYgY2xhc3M9XCJtYnNjLWltZy13XCI+JyArIGxpLmh0bWwoKSArICc8L2Rpdj4nKTtcbiAgICAgIHJldHVybiBsaS5odG1sKCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBMaXN0LmNhbGwodGhpcywgaW5zdCk7XG59O1xuXG52YXIgTWJzY0ltYWdlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjSW1hZ2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjSW1hZ2UoaW5pdGlhbEVsZW1lbnQsIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtZW50LCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMub3B0aW9uU2VydmljZSA9IG9wdGlvblNlcnZpY2U7XHJcbiAgICAgICAgX3RoaXMuZW5oYW5jZSA9IHRydWU7XHJcbiAgICAgICAgX3RoaXMucGxhY2Vob2xkZXIgPSAnJztcclxuICAgICAgICBfdGhpcy5vcHRpb25zID0ge307XHJcbiAgICAgICAgX3RoaXMub25DaGFuZ2VFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjSW1hZ2UucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE1ic2NJbWFnZS5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XHJcbiAgICAgICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuX2VsZW1lbnRSZWYgJiYgdGFyZ2V0Ll9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldC5nZXRJbnB1dEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuZ2V0SW5wdXRFbGVtZW50KCkudGhlbihmdW5jdGlvbiAoaW5wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZU9wdGlvbnMoeyBpbnB1dDogaW5wIH0sIHRydWUsIGZhbHNlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0YXJnZXQuZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5lbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvcHRpb25zID0gZXh0ZW5kJDEoeyBwcmVzZXQ6ICdpbWFnZScsIGlucHV0OiB0YXJnZXQgfSwgdGhpcy5vcHRpb25TZXJ2aWNlID8gdGhpcy5vcHRpb25TZXJ2aWNlLm9wdGlvbnMgOiB7fSwgdGhpcy5vcHRpb25zLCB0aGlzLmlubGluZU9wdGlvbnNPYmosIHRoaXMub3B0aW9uRXh0ZW5zaW9ucyk7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBJbWFnZVNjcm9sbGVyKHRoaXMuZWxlbWVudCwgb3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodGhpcy5pbml0aWFsVmFsdWUsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTWJzY0ltYWdlLnByb3RvdHlwZS5zZXROZXdWYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UgJiYgdGhpcy5pbnN0YW5jZS5nZXRWYWwoKSAhPT0gdikge1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNldFZhbCh2LCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnB1dFNlcnZpY2UgJiYgdGhpcy5faW5wdXRTZXJ2aWNlLmlucHV0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dFNlcnZpY2UuaW5wdXQuaW5uZXJWYWx1ZSA9IHRoaXMuaW5zdGFuY2UuX3ZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBNYnNjSW1hZ2UucHJvdG90eXBlLCBcImRlZmF1bHRWYWx1ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY0ltYWdlLnByb3RvdHlwZSwgXCJlbmhhbmNlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NJbWFnZS5wcm90b3R5cGUsIFwiaW5wdXRDbGFzc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIE1ic2NJbWFnZS5wcm90b3R5cGUsIFwiaW52YWxpZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIE1ic2NJbWFnZS5wcm90b3R5cGUsIFwibGFiZWxzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NJbWFnZS5wcm90b3R5cGUsIFwicGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NJbWFnZS5wcm90b3R5cGUsIFwic2hvd0lucHV0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdtYnNjLWRhdGEnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBNYnNjSW1hZ2UucHJvdG90eXBlLCBcIndoZWVsQXJyYXlcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ21ic2Mtb3B0aW9ucycpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjSW1hZ2UucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ21ic2MtdGFyZ2V0JyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NJbWFnZS5wcm90b3R5cGUsIFwidGFyZ2V0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdtYnNjLWltYWdlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxyXG4gICAgXSwgTWJzY0ltYWdlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCBudWxsKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgnbWJzYy1pbWFnZUNoYW5nZScpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjSW1hZ2UucHJvdG90eXBlLCBcIm9uQ2hhbmdlRW1pdHRlclwiLCB2b2lkIDApO1xyXG4gICAgTWJzY0ltYWdlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgRGlyZWN0aXZlKHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWJzYy1pbWFnZV0nLFxyXG4gICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgyLCBPcHRpb25hbCgpKSwgX19wYXJhbSgzLCBPcHRpb25hbCgpKSwgX19wYXJhbSg0LCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZSwgTmdDb250cm9sLCBNYnNjSW5wdXRTZXJ2aWNlLCBNYnNjT3B0aW9uc1NlcnZpY2UsIFZpZXdDb250YWluZXJSZWZdKVxyXG4gICAgXSwgTWJzY0ltYWdlKTtcclxuICAgIHJldHVybiBNYnNjSW1hZ2U7XHJcbn0oTWJzY1Njcm9sbGVyQmFzZSkpO1xyXG52YXIgTWJzY0ltYWdlQ29tcG9uZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjSW1hZ2VDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjSW1hZ2VDb21wb25lbnQoaW5pdGlhbEVsZW0sIHpvbmUsIGxpc3RTZXJ2aWNlLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCBudWxsKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmxpc3RTZXJ2aWNlID0gbGlzdFNlcnZpY2U7XHJcbiAgICAgICAgX3RoaXMuZXJyb3JNZXNzYWdlID0gJyc7XHJcbiAgICAgICAgX3RoaXMubGFiZWwgPSAnJztcclxuICAgICAgICBfdGhpcy5wbGFjZWhvbGRlciA9ICcnO1xyXG4gICAgICAgIF90aGlzLnNob3dJbnB1dCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmlubGluZU9wdGlvbnNPYmogPSB7XHJcbiAgICAgICAgICAgIGl0ZW1TZWxlY3RvcjogJ21ic2MtaW1hZ2UtaXRlbScsXHJcbiAgICAgICAgICAgIHNob3dJbnB1dDogZmFsc2VcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE1ic2NJbWFnZUNvbXBvbmVudC5wcm90b3R5cGUuc2V0RWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5pdGVtV3JhcHBlcikge1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSB0aGlzLml0ZW1XcmFwcGVyLm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSB0aGlzLmluaXRpYWxFbGVtLm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1ic2NJbWFnZUNvbXBvbmVudC5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nT25Jbml0LmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5hZGRSZW1vdmVIYW5kbGVyID0gdGhpcy5saXN0U2VydmljZS5vbkFkZFJlbW92ZSgpLnN1YnNjcmliZShmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMuaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmluc3RhbmNlLm9wdGlvbih7fSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBNYnNjSW1hZ2VDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2V0VGhlbWVDbGFzc2VzKCk7XHJcbiAgICB9O1xyXG4gICAgTWJzY0ltYWdlQ29tcG9uZW50LnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMudGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gJCQxKCdtYnNjLWlucHV0JywgdGhpcy5pbml0aWFsRWxlbS5uYXRpdmVFbGVtZW50KVswXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5pbml0Q29udHJvbC5jYWxsKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIE1ic2NJbWFnZUNvbXBvbmVudC5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5saXN0U2VydmljZS5vbkFkZFJlbW92ZSgpLnVuc3Vic2NyaWJlKHRoaXMuYWRkUmVtb3ZlSGFuZGxlcik7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ09uRGVzdHJveS5jYWxsKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ2ljb24nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0ltYWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpbnB1dEljb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ2ljb24tYWxpZ24nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0ltYWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpY29uQWxpZ25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0ltYWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjSW1hZ2VDb21wb25lbnQucHJvdG90eXBlLCBcImVycm9yXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NJbWFnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZXJyb3JNZXNzYWdlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NJbWFnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnZGF0YScpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIE1ic2NJbWFnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwid2hlZWxBcnJheVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjSW1hZ2VDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NJbWFnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwicGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIFZpZXdDaGlsZCgnaXRlbVdyYXBwZXInLCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXHJcbiAgICBdLCBNYnNjSW1hZ2VDb21wb25lbnQucHJvdG90eXBlLCBcIml0ZW1XcmFwcGVyXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjSW1hZ2VDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dJbnB1dFwiLCB2b2lkIDApO1xyXG4gICAgTWJzY0ltYWdlQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLWltYWdlJyxcclxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IFwiPG1ic2MtaW5wdXQgKm5nSWY9XFxcIiFpbmxpbmUgfHwgc2hvd0lucHV0XFxcIiBcXG4gICAgICAgIFtuYW1lXT1cXFwibmFtZVxcXCIgXFxuICAgICAgICBbdGhlbWVdPVxcXCJ0aGVtZVxcXCIgXFxuICAgICAgICBbZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCIgXFxuICAgICAgICBbZXJyb3JdPVxcXCJlcnJvclxcXCIgXFxuICAgICAgICBbZXJyb3JNZXNzYWdlXT1cXFwiZXJyb3JNZXNzYWdlXFxcIiBcXG4gICAgICAgIFtpY29uXT1cXFwiaW5wdXRJY29uXFxcIiBcXG4gICAgICAgIFtpY29uLWFsaWduXT1cXFwiaWNvbkFsaWduXFxcIlxcbiAgICAgICAgW3BsYWNlaG9sZGVyXT1cXFwicGxhY2Vob2xkZXJcXFwiXFxuICAgICAgICBbY29udHJvbE5nXT1cXFwiZmFsc2VcXFwiPnt7bGFiZWx9fVxcbiAgICAgICAgPC9tYnNjLWlucHV0PlxcbiAgICAgICAgPHNwYW4gI2l0ZW1XcmFwcGVyPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L3NwYW4+XCIsXHJcbiAgICAgICAgICAgIHByb3ZpZGVyczogW01ic2NMaXN0U2VydmljZV1cclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDMsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDQsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDUsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLCBNYnNjTGlzdFNlcnZpY2UsIE5nQ29udHJvbCwgTWJzY0lucHV0U2VydmljZSwgTWJzY09wdGlvbnNTZXJ2aWNlXSlcclxuICAgIF0sIE1ic2NJbWFnZUNvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gTWJzY0ltYWdlQ29tcG9uZW50O1xyXG59KE1ic2NJbWFnZSkpO1xyXG52YXIgTWJzY0ltYWdlSXRlbSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNYnNjSW1hZ2VJdGVtKGxpc3RTZXJ2aWNlKSB7XHJcbiAgICAgICAgdGhpcy5saXN0U2VydmljZSA9IGxpc3RTZXJ2aWNlO1xyXG4gICAgfVxyXG4gICAgTWJzY0ltYWdlSXRlbS5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMubGlzdFNlcnZpY2Uubm90aWZ5QWRkUmVtb3ZlKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIE1ic2NJbWFnZUl0ZW0ucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMubGlzdFNlcnZpY2Uubm90aWZ5QWRkUmVtb3ZlKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY0ltYWdlSXRlbS5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0ltYWdlSXRlbS5wcm90b3R5cGUsIFwiaWNvblwiLCB2b2lkIDApO1xyXG4gICAgTWJzY0ltYWdlSXRlbSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1pbWFnZS1pdGVtJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcclxuICAgICAgICAgICAgaG9zdDoge1xyXG4gICAgICAgICAgICAgICAgJ1thdHRyLmRhdGEtdmFsXSc6ICd2YWx1ZScsXHJcbiAgICAgICAgICAgICAgICAnW2F0dHIuZGF0YS1pY29uXSc6ICdpY29uJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtNYnNjTGlzdFNlcnZpY2VdKVxyXG4gICAgXSwgTWJzY0ltYWdlSXRlbSk7XHJcbiAgICByZXR1cm4gTWJzY0ltYWdlSXRlbTtcclxufSgpKTtcclxudmFyIE1ic2NJbWFnZU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNYnNjSW1hZ2VNb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBNYnNjSW1hZ2VNb2R1bGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBOZ01vZHVsZSh7XHJcbiAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIE1ic2NTY3JvbGxlckJhc2VNb2R1bGUsIE1ic2NJbnB1dE1vZHVsZV0sXHJcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01ic2NJbWFnZSwgTWJzY0ltYWdlQ29tcG9uZW50LCBNYnNjSW1hZ2VJdGVtXSxcclxuICAgICAgICAgICAgZXhwb3J0czogW01ic2NJbWFnZSwgTWJzY0ltYWdlQ29tcG9uZW50LCBNYnNjSW1hZ2VJdGVtXVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBNYnNjSW1hZ2VNb2R1bGUpO1xyXG4gICAgcmV0dXJuIE1ic2NJbWFnZU1vZHVsZTtcclxufSgpKTtcblxudmFyIE1lYXN1cmVtZW50ID0gU2Nyb2xsZXI7XG52YXIgZGVmYXVsdHMkNiA9IHtcbiAgYmF0Y2g6IDUwLFxuICBtaW46IDAsXG4gIG1heDogMTAwLFxuICBkZWZhdWx0VW5pdDogJycsXG4gIHVuaXRzOiBudWxsLFxuICB1bml0TmFtZXM6IG51bGwsXG4gIGludmFsaWQ6IFtdLFxuICBzaWduOiBmYWxzZSxcbiAgc3RlcDogMC4wNSxcbiAgc2NhbGU6IDIsXG4gIGNvbnZlcnQ6IGZ1bmN0aW9uIGNvbnZlcnQodmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfSxcbiAgLy8gTG9jYWxpemF0aW9uXG4gIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcbiAgc2lnblRleHQ6ICcmbmJzcDsnLFxuICB3aG9sZVRleHQ6ICdXaG9sZScsXG4gIGZyYWN0aW9uVGV4dDogJ0ZyYWN0aW9uJyxcbiAgdW5pdFRleHQ6ICdVbml0J1xufTtcblxucHJlc2V0cy5tZWFzdXJlbWVudCA9IGZ1bmN0aW9uIChpbnN0KSB7XG4gIHZhciBvcmlnID0gZXh0ZW5kJDEoe30sIGluc3Quc2V0dGluZ3MpLFxuICAgICAgcyA9IGV4dGVuZCQxKGluc3Quc2V0dGluZ3MsIGRlZmF1bHRzJDYsIG9yaWcpLFxuICAgICAgd2hlZWwgPSB7fSxcbiAgICAgIHcgPSBbW11dLFxuICAgICAgd2hvbGVJbnZhbGlkcyA9IHt9LFxuICAgICAgd2hvbGVXaGVlbCA9IHt9LFxuICAgICAgZnJhY3Rpb25XaGVlbCA9IHt9LFxuICAgICAgZnJhY3Rpb25zID0gW10sXG4gICAgICB1c2VTaWduID0gcy5zaWduLFxuICAgICAgdXNlVW5pdHMgPSBzLnVuaXRzICYmIHMudW5pdHMubGVuZ3RoLFxuICAgICAgYmFzZVVuaXQgPSB1c2VVbml0cyA/IHMuZGVmYXVsdFVuaXQgfHwgcy51bml0c1swXSA6ICcnLFxuICAgICAgdW5pdHMgPSBbXSxcbiAgICAgIHVzZUZyYWN0ID0gcy5zdGVwIDwgMSxcbiAgICAgIHdob2xlU3RlcCA9IHMuc3RlcCA+IDEgPyBzLnN0ZXAgOiAxLFxuICAgICAgZnJhY3RMZW5ndGggPSB1c2VGcmFjdCA/IE1hdGgubWF4KHMuc2NhbGUsIChzLnN0ZXAgKyAnJykuc3BsaXQoJy4nKVsxXS5sZW5ndGgpIDogMSxcbiAgICAgIG9uZSA9IE1hdGgucG93KDEwLCBmcmFjdExlbmd0aCksXG4gICAgICBzdGVwcyA9IE1hdGgucm91bmQodXNlRnJhY3QgPyBzLnN0ZXAgKiBvbmUgOiBzLnN0ZXApLFxuICAgICAgZnJhY3ROcixcbiAgICAgIHJlYWxWYWx1ZSxcbiAgICAgIG9sZFVuaXQsXG4gICAgICBpZHhGcmFjdCxcbiAgICAgIGlkeFdob2xlLFxuICAgICAgaWR4VW5pdCxcbiAgICAgIG1pblZhbCxcbiAgICAgIG1heFZhbCxcbiAgICAgIG1pbldob2xlLFxuICAgICAgbWF4V2hvbGUsXG4gICAgICBtaW5GcmFjdCxcbiAgICAgIG1heEZyYWN0LFxuICAgICAgd2hvbGVPZmZzZXQgPSAwLFxuICAgICAgZnJhY3RPZmZzZXQgPSAwLFxuICAgICAgdixcbiAgICAgIGosXG4gICAgICBpID0gMDtcblxuICBmdW5jdGlvbiBnZXRXaG9sZShrKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1pbldob2xlLCBNYXRoLm1pbihtYXhXaG9sZSwgdXNlRnJhY3QgPyBrIDwgMCA/IE1hdGguY2VpbChrKSA6IE1hdGguZmxvb3IoaykgOiBzdGVwKE1hdGgucm91bmQoayAtIHdob2xlT2Zmc2V0KSwgc3RlcHMpICsgd2hvbGVPZmZzZXQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZyYWN0KGspIHtcbiAgICByZXR1cm4gdXNlRnJhY3QgPyBzdGVwKChNYXRoLmFicyhrKSAtIE1hdGguYWJzKGdldFdob2xlKGspKSkgKiBvbmUgLSBmcmFjdE9mZnNldCwgc3RlcHMpICsgZnJhY3RPZmZzZXQgOiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UGFydHModikge1xuICAgIHZhciB3aG9sZSA9IGdldFdob2xlKHYpLFxuICAgICAgICBmcmFjdCA9IGdldEZyYWN0KHYpLFxuICAgICAgICBzaWduID0gdiA8IDAgPyAnLScgOiAnKyc7XG5cbiAgICBpZiAoZnJhY3QgPj0gb25lKSB7XG4gICAgICBpZiAodiA8IDApIHtcbiAgICAgICAgd2hvbGUtLTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdob2xlKys7XG4gICAgICB9XG5cbiAgICAgIGZyYWN0ID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gW3NpZ24sIHdob2xlLCBmcmFjdF07XG4gIH1cblxuICBmdW5jdGlvbiBnZXROcihkKSB7XG4gICAgdmFyIHdob2xlID0gK2RbaWR4V2hvbGVdLFxuICAgICAgICBmcmFjdCA9IHVzZUZyYWN0ID8gZFtpZHhGcmFjdF0gLyBvbmUgKiAod2hvbGUgPCAwID8gLTEgOiAxKSA6IDA7XG4gICAgcmV0dXJuICh1c2VTaWduICYmIGRbMF0gPT0gJy0nID8gLTEgOiAxKSAqICh3aG9sZSArIGZyYWN0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0ZXAodiwgc3QpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh2IC8gc3QpICogc3Q7XG4gIH1cblxuICBmdW5jdGlvbiBjb252ZXJ0KHYsIHUxLCB1Mikge1xuICAgIGlmICh1MSA9PT0gdTIgfHwgIXMuY29udmVydCkge1xuICAgICAgcmV0dXJuIHY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHMuY29udmVydC5jYWxsKHRoaXMsIHYsIHUxLCB1Mik7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRNaW5NYXgodW5pdCkge1xuICAgIHZhciBtaW52LCBtYXh2O1xuICAgIG1pblZhbCA9IGNvbnZlcnQocy5taW4sIGJhc2VVbml0LCB1bml0KTtcbiAgICBtYXhWYWwgPSBjb252ZXJ0KHMubWF4LCBiYXNlVW5pdCwgdW5pdCk7XG5cbiAgICBpZiAodXNlRnJhY3QpIHtcbiAgICAgIG1pbldob2xlID0gbWluVmFsIDwgMCA/IE1hdGguY2VpbChtaW5WYWwpIDogTWF0aC5mbG9vcihtaW5WYWwpO1xuICAgICAgbWF4V2hvbGUgPSBtYXhWYWwgPCAwID8gTWF0aC5jZWlsKG1heFZhbCkgOiBNYXRoLmZsb29yKG1heFZhbCk7XG4gICAgICBtaW5GcmFjdCA9IGdldEZyYWN0KG1pblZhbCk7XG4gICAgICBtYXhGcmFjdCA9IGdldEZyYWN0KG1heFZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pbldob2xlID0gTWF0aC5yb3VuZChtaW5WYWwpO1xuICAgICAgbWF4V2hvbGUgPSBNYXRoLnJvdW5kKG1heFZhbCk7XG4gICAgICBtYXhXaG9sZSA9IG1pbldob2xlICsgTWF0aC5mbG9vcigobWF4V2hvbGUgLSBtaW5XaG9sZSkgLyBzdGVwcykgKiBzdGVwcztcbiAgICAgIHdob2xlT2Zmc2V0ID0gbWluV2hvbGUgJSBzdGVwcztcbiAgICB9XG5cbiAgICBtaW52ID0gbWluV2hvbGU7XG4gICAgbWF4diA9IG1heFdob2xlO1xuXG4gICAgaWYgKHVzZVNpZ24pIHtcbiAgICAgIG1heHYgPSBNYXRoLmFicyhtaW52KSA+IE1hdGguYWJzKG1heHYpID8gTWF0aC5hYnMobWludikgOiBNYXRoLmFicyhtYXh2KTtcbiAgICAgIG1pbnYgPSBtaW52IDwgMCA/IDAgOiBtaW52O1xuICAgIH1cblxuICAgIHdob2xlV2hlZWwubWluID0gbWludiA8IDAgPyBNYXRoLmNlaWwobWludiAvIHdob2xlU3RlcCkgOiBNYXRoLmZsb29yKG1pbnYgLyB3aG9sZVN0ZXApO1xuICAgIHdob2xlV2hlZWwubWF4ID0gbWF4diA8IDAgPyBNYXRoLmNlaWwobWF4diAvIHdob2xlU3RlcCkgOiBNYXRoLmZsb29yKG1heHYgLyB3aG9sZVN0ZXApO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0KGQpIHtcbiAgICByZXR1cm4gZ2V0TnIoZCkudG9GaXhlZCh1c2VGcmFjdCA/IGZyYWN0TGVuZ3RoIDogMCkgKyAodXNlVW5pdHMgPyAnICcgKyB1bml0c1tkW2lkeFVuaXRdXSA6ICcnKTtcbiAgfSAvLyBFeHRlbmRlZCBtZXRob2RzXG4gIC8vIC0tLVxuXG5cbiAgaW5zdC5zZXRWYWwgPSBmdW5jdGlvbiAodmFsLCBmaWxsLCBjaGFuZ2UsIHRlbXAsIHRpbWUpIHtcbiAgICAvLyBGb3JjZSBwYXJzZSBpZiB2YWx1ZSBpcyBwYXNzZWQgYXMgYW4gYXJyYXlcbiAgICBpbnN0Ll9zZXRWYWwoJCQxLmlzQXJyYXkodmFsKSA/IGZvcm1hdCh2YWwpIDogdmFsLCBmaWxsLCBjaGFuZ2UsIHRlbXAsIHRpbWUpO1xuICB9OyAvLyAtLS1cbiAgLy8gSW5pdHNcbiAgLy8gZ2VuZXJhdGUgYXJyYXkgZnJvbSB1bml0TmFtZXNcblxuXG4gIGlmIChzLnVuaXRzKSB7XG4gICAgZm9yIChqID0gMDsgaiA8IHMudW5pdHMubGVuZ3RoOyArK2opIHtcbiAgICAgIHYgPSBzLnVuaXRzW2pdO1xuICAgICAgdW5pdHMucHVzaChzLnVuaXROYW1lcyA/IHMudW5pdE5hbWVzW3ZdIHx8IHYgOiB2KTtcbiAgICB9XG4gIH0gLy8gQ2hlY2sgaWYgc2lnbiBpcyBuZWVkZWRcblxuXG4gIGlmICh1c2VTaWduKSB7XG4gICAgdXNlU2lnbiA9IGZhbHNlO1xuXG4gICAgaWYgKHVzZVVuaXRzKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgcy51bml0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAoY29udmVydChzLm1pbiwgYmFzZVVuaXQsIHMudW5pdHNbal0pIDwgMCkge1xuICAgICAgICAgIHVzZVNpZ24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHVzZVNpZ24gPSBzLm1pbiA8IDA7XG4gICAgfVxuICB9IC8vIFNpZ24gd2hlZWwgKGlmIGVuYWJsZWQpXG5cblxuICBpZiAodXNlU2lnbikge1xuICAgIHdbMF0ucHVzaCh7XG4gICAgICBkYXRhOiBbJy0nLCAnKyddLFxuICAgICAgbGFiZWw6IHMuc2lnblRleHRcbiAgICB9KTtcbiAgICBpKys7XG4gIH0gLy8gV2hvbGUgd2hlZWwgKGxhdGVyIGdlbmVyYXRlZClcblxuXG4gIHdob2xlV2hlZWwgPSB7XG4gICAgbGFiZWw6IHMud2hvbGVUZXh0LFxuICAgIGRhdGE6IGZ1bmN0aW9uIGRhdGEoaSkge1xuICAgICAgcmV0dXJuIG1pbldob2xlICUgd2hvbGVTdGVwICsgaSAqIHdob2xlU3RlcDtcbiAgICB9LFxuICAgIGdldEluZGV4OiBmdW5jdGlvbiBnZXRJbmRleChpKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCgoaSAtIG1pbldob2xlICUgd2hvbGVTdGVwKSAvIHdob2xlU3RlcCk7XG4gICAgfVxuICB9O1xuICB3WzBdLnB1c2god2hvbGVXaGVlbCk7XG4gIGlkeFdob2xlID0gaSsrO1xuICBzZXRNaW5NYXgoYmFzZVVuaXQpOyAvLyBGcmFjdGlvbiB3aGVlbFxuXG4gIGlmICh1c2VGcmFjdCkge1xuICAgIHdbMF0ucHVzaChmcmFjdGlvbldoZWVsKTtcbiAgICBmcmFjdGlvbldoZWVsLmRhdGEgPSBbXTtcbiAgICBmcmFjdGlvbldoZWVsLmxhYmVsID0gcy5mcmFjdGlvblRleHQ7XG5cbiAgICBmb3IgKGogPSBmcmFjdE9mZnNldDsgaiA8IG9uZTsgaiArPSBzdGVwcykge1xuICAgICAgZnJhY3Rpb25zLnB1c2goaik7XG4gICAgICBmcmFjdGlvbldoZWVsLmRhdGEucHVzaCh7XG4gICAgICAgIHZhbHVlOiBqLFxuICAgICAgICBkaXNwbGF5OiBzLmRlY2ltYWxTZXBhcmF0b3IgKyBwYWQoaiwgZnJhY3RMZW5ndGgpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZHhGcmFjdCA9IGkrKztcbiAgICBmcmFjdE5yID0gTWF0aC5jZWlsKDEwMCAvIHN0ZXBzKTtcblxuICAgIGlmIChzLmludmFsaWQgJiYgcy5pbnZhbGlkLmxlbmd0aCkge1xuICAgICAgLy8gQ2FsY3VsYXRlIHdob2xlIGludmFsaWRzXG4gICAgICAkJDEuZWFjaChzLmludmFsaWQsIGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICAgIHZhciB3ID0gdiA+IDAgPyBNYXRoLmZsb29yKHYpIDogTWF0aC5jZWlsKHYpO1xuXG4gICAgICAgIGlmICh3ID09PSAwKSB7XG4gICAgICAgICAgLy8gV2UgbmVlZCB0byB0cmFjayArMCBhbmQgLTAgc2VwcGFyYXRlbHlcbiAgICAgICAgICB3ID0gdiA8PSAwID8gLTAuMDAxIDogMC4wMDE7XG4gICAgICAgIH1cblxuICAgICAgICB3aG9sZUludmFsaWRzW3ddID0gKHdob2xlSW52YWxpZHNbd10gfHwgMCkgKyAxO1xuXG4gICAgICAgIGlmICh2ID09PSAwKSB7XG4gICAgICAgICAgdyA9IDAuMDAxO1xuICAgICAgICAgIHdob2xlSW52YWxpZHNbd10gPSAod2hvbGVJbnZhbGlkc1t3XSB8fCAwKSArIDE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgJCQxLmVhY2god2hvbGVJbnZhbGlkcywgZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgICAgaWYgKHYgPCBmcmFjdE5yKSB7XG4gICAgICAgICAgZGVsZXRlIHdob2xlSW52YWxpZHNbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2hvbGVJbnZhbGlkc1tpXSA9IGk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSAvLyBVbml0IHdoZWVsXG5cblxuICBpZiAodXNlVW5pdHMpIHtcbiAgICB3aGVlbCA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgbGFiZWw6IHMudW5pdFRleHQsXG4gICAgICBjc3NDbGFzczogJ21ic2MtbXNyLXdobC11bml0JyxcbiAgICAgIGNpcmN1bGFyOiBmYWxzZVxuICAgIH07XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgcy51bml0cy5sZW5ndGg7IGorKykge1xuICAgICAgd2hlZWwuZGF0YS5wdXNoKHtcbiAgICAgICAgdmFsdWU6IGosXG4gICAgICAgIGRpc3BsYXk6IHVuaXRzW2pdXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB3WzBdLnB1c2god2hlZWwpO1xuICB9XG5cbiAgaWR4VW5pdCA9IGk7XG4gIHJldHVybiB7XG4gICAgd2hlZWxzOiB3LFxuICAgIG1pbldpZHRoOiB1c2VTaWduICYmIHVzZUZyYWN0ID8gNzAgOiA4MCxcbiAgICBzaG93TGFiZWw6IGZhbHNlLFxuICAgIGZvcm1hdFZhbHVlOiBmb3JtYXQsXG4gICAgY29tcENsYXNzOiAnbWJzYy1tc3IgbWJzYy1zYycsXG4gICAgcGFyc2VWYWx1ZTogZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XG4gICAgICB2YXIgdnYgPSAodHlwZW9mIHYgPT09ICdudW1iZXInID8gdiArICcnIDogdikgfHwgcy5kZWZhdWx0VmFsdWUsXG4gICAgICAgICAgZCA9ICh2diArICcnKS5zcGxpdCgnICcpLFxuICAgICAgICAgIHZhbCA9ICtkWzBdLFxuICAgICAgICAgIHJldCA9IFtdLFxuICAgICAgICAgIHBhcnRzLFxuICAgICAgICAgIHVuaXQgPSAnJztcblxuICAgICAgaWYgKHVzZVVuaXRzKSB7XG4gICAgICAgIHVuaXQgPSAkJDEuaW5BcnJheShkWzFdLCB1bml0cyk7XG4gICAgICAgIHVuaXQgPSB1bml0ID09IC0xID8gJCQxLmluQXJyYXkoYmFzZVVuaXQsIHMudW5pdHMpIDogdW5pdDtcbiAgICAgICAgdW5pdCA9IHVuaXQgPT0gLTEgPyAwIDogdW5pdDtcbiAgICAgIH1cblxuICAgICAgb2xkVW5pdCA9IHVzZVVuaXRzID8gcy51bml0c1t1bml0XSA6ICcnO1xuICAgICAgc2V0TWluTWF4KG9sZFVuaXQpO1xuICAgICAgdmFsID0gaXNOYU4odmFsKSA/IDAgOiB2YWw7XG4gICAgICB2YWwgPSBjb25zdHJhaW4odmFsLCBtaW5WYWwsIG1heFZhbCk7XG4gICAgICBwYXJ0cyA9IGdldFBhcnRzKHZhbCk7XG4gICAgICBwYXJ0c1sxXSA9IGNvbnN0cmFpbihwYXJ0c1sxXSwgbWluV2hvbGUsIG1heFdob2xlKTtcbiAgICAgIHJlYWxWYWx1ZSA9IHZhbDtcblxuICAgICAgaWYgKHVzZVNpZ24pIHtcbiAgICAgICAgcmV0WzBdID0gcGFydHNbMF07XG4gICAgICAgIHBhcnRzWzFdID0gTWF0aC5hYnMocGFydHNbMV0pO1xuICAgICAgfVxuXG4gICAgICByZXRbaWR4V2hvbGVdID0gcGFydHNbMV07XG5cbiAgICAgIGlmICh1c2VGcmFjdCkge1xuICAgICAgICByZXRbaWR4RnJhY3RdID0gcGFydHNbMl07XG4gICAgICB9XG5cbiAgICAgIGlmICh1c2VVbml0cykge1xuICAgICAgICByZXRbaWR4VW5pdF0gPSB1bml0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG4gICAgb25DYW5jZWw6IGZ1bmN0aW9uIG9uQ2FuY2VsKCkge1xuICAgICAgcmVhbFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKGRhdGEpIHtcbiAgICAgIHZhciBtaW51cyxcbiAgICAgICAgICBwYXJ0cyxcbiAgICAgICAgICB3aG9sZSxcbiAgICAgICAgICBpcGFydHMsXG4gICAgICAgICAgZnJvbSxcbiAgICAgICAgICB2YWx1ZXMgPSBkYXRhLnZhbHVlcyxcbiAgICAgICAgICBpbmRleCA9IGRhdGEuaW5kZXgsXG4gICAgICAgICAgZGlyID0gZGF0YS5kaXJlY3Rpb24sXG4gICAgICAgICAgZGlzID0ge30sXG4gICAgICAgICAgZGlzYWJsZWQgPSBbXSxcbiAgICAgICAgICB3aGVlbHMgPSB7fSxcbiAgICAgICAgICBuZXdVbml0ID0gdXNlVW5pdHMgPyBzLnVuaXRzW3ZhbHVlc1tpZHhVbml0XV0gOiAnJzsgLy8gU2lnbiBjaGFuZ2VkXG5cbiAgICAgIGlmICh1c2VTaWduICYmIGluZGV4ID09PSAwKSB7XG4gICAgICAgIHJlYWxWYWx1ZSA9IE1hdGguYWJzKHJlYWxWYWx1ZSkgKiAodmFsdWVzWzBdID09ICctJyA/IC0xIDogMSk7XG4gICAgICB9IC8vIFNldCByZWFsIHZhbHVlIGlmIG51bWJlcnMgY2hhbmdlZFxuXG5cbiAgICAgIGlmIChpbmRleCA9PT0gaWR4V2hvbGUgfHwgaW5kZXggPT09IGlkeEZyYWN0ICYmIHVzZUZyYWN0IHx8IHJlYWxWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVhbFZhbHVlID0gZ2V0TnIodmFsdWVzKTtcbiAgICAgICAgb2xkVW5pdCA9IG5ld1VuaXQ7XG4gICAgICB9IC8vIENvbnZlcnQgdmFsdWUgaWYgdW5pdCBjaGFuZ2VkXG5cblxuICAgICAgaWYgKHVzZVVuaXRzICYmIGluZGV4ID09PSBpZHhVbml0ICYmIG9sZFVuaXQgIT09IG5ld1VuaXQgfHwgaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXRNaW5NYXgobmV3VW5pdCk7XG4gICAgICAgIHJlYWxWYWx1ZSA9IGNvbnZlcnQocmVhbFZhbHVlLCBvbGRVbml0LCBuZXdVbml0KTtcbiAgICAgICAgb2xkVW5pdCA9IG5ld1VuaXQ7XG4gICAgICAgIHBhcnRzID0gZ2V0UGFydHMocmVhbFZhbHVlKTtcblxuICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vd2hvbGVXaGVlbC5fcmVmcmVzaCgpO1xuICAgICAgICAgIHdoZWVsc1tpZHhXaG9sZV0gPSB3aG9sZVdoZWVsO1xuICAgICAgICAgIGluc3QuY2hhbmdlV2hlZWwod2hlZWxzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1c2VTaWduKSB7XG4gICAgICAgICAgdmFsdWVzWzBdID0gcGFydHNbMF07XG4gICAgICAgIH1cbiAgICAgIH0gLy8gRGlzYWJsZSBpbnZhbGlkIHZhbHVlc1xuXG5cbiAgICAgIGRpc2FibGVkW2lkeFdob2xlXSA9IFtdO1xuXG4gICAgICBpZiAodXNlU2lnbikge1xuICAgICAgICAvLyBEaXNhYmxlICsvLSBzaWduc1xuICAgICAgICBkaXNhYmxlZFswXSA9IFtdO1xuXG4gICAgICAgIGlmIChtaW5WYWwgPiAwKSB7XG4gICAgICAgICAgZGlzYWJsZWRbMF0ucHVzaCgnLScpO1xuICAgICAgICAgIHZhbHVlc1swXSA9ICcrJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXhWYWwgPCAwKSB7XG4gICAgICAgICAgZGlzYWJsZWRbMF0ucHVzaCgnKycpO1xuICAgICAgICAgIHZhbHVlc1swXSA9ICctJztcbiAgICAgICAgfVxuXG4gICAgICAgIGZyb20gPSBNYXRoLmFicyh2YWx1ZXNbMF0gPT0gJy0nID8gbWluV2hvbGUgOiBtYXhXaG9sZSk7XG5cbiAgICAgICAgZm9yIChpID0gZnJvbSArIHdob2xlU3RlcDsgaSA8IGZyb20gKyAyMCAqIHdob2xlU3RlcDsgaSArPSB3aG9sZVN0ZXApIHtcbiAgICAgICAgICBkaXNhYmxlZFtpZHhXaG9sZV0ucHVzaChpKTtcbiAgICAgICAgICBkaXNbaV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlYWxWYWx1ZSA9IGNvbnN0cmFpbihyZWFsVmFsdWUsIG1pblZhbCwgbWF4VmFsKTtcbiAgICAgIHBhcnRzID0gZ2V0UGFydHMocmVhbFZhbHVlKTtcbiAgICAgIHdob2xlID0gdXNlU2lnbiA/IE1hdGguYWJzKHBhcnRzWzFdKSA6IHBhcnRzWzFdO1xuICAgICAgbWludXMgPSB1c2VTaWduID8gdmFsdWVzWzBdID09ICctJyA6IHJlYWxWYWx1ZSA8IDA7XG4gICAgICB2YWx1ZXNbaWR4V2hvbGVdID0gd2hvbGU7XG5cbiAgICAgIGlmIChtaW51cykge1xuICAgICAgICAvLyBOZWVkIHRoaXMgZm9yIDBcbiAgICAgICAgcGFydHNbMF0gPSAnLSc7XG4gICAgICB9XG5cbiAgICAgIGlmICh1c2VGcmFjdCkge1xuICAgICAgICB2YWx1ZXNbaWR4RnJhY3RdID0gcGFydHNbMl07XG4gICAgICB9IC8vIERpc2FibGUgaW52YWxpZCB2YWx1ZXMgb24gd2hvbGUgd2hlZWxcblxuXG4gICAgICAkJDEuZWFjaCh1c2VGcmFjdCA/IHdob2xlSW52YWxpZHMgOiBzLmludmFsaWQsIGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICAgIC8vIGRpc2FibGUgd2hvbGUgdXNlciB2YWx1ZXNcbiAgICAgICAgaWYgKHVzZVNpZ24gJiYgbWludXMpIHtcbiAgICAgICAgICBpZiAodiA8PSAwKSB7XG4gICAgICAgICAgICB2ID0gTWF0aC5hYnModik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2ID0gc3RlcChjb252ZXJ0KHYsIGJhc2VVbml0LCBuZXdVbml0KSwgdXNlRnJhY3QgPyAxIDogc3RlcHMpO1xuICAgICAgICBkaXNbdl0gPSB0cnVlO1xuICAgICAgICBkaXNhYmxlZFtpZHhXaG9sZV0ucHVzaCh2KTtcbiAgICAgIH0pOyAvLyBGaW5kIG5lYXJlc3QgdmFsaWQgd2hvbGUgdmFsdWVcblxuICAgICAgdmFsdWVzW2lkeFdob2xlXSA9IGluc3QuZ2V0VmFsaWRWYWx1ZShpZHhXaG9sZSwgd2hvbGUsIGRpciwgZGlzKTtcbiAgICAgIHBhcnRzWzFdID0gdmFsdWVzW2lkeFdob2xlXSAqICh1c2VTaWduICYmIG1pbnVzID8gLTEgOiAxKTsgLy8gVmFsaWRhdGUgZnJhY3Rpb24gd2hlZWwgdmFsdWVzXG5cbiAgICAgIGlmICh1c2VGcmFjdCkge1xuICAgICAgICBkaXNhYmxlZFtpZHhGcmFjdF0gPSBbXTsgLy8gV2UgbmVlZCB0byBtYWtlIGRpZmZlcmVuY2UgYmV0d2VlbiArMCBhbmQgLTAsIHNvIHdlIGNvbXBhcmUgdGhlIHN0cmluZ3MgaW5zdGVhZCBvZiBudW1iZXJzXG5cbiAgICAgICAgdmFyIHAxID0gdXNlU2lnbiA/IHZhbHVlc1swXSArIHZhbHVlc1sxXSA6IChyZWFsVmFsdWUgPCAwID8gJy0nIDogJysnKSArIE1hdGguYWJzKHBhcnRzWzFdKSxcbiAgICAgICAgICAgIHAyID0gKG1pblZhbCA8IDAgPyAnLScgOiAnKycpICsgTWF0aC5hYnMobWluV2hvbGUpLFxuICAgICAgICAgICAgcDMgPSAobWF4VmFsIDwgMCA/ICctJyA6ICcrJykgKyBNYXRoLmFicyhtYXhXaG9sZSk7IC8vIERpc2FibGUgb3V0IG9mIHJhbmdlIGZyYWN0aW9uIHZhbHVlc1xuXG4gICAgICAgIGlmIChwMSA9PT0gcDIpIHtcbiAgICAgICAgICAkJDEoZnJhY3Rpb25zKS5lYWNoKGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICAgICAgICBpZiAobWludXMgPyB2ID4gbWluRnJhY3QgOiB2IDwgbWluRnJhY3QpIHtcbiAgICAgICAgICAgICAgZGlzYWJsZWRbaWR4RnJhY3RdLnB1c2godik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocDEgPT09IHAzKSB7XG4gICAgICAgICAgJCQxKGZyYWN0aW9ucykuZWFjaChmdW5jdGlvbiAoaSwgdikge1xuICAgICAgICAgICAgaWYgKG1pbnVzID8gdiA8IG1heEZyYWN0IDogdiA+IG1heEZyYWN0KSB7XG4gICAgICAgICAgICAgIGRpc2FibGVkW2lkeEZyYWN0XS5wdXNoKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IC8vIERpc2FibGUgaW52YWxpZCBmcmFjdGlvbiB2YWx1ZXNcblxuXG4gICAgICAgICQkMS5lYWNoKHMuaW52YWxpZCwgZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgICAgICBpcGFydHMgPSBnZXRQYXJ0cyhjb252ZXJ0KHYsIGJhc2VVbml0LCBuZXdVbml0KSk7IC8vIFNpZ24gYW5kIHdob2xlIHBhcnQgbWF0Y2hlc1xuXG4gICAgICAgICAgaWYgKChwYXJ0c1swXSA9PT0gaXBhcnRzWzBdIHx8IHBhcnRzWzFdID09PSAwICYmIGlwYXJ0c1sxXSA9PT0gMCAmJiBpcGFydHNbMl0gPT09IDApICYmIHBhcnRzWzFdID09PSBpcGFydHNbMV0pIHtcbiAgICAgICAgICAgIGRpc2FibGVkW2lkeEZyYWN0XS5wdXNoKGlwYXJ0c1syXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgICAgICB2YWxpZDogdmFsdWVzXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBkZWZhdWx0cyQ3ID0ge1xuICBtaW46IC0yMCxcbiAgbWF4OiA0MCxcbiAgZGVmYXVsdFVuaXQ6ICdjJyxcbiAgdW5pdHM6IFsnYycsICdrJywgJ2YnLCAnciddLFxuICB1bml0TmFtZXM6IHtcbiAgICBjOiAnwrBDJyxcbiAgICBrOiAnSycsXG4gICAgZjogJ8KwRicsXG4gICAgcjogJ8KwUidcbiAgfVxufSxcbiAgICBjb2JqID0ge1xuICBjMms6IGZ1bmN0aW9uIGMyayhjKSB7XG4gICAgcmV0dXJuIGMgKyAyNzMuMTU7XG4gIH0sXG4gIGMyZjogZnVuY3Rpb24gYzJmKGMpIHtcbiAgICByZXR1cm4gYyAqIDkgLyA1ICsgMzI7XG4gIH0sXG4gIGMycjogZnVuY3Rpb24gYzJyKGMpIHtcbiAgICByZXR1cm4gKGMgKyAyNzMuMTUpICogOSAvIDU7XG4gIH0sXG4gIGsyYzogZnVuY3Rpb24gazJjKGspIHtcbiAgICByZXR1cm4gayAtIDI3My4xNTtcbiAgfSxcbiAgazJmOiBmdW5jdGlvbiBrMmYoaykge1xuICAgIHJldHVybiBrICogOSAvIDUgLSA0NTkuNjc7XG4gIH0sXG4gIGsycjogZnVuY3Rpb24gazJyKGspIHtcbiAgICByZXR1cm4gayAqIDkgLyA1O1xuICB9LFxuICBmMmM6IGZ1bmN0aW9uIGYyYyhmKSB7XG4gICAgcmV0dXJuIChmIC0gMzIpICogNSAvIDk7XG4gIH0sXG4gIGYyazogZnVuY3Rpb24gZjJrKGYpIHtcbiAgICByZXR1cm4gKGYgKyA0NTkuNjcpICogNSAvIDk7XG4gIH0sXG4gIGYycjogZnVuY3Rpb24gZjJyKGYpIHtcbiAgICByZXR1cm4gZiArIDQ1OS42NztcbiAgfSxcbiAgcjJjOiBmdW5jdGlvbiByMmMocikge1xuICAgIHJldHVybiAociAtIDQ5MS42NykgKiA1IC8gOTtcbiAgfSxcbiAgcjJrOiBmdW5jdGlvbiByMmsocikge1xuICAgIHJldHVybiByICogNSAvIDk7XG4gIH0sXG4gIHIyZjogZnVuY3Rpb24gcjJmKHIpIHtcbiAgICByZXR1cm4gciAtIDQ1OS42NztcbiAgfVxufTtcblxucHJlc2V0cy50ZW1wZXJhdHVyZSA9IGZ1bmN0aW9uIChpbnN0KSB7XG4gIHZhciBzID0gZXh0ZW5kJDEoe30sIGRlZmF1bHRzJDcsIGluc3Quc2V0dGluZ3MpO1xuICBleHRlbmQkMShpbnN0LnNldHRpbmdzLCBzLCB7XG4gICAgc2lnbjogdHJ1ZSxcbiAgICBjb252ZXJ0OiBmdW5jdGlvbiBjb252ZXJ0KHZhbCwgdW5pdDEsIHVuaXQyKSB7XG4gICAgICByZXR1cm4gY29ialt1bml0MSArICcyJyArIHVuaXQyXSh2YWwpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwcmVzZXRzLm1lYXN1cmVtZW50LmNhbGwodGhpcywgaW5zdCk7XG59O1xuXG52YXIgZGVmYXVsdHMkOCA9IHtcbiAgbWluOiAwLFxuICBtYXg6IDEwMCxcbiAgZGVmYXVsdFVuaXQ6ICdrbScsXG4gIHVuaXRzOiBbJ20nLCAna20nLCAnaW4nLCAnZnQnLCAneWQnLCAnbWknXVxufSxcbiAgICBjb2JqJDEgPSB7XG4gIG1tOiAwLjAwMSxcbiAgY206IDAuMDEsXG4gIGRtOiAwLjEsXG4gIG06IDEsXG4gIGRhbTogMTAsXG4gIGhtOiAxMDAsXG4gIGttOiAxMDAwLFxuICAnaW4nOiAwLjAyNTQsXG4gIGZ0OiAwLjMwNDgsXG4gIHlkOiAwLjkxNDQsXG4gIGNoOiAyMC4xMTY4LFxuICBmdXI6IDIwMS4xNjgsXG4gIG1pOiAxNjA5LjM0NCxcbiAgbGVhOiA0ODI4LjAzMlxufTtcblxucHJlc2V0cy5kaXN0YW5jZSA9IGZ1bmN0aW9uIChpbnN0KSB7XG4gIHZhciBzID0gZXh0ZW5kJDEoe30sIGRlZmF1bHRzJDgsIGluc3Quc2V0dGluZ3MpO1xuICBleHRlbmQkMShpbnN0LnNldHRpbmdzLCBzLCB7XG4gICAgc2lnbjogZmFsc2UsXG4gICAgY29udmVydDogZnVuY3Rpb24gY29udmVydCh2YWwsIHVuaXQxLCB1bml0Mikge1xuICAgICAgcmV0dXJuIHZhbCAqIGNvYmokMVt1bml0MV0gLyBjb2JqJDFbdW5pdDJdO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwcmVzZXRzLm1lYXN1cmVtZW50LmNhbGwodGhpcywgaW5zdCk7XG59O1xuXG52YXIgZGVmYXVsdHMkOSA9IHtcbiAgbWluOiAwLFxuICBtYXg6IDEwMCxcbiAgZGVmYXVsdFVuaXQ6ICdrcGgnLFxuICB1bml0czogWydrcGgnLCAnbXBoJywgJ21wcycsICdmcHMnLCAna25vdCddLFxuICB1bml0TmFtZXM6IHtcbiAgICBrcGg6ICdrbS9oJyxcbiAgICBtcGg6ICdtaS9oJyxcbiAgICBtcHM6ICdtL3MnLFxuICAgIGZwczogJ2Z0L3MnLFxuICAgIGtub3Q6ICdrbm90J1xuICB9XG59LFxuICAgIGNvYmokMiA9IHtcbiAga3BoOiAxLFxuICBtcGg6IDEuNjA5MzQsXG4gIG1wczogMy42LFxuICBmcHM6IDEuMDk3MjgsXG4gIGtub3Q6IDEuODUyXG59O1xuXG5wcmVzZXRzLnNwZWVkID0gZnVuY3Rpb24gKGluc3QpIHtcbiAgdmFyIHMgPSBleHRlbmQkMSh7fSwgZGVmYXVsdHMkOSwgaW5zdC5zZXR0aW5ncyk7XG4gIGV4dGVuZCQxKGluc3Quc2V0dGluZ3MsIHMsIHtcbiAgICBzaWduOiBmYWxzZSxcbiAgICBjb252ZXJ0OiBmdW5jdGlvbiBjb252ZXJ0KHZhbCwgdW5pdDEsIHVuaXQyKSB7XG4gICAgICByZXR1cm4gdmFsICogY29iaiQyW3VuaXQxXSAvIGNvYmokMlt1bml0Ml07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHByZXNldHMubWVhc3VyZW1lbnQuY2FsbCh0aGlzLCBpbnN0KTtcbn07XG5cbnZhciBkZWZhdWx0cyRhID0ge1xuICBtaW46IDAsXG4gIG1heDogMTAwLFxuICBkZWZhdWx0VW5pdDogJ04nLFxuICB1bml0czogWydOJywgJ2twJywgJ2xiZicsICdwZGwnXVxufSxcbiAgICBjb2JqJDMgPSB7XG4gIE46IDEsXG4gIGtwOiA5LjgwNjY1LFxuICBsYmY6IDQuNDQ4MjIyLFxuICBwZGw6IDAuMTM4MjU1XG59O1xuXG5wcmVzZXRzLmZvcmNlID0gZnVuY3Rpb24gKGluc3QpIHtcbiAgdmFyIHMgPSBleHRlbmQkMSh7fSwgZGVmYXVsdHMkYSwgaW5zdC5zZXR0aW5ncyk7XG4gIGV4dGVuZCQxKGluc3Quc2V0dGluZ3MsIHMsIHtcbiAgICBzaWduOiBmYWxzZSxcbiAgICBjb252ZXJ0OiBmdW5jdGlvbiBjb252ZXJ0KHZhbCwgdW5pdDEsIHVuaXQyKSB7XG4gICAgICByZXR1cm4gdmFsICogY29iaiQzW3VuaXQxXSAvIGNvYmokM1t1bml0Ml07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHByZXNldHMubWVhc3VyZW1lbnQuY2FsbCh0aGlzLCBpbnN0KTtcbn07XG5cbnZhciBkZWZhdWx0cyRiID0ge1xuICBtaW46IDAsXG4gIG1heDogMTAwMCxcbiAgZGVmYXVsdFVuaXQ6ICdrZycsXG4gIHVuaXRzOiBbJ2cnLCAna2cnLCAnb3onLCAnbGInXSxcbiAgdW5pdE5hbWVzOiB7XG4gICAgdGxvbmc6ICd0IChsb25nKScsXG4gICAgdHNob3J0OiAndCAoc2hvcnQpJ1xuICB9XG59LFxuICAgIGNvYmokNCA9IHtcbiAgbWc6IDAuMDAxLFxuICBjZzogMC4wMSxcbiAgZGc6IDAuMSxcbiAgZzogMSxcbiAgZGFnOiAxMCxcbiAgaGc6IDEwMCxcbiAga2c6IDEwMDAsXG4gIHQ6IDEwMDAwMDAsXG4gIGRyYzogMS43NzE4NDUyLFxuICBvejogMjguMzQ5NSxcbiAgbGI6IDQ1My41OTIzNyxcbiAgc3Q6IDYzNTAuMjkzMTgsXG4gIHF0cjogMTI3MDAuNTg2MzYsXG4gIGN3dDogNTA4MDIuMzQ1NDQsXG4gIHRsb25nOiAxMDE2MDQ2LjkwODgsXG4gIHRzaG9ydDogOTA3MTg0Ljc0XG59O1xuXG5wcmVzZXRzLm1hc3MgPSBmdW5jdGlvbiAoaW5zdCkge1xuICB2YXIgcyA9IGV4dGVuZCQxKHt9LCBkZWZhdWx0cyRiLCBpbnN0LnNldHRpbmdzKTtcbiAgZXh0ZW5kJDEoaW5zdC5zZXR0aW5ncywgcywge1xuICAgIHNpZ246IGZhbHNlLFxuICAgIGNvbnZlcnQ6IGZ1bmN0aW9uIGNvbnZlcnQodmFsLCB1bml0MSwgdW5pdDIpIHtcbiAgICAgIHJldHVybiB2YWwgKiBjb2JqJDRbdW5pdDFdIC8gY29iaiQ0W3VuaXQyXTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcHJlc2V0cy5tZWFzdXJlbWVudC5jYWxsKHRoaXMsIGluc3QpO1xufTtcblxudmFyIE1ic2NNZWFzdXJlbWVudEJhc2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NNZWFzdXJlbWVudEJhc2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjTWVhc3VyZW1lbnRCYXNlKGluaXRpYWxFbGVtZW50LCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIHZpZXcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbWVudCwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCB2aWV3KSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLm9wdGlvblNlcnZpY2UgPSBvcHRpb25TZXJ2aWNlO1xyXG4gICAgICAgIF90aGlzLnByZXNldCA9ICdtZWFzdXJlbWVudCc7XHJcbiAgICAgICAgX3RoaXMub25DaGFuZ2VFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjTWVhc3VyZW1lbnRCYXNlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB0aGlzLnNldE5ld1ZhbHVlUHJveHkodik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBNYnNjTWVhc3VyZW1lbnRCYXNlLnByb3RvdHlwZS5zZXROZXdWYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgdmFyIGlubmVyVmFsdWUgPSB0aGlzLmluc3RhbmNlLmdldFZhbCgpO1xyXG4gICAgICAgICAgICBpZiAoaW5uZXJWYWx1ZSAhPT0gdikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodiwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lucHV0U2VydmljZSAmJiB0aGlzLl9pbnB1dFNlcnZpY2UuaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dFNlcnZpY2UuaW5wdXQuaW5uZXJWYWx1ZSA9IHRoaXMuaW5zdGFuY2UuX3ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1ic2NNZWFzdXJlbWVudEJhc2UucHJvdG90eXBlLmluaXRDb250cm9sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gZXh0ZW5kJDEoeyBwcmVzZXQ6IHRoaXMucHJlc2V0IH0sIHRoaXMub3B0aW9uU2VydmljZSA/IHRoaXMub3B0aW9uU2VydmljZS5vcHRpb25zIDoge30sIHRoaXMub3B0aW9ucywgdGhpcy5pbmxpbmVPcHRpb25zT2JqLCB0aGlzLm9wdGlvbkV4dGVuc2lvbnMpO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgU2Nyb2xsZXIodGhpcy5lbGVtZW50LCBvcHRpb25zKTtcclxuICAgICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNldFZhbCh0aGlzLmluaXRpYWxWYWx1ZSwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIE1ic2NNZWFzdXJlbWVudEJhc2UucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBNYnNjTWVhc3VyZW1lbnRCYXNlLnByb3RvdHlwZSwgXCJtaW5cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY01lYXN1cmVtZW50QmFzZS5wcm90b3R5cGUsIFwiZGVjaW1hbFNlcGFyYXRvclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjTWVhc3VyZW1lbnRCYXNlLnByb3RvdHlwZSwgXCJkZWZhdWx0VmFsdWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBNYnNjTWVhc3VyZW1lbnRCYXNlLnByb3RvdHlwZSwgXCJpbnZhbGlkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIE1ic2NNZWFzdXJlbWVudEJhc2UucHJvdG90eXBlLCBcInNjYWxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIE1ic2NNZWFzdXJlbWVudEJhc2UucHJvdG90eXBlLCBcInN0ZXBcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY01lYXN1cmVtZW50QmFzZS5wcm90b3R5cGUsIFwiZGVmYXVsdFVuaXRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY01lYXN1cmVtZW50QmFzZS5wcm90b3R5cGUsIFwidW5pdE5hbWVzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgTWJzY01lYXN1cmVtZW50QmFzZS5wcm90b3R5cGUsIFwidW5pdHNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY01lYXN1cmVtZW50QmFzZS5wcm90b3R5cGUsIFwid2hvbGVUZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NNZWFzdXJlbWVudEJhc2UucHJvdG90eXBlLCBcImZyYWN0aW9uVGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjTWVhc3VyZW1lbnRCYXNlLnByb3RvdHlwZSwgXCJzaWduVGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnbWJzYy1tZWFzdXJlbWVudCcpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcclxuICAgIF0sIE1ic2NNZWFzdXJlbWVudEJhc2UucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCdtYnNjLW1lYXN1cmVtZW50Q2hhbmdlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NNZWFzdXJlbWVudEJhc2UucHJvdG90eXBlLCBcIm9uQ2hhbmdlRW1pdHRlclwiLCB2b2lkIDApO1xyXG4gICAgTWJzY01lYXN1cmVtZW50QmFzZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW21ic2MtbS1iXScgfSksXHJcbiAgICAgICAgX19wYXJhbSg0LCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZSwgTmdDb250cm9sLCBNYnNjSW5wdXRTZXJ2aWNlLCBNYnNjT3B0aW9uc1NlcnZpY2UsIFZpZXdDb250YWluZXJSZWZdKVxyXG4gICAgXSwgTWJzY01lYXN1cmVtZW50QmFzZSk7XHJcbiAgICByZXR1cm4gTWJzY01lYXN1cmVtZW50QmFzZTtcclxufShNYnNjU2Nyb2xsZXJCYXNlKSk7XHJcbnZhciBNYnNjTWVhc3VyZW1lbnRDaGlsZCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY01lYXN1cmVtZW50Q2hpbGQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjTWVhc3VyZW1lbnRDaGlsZChpbml0aWFsRWxlbWVudCwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtZW50LCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjTWVhc3VyZW1lbnRDaGlsZC5wcm90b3R5cGUsIFwiY29udmVydFwiLCB2b2lkIDApO1xyXG4gICAgTWJzY01lYXN1cmVtZW50Q2hpbGQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1ttYnNjLW0tY10nIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLCBOZ0NvbnRyb2wsIE1ic2NJbnB1dFNlcnZpY2UsIE1ic2NPcHRpb25zU2VydmljZSwgVmlld0NvbnRhaW5lclJlZl0pXHJcbiAgICBdLCBNYnNjTWVhc3VyZW1lbnRDaGlsZCk7XHJcbiAgICByZXR1cm4gTWJzY01lYXN1cmVtZW50Q2hpbGQ7XHJcbn0oTWJzY01lYXN1cmVtZW50QmFzZSkpO1xyXG52YXIgTWJzY01lYXN1cmVtZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjTWVhc3VyZW1lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjTWVhc3VyZW1lbnQoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcclxuICAgIF0sIE1ic2NNZWFzdXJlbWVudC5wcm90b3R5cGUsIFwiY29udmVydFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnbWJzYy1vcHRpb25zJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NNZWFzdXJlbWVudC5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgTWJzY01lYXN1cmVtZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgRGlyZWN0aXZlKHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWJzYy1tZWFzdXJlbWVudF0nLFxyXG4gICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgyLCBPcHRpb25hbCgpKSwgX19wYXJhbSgzLCBPcHRpb25hbCgpKSwgX19wYXJhbSg0LCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZSwgTmdDb250cm9sLCBNYnNjSW5wdXRTZXJ2aWNlLCBNYnNjT3B0aW9uc1NlcnZpY2UsIFZpZXdDb250YWluZXJSZWZdKVxyXG4gICAgXSwgTWJzY01lYXN1cmVtZW50KTtcclxuICAgIHJldHVybiBNYnNjTWVhc3VyZW1lbnQ7XHJcbn0oTWJzY01lYXN1cmVtZW50QmFzZSkpO1xyXG52YXIgTWJzY01lYXN1cmVtZW50Q29tcG9uZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjTWVhc3VyZW1lbnRDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjTWVhc3VyZW1lbnRDb21wb25lbnQoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIG51bGwpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZXJyb3JNZXNzYWdlID0gJyc7XHJcbiAgICAgICAgX3RoaXMucGxhY2Vob2xkZXIgPSAnJztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBNYnNjTWVhc3VyZW1lbnRDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2V0VGhlbWVDbGFzc2VzKCk7XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnaWNvbicpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjTWVhc3VyZW1lbnRDb21wb25lbnQucHJvdG90eXBlLCBcImlucHV0SWNvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnaWNvbi1hbGlnbicpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjTWVhc3VyZW1lbnRDb21wb25lbnQucHJvdG90eXBlLCBcImljb25BbGlnblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjTWVhc3VyZW1lbnRDb21wb25lbnQucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NNZWFzdXJlbWVudENvbXBvbmVudC5wcm90b3R5cGUsIFwiZXJyb3JcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY01lYXN1cmVtZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJlcnJvck1lc3NhZ2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY01lYXN1cmVtZW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJvcHRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NNZWFzdXJlbWVudENvbXBvbmVudC5wcm90b3R5cGUsIFwicGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NNZWFzdXJlbWVudENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1tZWFzdXJlbWVudCcsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBJTlBVVF9URU1QTEFURVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMiwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksIF9fcGFyYW0oNCwgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBOZ1pvbmUsIE5nQ29udHJvbCwgTWJzY0lucHV0U2VydmljZSwgTWJzY09wdGlvbnNTZXJ2aWNlXSlcclxuICAgIF0sIE1ic2NNZWFzdXJlbWVudENvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gTWJzY01lYXN1cmVtZW50Q29tcG9uZW50O1xyXG59KE1ic2NNZWFzdXJlbWVudCkpO1xyXG52YXIgTWJzY1RlbXBlcmF0dXJlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjVGVtcGVyYXR1cmUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjVGVtcGVyYXR1cmUoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5wcmVzZXQgPSAndGVtcGVyYXR1cmUnO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjVGVtcGVyYXR1cmUucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ21ic2Mtb3B0aW9ucycpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjVGVtcGVyYXR1cmUucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ21ic2MtdGVtcGVyYXR1cmUnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXHJcbiAgICBdLCBNYnNjVGVtcGVyYXR1cmUucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCdtYnNjLXRlbXBlcmF0dXJlQ2hhbmdlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NUZW1wZXJhdHVyZS5wcm90b3R5cGUsIFwib25DaGFuZ2VFbWl0dGVyXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjVGVtcGVyYXR1cmUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBEaXJlY3RpdmUoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ1ttYnNjLXRlbXBlcmF0dXJlXScsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCdcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDIsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDMsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDQsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLCBOZ0NvbnRyb2wsIE1ic2NJbnB1dFNlcnZpY2UsIE1ic2NPcHRpb25zU2VydmljZSwgVmlld0NvbnRhaW5lclJlZl0pXHJcbiAgICBdLCBNYnNjVGVtcGVyYXR1cmUpO1xyXG4gICAgcmV0dXJuIE1ic2NUZW1wZXJhdHVyZTtcclxufShNYnNjTWVhc3VyZW1lbnRDaGlsZCkpO1xyXG52YXIgTWJzY1RlbXBlcmF0dXJlQ29tcG9uZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjVGVtcGVyYXR1cmVDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjVGVtcGVyYXR1cmVDb21wb25lbnQoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIG51bGwpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZXJyb3JNZXNzYWdlID0gJyc7XHJcbiAgICAgICAgX3RoaXMucGxhY2Vob2xkZXIgPSAnJztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBNYnNjVGVtcGVyYXR1cmVDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2V0VGhlbWVDbGFzc2VzKCk7XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnaWNvbicpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjVGVtcGVyYXR1cmVDb21wb25lbnQucHJvdG90eXBlLCBcImlucHV0SWNvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnaWNvbi1hbGlnbicpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjVGVtcGVyYXR1cmVDb21wb25lbnQucHJvdG90eXBlLCBcImljb25BbGlnblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjVGVtcGVyYXR1cmVDb21wb25lbnQucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NUZW1wZXJhdHVyZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZXJyb3JcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1RlbXBlcmF0dXJlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlcnJvck1lc3NhZ2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY1RlbXBlcmF0dXJlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvcHRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NUZW1wZXJhdHVyZUNvbXBvbmVudC5wcm90b3R5cGUsIFwicGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NUZW1wZXJhdHVyZUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy10ZW1wZXJhdHVyZScsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBJTlBVVF9URU1QTEFURVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMiwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksIF9fcGFyYW0oNCwgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBOZ1pvbmUsIE5nQ29udHJvbCwgTWJzY0lucHV0U2VydmljZSwgTWJzY09wdGlvbnNTZXJ2aWNlXSlcclxuICAgIF0sIE1ic2NUZW1wZXJhdHVyZUNvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gTWJzY1RlbXBlcmF0dXJlQ29tcG9uZW50O1xyXG59KE1ic2NUZW1wZXJhdHVyZSkpO1xyXG52YXIgTWJzY0Rpc3RhbmNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjRGlzdGFuY2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjRGlzdGFuY2UoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5wcmVzZXQgPSAnZGlzdGFuY2UnO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjRGlzdGFuY2UucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ21ic2Mtb3B0aW9ucycpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjRGlzdGFuY2UucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ21ic2MtZGlzdGFuY2UnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXHJcbiAgICBdLCBNYnNjRGlzdGFuY2UucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCdtYnNjLWRpc3RhbmNlQ2hhbmdlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NEaXN0YW5jZS5wcm90b3R5cGUsIFwib25DaGFuZ2VFbWl0dGVyXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjRGlzdGFuY2UgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBEaXJlY3RpdmUoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ1ttYnNjLWRpc3RhbmNlXScsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCdcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDIsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDMsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDQsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLCBOZ0NvbnRyb2wsIE1ic2NJbnB1dFNlcnZpY2UsIE1ic2NPcHRpb25zU2VydmljZSwgVmlld0NvbnRhaW5lclJlZl0pXHJcbiAgICBdLCBNYnNjRGlzdGFuY2UpO1xyXG4gICAgcmV0dXJuIE1ic2NEaXN0YW5jZTtcclxufShNYnNjTWVhc3VyZW1lbnRCYXNlKSk7XHJcbnZhciBNYnNjRGlzdGFuY2VDb21wb25lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NEaXN0YW5jZUNvbXBvbmVudCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NEaXN0YW5jZUNvbXBvbmVudChpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgbnVsbCkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5lcnJvck1lc3NhZ2UgPSAnJztcclxuICAgICAgICBfdGhpcy5wbGFjZWhvbGRlciA9ICcnO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE1ic2NEaXN0YW5jZUNvbXBvbmVudC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0LmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zZXRUaGVtZUNsYXNzZXMoKTtcclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdpY29uJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NEaXN0YW5jZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5wdXRJY29uXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdpY29uLWFsaWduJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NEaXN0YW5jZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiaWNvbkFsaWduXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NEaXN0YW5jZUNvbXBvbmVudC5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY0Rpc3RhbmNlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlcnJvclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjRGlzdGFuY2VDb21wb25lbnQucHJvdG90eXBlLCBcImVycm9yTWVzc2FnZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjRGlzdGFuY2VDb21wb25lbnQucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0Rpc3RhbmNlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwbGFjZWhvbGRlclwiLCB2b2lkIDApO1xyXG4gICAgTWJzY0Rpc3RhbmNlQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLWRpc3RhbmNlJyxcclxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IElOUFVUX1RFTVBMQVRFXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgyLCBPcHRpb25hbCgpKSwgX19wYXJhbSgzLCBPcHRpb25hbCgpKSwgX19wYXJhbSg0LCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZSwgTmdDb250cm9sLCBNYnNjSW5wdXRTZXJ2aWNlLCBNYnNjT3B0aW9uc1NlcnZpY2VdKVxyXG4gICAgXSwgTWJzY0Rpc3RhbmNlQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBNYnNjRGlzdGFuY2VDb21wb25lbnQ7XHJcbn0oTWJzY0Rpc3RhbmNlKSk7XHJcbnZhciBNYnNjU3BlZWQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NTcGVlZCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NTcGVlZChpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5vcHRpb25zID0ge307XHJcbiAgICAgICAgX3RoaXMub25DaGFuZ2VFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLnByZXNldCA9ICdzcGVlZCc7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NTcGVlZC5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXROZXdWYWx1ZVByb3h5KHYpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnbWJzYy1vcHRpb25zJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NTcGVlZC5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnbWJzYy1zcGVlZCcpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcclxuICAgIF0sIE1ic2NTcGVlZC5wcm90b3R5cGUsIFwidmFsdWVcIiwgbnVsbCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoJ21ic2Mtc3BlZWRDaGFuZ2UnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY1NwZWVkLnByb3RvdHlwZSwgXCJvbkNoYW5nZUVtaXR0ZXJcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NTcGVlZCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIERpcmVjdGl2ZSh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW21ic2Mtc3BlZWRdJyxcclxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJ1xyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMiwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksIF9fcGFyYW0oNCwgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBOZ1pvbmUsIE5nQ29udHJvbCwgTWJzY0lucHV0U2VydmljZSwgTWJzY09wdGlvbnNTZXJ2aWNlLCBWaWV3Q29udGFpbmVyUmVmXSlcclxuICAgIF0sIE1ic2NTcGVlZCk7XHJcbiAgICByZXR1cm4gTWJzY1NwZWVkO1xyXG59KE1ic2NNZWFzdXJlbWVudEJhc2UpKTtcclxudmFyIE1ic2NTcGVlZENvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY1NwZWVkQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY1NwZWVkQ29tcG9uZW50KGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCBudWxsKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmVycm9yTWVzc2FnZSA9ICcnO1xyXG4gICAgICAgIF90aGlzLnBsYWNlaG9sZGVyID0gJyc7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgTWJzY1NwZWVkQ29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnNldFRoZW1lQ2xhc3NlcygpO1xyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ2ljb24nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1NwZWVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpbnB1dEljb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ2ljb24tYWxpZ24nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1NwZWVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpY29uQWxpZ25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1NwZWVkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjU3BlZWRDb21wb25lbnQucHJvdG90eXBlLCBcImVycm9yXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NTcGVlZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZXJyb3JNZXNzYWdlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NTcGVlZENvbXBvbmVudC5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjU3BlZWRDb21wb25lbnQucHJvdG90eXBlLCBcInBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjU3BlZWRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ21ic2Mtc3BlZWQnLFxyXG4gICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogSU5QVVRfVEVNUExBVEVcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDIsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDMsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDQsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLCBOZ0NvbnRyb2wsIE1ic2NJbnB1dFNlcnZpY2UsIE1ic2NPcHRpb25zU2VydmljZV0pXHJcbiAgICBdLCBNYnNjU3BlZWRDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIE1ic2NTcGVlZENvbXBvbmVudDtcclxufShNYnNjU3BlZWQpKTtcclxudmFyIE1ic2NGb3JjZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY0ZvcmNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY0ZvcmNlKGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIHZpZXcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSB7fTtcclxuICAgICAgICBfdGhpcy5vbkNoYW5nZUVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMucHJlc2V0ID0gJ2ZvcmNlJztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY0ZvcmNlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB0aGlzLnNldE5ld1ZhbHVlUHJveHkodik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdtYnNjLW9wdGlvbnMnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY0ZvcmNlLnByb3RvdHlwZSwgXCJvcHRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdtYnNjLWZvcmNlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxyXG4gICAgXSwgTWJzY0ZvcmNlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCBudWxsKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgnbWJzYy1mb3JjZUNoYW5nZScpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjRm9yY2UucHJvdG90eXBlLCBcIm9uQ2hhbmdlRW1pdHRlclwiLCB2b2lkIDApO1xyXG4gICAgTWJzY0ZvcmNlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgRGlyZWN0aXZlKHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWJzYy1mb3JjZV0nLFxyXG4gICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgyLCBPcHRpb25hbCgpKSwgX19wYXJhbSgzLCBPcHRpb25hbCgpKSwgX19wYXJhbSg0LCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZSwgTmdDb250cm9sLCBNYnNjSW5wdXRTZXJ2aWNlLCBNYnNjT3B0aW9uc1NlcnZpY2UsIFZpZXdDb250YWluZXJSZWZdKVxyXG4gICAgXSwgTWJzY0ZvcmNlKTtcclxuICAgIHJldHVybiBNYnNjRm9yY2U7XHJcbn0oTWJzY01lYXN1cmVtZW50QmFzZSkpO1xyXG52YXIgTWJzY0ZvcmNlQ29tcG9uZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjRm9yY2VDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjRm9yY2VDb21wb25lbnQoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIG51bGwpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZXJyb3JNZXNzYWdlID0gJyc7XHJcbiAgICAgICAgX3RoaXMucGxhY2Vob2xkZXIgPSAnJztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBNYnNjRm9yY2VDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2V0VGhlbWVDbGFzc2VzKCk7XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnaWNvbicpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjRm9yY2VDb21wb25lbnQucHJvdG90eXBlLCBcImlucHV0SWNvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnaWNvbi1hbGlnbicpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjRm9yY2VDb21wb25lbnQucHJvdG90eXBlLCBcImljb25BbGlnblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjRm9yY2VDb21wb25lbnQucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NGb3JjZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZXJyb3JcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0ZvcmNlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlcnJvck1lc3NhZ2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY0ZvcmNlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvcHRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NGb3JjZUNvbXBvbmVudC5wcm90b3R5cGUsIFwicGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NGb3JjZUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1mb3JjZScsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBJTlBVVF9URU1QTEFURVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMiwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksIF9fcGFyYW0oNCwgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBOZ1pvbmUsIE5nQ29udHJvbCwgTWJzY0lucHV0U2VydmljZSwgTWJzY09wdGlvbnNTZXJ2aWNlXSlcclxuICAgIF0sIE1ic2NGb3JjZUNvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gTWJzY0ZvcmNlQ29tcG9uZW50O1xyXG59KE1ic2NGb3JjZSkpO1xyXG52YXIgTWJzY01hc3MgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NNYXNzLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY01hc3MoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5wcmVzZXQgPSAnbWFzcyc7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NNYXNzLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB0aGlzLnNldE5ld1ZhbHVlUHJveHkodik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdtYnNjLW9wdGlvbnMnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY01hc3MucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ21ic2MtbWFzcycpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcclxuICAgIF0sIE1ic2NNYXNzLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCBudWxsKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgnbWJzYy1tYXNzQ2hhbmdlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NNYXNzLnByb3RvdHlwZSwgXCJvbkNoYW5nZUVtaXR0ZXJcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NNYXNzID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgRGlyZWN0aXZlKHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWJzYy1tYXNzXScsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCdcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDIsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDMsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDQsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLCBOZ0NvbnRyb2wsIE1ic2NJbnB1dFNlcnZpY2UsIE1ic2NPcHRpb25zU2VydmljZSwgVmlld0NvbnRhaW5lclJlZl0pXHJcbiAgICBdLCBNYnNjTWFzcyk7XHJcbiAgICByZXR1cm4gTWJzY01hc3M7XHJcbn0oTWJzY01lYXN1cmVtZW50QmFzZSkpO1xyXG52YXIgTWJzY01hc3NDb21wb25lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NNYXNzQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY01hc3NDb21wb25lbnQoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIG51bGwpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZXJyb3JNZXNzYWdlID0gJyc7XHJcbiAgICAgICAgX3RoaXMucGxhY2Vob2xkZXIgPSAnJztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBNYnNjTWFzc0NvbXBvbmVudC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0LmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zZXRUaGVtZUNsYXNzZXMoKTtcclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdpY29uJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NNYXNzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpbnB1dEljb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ2ljb24tYWxpZ24nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY01hc3NDb21wb25lbnQucHJvdG90eXBlLCBcImljb25BbGlnblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjTWFzc0NvbXBvbmVudC5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY01hc3NDb21wb25lbnQucHJvdG90eXBlLCBcImVycm9yXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NNYXNzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlcnJvck1lc3NhZ2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY01hc3NDb21wb25lbnQucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY01hc3NDb21wb25lbnQucHJvdG90eXBlLCBcInBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjTWFzc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1tYXNzJyxcclxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IElOUFVUX1RFTVBMQVRFXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgyLCBPcHRpb25hbCgpKSwgX19wYXJhbSgzLCBPcHRpb25hbCgpKSwgX19wYXJhbSg0LCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZSwgTmdDb250cm9sLCBNYnNjSW5wdXRTZXJ2aWNlLCBNYnNjT3B0aW9uc1NlcnZpY2VdKVxyXG4gICAgXSwgTWJzY01hc3NDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIE1ic2NNYXNzQ29tcG9uZW50O1xyXG59KE1ic2NNYXNzKSk7XHJcbnZhciBjb21wJDQgPSBbXHJcbiAgICBNYnNjTWVhc3VyZW1lbnQsXHJcbiAgICBNYnNjTWVhc3VyZW1lbnRCYXNlLFxyXG4gICAgTWJzY01lYXN1cmVtZW50Q2hpbGQsXHJcbiAgICBNYnNjTWVhc3VyZW1lbnRDb21wb25lbnQsXHJcbiAgICBNYnNjVGVtcGVyYXR1cmUsXHJcbiAgICBNYnNjVGVtcGVyYXR1cmVDb21wb25lbnQsXHJcbiAgICBNYnNjRGlzdGFuY2UsXHJcbiAgICBNYnNjRGlzdGFuY2VDb21wb25lbnQsXHJcbiAgICBNYnNjU3BlZWQsXHJcbiAgICBNYnNjU3BlZWRDb21wb25lbnQsXHJcbiAgICBNYnNjRm9yY2UsXHJcbiAgICBNYnNjRm9yY2VDb21wb25lbnQsXHJcbiAgICBNYnNjTWFzcyxcclxuICAgIE1ic2NNYXNzQ29tcG9uZW50XHJcbl07XHJcbnZhciBNYnNjTWVhc3VyZW1lbnRNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWJzY01lYXN1cmVtZW50TW9kdWxlKCkge1xyXG4gICAgfVxyXG4gICAgTWJzY01lYXN1cmVtZW50TW9kdWxlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgTmdNb2R1bGUoe1xyXG4gICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBNYnNjU2Nyb2xsZXJCYXNlTW9kdWxlLCBNYnNjSW5wdXRNb2R1bGVdLFxyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IGNvbXAkNCxcclxuICAgICAgICAgICAgZXhwb3J0czogY29tcCQ0XHJcbiAgICAgICAgfSlcclxuICAgIF0sIE1ic2NNZWFzdXJlbWVudE1vZHVsZSk7XHJcbiAgICByZXR1cm4gTWJzY01lYXN1cmVtZW50TW9kdWxlO1xyXG59KCkpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbnZhciBndWlkJDEgPSAxO1xudmFyIFNjcm9sbFZpZXcgPSBmdW5jdGlvbiBTY3JvbGxWaWV3KGVsbSwgc2V0dGluZ3MsIGluaGVyaXQpIHtcbiAgdmFyICRhY3RpdmVJdGVtLFxuICAgICAgJGNvbnQsXG4gICAgICAkY3R4LFxuICAgICAgJHduZCxcbiAgICAgIGNvbnRXaWR0aCxcbiAgICAgIGl0ZW1XaWR0aCxcbiAgICAgIGlzQ2xpY2ssXG4gICAgICBvYnNlcnZlcixcbiAgICAgIG9sZFdpZHRoLFxuICAgICAgcG9zRGVib3VuY2UsXG4gICAgICBydGwsXG4gICAgICBzY3JvbGxWaWV3LFxuICAgICAgc25hcCxcbiAgICAgIHMsXG4gICAgICB0b3RhbFdpZHRoLFxuICAgICAgdG91Y2hlZCxcbiAgICAgIHRyaWdnZXIsXG4gICAgICBjc3NDbGFzc2VzID0ge30sXG4gICAgICBhbmltVGltZSA9IDEwMDAsXG4gICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICRlbG0gPSAkJDEoZWxtKTtcblxuICBmdW5jdGlvbiBvblJlc2l6ZShldikge1xuICAgIGNsZWFyVGltZW91dChwb3NEZWJvdW5jZSk7XG4gICAgcG9zRGVib3VuY2UgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHNpemUoIWV2IHx8IGV2LnR5cGUgIT09ICdsb2FkJyk7XG4gICAgfSwgMjAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ2xpY2soKSB7XG4gICAgaWYgKGlzQ2xpY2sgJiYgdGhpcy5wYXJlbnROb2RlID09PSBlbG0pIHtcbiAgICAgIG9uSXRlbVRhcCgkJDEodGhpcyksIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uSXRlbVRhcCgkaXRlbSwgdG9nZ2xlKSB7XG4gICAgaWYgKCEkaXRlbS5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2dnbGUgPSB0aGF0Ll9vbkl0ZW1UYXAoJGl0ZW0sIHRvZ2dsZSk7XG4gICAgJGFjdGl2ZUl0ZW0gPSAkaXRlbTtcblxuICAgIGlmICgkaXRlbS5wYXJlbnQoKVswXSA9PSBlbG0pIHtcbiAgICAgIHZhciBibCA9ICRpdGVtLm9mZnNldCgpLmxlZnQsXG4gICAgICAgICAgYnAgPSAkaXRlbVswXS5vZmZzZXRMZWZ0LFxuICAgICAgICAgIGJ3ID0gJGl0ZW1bMF0ub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgY2wgPSAkY29udC5vZmZzZXQoKS5sZWZ0O1xuXG4gICAgICBpZiAocnRsKSB7XG4gICAgICAgIGJwID0gdG90YWxXaWR0aCAtIGJwIC0gYnc7XG4gICAgICB9IC8vIFNjcm9sbCBpdGVtIHRvIHZpZXdcblxuXG4gICAgICBpZiAocy52YXJpYW50ID09ICdhJykge1xuICAgICAgICBpZiAoYmwgPCBjbCkge1xuICAgICAgICAgIHNjcm9sbFZpZXcuc2Nyb2xsKHJ0bCA/IGJwICsgYncgLSBjb250V2lkdGggOiAtYnAsIGFuaW1UaW1lLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChibCArIGJ3ID4gY2wgKyBjb250V2lkdGgpIHtcbiAgICAgICAgICBzY3JvbGxWaWV3LnNjcm9sbChydGwgPyBicCA6IGNvbnRXaWR0aCAtIGJwIC0gYncsIGFuaW1UaW1lLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2Nyb2xsIGl0ZW0gdG8gY2VudGVyXG4gICAgICAgIHNjcm9sbFZpZXcuc2Nyb2xsKChjb250V2lkdGggLyAyIC0gYnAgLSBidyAvIDIpICogKHJ0bCA/IC0xIDogMSksIGFuaW1UaW1lLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodG9nZ2xlKSB7XG4gICAgICAvLyBUcmlnZ2VyIHRhcCBldmVudFxuICAgICAgdHJpZ2dlcignb25JdGVtVGFwJywge1xuICAgICAgICB0YXJnZXQ6ICRpdGVtWzBdXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0TWFya3VwKCkge1xuICAgIHZhciAkZmlyc3RJdGVtLCBwcm9wcztcblxuICAgIHRoYXQuX2luaXRNYXJrdXAoJGNvbnQpO1xuXG4gICAgJGVsbS5maW5kKCcubWJzYy1yaXBwbGUnKS5yZW1vdmUoKTtcbiAgICB0aGF0Ll8kaXRlbXMgPSAkZWxtLmNoaWxkcmVuKCk7XG5cbiAgICB0aGF0Ll8kaXRlbXMuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgdmFyIGNzc0NsYXNzLFxuICAgICAgICAgICRpdGVtID0gJCQxKHRoaXMpLFxuICAgICAgICAgIHJlZiA9ICRpdGVtLmF0dHIoJ2RhdGEtcmVmJyk7XG5cbiAgICAgIGlmICghcmVmKSB7XG4gICAgICAgIHJlZiA9IGd1aWQkMSsrO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAkZmlyc3RJdGVtID0gJGl0ZW07XG4gICAgICB9XG5cbiAgICAgIGlmICghJGFjdGl2ZUl0ZW0pIHtcbiAgICAgICAgJGFjdGl2ZUl0ZW0gPSB0aGF0Ll9nZXRBY3RpdmVJdGVtKCRpdGVtKTtcbiAgICAgIH1cblxuICAgICAgcHJvcHMgPSB0aGF0Ll9nZXRJdGVtUHJvcHMoJGl0ZW0pIHx8IHt9O1xuICAgICAgY3NzQ2xhc3MgPSAnbWJzYy1zY3YtaXRlbSBtYnNjLWJ0bi1lICcgKyAocHJvcHMuY3NzQ2xhc3MgfHwgJycpO1xuICAgICAgJGl0ZW0uYXR0cignZGF0YS1yZWYnLCByZWYpLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXNbcmVmXSkuYWRkQ2xhc3MoY3NzQ2xhc3MpO1xuICAgICAgY3NzQ2xhc3Nlc1tyZWZdID0gY3NzQ2xhc3M7XG4gICAgICAvKiBUUklBTCAqL1xuICAgIH0pO1xuXG4gICAgaWYgKCEkYWN0aXZlSXRlbSkge1xuICAgICAgJGFjdGl2ZUl0ZW0gPSAkZmlyc3RJdGVtO1xuICAgIH1cblxuICAgIHRoYXQuX21hcmt1cFJlYWR5KCRjb250KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNpemUoY2hlY2ssIG5vU2Nyb2xsKSB7XG4gICAgdmFyIHcgPSBzLml0ZW1XaWR0aCxcbiAgICAgICAgbGF5b3V0ID0gcy5sYXlvdXQ7XG4gICAgdGhhdC5jb250V2lkdGggPSBjb250V2lkdGggPSAkY29udC53aWR0aCgpO1xuXG4gICAgaWYgKHRoYXQuX2NoZWNrUmVzcCgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrICYmIG9sZFdpZHRoID09PSBjb250V2lkdGggfHwgIWNvbnRXaWR0aCkge1xuICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgY29udGFpbmVyIHdpZHRoIGhhcyBub3QgY2hhbmdlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9sZFdpZHRoID0gY29udFdpZHRoO1xuXG4gICAgaWYgKGlzTnVtZXJpYyhsYXlvdXQpKSB7XG4gICAgICBpdGVtV2lkdGggPSBjb250V2lkdGggPyBjb250V2lkdGggLyBsYXlvdXQgOiB3O1xuXG4gICAgICBpZiAoaXRlbVdpZHRoIDwgdykge1xuICAgICAgICBsYXlvdXQgPSAnbGlxdWlkJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodykge1xuICAgICAgaWYgKGxheW91dCA9PSAnbGlxdWlkJykge1xuICAgICAgICAvLyBUaGUgc3BlY2lmaWVkIGl0ZW1XaWR0aCB3aWxsIGJlIGhhbmRsZWQgYXMgbWluIHdpZHRoXG4gICAgICAgIGl0ZW1XaWR0aCA9IGNvbnRXaWR0aCA/IGNvbnRXaWR0aCAvIE1hdGgubWluKE1hdGguZmxvb3IoY29udFdpZHRoIC8gdyksIHRoYXQuXyRpdGVtcy5sZW5ndGgpIDogdztcbiAgICAgIH0gZWxzZSBpZiAobGF5b3V0ID09ICdmaXhlZCcpIHtcbiAgICAgICAgLy8gRml4ZWQgd2lkdGhcbiAgICAgICAgaXRlbVdpZHRoID0gdztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGF0Ll9zaXplKGNvbnRXaWR0aCwgaXRlbVdpZHRoKTtcblxuICAgIGlmIChpdGVtV2lkdGgpIHtcbiAgICAgICRlbG0uY2hpbGRyZW4oKS5jc3MoJ3dpZHRoJywgaXRlbVdpZHRoICsgJ3B4Jyk7XG4gICAgfVxuXG4gICAgdGhhdC50b3RhbFdpZHRoID0gdG90YWxXaWR0aCA9IGVsbS5vZmZzZXRXaWR0aDtcbiAgICBleHRlbmQkMShzY3JvbGxWaWV3LnNldHRpbmdzLCB7XG4gICAgICBjb250U2l6ZTogY29udFdpZHRoLFxuICAgICAgbWF4U25hcFNjcm9sbDogcy5wYWdpbmcgPyAxIDogZmFsc2UsXG4gICAgICBtYXhTY3JvbGw6IDAsXG4gICAgICBtaW5TY3JvbGw6IHRvdGFsV2lkdGggPiBjb250V2lkdGggPyBjb250V2lkdGggLSB0b3RhbFdpZHRoIDogMCxcbiAgICAgIHNuYXA6IHMucGFnaW5nID8gY29udFdpZHRoIDogc25hcCA/IGl0ZW1XaWR0aCB8fCAnLm1ic2Mtc2N2LWl0ZW0nIDogZmFsc2UsXG4gICAgICBlbGFzdGljOiB0b3RhbFdpZHRoID4gY29udFdpZHRoID8gaXRlbVdpZHRoIHx8IGNvbnRXaWR0aCA6IGZhbHNlXG4gICAgfSk7IC8vIFBhc3MgbmV3IHZhbHVlcyB0byBzY3JvbGx2aWV3XG5cbiAgICBzY3JvbGxWaWV3LnJlZnJlc2gobm9TY3JvbGwpOyAvLyBNYWtlIHN1cmUgdGhlIGFjdGl2ZSBpdGVtIHJlbWFpbnMgdmlzaWJsZVxuXG4gICAgaWYgKCRhY3RpdmVJdGVtKSB7XG4gICAgICBvbkl0ZW1UYXAoJGFjdGl2ZUl0ZW0sIGZhbHNlKTtcbiAgICB9XG4gIH0gLy8gQ2FsbCB0aGUgcGFyZW50IGNvbnN0cnVjdG9yXG5cblxuICBCYXNlLmNhbGwodGhpcywgZWxtLCBzZXR0aW5ncywgdHJ1ZSk7XG5cbiAgdGhhdC5uYXZpZ2F0ZSA9IGZ1bmN0aW9uICgkaXRlbSwgdG9nZ2xlKSB7XG4gICAgb25JdGVtVGFwKHRoYXQuX2dldEl0ZW0oJGl0ZW0pLCB0b2dnbGUpO1xuICB9O1xuXG4gIHRoYXQubmV4dCA9IGZ1bmN0aW9uICh0b2dnbGUpIHtcbiAgICBpZiAoJGFjdGl2ZUl0ZW0pIHtcbiAgICAgIHZhciAkbmV4dCA9ICRhY3RpdmVJdGVtLm5leHQoKTtcblxuICAgICAgaWYgKCRuZXh0Lmxlbmd0aCkge1xuICAgICAgICAkYWN0aXZlSXRlbSA9ICRuZXh0O1xuICAgICAgICBvbkl0ZW1UYXAoJGFjdGl2ZUl0ZW0sIHRvZ2dsZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHRoYXQucHJldiA9IGZ1bmN0aW9uICh0b2dnbGUpIHtcbiAgICBpZiAoJGFjdGl2ZUl0ZW0pIHtcbiAgICAgIHZhciAkcHJldiA9ICRhY3RpdmVJdGVtLnByZXYoKTtcblxuICAgICAgaWYgKCRwcmV2Lmxlbmd0aCkge1xuICAgICAgICAkYWN0aXZlSXRlbSA9ICRwcmV2O1xuICAgICAgICBvbkl0ZW1UYXAoJGFjdGl2ZUl0ZW0sIHRvZ2dsZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBSZWNhbGN1bGF0ZXMgc2l6ZXMuXHJcbiAgICovXG5cblxuICB0aGF0LnJlZnJlc2ggPSB0aGF0LnBvc2l0aW9uID0gZnVuY3Rpb24gKG5vU2Nyb2xsKSB7XG4gICAgaW5pdE1hcmt1cCgpO1xuICAgIHNpemUoZmFsc2UsIG5vU2Nyb2xsKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6YXRpb24uXHJcbiAgICovXG5cblxuICB0aGF0Ll9pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb250Q2xhc3M7XG4gICAgJGN0eCA9ICQkMShzLmNvbnRleHQpO1xuICAgICR3bmQgPSAkJDEocy5jb250ZXh0ID09ICdib2R5JyA/IHdpbmRvdyA6IHMuY29udGV4dCk7XG5cbiAgICB0aGF0Ll9faW5pdCgpO1xuXG4gICAgcnRsID0gcy5ydGw7XG4gICAgc25hcCA9IHMuaXRlbVdpZHRoICYmIHMubGF5b3V0ICE9ICdmaXhlZCcgJiYgcy5zbmFwID09PSB1bmRlZmluZWQgPyB0cnVlIDogcy5zbmFwO1xuICAgIGNvbnRDbGFzcyA9ICdtYnNjLXNjdi1jIG1ic2Mtbm8tdG91Y2gnICsgJyBtYnNjLScgKyBzLnRoZW1lICsgJyAnICsgKHMuY3NzQ2xhc3MgfHwgJycpICsgJyAnICsgKHMud3JhcHBlckNsYXNzIHx8ICcnKSArIChzLmJhc2VUaGVtZSA/ICcgbWJzYy0nICsgcy5iYXNlVGhlbWUgOiAnJykgKyAocnRsID8gJyBtYnNjLXJ0bCcgOiAnIG1ic2MtbHRyJykgKyAocy5pdGVtV2lkdGggPyAnIG1ic2Mtc2N2LWhhc3cnIDogJycpICsgKHMuY29udGV4dCA9PSAnYm9keScgPyAnJyA6ICcgbWJzYy1zY3YtY3R4JykgKyAnICcgKyAodGhhdC5fZ2V0Q29udENsYXNzKCkgfHwgJycpO1xuXG4gICAgaWYgKCEkY29udCkge1xuICAgICAgJGNvbnQgPSAkJDEoJzxkaXYgY2xhc3M9XCInICsgY29udENsYXNzICsgJ1wiPjxkaXYgY2xhc3M9XCJtYnNjLXNjdi1zY1wiPjwvZGl2PjwvZGl2PicpLm9uKCdjbGljaycsICcubWJzYy1zY3YtaXRlbScsIG9uQ2xpY2spLmluc2VydEFmdGVyKCRlbG0pO1xuICAgICAgJGNvbnQuZmluZCgnLm1ic2Mtc2N2LXNjJykuYXBwZW5kKCRlbG0pOyAvLyBXaGVuIGltYWdlcyBhcmUgbG9hZGVkLCBzaXplIG1pZ3RoIGNoYW5nZVxuXG4gICAgICAkY29udC5maW5kKCdpbWcnKS5vbignbG9hZCcsIG9uUmVzaXplKTtcbiAgICAgICR3bmQub24oJ29yaWVudGF0aW9uY2hhbmdlIHJlc2l6ZScsIG9uUmVzaXplKTtcbiAgICAgIG9ic2VydmVyID0gcmVzaXplT2JzZXJ2ZXIoJGNvbnRbMF0sIG9uUmVzaXplLCBzLnpvbmUpO1xuICAgICAgc2Nyb2xsVmlldyA9IG5ldyBTY3JvbGxWaWV3QmFzZSgkY29udFswXSwge1xuICAgICAgICBheGlzOiAnWCcsXG4gICAgICAgIGNvbnRTaXplOiAwLFxuICAgICAgICBtYXhTY3JvbGw6IDAsXG4gICAgICAgIG1heFNuYXBTY3JvbGw6IDEsXG4gICAgICAgIG1pblNjcm9sbDogMCxcbiAgICAgICAgc25hcDogMSxcbiAgICAgICAgZWxhc3RpYzogMSxcbiAgICAgICAgcnRsOiBydGwsXG4gICAgICAgIG1vdXNld2hlZWw6IHMubW91c2V3aGVlbCxcbiAgICAgICAgdGhyZXNob2xkWDogcy50aHJlc2hvbGQsXG4gICAgICAgIHN0b3BQcm9wOiBzLnN0b3BQcm9wLFxuICAgICAgICBvblN0YXJ0OiBmdW5jdGlvbiBvblN0YXJ0KGV2KSB7XG4gICAgICAgICAgaWYgKGV2LmRvbUV2ZW50LnR5cGUgPT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgICAgICBpc0NsaWNrID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICghdG91Y2hlZCkge1xuICAgICAgICAgICAgICB0b3VjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgJGN0eC5maW5kKCcubWJzYy1uby10b3VjaCcpLnJlbW92ZUNsYXNzKCdtYnNjLW5vLXRvdWNoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkJ0blRhcDogZnVuY3Rpb24gb25CdG5UYXAoZXYpIHtcbiAgICAgICAgICBpc0NsaWNrID0gdHJ1ZTsgLy8gVHJpZ2dlciBjbGljayBhbmQgYWN0aXZhdGUgdGFyZ2V0LCBpZiBpdCdzIGEgZm9ybSBjb250cm9sXG5cbiAgICAgICAgICB2YXIgZG9tRXZlbnQgPSBldi5kb21FdmVudCxcbiAgICAgICAgICAgICAgdGFyZ2V0ID0gZG9tRXZlbnQudGFyZ2V0O1xuXG4gICAgICAgICAgaWYgKGRvbUV2ZW50LnR5cGUgPT09ICd0b3VjaGVuZCcgJiYgcy50YXApIHtcbiAgICAgICAgICAgIGFjdGl2YXRlQ29udHJvbCh0YXJnZXQsIGdldENvbnRyb2xUeXBlKCQkMSh0YXJnZXQpKSwgZG9tRXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25HZXN0dXJlU3RhcnQ6IGZ1bmN0aW9uIG9uR2VzdHVyZVN0YXJ0KGV2KSB7XG4gICAgICAgICAgdHJpZ2dlcignb25HZXN0dXJlU3RhcnQnLCBldik7XG4gICAgICAgIH0sXG4gICAgICAgIG9uR2VzdHVyZUVuZDogZnVuY3Rpb24gb25HZXN0dXJlRW5kKGV2KSB7XG4gICAgICAgICAgdHJpZ2dlcignb25HZXN0dXJlRW5kJywgZXYpO1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdmU6IGZ1bmN0aW9uIG9uTW92ZShldikge1xuICAgICAgICAgIHRyaWdnZXIoJ29uTW92ZScsIGV2KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25BbmltYXRpb25TdGFydDogZnVuY3Rpb24gb25BbmltYXRpb25TdGFydChldikge1xuICAgICAgICAgIHRyaWdnZXIoJ29uQW5pbWF0aW9uU3RhcnQnLCBldik7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQW5pbWF0aW9uRW5kOiBmdW5jdGlvbiBvbkFuaW1hdGlvbkVuZChldikge1xuICAgICAgICAgIHRyaWdnZXIoJ29uQW5pbWF0aW9uRW5kJywgZXYpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgJGNvbnQuYXR0cignY2xhc3MnLCBjb250Q2xhc3MpOyAvLyBSZW1vdmUgcmlwcGxlIGV2ZW50cyAoaWYgdGhlbWUgY2hhbmdlZClcblxuICAgICAgaWYgKGVsbS5fX21ic2NSaXBwbGVPZmYpIHtcbiAgICAgICAgZWxtLl9fbWJzY1JpcHBsZU9mZigpO1xuICAgICAgfVxuICAgIH0gLy8gUHJlcGFyZSBtYXJrdXBcblxuXG4gICAgJGVsbS5jc3MoJ2Rpc3BsYXknLCAnJykuYWRkQ2xhc3MoJ21ic2Mtc2N2JykucmVtb3ZlQ2xhc3MoJ21ic2MtY2xvYWsnKTtcbiAgICBpbml0TWFya3VwKCk7XG4gICAgdHJpZ2dlcignb25NYXJrdXBSZWFkeScsIHtcbiAgICAgIHRhcmdldDogJGNvbnRbMF1cbiAgICB9KTtcbiAgICBzaXplKCk7XG4gIH07XG5cbiAgdGhhdC5fc2l6ZSA9IG5vb3A7XG4gIHRoYXQuX2luaXRNYXJrdXAgPSBub29wO1xuICB0aGF0Ll9tYXJrdXBSZWFkeSA9IG5vb3A7XG4gIHRoYXQuX2dldENvbnRDbGFzcyA9IG5vb3A7XG4gIHRoYXQuX2dldEl0ZW1Qcm9wcyA9IG5vb3A7XG4gIHRoYXQuX2dldEFjdGl2ZUl0ZW0gPSBub29wO1xuICB0aGF0Ll9faW5pdCA9IG5vb3A7XG4gIHRoYXQuX19kZXN0cm95ID0gbm9vcDtcbiAgLyoqXHJcbiAgICogRGVzdHJveVxyXG4gICAqL1xuXG4gIHRoYXQuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhhdC5fX2Rlc3Ryb3koKTtcblxuICAgICR3bmQub2ZmKCdvcmllbnRhdGlvbmNoYW5nZSByZXNpemUnLCBvblJlc2l6ZSk7XG4gICAgJGVsbS5yZW1vdmVDbGFzcygnbWJzYy1zY3YnKS5pbnNlcnRBZnRlcigkY29udCkuZmluZCgnLm1ic2Mtc2N2LWl0ZW0nKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkaXRlbSA9ICQkMSh0aGlzKTtcbiAgICAgICRpdGVtLndpZHRoKCcnKS5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzWyRpdGVtLmF0dHIoJ2RhdGEtcmVmJyldKTtcbiAgICB9KTtcbiAgICAkY29udC5yZW1vdmUoKTtcbiAgICBzY3JvbGxWaWV3LmRlc3Ryb3koKTtcbiAgICBvYnNlcnZlci5kZXRhY2goKTtcbiAgfTtcblxuICB0aGF0Ll9nZXRJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAodHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnKSB7XG4gICAgICBpdGVtID0gdGhhdC5fJGl0ZW1zLmZpbHRlcignW2RhdGEtaWQ9XCInICsgaXRlbSArICdcIl0nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJCQxKGl0ZW0pO1xuICB9O1xuXG4gIHRoYXQuX29uSXRlbVRhcCA9IGZ1bmN0aW9uICgkaXRlbSwgdG9nZ2xlKSB7XG4gICAgaWYgKHRvZ2dsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9nZ2xlO1xuICB9OyAvLyAtLS1cbiAgLy8gQ29uc3RydWN0b3JcblxuXG4gIHMgPSB0aGF0LnNldHRpbmdzO1xuICB0cmlnZ2VyID0gdGhhdC50cmlnZ2VyO1xuXG4gIGlmICghaW5oZXJpdCkge1xuICAgIHRoYXQuaW5pdCgpO1xuICB9XG59OyAvLyBEZWZhdWx0c1xuXG5TY3JvbGxWaWV3LnByb3RvdHlwZSA9IHtcbiAgX2NsYXNzOiAnc2Nyb2xsdmlldycsXG4gIF9oYXNEZWY6IHRydWUsXG4gIF9oYXNUaGVtZTogdHJ1ZSxcbiAgX2hhc0xhbmc6IHRydWUsXG4gIF9yZXNwb25zaXZlOiB0cnVlLFxuICBfZGVmYXVsdHM6IHtcbiAgICB0YXA6IGhhc0dob3N0Q2xpY2ssXG4gICAgc3RvcFByb3A6IGZhbHNlLFxuICAgIGNvbnRleHQ6ICdib2R5JyxcbiAgICBsYXlvdXQ6ICdsaXF1aWQnXG4gIH1cbn07XG5jbGFzc2VzLlNjcm9sbFZpZXcgPSBTY3JvbGxWaWV3O1xuXG52YXIgTmF2aWdhdGlvbkJhc2UgPSBmdW5jdGlvbiBOYXZpZ2F0aW9uQmFzZShlbG0sIHNldHRpbmdzLCBpbmhlcml0KSB7XG4gIHZhciAkY3R4LFxuICAgICAgZGlzcGxheSxcbiAgICAgIG11bHRpcGxlLFxuICAgICAgc2VsZWN0LFxuICAgICAgc2VsZWN0ZWRDbGFzcyxcbiAgICAgIHMsXG4gICAgICAkZWxtID0gJCQxKGVsbSksXG4gICAgICB0aGF0ID0gdGhpcztcblxuICBmdW5jdGlvbiByZW1vdmVQYWdlUGFkZGluZygpIHtcbiAgICBpZiAoZGlzcGxheSAmJiBkaXNwbGF5ICE9ICdpbmxpbmUnKSB7XG4gICAgICAkY3R4LmZpbmQoJy5tYnNjLXBhZ2UnKS5jc3MoJ3BhZGRpbmctJyArIGRpc3BsYXksICcnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3RJdGVtKCRpdGVtKSB7XG4gICAgJGl0ZW0uYWRkQ2xhc3Moc2VsZWN0ZWRDbGFzcykuYXR0cignZGF0YS1zZWxlY3RlZCcsICd0cnVlJykuYXR0cignYXJpYS1zZWxlY3RlZCcsICd0cnVlJyk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXNlbGVjdEl0ZW0oJGl0ZW0pIHtcbiAgICAkaXRlbS5yZW1vdmVDbGFzcyhzZWxlY3RlZENsYXNzKS5yZW1vdmVBdHRyKCdkYXRhLXNlbGVjdGVkJykucmVtb3ZlQXR0cignYXJpYS1zZWxlY3RlZCcpO1xuICB9IC8vIENhbGwgdGhlIHBhcmVudCBjb25zdHJ1Y3RvclxuXG5cbiAgU2Nyb2xsVmlldy5jYWxsKHRoaXMsIGVsbSwgc2V0dGluZ3MsIHRydWUpO1xuXG4gIHRoYXQuc2VsZWN0ID0gZnVuY3Rpb24gKCRpdGVtKSB7XG4gICAgaWYgKCFtdWx0aXBsZSkge1xuICAgICAgZGVzZWxlY3RJdGVtKHRoYXQuXyRpdGVtcy5maWx0ZXIoJy5tYnNjLW1zLWl0ZW0tc2VsJykpO1xuICAgIH1cblxuICAgIHNlbGVjdEl0ZW0odGhhdC5fZ2V0SXRlbSgkaXRlbSkpO1xuICB9O1xuXG4gIHRoYXQuZGVzZWxlY3QgPSBmdW5jdGlvbiAoJGl0ZW0pIHtcbiAgICBkZXNlbGVjdEl0ZW0odGhhdC5fZ2V0SXRlbSgkaXRlbSkpO1xuICB9O1xuXG4gIHRoYXQuZW5hYmxlID0gZnVuY3Rpb24gKCRpdGVtKSB7XG4gICAgdGhhdC5fZ2V0SXRlbSgkaXRlbSkucmVtb3ZlQ2xhc3MoJ21ic2MtZGlzYWJsZWQnKS5yZW1vdmVBdHRyKCdkYXRhLWRpc2FibGVkJykucmVtb3ZlQXR0cignYXJpYS1kaXNhYmxlZCcpO1xuICB9O1xuXG4gIHRoYXQuZGlzYWJsZSA9IGZ1bmN0aW9uICgkaXRlbSkge1xuICAgIHRoYXQuX2dldEl0ZW0oJGl0ZW0pLmFkZENsYXNzKCdtYnNjLWRpc2FibGVkJykuYXR0cignZGF0YS1kaXNhYmxlZCcsICd0cnVlJykuYXR0cignYXJpYS1kaXNhYmxlZCcsICd0cnVlJyk7XG4gIH07XG5cbiAgdGhhdC5zZXRCYWRnZSA9IGZ1bmN0aW9uICgkaXRlbSwgY29udGVudCkge1xuICAgIHZhciAkYmFkZ2U7XG4gICAgJGl0ZW0gPSB0aGF0Ll9nZXRJdGVtKCRpdGVtKS5hdHRyKCdkYXRhLWJhZGdlJywgY29udGVudCk7XG4gICAgJGJhZGdlID0gJCQxKCcubWJzYy1tcy1iYWRnZScsICRpdGVtKTtcblxuICAgIGlmICgkYmFkZ2UubGVuZ3RoKSB7XG4gICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAkYmFkZ2UuaHRtbChjb250ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRiYWRnZS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbnRlbnQpIHtcbiAgICAgICRpdGVtLmFwcGVuZCgnPHNwYW4gY2xhc3M9XCJtYnNjLW1zLWJhZGdlXCI+JyArIGNvbnRlbnQgKyAnPC9zcGFuPicpO1xuICAgIH1cbiAgfTtcblxuICB0aGF0Ll9tYXJrdXBSZWFkeSA9IGZ1bmN0aW9uICgkY29udCkge1xuICAgIGlmICh0aGF0Ll9oYXNJY29ucykge1xuICAgICAgJGNvbnQuYWRkQ2xhc3MoJ21ic2MtbXMtaWNvbnMnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJGNvbnQucmVtb3ZlQ2xhc3MoJ21ic2MtbXMtaWNvbnMnKTtcbiAgICB9XG5cbiAgICBpZiAodGhhdC5faGFzVGV4dCkge1xuICAgICAgJGNvbnQuYWRkQ2xhc3MoJ21ic2MtbXMtdHh0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICRjb250LnJlbW92ZUNsYXNzKCdtYnNjLW1zLXR4dCcpO1xuICAgIH1cblxuICAgIHRoYXQuX19tYXJrdXBSZWFkeSgkY29udCk7XG4gIH07XG5cbiAgdGhhdC5fc2l6ZSA9IGZ1bmN0aW9uIChjb250V2lkdGgsIGl0ZW1XaWR0aCkge1xuICAgIHRoYXQuX19zaXplKGNvbnRXaWR0aCwgaXRlbVdpZHRoKTsgLy8gQWRkIHNwYWNlIHRvIHBhZ2VzIHdpdGhpbiBjb250ZXh0XG5cblxuICAgIGlmIChkaXNwbGF5ICE9ICdpbmxpbmUnKSB7XG4gICAgICAkY3R4LmZpbmQoJy5tYnNjLXBhZ2UnKS5jc3MoJ3BhZGRpbmctJyArIGRpc3BsYXksIGVsbS5vZmZzZXRIZWlnaHQgKyAncHgnKTtcbiAgICB9XG4gIH07XG5cbiAgdGhhdC5fb25JdGVtVGFwID0gZnVuY3Rpb24gKCRpdGVtLCB0b2dnbGUpIHtcbiAgICBpZiAodGhhdC5fX29uSXRlbVRhcCgkaXRlbSwgdG9nZ2xlKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodG9nZ2xlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRvZ2dsZSA9ICFtdWx0aXBsZTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0ICYmIHRvZ2dsZSAmJiAhJGl0ZW0uaGFzQ2xhc3MoJ21ic2MtZGlzYWJsZWQnKSkge1xuICAgICAgaWYgKG11bHRpcGxlKSB7XG4gICAgICAgIGlmICgkaXRlbS5hdHRyKCdkYXRhLXNlbGVjdGVkJykgPT0gJ3RydWUnKSB7XG4gICAgICAgICAgZGVzZWxlY3RJdGVtKCRpdGVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxlY3RJdGVtKCRpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVzZWxlY3RJdGVtKHRoYXQuXyRpdGVtcy5maWx0ZXIoJy5tYnNjLW1zLWl0ZW0tc2VsJykpO1xuICAgICAgICBzZWxlY3RJdGVtKCRpdGVtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdG9nZ2xlO1xuICB9O1xuXG4gIHRoYXQuX2dldEFjdGl2ZUl0ZW0gPSBmdW5jdGlvbiAoJGl0ZW0pIHtcbiAgICB2YXIgc2VsZWN0ZWQgPSAkaXRlbS5hdHRyKCdkYXRhLXNlbGVjdGVkJykgPT0gJ3RydWUnO1xuXG4gICAgaWYgKHNlbGVjdCAmJiAhbXVsdGlwbGUgJiYgc2VsZWN0ZWQpIHtcbiAgICAgIHJldHVybiAkaXRlbTtcbiAgICB9XG4gIH07XG5cbiAgdGhhdC5fZ2V0SXRlbVByb3BzID0gZnVuY3Rpb24gKCRpdGVtKSB7XG4gICAgdmFyIHNlbGVjdGVkID0gJGl0ZW0uYXR0cignZGF0YS1zZWxlY3RlZCcpID09ICd0cnVlJyxcbiAgICAgICAgZGlzYWJsZWQgPSAkaXRlbS5hdHRyKCdkYXRhLWRpc2FibGVkJykgPT0gJ3RydWUnLFxuICAgICAgICBpY29uID0gJGl0ZW0uYXR0cignZGF0YS1pY29uJyksXG4gICAgICAgIGJhZGdlID0gJGl0ZW0uYXR0cignZGF0YS1iYWRnZScpO1xuICAgICRpdGVtLmF0dHIoJ2RhdGEtcm9sZScsICdidXR0b24nKS5hdHRyKCdhcmlhLXNlbGVjdGVkJywgc2VsZWN0ZWQgPyAndHJ1ZScgOiAnZmFsc2UnKS5hdHRyKCdhcmlhLWRpc2FibGVkJywgZGlzYWJsZWQgPyAndHJ1ZScgOiAnZmFsc2UnKS5maW5kKCcubWJzYy1tcy1iYWRnZScpLnJlbW92ZSgpO1xuXG4gICAgaWYgKGJhZGdlKSB7XG4gICAgICAkaXRlbS5hcHBlbmQoJzxzcGFuIGNsYXNzPVwibWJzYy1tcy1iYWRnZVwiPicgKyBiYWRnZSArICc8L3NwYW4+Jyk7XG4gICAgfVxuXG4gICAgaWYgKGljb24pIHtcbiAgICAgIHRoYXQuX2hhc0ljb25zID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoJGl0ZW0udGV4dCgpKSB7XG4gICAgICB0aGF0Ll9oYXNUZXh0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY3NzQ2xhc3M6ICdtYnNjLW1zLWl0ZW0gJyArIChzLml0ZW1DbGFzcyB8fCAnJykgKyAnICcgKyAoc2VsZWN0ZWQgPyBzZWxlY3RlZENsYXNzIDogJycpICsgKGRpc2FibGVkID8gJyBtYnNjLWRpc2FibGVkICcgKyAocy5kaXNhYmxlZENsYXNzIHx8ICcnKSA6ICcnKSArIChpY29uID8gJyBtYnNjLW1zLWljIG1ic2MtaWMgbWJzYy1pYy0nICsgaWNvbiA6ICcnKVxuICAgIH07XG4gIH07XG5cbiAgdGhhdC5fZ2V0Q29udENsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnIG1ic2MtbXMtYyBtYnNjLW1zLScgKyBzLnZhcmlhbnQgKyAnIG1ic2MtbXMtJyArIGRpc3BsYXkgKyAoc2VsZWN0ID8gJycgOiAnIG1ic2MtbXMtbm9zZWwnKSArICh0aGF0Ll9fZ2V0Q29udENsYXNzKCkgfHwgJycpO1xuICB9O1xuXG4gIHRoYXQuX19pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoYXQuX19faW5pdCgpO1xuXG4gICAgJGN0eCA9ICQkMShzLmNvbnRleHQpOyAvLyBSZW1vdmUgb2xkIHBhZGRpbmcgZnJvbSBtYnNjLXBhZ2VcbiAgICAvLyBpZiBkaXNwbGF5IGNoYW5nZWQgZHluYW1pY2FsbHlcblxuICAgIHJlbW92ZVBhZ2VQYWRkaW5nKCk7XG4gICAgZGlzcGxheSA9IHMuZGlzcGxheTtcbiAgICBtdWx0aXBsZSA9IHMuc2VsZWN0ID09ICdtdWx0aXBsZSc7XG4gICAgc2VsZWN0ID0gcy5zZWxlY3QgIT0gJ29mZic7XG4gICAgc2VsZWN0ZWRDbGFzcyA9ICcgbWJzYy1tcy1pdGVtLXNlbCAnICsgKHMuYWN0aXZlQ2xhc3MgfHwgJycpO1xuICAgICRlbG0uYWRkQ2xhc3MoJ21ic2MtbXMgbWJzYy1tcy1iYXNlICcgKyAocy5ncm91cENsYXNzIHx8ICcnKSk7XG4gIH07XG5cbiAgdGhhdC5fX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgJGVsbS5yZW1vdmVDbGFzcygnbWJzYy1tcyBtYnNjLW1zLWJhc2UgJyArIChzLmdyb3VwQ2xhc3MgfHwgJycpKTtcbiAgICByZW1vdmVQYWdlUGFkZGluZygpO1xuXG4gICAgdGhhdC5fX19kZXN0cm95KCk7XG4gIH07XG5cbiAgdGhhdC5fX29uSXRlbVRhcCA9IG5vb3A7XG4gIHRoYXQuX19nZXRDb250Q2xhc3MgPSBub29wO1xuICB0aGF0Ll9fbWFya3VwUmVhZHkgPSBub29wO1xuICB0aGF0Ll9fc2l6ZSA9IG5vb3A7XG4gIHRoYXQuX19faW5pdCA9IG5vb3A7XG4gIHRoYXQuX19fZGVzdHJveSA9IG5vb3A7IC8vIC0tLVxuICAvLyBDb25zdHJ1Y3RvclxuXG4gIHMgPSB0aGF0LnNldHRpbmdzO1xuXG4gIGlmICghaW5oZXJpdCkge1xuICAgIHRoYXQuaW5pdCgpO1xuICB9XG59OyAvLyBEZWZhdWx0c1xuXG5OYXZpZ2F0aW9uQmFzZS5wcm90b3R5cGUgPSB7XG4gIF9kZWZhdWx0czogZXh0ZW5kJDEoe30sIFNjcm9sbFZpZXcucHJvdG90eXBlLl9kZWZhdWx0cylcbn07XG5cbnZhciBOYXZpZ2F0aW9uID0gZnVuY3Rpb24gTmF2aWdhdGlvbihlbG0sIHNldHRpbmdzKSB7XG4gIHZhciAkZWxtID0gJCQxKGVsbSksXG4gICAgICAkbWVudSxcbiAgICAgICRwb3B1cCxcbiAgICAgIG1lbnVDbGFzcyxcbiAgICAgIHMsXG4gICAgICBwb3B1cCxcbiAgICAgIGlzTGlzdCA9ICRlbG0uaXMoJ3VsLG9sJyksXG4gICAgICB0aGF0ID0gdGhpczsgLy8gQ2FsbCB0aGUgcGFyZW50IGNvbnN0cnVjdG9yXG5cbiAgTmF2aWdhdGlvbkJhc2UuY2FsbCh0aGlzLCBlbG0sIHNldHRpbmdzLCB0cnVlKTtcblxuICB0aGF0Ll9pbml0TWFya3VwID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICgkbWVudSkge1xuICAgICAgJG1lbnUucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgaWYgKCRwb3B1cCkge1xuICAgICAgJGVsbS5hcHBlbmQoJHBvcHVwLmNoaWxkcmVuKCkpO1xuICAgIH1cbiAgfTtcblxuICB0aGF0Ll9fc2l6ZSA9IGZ1bmN0aW9uIChjb250V2lkdGgsIGl0ZW1XaWR0aCkge1xuICAgIHZhciBzaG93TW9yZSxcbiAgICAgICAgc2hvd01vcmVXaWR0aCA9IGl0ZW1XaWR0aCB8fCA3MixcbiAgICAgICAgaXRlbXNOciA9IHRoYXQuXyRpdGVtcy5sZW5ndGgsXG4gICAgICAgIGl0ZW1zV2lkdGggPSAwO1xuICAgIHBvcHVwLmhpZGUoKTsgLy8gc2hvdyBtb3JlIG1lbnVcblxuICAgIGlmIChzLnR5cGUgPT0gJ2JvdHRvbScpIHtcbiAgICAgICRlbG0ucmVtb3ZlQ2xhc3MoJ21ic2Mtc2N2LWxpcScpOyAvLy5lbXB0eSgpOyAvLyBlbXB0eSBsaXN0XG5cbiAgICAgICRtZW51LnJlbW92ZSgpO1xuXG4gICAgICB0aGF0Ll8kaXRlbXMucmVtb3ZlKCkuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgJGl0ZW0gPSAkJDEodGhpcyk7XG4gICAgICAgICRlbG0uYXBwZW5kKCRpdGVtKTtcbiAgICAgICAgaXRlbXNXaWR0aCArPSBpdGVtV2lkdGggfHwgdGhpcy5vZmZzZXRXaWR0aCB8fCAwOyAvLyBpZiBuZXh0IGl0ZW0gZG9lc24ndCBmaXQsIGFkZCB0byBzaG93IG1vcmUgbWVudVxuXG4gICAgICAgIGlmIChNYXRoLnJvdW5kKGl0ZW1zV2lkdGggKyAoaSA8IGl0ZW1zTnIgLSAxID8gc2hvd01vcmVXaWR0aCA6IDApKSA+IGNvbnRXaWR0aCkge1xuICAgICAgICAgIHNob3dNb3JlID0gdHJ1ZTtcbiAgICAgICAgICAkcG9wdXAuYXBwZW5kKCRpdGVtLmNzcygnd2lkdGgnLCAnJykuYWRkQ2xhc3MoJ21ic2MtZnItYnRuLWUnKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAkbWVudS5hdHRyKCdjbGFzcycsIG1lbnVDbGFzcyArIChzLm1vcmVJY29uID8gJyBtYnNjLW1lbnUtaXRlbS1pYyBtYnNjLW1zLWljIG1ic2MtaWMgbWJzYy1pYy0nICsgcy5tb3JlSWNvbiA6ICcnKSkuaHRtbCh0aGF0Ll9oYXNJY29ucyAmJiB0aGF0Ll9oYXNUZXh0ID8gcy5tb3JlVGV4dCA6ICcnKTsgLy8gYWRkIHNob3cgbW9yZSBpdGVtIGlmIG5lZWRlZFxuXG4gICAgICBpZiAoc2hvd01vcmUpIHtcbiAgICAgICAgJGVsbS5hcHBlbmQoJG1lbnUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzLmxheW91dCA9PSAnbGlxdWlkJykge1xuICAgICAgJGVsbS5hZGRDbGFzcygnbWJzYy1zY3YtbGlxJyk7XG4gICAgfVxuICB9O1xuXG4gIHRoYXQuX19vbkl0ZW1UYXAgPSBmdW5jdGlvbiAoJGl0ZW0pIHtcbiAgICBpZiAoJGl0ZW0uaGFzQ2xhc3MoJ21ic2MtbWVudS1pdGVtJykgJiYgdGhhdC50cmlnZ2VyKCdvbk1lbnVTaG93Jywge1xuICAgICAgdGFyZ2V0OiAkaXRlbVswXSxcbiAgICAgIG1lbnU6IHBvcHVwXG4gICAgfSkgIT09IGZhbHNlKSB7XG4gICAgICBwb3B1cC5zaG93KGZhbHNlLCB0cnVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgdGhhdC5fX2dldENvbnRDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcy50eXBlID09ICdoYW1idXJnZXInID8gJyBtYnNjLW1zLWhhbWJ1cmdlcicgOiAnJztcbiAgfTtcblxuICB0aGF0Ll9fbWFya3VwUmVhZHkgPSBmdW5jdGlvbiAoJGNvbnQpIHtcbiAgICBpZiAocy50eXBlID09ICdoYW1idXJnZXInKSB7XG4gICAgICAkcG9wdXAuYXBwZW5kKHRoYXQuXyRpdGVtcy5hZGRDbGFzcygnbWJzYy1mci1idG4tZScpKTtcbiAgICAgICRtZW51LmF0dHIoJ2NsYXNzJywgbWVudUNsYXNzICsgKHMubWVudUljb24gPyAnIG1ic2MtbWVudS1pdGVtLWljIG1ic2MtbXMtaWMgbWJzYy1pYyBtYnNjLWljLScgKyBzLm1lbnVJY29uIDogJycpKS5odG1sKHMubWVudVRleHQgfHwgJycpO1xuICAgICAgJGVsbS5hcHBlbmQoJG1lbnUpO1xuXG4gICAgICBpZiAoIXMubWVudVRleHQgfHwgIXMubWVudUljb24pIHtcbiAgICAgICAgJGNvbnQucmVtb3ZlQ2xhc3MoJ21ic2MtbXMtaWNvbnMnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzLm1lbnVUZXh0KSB7XG4gICAgICAgICRjb250LnJlbW92ZUNsYXNzKCdtYnNjLW1zLXR4dCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGNvbnQuYWRkQ2xhc3MoJ21ic2MtbXMtdHh0Jyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHRoYXQuX19faW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgJHRhcmdldDtcblxuICAgIGlmIChzLnR5cGUgPT0gJ3RhYicpIHtcbiAgICAgIHMuZGlzcGxheSA9IHMuZGlzcGxheSB8fCAndG9wJztcbiAgICAgIHMudmFyaWFudCA9IHMudmFyaWFudCB8fCAnYic7XG4gICAgfSBlbHNlIGlmIChzLnR5cGUgPT0gJ2JvdHRvbScpIHtcbiAgICAgIHMuZGlzcGxheSA9IHMuZGlzcGxheSB8fCAnYm90dG9tJztcbiAgICAgIHMudmFyaWFudCA9IHMudmFyaWFudCB8fCAnYSc7XG4gICAgfSBlbHNlIGlmIChzLnR5cGUgPT0gJ2hhbWJ1cmdlcicpIHtcbiAgICAgIHMuZGlzcGxheSA9IHMuZGlzcGxheSB8fCAnaW5saW5lJztcbiAgICAgIHMudmFyaWFudCA9IHMudmFyaWFudCB8fCAnYSc7XG4gICAgfVxuXG4gICAgbWVudUNsYXNzID0gJ21ic2Mtc2N2LWl0ZW0gbWJzYy1tcy1pdGVtIG1ic2MtYnRuLWUgbWJzYy1tZW51LWl0ZW0gJyArIChzLml0ZW1DbGFzcyB8fCAnJyk7XG5cbiAgICBpZiAoISRtZW51KSB7XG4gICAgICAkbWVudSA9ICQkMShpc0xpc3QgPyAnPGxpPjwvbGk+JyA6ICc8ZGl2PjwvZGl2PicpO1xuICAgICAgJHBvcHVwID0gJCQxKGlzTGlzdCA/ICc8dWw+PC91bD4nIDogJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ21ic2Mtc2N2IG1ic2MtbXMnKTtcbiAgICB9XG5cbiAgICBwb3B1cCA9IG5ldyBQb3B1cCgkcG9wdXBbMF0sIHtcbiAgICAgIGRpc3BsYXk6ICdidWJibGUnLFxuICAgICAgdGhlbWU6IHMudGhlbWUsXG4gICAgICBsYW5nOiBzLmxhbmcsXG4gICAgICBjb250ZXh0OiBzLmNvbnRleHQsXG4gICAgICBidXR0b25zOiBbXSxcbiAgICAgIGFuY2hvcjogJG1lbnUsXG4gICAgICBvbkJlZm9yZVNob3c6IGZ1bmN0aW9uIG9uQmVmb3JlU2hvdyhldmVudCwgaW5zdCkge1xuICAgICAgICAkdGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgaW5zdC5zZXR0aW5ncy5jc3NDbGFzcyA9ICdtYnNjLXdkZyBtYnNjLW1zLWEgbWJzYy1tcy1tb3JlJyArICh0aGF0Ll9oYXNUZXh0ID8gJycgOiAnIG1ic2MtbXMtbW9yZS1pY29ucycpO1xuICAgICAgfSxcbiAgICAgIG9uQmVmb3JlQ2xvc2U6IGZ1bmN0aW9uIG9uQmVmb3JlQ2xvc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGF0LnRyaWdnZXIoJ29uTWVudUhpZGUnLCB7XG4gICAgICAgICAgdGFyZ2V0OiAkdGFyZ2V0ICYmICR0YXJnZXRbMF0sXG4gICAgICAgICAgbWVudTogcG9wdXBcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgb25NYXJrdXBSZWFkeTogZnVuY3Rpb24gb25NYXJrdXBSZWFkeShldmVudCwgaW5zdCkge1xuICAgICAgICB0aGF0LnRhcChpbnN0Ll9tYXJrdXAuZmluZCgnLm1ic2MtZnItYycpLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAkdGFyZ2V0ID0gJCQxKGV2LnRhcmdldCkuY2xvc2VzdCgnLm1ic2MtbXMtaXRlbScpO1xuXG4gICAgICAgICAgaWYgKCR0YXJnZXQubGVuZ3RoICYmICEkdGFyZ2V0Lmhhc0NsYXNzKCdtYnNjLWRpc2FibGVkJykpIHtcbiAgICAgICAgICAgIHRoYXQubmF2aWdhdGUoJHRhcmdldCwgdHJ1ZSk7XG4gICAgICAgICAgICBwb3B1cC5oaWRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB0aGF0Ll9fX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgcG9wdXAuZGVzdHJveSgpO1xuICAgICRlbG0uYXBwZW5kKHRoYXQuXyRpdGVtcyk7XG4gICAgJG1lbnUucmVtb3ZlKCk7XG4gIH07IC8vIC0tLVxuICAvLyBDb25zdHJ1Y3RvclxuXG5cbiAgcyA9IHRoYXQuc2V0dGluZ3M7XG4gIHRoYXQuaW5pdCgpO1xufTsgLy8gRGVmYXVsdHNcblxuTmF2aWdhdGlvbi5wcm90b3R5cGUgPSB7XG4gIF9jbGFzczogJ25hdmlnYXRpb24nLFxuICBfaGFzRGVmOiB0cnVlLFxuICBfaGFzVGhlbWU6IHRydWUsXG4gIF9oYXNMYW5nOiB0cnVlLFxuICBfcmVzcG9uc2l2ZTogdHJ1ZSxcbiAgX2RlZmF1bHRzOiBleHRlbmQkMSh7fSwgTmF2aWdhdGlvbkJhc2UucHJvdG90eXBlLl9kZWZhdWx0cywge1xuICAgIHR5cGU6ICdib3R0b20nLFxuICAgIG1vcmVUZXh0OiAnTW9yZScsXG4gICAgbW9yZUljb246ICdtYXRlcmlhbC1tb3JlLWhvcml6JyxcbiAgICBtZW51SWNvbjogJ21hdGVyaWFsLW1lbnUnXG4gIH0pXG59O1xuY2xhc3Nlcy5OYXZpZ2F0aW9uID0gTmF2aWdhdGlvbjtcblxudmFyIE1ic2NOb3RpZnlJdGVtU2VydmljZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNYnNjTm90aWZ5SXRlbVNlcnZpY2UoKSB7XHJcbiAgICAgICAgdGhpcy5faW5zdGFuY2VPYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKTtcclxuICAgICAgICB0aGlzLl9hZGRSZW1vdmVPYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKTtcclxuICAgICAgICB0aGlzLmluc3QgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgTWJzY05vdGlmeUl0ZW1TZXJ2aWNlLnByb3RvdHlwZS5ub3RpZnlJbnN0YW5jZVJlYWR5ID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XHJcbiAgICAgICAgdGhpcy5pbnN0ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgdGhpcy5faW5zdGFuY2VPYnNlcnZhYmxlLm5leHQoaW5zdGFuY2UpO1xyXG4gICAgfTtcclxuICAgIE1ic2NOb3RpZnlJdGVtU2VydmljZS5wcm90b3R5cGUubm90aWZ5QWRkUmVtb3ZlID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB0aGlzLl9hZGRSZW1vdmVPYnNlcnZhYmxlLm5leHQoaXRlbSk7XHJcbiAgICB9O1xyXG4gICAgTWJzY05vdGlmeUl0ZW1TZXJ2aWNlLnByb3RvdHlwZS5vbkluc3RhbmNlUmVhZHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlT2JzZXJ2YWJsZTtcclxuICAgIH07XHJcbiAgICBNYnNjTm90aWZ5SXRlbVNlcnZpY2UucHJvdG90eXBlLm9uQWRkUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRSZW1vdmVPYnNlcnZhYmxlO1xyXG4gICAgfTtcclxuICAgIE1ic2NOb3RpZnlJdGVtU2VydmljZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIEluamVjdGFibGUoKVxyXG4gICAgXSwgTWJzY05vdGlmeUl0ZW1TZXJ2aWNlKTtcclxuICAgIHJldHVybiBNYnNjTm90aWZ5SXRlbVNlcnZpY2U7XHJcbn0oKSk7XHJcbnZhciBNYnNjU2Nyb2xsSXRlbUJhc2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWJzY1Njcm9sbEl0ZW1CYXNlKG5vdGlmeUl0ZW1TZXJ2aWNlLCBfZWxlbSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5ub3RpZnlJdGVtU2VydmljZSA9IG5vdGlmeUl0ZW1TZXJ2aWNlO1xyXG4gICAgICAgIHRoaXMuX2VsZW0gPSBfZWxlbTtcclxuICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmluc3RhbmNlT2JzZXJ2ZXIgPSB0aGlzLm5vdGlmeUl0ZW1TZXJ2aWNlLm9uSW5zdGFuY2VSZWFkeSgpLnN1YnNjcmliZShmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgX3RoaXMuX2luc3RhbmNlID0gaW5zdGFuY2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKG5vdGlmeUl0ZW1TZXJ2aWNlLmluc3QpIHtcclxuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBub3RpZnlJdGVtU2VydmljZS5pbnN0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjU2Nyb2xsSXRlbUJhc2UucHJvdG90eXBlLCBcIm5hdGl2ZUVsZW1lbnRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZWxlbS5uYXRpdmVFbGVtZW50O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTWJzY1Njcm9sbEl0ZW1CYXNlLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5ub3RpZnlJdGVtU2VydmljZS5ub3RpZnlBZGRSZW1vdmUodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgTWJzY1Njcm9sbEl0ZW1CYXNlLnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLm5vdGlmeUl0ZW1TZXJ2aWNlLm9uSW5zdGFuY2VSZWFkeSgpLnVuc3Vic2NyaWJlKHRoaXMuaW5zdGFuY2VPYnNlcnZlcik7XHJcbiAgICAgICAgdGhpcy5ub3RpZnlJdGVtU2VydmljZS5ub3RpZnlBZGRSZW1vdmUodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjU2Nyb2xsSXRlbUJhc2UucHJvdG90eXBlLCBcImlkXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjU2Nyb2xsSXRlbUJhc2UgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1ttYnNjLXNpLWInIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTWJzY05vdGlmeUl0ZW1TZXJ2aWNlLCBFbGVtZW50UmVmXSlcclxuICAgIF0sIE1ic2NTY3JvbGxJdGVtQmFzZSk7XHJcbiAgICByZXR1cm4gTWJzY1Njcm9sbEl0ZW1CYXNlO1xyXG59KCkpO1xyXG52YXIgTWJzY1Njcm9sbFZpZXdCYXNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjU2Nyb2xsVmlld0Jhc2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjU2Nyb2xsVmlld0Jhc2UoaW5pdGlhbEVsZW0sIHpvbmUsIG5vdGlmeUl0ZW1TZXJ2aWNlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMubm90aWZ5SXRlbVNlcnZpY2UgPSBub3RpZnlJdGVtU2VydmljZTtcclxuICAgICAgICBfdGhpcy5vbkl0ZW1UYXAgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMub25NYXJrdXBSZWFkeSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5vbkFuaW1hdGlvblN0YXJ0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm9uQW5pbWF0aW9uRW5kID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm9uTW92ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5vbkdlc3R1cmVTdGFydCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5vbkdlc3R1cmVFbmQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjU2Nyb2xsVmlld0Jhc2UucHJvdG90eXBlLCBcImNvbnRleHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgTWJzY1Njcm9sbFZpZXdCYXNlLnByb3RvdHlwZSwgXCJpdGVtV2lkdGhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY1Njcm9sbFZpZXdCYXNlLnByb3RvdHlwZSwgXCJsYXlvdXRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NTY3JvbGxWaWV3QmFzZS5wcm90b3R5cGUsIFwibW91c2V3aGVlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY1Njcm9sbFZpZXdCYXNlLnByb3RvdHlwZSwgXCJzbmFwXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIE1ic2NTY3JvbGxWaWV3QmFzZS5wcm90b3R5cGUsIFwidGhyZXNob2xkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjU2Nyb2xsVmlld0Jhc2UucHJvdG90eXBlLCBcInBhZ2luZ1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NTY3JvbGxWaWV3QmFzZS5wcm90b3R5cGUsIFwib25JdGVtVGFwXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY1Njcm9sbFZpZXdCYXNlLnByb3RvdHlwZSwgXCJvbk1hcmt1cFJlYWR5XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY1Njcm9sbFZpZXdCYXNlLnByb3RvdHlwZSwgXCJvbkFuaW1hdGlvblN0YXJ0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY1Njcm9sbFZpZXdCYXNlLnByb3RvdHlwZSwgXCJvbkFuaW1hdGlvbkVuZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NTY3JvbGxWaWV3QmFzZS5wcm90b3R5cGUsIFwib25Nb3ZlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY1Njcm9sbFZpZXdCYXNlLnByb3RvdHlwZSwgXCJvbkdlc3R1cmVTdGFydFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NTY3JvbGxWaWV3QmFzZS5wcm90b3R5cGUsIFwib25HZXN0dXJlRW5kXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjU2Nyb2xsVmlld0Jhc2UgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1ttYnNjLXMtYicgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBOZ1pvbmUsIE1ic2NOb3RpZnlJdGVtU2VydmljZV0pXHJcbiAgICBdLCBNYnNjU2Nyb2xsVmlld0Jhc2UpO1xyXG4gICAgcmV0dXJuIE1ic2NTY3JvbGxWaWV3QmFzZTtcclxufShNYnNjQmFzZSkpO1xyXG52YXIgTWJzY1Njcm9sbFZpZXdCYXNlTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1ic2NTY3JvbGxWaWV3QmFzZU1vZHVsZSgpIHtcclxuICAgIH1cclxuICAgIE1ic2NTY3JvbGxWaWV3QmFzZU1vZHVsZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE5nTW9kdWxlKHtcclxuICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgTWJzY0Jhc2VNb2R1bGVdLFxyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNYnNjU2Nyb2xsSXRlbUJhc2UsIE1ic2NTY3JvbGxWaWV3QmFzZV0sXHJcbiAgICAgICAgfSlcclxuICAgIF0sIE1ic2NTY3JvbGxWaWV3QmFzZU1vZHVsZSk7XHJcbiAgICByZXR1cm4gTWJzY1Njcm9sbFZpZXdCYXNlTW9kdWxlO1xyXG59KCkpO1xuXG52YXIgTWJzY05hdkl0ZW1CYXNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjTmF2SXRlbUJhc2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjTmF2SXRlbUJhc2Uobm90aWZ5SXRlbVNlcnZpY2UsIGVsZW0pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBub3RpZnlJdGVtU2VydmljZSwgZWxlbSkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5zZWxlY3RlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY05hdkl0ZW1CYXNlLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSB2O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9kaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLmRpc2FibGUodGhpcy5fZWxlbS5uYXRpdmVFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLmVuYWJsZSh0aGlzLl9lbGVtLm5hdGl2ZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY05hdkl0ZW1CYXNlLnByb3RvdHlwZSwgXCJzZWxlY3RlZFwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSB2O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLnNlbGVjdCh0aGlzLl9lbGVtLm5hdGl2ZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UuZGVzZWxlY3QodGhpcy5fZWxlbS5uYXRpdmVFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTWJzY05hdkl0ZW1CYXNlLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSAhdGhpcy5fc2VsZWN0ZWQ7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZS5lbWl0KHRoaXMuX3NlbGVjdGVkKTtcclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NOYXZJdGVtQmFzZS5wcm90b3R5cGUsIFwiaWNvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxyXG4gICAgXSwgTWJzY05hdkl0ZW1CYXNlLnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCBudWxsKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcclxuICAgIF0sIE1ic2NOYXZJdGVtQmFzZS5wcm90b3R5cGUsIFwic2VsZWN0ZWRcIiwgbnVsbCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY05hdkl0ZW1CYXNlLnByb3RvdHlwZSwgXCJzZWxlY3RlZENoYW5nZVwiLCB2b2lkIDApO1xyXG4gICAgTWJzY05hdkl0ZW1CYXNlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbWJzYy1uaS1iJyB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW01ic2NOb3RpZnlJdGVtU2VydmljZSwgRWxlbWVudFJlZl0pXHJcbiAgICBdLCBNYnNjTmF2SXRlbUJhc2UpO1xyXG4gICAgcmV0dXJuIE1ic2NOYXZJdGVtQmFzZTtcclxufShNYnNjU2Nyb2xsSXRlbUJhc2UpKTtcclxudmFyIE1ic2NOYXZpZ2F0aW9uQmFzZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY05hdmlnYXRpb25CYXNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY05hdmlnYXRpb25CYXNlKGluaXRpYWxFbGVtLCB6b25lLCBub3RpZnlJdGVtU2VydmljZSkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgbm90aWZ5SXRlbVNlcnZpY2UpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBNYnNjTmF2aWdhdGlvbkJhc2UucHJvdG90eXBlLnRhcEhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQsIGluc3QpIHtcclxuICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3QgfHwgKGluc3QgJiYgaW5zdC5zZXR0aW5ncy5zZWxlY3QpO1xyXG4gICAgICAgIHN3aXRjaCAoc2VsZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ211bHRpcGxlJzoge1xyXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9nZXRJdGVtKGV2ZW50LnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICBpdGVtLnRvZ2dsZSgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAnc2luZ2xlJzoge1xyXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9nZXRJdGVtKGV2ZW50LnRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSAmJiAhaXRlbS5zZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5zZWxlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50b2dnbGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udG9nZ2xlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZXZlbnQuaW5zdCA9IGluc3Q7XHJcbiAgICAgICAgdGhpcy5vbkl0ZW1UYXAuZW1pdChldmVudCk7XHJcbiAgICB9O1xyXG4gICAgTWJzY05hdmlnYXRpb25CYXNlLnByb3RvdHlwZS5fZ2V0SXRlbSA9IGZ1bmN0aW9uIChuYXRpdmVFbCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmZpbmQoZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGl0ZW0ubmF0aXZlRWxlbWVudCA9PT0gbmF0aXZlRWw7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjTmF2aWdhdGlvbkJhc2UucHJvdG90eXBlLCBcImRpc3BsYXlcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ29wdGlvbnMnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY05hdmlnYXRpb25CYXNlLnByb3RvdHlwZSwgXCJvcHRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb250ZW50Q2hpbGRyZW4oTWJzY05hdkl0ZW1CYXNlKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxyXG4gICAgXSwgTWJzY05hdmlnYXRpb25CYXNlLnByb3RvdHlwZSwgXCJpdGVtc1wiLCB2b2lkIDApO1xyXG4gICAgTWJzY05hdmlnYXRpb25CYXNlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbWJzYy1uLWInIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLCBNYnNjTm90aWZ5SXRlbVNlcnZpY2VdKVxyXG4gICAgXSwgTWJzY05hdmlnYXRpb25CYXNlKTtcclxuICAgIHJldHVybiBNYnNjTmF2aWdhdGlvbkJhc2U7XHJcbn0oTWJzY1Njcm9sbFZpZXdCYXNlKSk7XHJcbnZhciBNYnNjTmF2aWdhdGlvbkJhc2VNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWJzY05hdmlnYXRpb25CYXNlTW9kdWxlKCkge1xyXG4gICAgfVxyXG4gICAgTWJzY05hdmlnYXRpb25CYXNlTW9kdWxlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgTmdNb2R1bGUoe1xyXG4gICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBNYnNjU2Nyb2xsVmlld0Jhc2VNb2R1bGVdLFxyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNYnNjTmF2aWdhdGlvbkJhc2UsIE1ic2NOYXZJdGVtQmFzZV0sXHJcbiAgICAgICAgfSlcclxuICAgIF0sIE1ic2NOYXZpZ2F0aW9uQmFzZU1vZHVsZSk7XHJcbiAgICByZXR1cm4gTWJzY05hdmlnYXRpb25CYXNlTW9kdWxlO1xyXG59KCkpO1xuXG52YXIgTWJzY05hdkl0ZW0gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NOYXZJdGVtLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY05hdkl0ZW0obm90aWZ5SXRlbVNlcnZpY2UsIGVsZW0sIGluaiwgcm91dGVyVG9rZW4pIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBub3RpZnlJdGVtU2VydmljZSwgZWxlbSkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5pbmogPSBpbmo7XHJcbiAgICAgICAgX3RoaXMucm91dGVyTGlua0FjdGl2ZU9wdGlvbnMgPSB7IGV4YWN0OiBmYWxzZSB9O1xyXG4gICAgICAgIF90aGlzLmluc3RPYnNlcnZlciA9IG5vdGlmeUl0ZW1TZXJ2aWNlLm9uSW5zdGFuY2VSZWFkeSgpLnN1YnNjcmliZShmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgaWYgKF90aGlzLmluaXRpYWxCYWRnZSkge1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uuc2V0QmFkZ2UoX3RoaXMubmF0aXZlRWxlbWVudCwgX3RoaXMuaW5pdGlhbEJhZGdlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChyb3V0ZXJUb2tlbikge1xyXG4gICAgICAgICAgICBfdGhpcy5pbmplY3RlZFJvdXRlciA9IHJvdXRlclRva2VuO1xyXG4gICAgICAgICAgICBfdGhpcy5hY3RpdmF0ZWRSb3V0ZSA9IF90aGlzLmluai5nZXQoX3RoaXMuaW5qZWN0ZWRSb3V0ZXIucm91dGVyU3RhdGUucm9vdC5fX3Byb3RvX18uY29uc3RydWN0b3IsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX3RoaXMuaW5qZWN0ZWRSb3V0ZXIpIHtcclxuICAgICAgICAgICAgX3RoaXMuaW5qZWN0ZWRSb3V0ZXIuZXZlbnRzLnN1YnNjcmliZShmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5kZWJvdW5jZUhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZGVib3VuY2VIYW5kbGVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2hlY2tTZWxlY3RlZCgpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY05hdkl0ZW0ucHJvdG90eXBlLCBcImJhZGdlXCIsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChiYWRnZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLnNldEJhZGdlKHRoaXMubmF0aXZlRWxlbWVudCwgYmFkZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsQmFkZ2UgPSBiYWRnZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTWJzY05hdkl0ZW0ucHJvdG90eXBlLmNoZWNrU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5qZWN0ZWRSb3V0ZXIgJiYgdGhpcy5yb3V0ZXJMaW5rICE9PSBudWxsICYmIHRoaXMucm91dGVyTGluayAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHZhciBjb21tYW5kcyA9IEFycmF5LmlzQXJyYXkodGhpcy5yb3V0ZXJMaW5rKSA/IHRoaXMucm91dGVyTGluayA6IFt0aGlzLnJvdXRlckxpbmtdO1xyXG4gICAgICAgICAgICB2YXIgdXJsVHJlZSA9IHRoaXMuaW5qZWN0ZWRSb3V0ZXIuY3JlYXRlVXJsVHJlZShjb21tYW5kcywgeyByZWxhdGl2ZVRvOiB0aGlzLmFjdGl2YXRlZFJvdXRlIH0pO1xyXG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSB0aGlzLmluamVjdGVkUm91dGVyLmlzQWN0aXZlKHVybFRyZWUsIHRoaXMucm91dGVyTGlua0FjdGl2ZU9wdGlvbnMuZXhhY3QpO1xyXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkID0gc2VsZWN0ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5zZWxlY3QodGhpcy5fZWxlbS5uYXRpdmVFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLmRlc2VsZWN0KHRoaXMuX2VsZW0ubmF0aXZlRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTWJzY05hdkl0ZW0ucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMubm90aWZ5SXRlbVNlcnZpY2Uub25JbnN0YW5jZVJlYWR5KCkudW5zdWJzY3JpYmUodGhpcy5pbnN0T2JzZXJ2ZXIpO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdPbkRlc3Ryb3kuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxyXG4gICAgXSwgTWJzY05hdkl0ZW0ucHJvdG90eXBlLCBcImJhZGdlXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjTmF2SXRlbS5wcm90b3R5cGUsIFwicm91dGVyTGlua1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjTmF2SXRlbS5wcm90b3R5cGUsIFwicm91dGVyTGlua0FjdGl2ZU9wdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NOYXZJdGVtID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLW5hdi1pdGVtJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcclxuICAgICAgICAgICAgaG9zdDoge1xyXG4gICAgICAgICAgICAgICAgJ1thdHRyLmRhdGEtaWNvbl0nOiAnaWNvbicsXHJcbiAgICAgICAgICAgICAgICAnW2F0dHIuZGF0YS1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxyXG4gICAgICAgICAgICAgICAgJ1thdHRyLmRhdGEtc2VsZWN0ZWRdJzogJ3NlbGVjdGVkJyxcclxuICAgICAgICAgICAgICAgICdbYXR0ci5kYXRhLWlkXSc6ICdpZCdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtNYnNjTm90aWZ5SXRlbVNlcnZpY2UsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBNYnNjUm91dGVyVG9rZW5dKVxyXG4gICAgXSwgTWJzY05hdkl0ZW0pO1xyXG4gICAgcmV0dXJuIE1ic2NOYXZJdGVtO1xyXG59KE1ic2NOYXZJdGVtQmFzZSkpO1xyXG52YXIgTWJzY05hdiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY05hdiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NOYXYoaW5pdGlhbEVsZW0sIHpvbmUsIG5vdGlmeUl0ZW1TZXJ2aWNlLCBvcHRpb25TZXJ2aWNlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIG5vdGlmeUl0ZW1TZXJ2aWNlKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLm9wdGlvblNlcnZpY2UgPSBvcHRpb25TZXJ2aWNlO1xyXG4gICAgICAgIF90aGlzLnNlbGVjdCA9ICdzaW5nbGUnO1xyXG4gICAgICAgIF90aGlzLm9uTWVudUhpZGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMub25NZW51U2hvdyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBNYnNjTmF2LnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBvbkl0ZW1UYXAgPSB0aGlzLnRhcEhhbmRsZXIuYmluZCh0aGlzKTtcclxuICAgICAgICB2YXIgb25JdGVtVGFwVXNlciA9IHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMub25JdGVtVGFwO1xyXG4gICAgICAgIGlmIChvbkl0ZW1UYXBVc2VyKSB7XHJcbiAgICAgICAgICAgIG9uSXRlbVRhcCA9IGZ1bmN0aW9uIChldmVudCwgaW5zdCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudGFwSGFuZGxlcihldmVudCwgaW5zdCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb25JdGVtVGFwVXNlcihldmVudCwgaW5zdCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvcHRpb25zID0gZXh0ZW5kJDEoeyB0eXBlOiB0aGlzLnR5cGUgfSwgdGhpcy5vcHRpb25TZXJ2aWNlID8gdGhpcy5vcHRpb25TZXJ2aWNlLm9wdGlvbnMgOiB7fSwgdGhpcy5vcHRpb25zLCB0aGlzLmlubGluZU9wdGlvbnNPYmosIHsgb25JdGVtVGFwOiBvbkl0ZW1UYXAgfSk7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBOYXZpZ2F0aW9uKHRoaXMuaW5pdGlhbEVsZW0ubmF0aXZlRWxlbWVudCwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5ub3RpZnlJdGVtU2VydmljZS5ub3RpZnlJbnN0YW5jZVJlYWR5KHRoaXMuaW5zdGFuY2UpO1xyXG4gICAgICAgIHRoaXMuYWRkUmVtb3ZlT2JzZXJ2ZXIgPSB0aGlzLm5vdGlmeUl0ZW1TZXJ2aWNlLm9uQWRkUmVtb3ZlKCkuc3Vic2NyaWJlKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmluc3RhbmNlLnJlZnJlc2goKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBNYnNjTmF2LnByb3RvdHlwZS5uZ09uRGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLm5vdGlmeUl0ZW1TZXJ2aWNlLm9uQWRkUmVtb3ZlKCkudW5zdWJzY3JpYmUodGhpcy5hZGRSZW1vdmVPYnNlcnZlcik7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ09uRGVzdHJveS5jYWxsKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY05hdi5wcm90b3R5cGUsIFwibW9yZVRleHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY05hdi5wcm90b3R5cGUsIFwibW9yZUljb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY05hdi5wcm90b3R5cGUsIFwibWVudVRleHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY05hdi5wcm90b3R5cGUsIFwibWVudUljb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjTmF2LnByb3RvdHlwZSwgXCJvbk1lbnVIaWRlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY05hdi5wcm90b3R5cGUsIFwib25NZW51U2hvd1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29udGVudENoaWxkcmVuKE1ic2NOYXZJdGVtKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxyXG4gICAgXSwgTWJzY05hdi5wcm90b3R5cGUsIFwiaXRlbXNcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NOYXYgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtbmF2JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcclxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbTWJzY05vdGlmeUl0ZW1TZXJ2aWNlXSxcclxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJyxcclxuICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWJzYy1jbG9haycgfVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBOZ1pvbmUsIE1ic2NOb3RpZnlJdGVtU2VydmljZSwgTWJzY09wdGlvbnNTZXJ2aWNlXSlcclxuICAgIF0sIE1ic2NOYXYpO1xyXG4gICAgcmV0dXJuIE1ic2NOYXY7XHJcbn0oTWJzY05hdmlnYXRpb25CYXNlKSk7XHJcbnZhciBNYnNjQm90dG9tTmF2ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjQm90dG9tTmF2LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY0JvdHRvbU5hdihpbml0aWFsRWxlbSwgem9uZSwgbmF2SXRlbVNlcnZpY2UsIG9wdGlvblNlcnZpY2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgbmF2SXRlbVNlcnZpY2UsIG9wdGlvblNlcnZpY2UpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMudHlwZSA9ICdib3R0b20nO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE1ic2NCb3R0b21OYXYgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtYm90dG9tLW5hdicsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXHJcbiAgICAgICAgICAgIHByb3ZpZGVyczogW01ic2NOb3RpZnlJdGVtU2VydmljZV0sXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXHJcbiAgICAgICAgICAgIGhvc3Q6IHsgJ2NsYXNzJzogJ21ic2MtY2xvYWsnIH1cclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDMsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLCBNYnNjTm90aWZ5SXRlbVNlcnZpY2UsIE1ic2NPcHRpb25zU2VydmljZV0pXHJcbiAgICBdLCBNYnNjQm90dG9tTmF2KTtcclxuICAgIHJldHVybiBNYnNjQm90dG9tTmF2O1xyXG59KE1ic2NOYXYpKTtcclxudmFyIE1ic2NIYW1idXJnZXJOYXYgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NIYW1idXJnZXJOYXYsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjSGFtYnVyZ2VyTmF2KGluaXRpYWxFbGVtLCB6b25lLCBuYXZJdGVtU2VydmljZSwgb3B0aW9uU2VydmljZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBuYXZJdGVtU2VydmljZSwgb3B0aW9uU2VydmljZSkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy50eXBlID0gJ2hhbWJ1cmdlcic7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgTWJzY0hhbWJ1cmdlck5hdiA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1oYW1idXJnZXItbmF2JyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcclxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbTWJzY05vdGlmeUl0ZW1TZXJ2aWNlXSxcclxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJyxcclxuICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWJzYy1jbG9haycgfVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBOZ1pvbmUsIE1ic2NOb3RpZnlJdGVtU2VydmljZSwgTWJzY09wdGlvbnNTZXJ2aWNlXSlcclxuICAgIF0sIE1ic2NIYW1idXJnZXJOYXYpO1xyXG4gICAgcmV0dXJuIE1ic2NIYW1idXJnZXJOYXY7XHJcbn0oTWJzY05hdikpO1xyXG52YXIgTWJzY1RhYk5hdiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY1RhYk5hdiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NUYWJOYXYoaW5pdGlhbEVsZW0sIHpvbmUsIG5hdkl0ZW1TZXJ2aWNlLCBvcHRpb25TZXJ2aWNlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIG5hdkl0ZW1TZXJ2aWNlLCBvcHRpb25TZXJ2aWNlKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnR5cGUgPSAndGFiJztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBNYnNjVGFiTmF2ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLXRhYi1uYXYnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxyXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtNYnNjTm90aWZ5SXRlbVNlcnZpY2VdLFxyXG4gICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnLFxyXG4gICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYnNjLWNsb2FrJyB9XHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgzLCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZSwgTWJzY05vdGlmeUl0ZW1TZXJ2aWNlLCBNYnNjT3B0aW9uc1NlcnZpY2VdKVxyXG4gICAgXSwgTWJzY1RhYk5hdik7XHJcbiAgICByZXR1cm4gTWJzY1RhYk5hdjtcclxufShNYnNjTmF2KSk7XHJcbnZhciBjb21wcyA9IFtcclxuICAgIE1ic2NOYXZJdGVtLFxyXG4gICAgTWJzY05hdixcclxuICAgIE1ic2NCb3R0b21OYXYsXHJcbiAgICBNYnNjSGFtYnVyZ2VyTmF2LFxyXG4gICAgTWJzY1RhYk5hdlxyXG5dO1xyXG52YXIgTWJzY05hdmlnYXRpb25Nb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWJzY05hdmlnYXRpb25Nb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBNYnNjTmF2aWdhdGlvbk1vZHVsZV8xID0gTWJzY05hdmlnYXRpb25Nb2R1bGU7XHJcbiAgICBNYnNjTmF2aWdhdGlvbk1vZHVsZS5mb3JSb290ID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG5nTW9kdWxlOiBNYnNjTmF2aWdhdGlvbk1vZHVsZV8xLFxyXG4gICAgICAgICAgICBwcm92aWRlcnM6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogTWJzY1JvdXRlclRva2VuLFxyXG4gICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBjb25maWcuYW5ndWxhclJvdXRlclxyXG4gICAgICAgICAgICAgICAgfV1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIHZhciBNYnNjTmF2aWdhdGlvbk1vZHVsZV8xO1xyXG4gICAgTWJzY05hdmlnYXRpb25Nb2R1bGUgPSBNYnNjTmF2aWdhdGlvbk1vZHVsZV8xID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgTmdNb2R1bGUoe1xyXG4gICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBNYnNjTmF2aWdhdGlvbkJhc2VNb2R1bGVdLFxyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IGNvbXBzLFxyXG4gICAgICAgICAgICBleHBvcnRzOiBjb21wc1xyXG4gICAgICAgIH0pXHJcbiAgICBdLCBNYnNjTmF2aWdhdGlvbk1vZHVsZSk7XHJcbiAgICByZXR1cm4gTWJzY05hdmlnYXRpb25Nb2R1bGU7XHJcbn0oKSk7XG5cbnZhciBOdW1iZXJTY3JvbGxlciA9IE1lYXN1cmVtZW50O1xucHJlc2V0cy5udW1iZXIgPSBwcmVzZXRzLm1lYXN1cmVtZW50O1xuXG52YXIgTWJzY051bWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY051bWJlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NOdW1iZXIoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMub3B0aW9uU2VydmljZSA9IG9wdGlvblNlcnZpY2U7XHJcbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY051bWJlci5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTWJzY051bWJlci5wcm90b3R5cGUuc2V0TmV3VmFsdWUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHZhciBpbm5lclZhbHVlID0gdGhpcy5pbnN0YW5jZS5nZXRWYWwoKTtcclxuICAgICAgICAgICAgaWYgKGlubmVyVmFsdWUgIT09IHYpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0VmFsKHYsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbnB1dFNlcnZpY2UgJiYgdGhpcy5faW5wdXRTZXJ2aWNlLmlucHV0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5wdXRTZXJ2aWNlLmlucHV0LmlubmVyVmFsdWUgPSB0aGlzLmluc3RhbmNlLl92YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNYnNjTnVtYmVyLnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHsgcHJlc2V0OiAnbnVtYmVyJyB9LCB0aGlzLm9wdGlvblNlcnZpY2UgPyB0aGlzLm9wdGlvblNlcnZpY2Uub3B0aW9ucyA6IHt9LCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaiwgdGhpcy5vcHRpb25FeHRlbnNpb25zKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IE51bWJlclNjcm9sbGVyKHRoaXMuZWxlbWVudCwgb3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodGhpcy5pbml0aWFsVmFsdWUsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjTnVtYmVyLnByb3RvdHlwZSwgXCJkZWNpbWFsU2VwYXJhdG9yXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NOdW1iZXIucHJvdG90eXBlLCBcImRlZmF1bHRWYWx1ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIE1ic2NOdW1iZXIucHJvdG90eXBlLCBcImludmFsaWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgTWJzY051bWJlci5wcm90b3R5cGUsIFwibWF4XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIE1ic2NOdW1iZXIucHJvdG90eXBlLCBcIm1pblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBNYnNjTnVtYmVyLnByb3RvdHlwZSwgXCJzY2FsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBNYnNjTnVtYmVyLnByb3RvdHlwZSwgXCJzdGVwXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NOdW1iZXIucHJvdG90eXBlLCBcIndob2xlVGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjTnVtYmVyLnByb3RvdHlwZSwgXCJmcmFjdGlvblRleHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY051bWJlci5wcm90b3R5cGUsIFwic2lnblRleHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ21ic2Mtb3B0aW9ucycpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjTnVtYmVyLnByb3RvdHlwZSwgXCJvcHRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdtYnNjLW51bWJlcicpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcclxuICAgIF0sIE1ic2NOdW1iZXIucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCdtYnNjLW51bWJlckNoYW5nZScpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjTnVtYmVyLnByb3RvdHlwZSwgXCJvbkNoYW5nZUVtaXR0ZXJcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NOdW1iZXIgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBEaXJlY3RpdmUoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ1ttYnNjLW51bWJlcl0nLFxyXG4gICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgyLCBPcHRpb25hbCgpKSwgX19wYXJhbSgzLCBPcHRpb25hbCgpKSwgX19wYXJhbSg0LCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZSwgTmdDb250cm9sLCBNYnNjSW5wdXRTZXJ2aWNlLCBNYnNjT3B0aW9uc1NlcnZpY2UsIFZpZXdDb250YWluZXJSZWZdKVxyXG4gICAgXSwgTWJzY051bWJlcik7XHJcbiAgICByZXR1cm4gTWJzY051bWJlcjtcclxufShNYnNjU2Nyb2xsZXJCYXNlKSk7XHJcbnZhciBNYnNjTnVtYmVyQ29tcG9uZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjTnVtYmVyQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY051bWJlckNvbXBvbmVudChpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgbnVsbCkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5lcnJvck1lc3NhZ2UgPSAnJztcclxuICAgICAgICBfdGhpcy5wbGFjZWhvbGRlciA9ICcnO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE1ic2NOdW1iZXJDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2V0VGhlbWVDbGFzc2VzKCk7XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnaWNvbicpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjTnVtYmVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpbnB1dEljb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ2ljb24tYWxpZ24nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY051bWJlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaWNvbkFsaWduXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NOdW1iZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NOdW1iZXJDb21wb25lbnQucHJvdG90eXBlLCBcImVycm9yXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NOdW1iZXJDb21wb25lbnQucHJvdG90eXBlLCBcImVycm9yTWVzc2FnZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjTnVtYmVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvcHRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NOdW1iZXJDb21wb25lbnQucHJvdG90eXBlLCBcInBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjTnVtYmVyQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLW51bWJlcicsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBJTlBVVF9URU1QTEFURVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMiwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksIF9fcGFyYW0oNCwgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBOZ1pvbmUsIE5nQ29udHJvbCwgTWJzY0lucHV0U2VydmljZSwgTWJzY09wdGlvbnNTZXJ2aWNlXSlcclxuICAgIF0sIE1ic2NOdW1iZXJDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIE1ic2NOdW1iZXJDb21wb25lbnQ7XHJcbn0oTWJzY051bWJlcikpO1xyXG52YXIgTWJzY051bWJlck1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNYnNjTnVtYmVyTW9kdWxlKCkge1xyXG4gICAgfVxyXG4gICAgTWJzY051bWJlck1vZHVsZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE5nTW9kdWxlKHtcclxuICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgTWJzY1Njcm9sbGVyQmFzZU1vZHVsZSwgTWJzY0lucHV0TW9kdWxlXSxcclxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWJzY051bWJlciwgTWJzY051bWJlckNvbXBvbmVudF0sXHJcbiAgICAgICAgICAgIGV4cG9ydHM6IFtNYnNjTnVtYmVyLCBNYnNjTnVtYmVyQ29tcG9uZW50XVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBNYnNjTnVtYmVyTW9kdWxlKTtcclxuICAgIHJldHVybiBNYnNjTnVtYmVyTW9kdWxlO1xyXG59KCkpO1xuXG52YXIgcHJlc2V0cyQxID0ge307XG52YXIgTnVtcGFkID0gZnVuY3Rpb24gTnVtcGFkKGVsLCBzZXR0aW5ncywgaW5oZXJpdCkge1xuICB2YXIgJG1hcmt1cCxcbiAgICAgIGRlbGV0ZUJ0bixcbiAgICAgIGRpc2FibGVkQ2xhc3MsXG4gICAgICBwaCxcbiAgICAgIHBvcyxcbiAgICAgIHMsXG4gICAgICBtYXNrLFxuICAgICAgc1gsXG4gICAgICBzWSxcbiAgICAgIGVYLFxuICAgICAgZVksXG4gICAgICBkaWZmWCxcbiAgICAgIGRpZmZZLFxuICAgICAgYWN0aW9uLFxuICAgICAgaW50ZXJ2YWwsXG4gICAgICB0ZW1wVmFsdWVBcnJheSxcbiAgICAgIHRlbXBUb3RhbCxcbiAgICAgIHRyaWdnZXIsXG4gICAgICB0b3RhbCxcbiAgICAgIHZhbHVlQXJyYXksXG4gICAgICAkZWxtID0gJCQxKGVsKSxcbiAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgYWN0aW9ucyA9IFtdLFxuICAgICAgdGVtcEFjdGlvbnMgPSBbXSxcbiAgICAgIHRlbXBWYXJpYWJsZXMgPSB7fSxcbiAgICAgIHZhcmlhYmxlcyA9IHt9LFxuICAgICAgY3VzdG9tS2V5cyA9IHt9LFxuICAgICAgbnVtZXJpY0tleXMgPSB7XG4gICAgNDg6IDAsXG4gICAgNDk6IDEsXG4gICAgNTA6IDIsXG4gICAgNTE6IDMsXG4gICAgNTI6IDQsXG4gICAgNTM6IDUsXG4gICAgNTQ6IDYsXG4gICAgNTU6IDcsXG4gICAgNTY6IDgsXG4gICAgNTc6IDksXG4gICAgOTY6IDAsXG4gICAgOTc6IDEsXG4gICAgOTg6IDIsXG4gICAgOTk6IDMsXG4gICAgMTAwOiA0LFxuICAgIDEwMTogNSxcbiAgICAxMDI6IDYsXG4gICAgMTAzOiA3LFxuICAgIDEwNDogOCxcbiAgICAxMDU6IDlcbiAgfTtcblxuICBmdW5jdGlvbiBkaXNwbGF5KG1hbnVhbCkge1xuICAgIC8vIFZhbGlkYXRlXG4gICAgdmFyIGksXG4gICAgICAgIHJldCA9IHMudmFsaWRhdGUuY2FsbChlbCwge1xuICAgICAgdmFsdWVzOiB0ZW1wVmFsdWVBcnJheS5zbGljZSgwKSxcbiAgICAgIHZhcmlhYmxlczogdGVtcFZhcmlhYmxlc1xuICAgIH0sIHRoYXQpIHx8IFtdLFxuICAgICAgICBkaXNhYmxlZCA9IHJldCAmJiByZXQuZGlzYWJsZWQgfHwgW107XG4gICAgdGhhdC5faXNWYWxpZCA9IHJldC5pbnZhbGlkID8gZmFsc2UgOiB0cnVlOyAvLyBHZW5lcmF0ZSBmb3JtYXR0ZWQgdmFsdWVcblxuICAgIHRoYXQuX3RlbXBWYWx1ZSA9IHMuZm9ybWF0VmFsdWUuY2FsbChlbCwgdGVtcFZhbHVlQXJyYXkuc2xpY2UoMCksIHRlbXBWYXJpYWJsZXMsIHRoYXQpO1xuICAgIHBvcyA9IHRlbXBWYWx1ZUFycmF5Lmxlbmd0aDtcbiAgICB0ZW1wVG90YWwgPSByZXQubGVuZ3RoIHx8IHRvdGFsO1xuXG4gICAgaWYgKHRoYXQuX2lzVmlzaWJsZVxuICAgIC8qIFRSSUFMQ09ORCAqL1xuICAgICkge1xuICAgICAgICAvLyBGaWxsIHRlbXBsYXRlIHdpdGggbnVtYmVyc1xuICAgICAgICAkJDEoJy5tYnNjLW5wLXBoJywgJG1hcmt1cCkuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICQkMSh0aGlzKS5odG1sKHMuZmlsbCA9PSAnbHRyJyA/IGkgPj0gcG9zID8gcGggOiBtYXNrIHx8IHRlbXBWYWx1ZUFycmF5W2ldIDogaSA+PSB0b3RhbCAtIHRlbXBUb3RhbCA/IGkgKyBwb3MgPCB0b3RhbCA/IHBoIDogbWFzayB8fCB0ZW1wVmFsdWVBcnJheVtpICsgcG9zIC0gdG90YWxdIDogJycpO1xuICAgICAgICB9KTsgLy8gRmlsbCB2YXJpYWJsZSBwbGFjZWhvbGRlcnNcblxuICAgICAgICAkJDEoJy5tYnNjLW5wLWNwaCcsICRtYXJrdXApLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICQkMSh0aGlzKS5odG1sKHRlbXBWYXJpYWJsZXNbJCQxKHRoaXMpLmF0dHIoJ2RhdGEtdmFyJyldIHx8ICQkMSh0aGlzKS5hdHRyKCdkYXRhLXBoJykpO1xuICAgICAgICB9KTsgLy8gRGlzYWJsZSBhbGwgbnVtZXJpYyBidXR0b25zIGlmIHRlbXBsYXRlIGlzIGZ1bGxcblxuICAgICAgICBpZiAocG9zID09PSB0b3RhbCkge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPD0gOTsgaSsrKSB7XG4gICAgICAgICAgICBkaXNhYmxlZC5wdXNoKGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBEaXNhYmxlIGludmFsaWQgYnV0dG9uc1xuXG5cbiAgICAgICAgJCQxKCcubWJzYy1ucC1idG4nLCAkbWFya3VwKS5yZW1vdmVDbGFzcyhkaXNhYmxlZENsYXNzKTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGlzYWJsZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAkJDEoJy5tYnNjLW5wLWJ0bltkYXRhLXZhbD1cIicgKyBkaXNhYmxlZFtpXSArICdcIl0nLCAkbWFya3VwKS5hZGRDbGFzcyhkaXNhYmxlZENsYXNzKTtcbiAgICAgICAgfSAvLyBEaXNhYmxlIHNldCBidXR0b25cblxuXG4gICAgICAgIGlmICh0aGF0Ll9pc1ZhbGlkKSB7XG4gICAgICAgICAgJCQxKCcubWJzYy1mci1idG4tcyAubWJzYy1mci1idG4nLCAkbWFya3VwKS5yZW1vdmVDbGFzcyhkaXNhYmxlZENsYXNzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkJDEoJy5tYnNjLWZyLWJ0bi1zIC5tYnNjLWZyLWJ0bicsICRtYXJrdXApLmFkZENsYXNzKGRpc2FibGVkQ2xhc3MpO1xuICAgICAgICB9IC8vIEZpbGwgaW5wdXQgaWYgaW4gbGl2ZSBtb2RlXG5cblxuICAgICAgICBpZiAodGhhdC5saXZlKSB7XG4gICAgICAgICAgdGhhdC5faGFzVmFsdWUgPSBtYW51YWwgfHwgdGhhdC5faGFzVmFsdWU7XG4gICAgICAgICAgZmlsbFZhbHVlKG1hbnVhbCwgZmFsc2UsIG1hbnVhbCk7XG5cbiAgICAgICAgICBpZiAobWFudWFsKSB7XG4gICAgICAgICAgICB0cmlnZ2VyKCdvblNldCcsIHtcbiAgICAgICAgICAgICAgdmFsdWVUZXh0OiB0aGF0Ll92YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaWxsVmFsdWUoZmlsbCwgZGlzcCwgY2hhbmdlLCB0ZW1wKSB7XG4gICAgaWYgKGRpc3ApIHtcbiAgICAgIGRpc3BsYXkoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRlbXApIHtcbiAgICAgIHZhbHVlQXJyYXkgPSB0ZW1wVmFsdWVBcnJheS5zbGljZSgwKTtcbiAgICAgIHZhcmlhYmxlcyA9IGV4dGVuZCQxKHt9LCB0ZW1wVmFyaWFibGVzKTtcbiAgICAgIGFjdGlvbnMgPSB0ZW1wQWN0aW9ucy5zbGljZSgwKTtcbiAgICAgIHRoYXQuX3ZhbHVlID0gdGhhdC5faGFzVmFsdWUgPyB0aGF0Ll90ZW1wVmFsdWUgOiBudWxsO1xuICAgIH1cblxuICAgIGlmIChmaWxsKSB7XG4gICAgICBpZiAodGhhdC5faXNJbnB1dCkge1xuICAgICAgICAkZWxtLnZhbCh0aGF0Ll9oYXNWYWx1ZSAmJiB0aGF0Ll9pc1ZhbGlkID8gdGhhdC5fdmFsdWUgOiAnJyk7XG4gICAgICB9XG5cbiAgICAgIHRyaWdnZXIoJ29uRmlsbCcsIHtcbiAgICAgICAgdmFsdWVUZXh0OiB0aGF0Ll9oYXNWYWx1ZSA/IHRoYXQuX3RlbXBWYWx1ZSA6ICcnLFxuICAgICAgICBjaGFuZ2U6IGNoYW5nZVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICAgdGhhdC5fcHJldmVudENoYW5nZSA9IHRydWU7XG4gICAgICAgICRlbG0udHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbG9hZFZhbHVlcyh2YWx1ZXMpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgdmFycyxcbiAgICAgICAgdmFsID0gdmFsdWVzIHx8IFtdLFxuICAgICAgICByZXQgPSBbXTtcbiAgICB0ZW1wQWN0aW9ucyA9IFtdO1xuICAgIHRlbXBWYXJpYWJsZXMgPSB7fTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vaWYgKGlzTmFOKHBhcnNlSW50KHZhbFtpXSkpKSB7XG4gICAgICBpZiAoLzovLnRlc3QodmFsW2ldKSkge1xuICAgICAgICB2YXJzID0gdmFsW2ldLnNwbGl0KCc6Jyk7XG4gICAgICAgIHRlbXBWYXJpYWJsZXNbdmFyc1swXV0gPSB2YXJzWzFdO1xuICAgICAgICB0ZW1wQWN0aW9ucy5wdXNoKHZhcnNbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0LnB1c2godmFsW2ldKTtcbiAgICAgICAgdGVtcEFjdGlvbnMucHVzaCgnZGlnaXQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgZnVuY3Rpb24gdHJpZ2dlcklucHV0KGJ0biwgZXYpIHtcbiAgICB0cmlnZ2VyKCdvbklucHV0Jywge1xuICAgICAgZG9tRXZlbnQ6IGV2LFxuICAgICAgdGFyZ2V0OiBidG4sXG4gICAgICB2YWx1ZXM6IHRlbXBWYWx1ZUFycmF5LnNsaWNlKDApLFxuICAgICAgdmFsdWVUZXh0OiB0aGF0Ll90ZW1wVmFsdWUsXG4gICAgICB2YXJpYWJsZXM6IHRlbXBWYXJpYWJsZXNcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEtleXMoa2V5cywgcG9zKSB7XG4gICAgaWYgKGtleXMpIHtcbiAgICAgIGtleXMgPSAkJDEuaXNBcnJheShrZXlzKSA/IGtleXMgOiBba2V5c107XG4gICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBjdXN0b21LZXlzW2tleV0gPSBwb3M7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbk51bWJlclRhcChidG4sIHZhbCwgZXYpIHtcbiAgICBpZiAoIXBvcyAmJiAhdmFsICYmICFzLmFsbG93TGVhZGluZ1plcm8gfHwgYnRuLmhhc0NsYXNzKCdtYnNjLWRpc2FibGVkJykgfHwgYnRuLmhhc0NsYXNzKCdtYnNjLW5wLWJ0bi1lbXB0eScpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBvcyA8IHRvdGFsXG4gICAgLyogVFJJQUxDT05EICovXG4gICAgKSB7XG4gICAgICAgIHRlbXBBY3Rpb25zLnB1c2goJ2RpZ2l0Jyk7XG4gICAgICAgIHRlbXBWYWx1ZUFycmF5LnB1c2godmFsKTtcbiAgICAgICAgZGlzcGxheSh0cnVlKTtcbiAgICAgICAgdHJpZ2dlcklucHV0KGJ0blswXSwgZXYpO1xuICAgICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25DdXN0b21UYXAoYnRuLCBldikge1xuICAgIHZhciBpLFxuICAgICAgICB2LFxuICAgICAgICB2YWwgPSBidG4uYXR0cignZGF0YS12YWwnKSxcbiAgICAgICAgdHJhY2sgPSBidG4uYXR0cignZGF0YS10cmFjaycpICE9PSAnZmFsc2UnLFxuICAgICAgICB2YXJpYWJsZSA9IGJ0bi5hdHRyKCdkYXRhLXZhcicpO1xuXG4gICAgaWYgKCFidG4uaGFzQ2xhc3MoJ21ic2MtZGlzYWJsZWQnKSkge1xuICAgICAgaWYgKHZhcmlhYmxlKSB7XG4gICAgICAgIHYgPSB2YXJpYWJsZS5zcGxpdCgnOicpO1xuXG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgIHRlbXBBY3Rpb25zLnB1c2godlswXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZW1wVmFyaWFibGVzW3ZbMF1dID0gdlsyXSA9PT0gdW5kZWZpbmVkID8gdlsxXSA6IHRlbXBWYXJpYWJsZXNbdlswXV0gPT0gdlsxXSA/IHZbMl0gOiB2WzFdO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsLmxlbmd0aCArIHBvcyA8PSB0ZW1wVG90YWwpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHYgPSBpc051bWVyaWModmFsW2ldKSA/ICt2YWxbaV0gOiB2YWxbaV07XG5cbiAgICAgICAgICBpZiAocy5hbGxvd0xlYWRpbmdaZXJvIHx8IHBvcyB8fCB2KSB7XG4gICAgICAgICAgICB0ZW1wQWN0aW9ucy5wdXNoKCdkaWdpdCcpO1xuICAgICAgICAgICAgdGVtcFZhbHVlQXJyYXkucHVzaCh2KTtcbiAgICAgICAgICAgIHBvcyA9IHRlbXBWYWx1ZUFycmF5Lmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGlzcGxheSh0cnVlKTtcbiAgICAgIHRyaWdnZXJJbnB1dChidG5bMF0sIGV2KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkRlbGV0ZVRhcChldikge1xuICAgIHZhciBpLFxuICAgICAgICBvbGQsXG4gICAgICAgIGFjdCA9IHRlbXBBY3Rpb25zLnBvcCgpO1xuXG4gICAgaWYgKHBvcyB8fCBhY3QgIT09ICdkaWdpdCcpIHtcbiAgICAgIGlmIChhY3QgIT09ICdkaWdpdCcgJiYgdGVtcFZhcmlhYmxlc1thY3RdKSB7XG4gICAgICAgIGRlbGV0ZSB0ZW1wVmFyaWFibGVzW2FjdF07XG4gICAgICAgIG9sZCA9IHRlbXBBY3Rpb25zLnNsaWNlKDApO1xuICAgICAgICB0ZW1wQWN0aW9ucyA9IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvbGQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAob2xkW2ldICE9PSBhY3QpIHtcbiAgICAgICAgICAgIHRlbXBBY3Rpb25zLnB1c2gob2xkW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBWYWx1ZUFycmF5LnBvcCgpO1xuICAgICAgfVxuXG4gICAgICBkaXNwbGF5KHRydWUpO1xuICAgICAgdHJpZ2dlcklucHV0KGRlbGV0ZUJ0biwgZXYpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0RGVsZXRlKGV2KSB7XG4gICAgYWN0aW9uID0gdHJ1ZTtcbiAgICBzWCA9IGdldENvb3JkKGV2LCAnWCcpO1xuICAgIHNZID0gZ2V0Q29vcmQoZXYsICdZJyk7XG4gICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgY2xlYXJUaW1lb3V0KGludGVydmFsKTtcbiAgICBvbkRlbGV0ZVRhcChldik7XG4gICAgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICBvbkRlbGV0ZVRhcChldik7XG4gICAgfSwgMTUwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0b3BEZWxldGUoKSB7XG4gICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgYWN0aW9uID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBvblN0YXJ0KGV2KSB7XG4gICAgaWYgKHRlc3RUb3VjaChldiwgdGhpcykpIHtcbiAgICAgIGlmIChldi50eXBlID09ICdrZXlkb3duJyAmJiBldi5rZXlDb2RlICE9IDMyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3RhcnREZWxldGUoZXYpO1xuXG4gICAgICBpZiAoZXYudHlwZSA9PSAnbW91c2Vkb3duJykge1xuICAgICAgICAkJDEoZG9jdW1lbnQpLm9uKCdtb3VzZW1vdmUnLCBvbk1vdmUpLm9uKCdtb3VzZXVwJywgb25FbmQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uTW92ZShldikge1xuICAgIGlmIChhY3Rpb24pIHtcbiAgICAgIGVYID0gZ2V0Q29vcmQoZXYsICdYJyk7XG4gICAgICBlWSA9IGdldENvb3JkKGV2LCAnWScpO1xuICAgICAgZGlmZlggPSBlWCAtIHNYO1xuICAgICAgZGlmZlkgPSBlWSAtIHNZO1xuXG4gICAgICBpZiAoTWF0aC5hYnMoZGlmZlgpID4gNyB8fCBNYXRoLmFicyhkaWZmWSkgPiA3KSB7XG4gICAgICAgIHN0b3BEZWxldGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkVuZChldikge1xuICAgIGlmIChhY3Rpb24pIHtcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBzdG9wRGVsZXRlKCk7XG5cbiAgICAgIGlmIChldi50eXBlID09ICdtb3VzZXVwJykge1xuICAgICAgICAkJDEoZG9jdW1lbnQpLm9mZignbW91c2Vtb3ZlJywgb25Nb3ZlKS5vZmYoJ21vdXNldXAnLCBvbkVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENhbGwgdGhlIHBhcmVudCBjb25zdHJ1Y3RvclxuXG5cbiAgRnJhbWUuY2FsbCh0aGlzLCBlbCwgc2V0dGluZ3MsIHRydWUpOyAvLyBQdWJsaWMgZnVuY3Rpb25zXG5cbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgdmFsdWVcclxuICAgKi9cblxuICB0aGF0LnNldFZhbCA9IHRoYXQuX3NldFZhbCA9IGZ1bmN0aW9uICh2YWwsIGZpbGwsIGNoYW5nZSwgdGVtcCkge1xuICAgIHRoYXQuX2hhc1ZhbHVlID0gdmFsICE9PSBudWxsICYmIHZhbCAhPT0gdW5kZWZpbmVkO1xuICAgIHRlbXBWYWx1ZUFycmF5ID0gbG9hZFZhbHVlcygkJDEuaXNBcnJheSh2YWwpID8gdmFsLnNsaWNlKDApIDogcy5wYXJzZVZhbHVlLmNhbGwoZWwsIHZhbCwgdGhhdCkpO1xuICAgIGZpbGxWYWx1ZShmaWxsLCB0cnVlLCBjaGFuZ2UgPT09IHVuZGVmaW5lZCA/IGZpbGwgOiBjaGFuZ2UsIHRlbXApO1xuICB9O1xuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBzZWxlY3RlZCB2YWx1ZVxyXG4gICAqL1xuXG5cbiAgdGhhdC5nZXRWYWwgPSB0aGF0Ll9nZXRWYWwgPSBmdW5jdGlvbiAodGVtcCkge1xuICAgIHJldHVybiB0aGF0Ll9oYXNWYWx1ZSB8fCB0ZW1wID8gdGhhdFt0ZW1wID8gJ190ZW1wVmFsdWUnIDogJ192YWx1ZSddIDogbnVsbDtcbiAgfTtcbiAgLypcclxuICAgKiBTZXRzIHRoZSB2YWx1ZSAocGFzc2VkIGFzIGFuIGFycmF5KVxyXG4gICAqL1xuXG5cbiAgdGhhdC5zZXRBcnJheVZhbCA9IHRoYXQuc2V0VmFsO1xuICAvKlxyXG4gICAqIFJldHVybnMgdGhlIHNlbGVjdGVkIHdoZWVsIHZhbHVlcyBhcyBhbiBhcnJheVxyXG4gICAqL1xuXG4gIHRoYXQuZ2V0QXJyYXlWYWwgPSBmdW5jdGlvbiAodGVtcCkge1xuICAgIHJldHVybiB0ZW1wID8gdGVtcFZhbHVlQXJyYXkuc2xpY2UoMCkgOiB0aGF0Ll9oYXNWYWx1ZSA/IHZhbHVlQXJyYXkuc2xpY2UoMCkgOiBudWxsO1xuICB9OyAvLyBQcm90ZWN0ZWQgb3ZlcnJpZGVzXG5cbiAgLyogVFJJQUxGVU5DICovXG5cblxuICB0aGF0Ll9yZWFkVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHYgPSAkZWxtLnZhbCgpIHx8ICcnO1xuXG4gICAgaWYgKHYgIT09ICcnKSB7XG4gICAgICB0aGF0Ll9oYXNWYWx1ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG1hc2spIHtcbiAgICAgIHRlbXBWYXJpYWJsZXMgPSB7fTtcbiAgICAgIHRlbXBBY3Rpb25zID0gW107XG4gICAgICB0ZW1wVmFsdWVBcnJheSA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZW1wVmFyaWFibGVzID0gdGhhdC5faGFzVmFsdWUgPyB2YXJpYWJsZXMgOiB7fTtcbiAgICAgIHRlbXBBY3Rpb25zID0gdGhhdC5faGFzVmFsdWUgPyBhY3Rpb25zIDogW107XG4gICAgICB0ZW1wVmFsdWVBcnJheSA9IHRoYXQuX2hhc1ZhbHVlICYmIHZhbHVlQXJyYXkgPyB2YWx1ZUFycmF5LnNsaWNlKDApIDogbG9hZFZhbHVlcyhzLnBhcnNlVmFsdWUuY2FsbChlbCwgdiwgdGhhdCkpO1xuICAgICAgZmlsbFZhbHVlKGZhbHNlLCB0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgdGhhdC5fZmlsbFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoYXQuX2hhc1ZhbHVlID0gdHJ1ZTtcbiAgICBmaWxsVmFsdWUodHJ1ZSwgZmFsc2UsIHRydWUpO1xuICB9O1xuXG4gIHRoYXQuX2dlbmVyYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgaixcbiAgICAgICAgdixcbiAgICAgICAgayA9IDEsXG4gICAgICAgIGxlZnRLZXkgPSBzLmxlZnRLZXksXG4gICAgICAgIHJpZ2h0S2V5ID0gcy5yaWdodEtleSxcbiAgICAgICAgdGVtcGxhdGUgPSAnJyxcbiAgICAgICAgaHRtbCA9ICcnOyAvLyBEaXNwbGF5XG5cbiAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwibWJzYy1ucC1oZHJcIj48ZGl2IHJvbGU9XCJidXR0b25cIiB0YWJpbmRleD1cIjBcIiBhcmlhLWxhYmVsPVwiJyArIHMuZGVsZXRlVGV4dCArICdcIiBjbGFzcz1cIm1ic2MtbnAtZGVsIG1ic2MtZnItYnRuLWUgbWJzYy1pYyBtYnNjLWljLScgKyBzLmRlbGV0ZUljb24gKyAnXCI+PC9kaXY+PGRpdiBjbGFzcz1cIm1ic2MtbnAtZHNwXCI+JzsgLy8gUHJvY2VzcyB0ZW1wbGF0ZVxuXG4gICAgdGVtcGxhdGUgPSBzLnRlbXBsYXRlLnJlcGxhY2UoL2QvZywgJzxzcGFuIGNsYXNzPVwibWJzYy1ucC1waFwiPicgKyBwaCArICc8L3NwYW4+JykucmVwbGFjZSgvJiMxMDA7L2csICdkJyk7IC8vIEdlbmVyYXRlIHRoZSB0ZW1wbGF0ZSBmb3IgY3VzdG9tIGJ1dHRvbnNcblxuICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZSgveyhbYS16QS1aMC05XSopOj8oW2EtekEtWjAtOVxcLV9dKil9L2csICc8c3BhbiBjbGFzcz1cIm1ic2MtbnAtY3BoXCIgZGF0YS12YXI9XCIkMVwiIGRhdGEtcGg9XCIkMlwiPiQyPC9zcGFuPicpO1xuICAgIGh0bWwgKz0gdGVtcGxhdGU7XG4gICAgaHRtbCArPSAnPC9kaXY+PC9kaXY+JzsgLy8gRGlnaXQgYnV0dG9uc1xuXG4gICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cIm1ic2MtbnAtdGJsLWMgbWJzYy13LXBcIj48ZGl2IGNsYXNzPVwibWJzYy1ucC10YmxcIj4nO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgaHRtbCArPSAnPGRpdiBjbGFzcz1cIm1ic2MtbnAtcm93XCI+JztcblxuICAgICAgZm9yIChqID0gMDsgaiA8IDM7IGorKykge1xuICAgICAgICB2ID0gaztcblxuICAgICAgICBpZiAoayA9PSAxMCB8fCBrID09IDEyKSB7XG4gICAgICAgICAgdiA9ICcnO1xuICAgICAgICB9IGVsc2UgaWYgKGsgPT0gMTEpIHtcbiAgICAgICAgICB2ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2ID09PSAnJykge1xuICAgICAgICAgIGlmIChrID09IDEwICYmIGxlZnRLZXkpIHtcbiAgICAgICAgICAgIGFkZEtleXMobGVmdEtleS5rZXlzLCAnbGVmdCcpO1xuICAgICAgICAgICAgaHRtbCArPSAnPGRpdiByb2xlPVwiYnV0dG9uXCIgdGFiaW5kZXg9XCIwXCIgY2xhc3M9XCJtYnNjLW5wLWJ0biBtYnNjLW5wLWJ0bi1jdXN0b20gbWJzYy1ucC1idG4tY3VzdG9tLWxlZnQgbWJzYy1mci1idG4tZVwiICcgKyAobGVmdEtleS52YXJpYWJsZSA/ICdkYXRhLXZhcj1cIicgKyBsZWZ0S2V5LnZhcmlhYmxlICsgJ1wiJyA6ICcnKSArICcgZGF0YS12YWw9XCInICsgKGxlZnRLZXkudmFsdWUgfHwgJycpICsgJ1wiICcgKyAobGVmdEtleS50cmFjayAhPT0gdW5kZWZpbmVkID8gJyBkYXRhLXRyYWNrPVwiJyArIGxlZnRLZXkudHJhY2sgKyAnXCInIDogJycpICsgJz4nICsgbGVmdEtleS50ZXh0ICsgJzwvZGl2Pic7XG4gICAgICAgICAgfSBlbHNlIGlmIChrID09IDEyICYmIHMucmlnaHRLZXkpIHtcbiAgICAgICAgICAgIGFkZEtleXMocmlnaHRLZXkua2V5cywgJ3JpZ2h0Jyk7XG4gICAgICAgICAgICBodG1sICs9ICc8ZGl2IHJvbGU9XCJidXR0b25cIiB0YWJpbmRleD1cIjBcIiBjbGFzcz1cIm1ic2MtbnAtYnRuIG1ic2MtbnAtYnRuLWN1c3RvbSBtYnNjLW5wLWJ0bi1jdXN0b20tcmlnaHQgbWJzYy1mci1idG4tZVwiICcgKyAocmlnaHRLZXkudmFyaWFibGUgPyAnZGF0YS12YXI9XCInICsgcmlnaHRLZXkudmFyaWFibGUgKyAnXCInIDogJycpICsgJyBkYXRhLXZhbD1cIicgKyAocmlnaHRLZXkudmFsdWUgfHwgJycpICsgJ1wiICcgKyAocmlnaHRLZXkudHJhY2sgIT09IHVuZGVmaW5lZCA/ICcgZGF0YS10cmFjaz1cIicgKyByaWdodEtleS50cmFjayArICdcIicgOiAnJykgKyAnID4nICsgcmlnaHRLZXkudGV4dCArICc8L2Rpdj4nO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBodG1sICs9ICc8ZGl2IGNsYXNzPVwibWJzYy1ucC1idG4gbWJzYy1ucC1idG4tZW1wdHlcIj48L2Rpdj4nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBodG1sICs9ICc8ZGl2IHRhYmluZGV4PVwiMFwiIHJvbGU9XCJidXR0b25cIiBjbGFzcz1cIm1ic2MtbnAtYnRuIG1ic2MtZnItYnRuLWVcIiBkYXRhLXZhbD1cIicgKyB2ICsgJ1wiPicgKyB2XG4gICAgICAgICAgLyogVFJJQUwgKi9cbiAgICAgICAgICArICc8L2Rpdj4nO1xuICAgICAgICB9XG5cbiAgICAgICAgaysrO1xuICAgICAgfVxuXG4gICAgICBodG1sICs9ICc8L2Rpdj4nO1xuICAgIH1cblxuICAgIGh0bWwgKz0gJzwvZGl2PjwvZGl2Pic7XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG5cbiAgdGhhdC5fbWFya3VwUmVhZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgJG1hcmt1cCA9IHRoYXQuX21hcmt1cDtcbiAgICBkaXNwbGF5KCk7XG4gIH07XG5cbiAgdGhhdC5fYXR0YWNoRXZlbnRzID0gZnVuY3Rpb24gKCRtKSB7XG4gICAgJG0ub24oJ2tleWRvd24nLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHZhciBidG4sXG4gICAgICAgICAga2V5ID0gZXYua2V5Q29kZTtcblxuICAgICAgaWYgKGN1c3RvbUtleXNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJ0biA9ICQkMSgnLm1ic2MtbnAtYnRuLWN1c3RvbS0nICsgY3VzdG9tS2V5c1trZXldLCAkbSk7XG5cbiAgICAgICAgaWYgKGJ0bi5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoYnRuLmF0dHIoJ2RhdGEtdmFyJykgPT09ICdzaWduOi06Jykge1xuICAgICAgICAgICAgdGVtcFZhcmlhYmxlcy5zaWduID0ga2V5ID09PSAxMDcgfHwga2V5ID09PSAxODcgPyAnLScgOiAnJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvbkN1c3RvbVRhcChidG4sIGV2KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChudW1lcmljS2V5c1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb25OdW1iZXJUYXAoJCQxKCcubWJzYy1ucC1idG5bZGF0YS12YWw9XCInICsgbnVtZXJpY0tleXNba2V5XSArICdcIl0nLCAkbSksIG51bWVyaWNLZXlzW2tleV0sIGV2KTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09IDgpIHtcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgb25EZWxldGVUYXAoZXYpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoYXQudGFwKCQkMSgnLm1ic2MtbnAtYnRuJywgJG0pLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgIHZhciBidG4gPSAkJDEodGhpcyk7XG5cbiAgICAgIGlmIChidG4uaGFzQ2xhc3MoJ21ic2MtbnAtYnRuLWN1c3RvbScpKSB7XG4gICAgICAgIG9uQ3VzdG9tVGFwKGJ0biwgZXYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25OdW1iZXJUYXAoYnRuLCArYnRuLmF0dHIoJ2RhdGEtdmFsJyksIGV2KTtcbiAgICAgIH1cbiAgICB9LCBmYWxzZSwgMzAsIHRydWUpO1xuICAgIGRlbGV0ZUJ0biA9ICQkMSgnLm1ic2MtbnAtZGVsJywgJG0pWzBdO1xuICAgIGxpc3RlbihkZWxldGVCdG4sICd0b3VjaHN0YXJ0Jywgb25TdGFydCwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGxpc3RlbihkZWxldGVCdG4sICdtb3VzZWRvd24nLCBvblN0YXJ0KTtcbiAgICBsaXN0ZW4oZGVsZXRlQnRuLCAna2V5ZG93bicsIG9uU3RhcnQpO1xuICAgIGxpc3RlbihkZWxldGVCdG4sICd0b3VjaG1vdmUnLCBvbk1vdmUsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICBsaXN0ZW4oZGVsZXRlQnRuLCAnbW91c2Vtb3ZlJywgb25Nb3ZlKTtcbiAgICBsaXN0ZW4oZGVsZXRlQnRuLCAndG91Y2hlbmQnLCBvbkVuZCk7XG4gICAgbGlzdGVuKGRlbGV0ZUJ0biwgJ21vdXNldXAnLCBvbkVuZCk7XG4gICAgbGlzdGVuKGRlbGV0ZUJ0biwgJ2tleXVwJywgb25FbmQpO1xuICB9O1xuXG4gIHRoYXQuX19pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIHMgPSB0aGF0LnNldHRpbmdzO1xuICAgIHMudGVtcGxhdGUgPSBzLnRlbXBsYXRlLnJlcGxhY2UoL1xcXFxkLywgJyYjMTAwOycpO1xuICAgIHBoID0gcy5wbGFjZWhvbGRlcjtcbiAgICB0b3RhbCA9IChzLnRlbXBsYXRlLm1hdGNoKC9kL2cpIHx8IFtdKS5sZW5ndGg7XG4gICAgZGlzYWJsZWRDbGFzcyA9ICdtYnNjLWRpc2FibGVkICcgKyAocy5kaXNhYmxlZENsYXNzIHx8ICcnKTtcbiAgICBtYXNrID0gcy5tYXNrO1xuICAgIHRyaWdnZXIgPSB0aGF0LnRyaWdnZXI7XG5cbiAgICBpZiAobWFzayAmJiAkZWxtLmlzKCdpbnB1dCcpKSB7XG4gICAgICAkZWxtLmF0dHIoJ3R5cGUnLCAncGFzc3dvcmQnKTtcbiAgICB9XG4gIH07XG5cbiAgdGhhdC5faW5kZXhPZiA9IGZ1bmN0aW9uIChjb250LCB2KSB7XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY29udC5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGNvbnRbaV0udG9TdHJpbmcoKSA9PT0gdi50b1N0cmluZygpKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfTsgLy8gQ29uc3RydWN0b3JcblxuXG4gIGlmICghaW5oZXJpdCkge1xuICAgIHRoYXQuaW5pdCgpO1xuICB9XG59OyAvLyBFeHRlbmQgZGVmYXVsdHNcblxuTnVtcGFkLnByb3RvdHlwZSA9IHtcbiAgX2hhc0RlZjogdHJ1ZSxcbiAgX2hhc1RoZW1lOiB0cnVlLFxuICBfaGFzTGFuZzogdHJ1ZSxcbiAgX3Jlc3BvbnNpdmU6IHRydWUsXG4gIF9jbGFzczogJ251bXBhZCcsXG4gIF9wcmVzZXRzOiBwcmVzZXRzJDEsXG4gIF9kZWZhdWx0czogZXh0ZW5kJDEoe30sIEZyYW1lLnByb3RvdHlwZS5fZGVmYXVsdHMsIHtcbiAgICB0ZW1wbGF0ZTogJ2RkLmRkJyxcbiAgICBwbGFjZWhvbGRlcjogJzAnLFxuICAgIGRlbGV0ZUljb246ICdiYWNrc3BhY2UnLFxuICAgIGFsbG93TGVhZGluZ1plcm86IGZhbHNlLFxuICAgIGhlYWRlclRleHQ6IGZhbHNlLFxuICAgIGZpbGw6ICdydGwnLFxuICAgIGNvbXBDbGFzczogJ21ic2MtbnAnLFxuICAgIC8vIExvY2FsaXphdGlvblxuICAgIGRlbGV0ZVRleHQ6ICdEZWxldGUnLFxuICAgIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcbiAgICB0aG91c2FuZHNTZXBhcmF0b3I6ICcsJyxcbiAgICAvLyBAdG9kb1xuICAgIC8vIC0tLVxuICAgIC8vZmlsbEZ1bGxUZW1wbGF0ZTogdHJ1ZSxcbiAgICAvLyAtLS1cbiAgICB2YWxpZGF0ZTogbm9vcCxcbiAgICBwYXJzZVZhbHVlOiBub29wLFxuICAgIGZvcm1hdFZhbHVlOiBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh2YWx1ZSwgdmFyaWFibGVzLCBpbnN0KSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICBqID0gMSxcbiAgICAgICAgICBzID0gaW5zdC5zZXR0aW5ncyxcbiAgICAgICAgICBwaCA9IHMucGxhY2Vob2xkZXIsXG4gICAgICAgICAgdGVtcGxhdGUgPSBzLnRlbXBsYXRlLFxuICAgICAgICAgIHZhbHVlTGVuID0gdmFsdWUubGVuZ3RoLFxuICAgICAgICAgIHRlbXBMZW4gPSB0ZW1wbGF0ZS5sZW5ndGgsXG4gICAgICAgICAgcmVzID0gJyc7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0ZW1wTGVuOyBpKyspIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlW3RlbXBMZW4gLSBpIC0gMV0gPT0gJ2QnKSB7XG4gICAgICAgICAgaWYgKGogPD0gdmFsdWVMZW4pIHtcbiAgICAgICAgICAgIHJlcyA9IHZhbHVlW3ZhbHVlTGVuIC0gal0gKyByZXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9IHBoICsgcmVzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGorKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXMgPSB0ZW1wbGF0ZVt0ZW1wTGVuIC0gaSAtIDFdICsgcmVzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgICQkMS5lYWNoKHZhcmlhYmxlcywgZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgICAgcmVzID0gcmVzLnJlcGxhY2UoJ3snICsgaSArICd9Jywgdik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAkJDEoJzxkaXY+JyArIHJlcyArICc8L2Rpdj4nKS50ZXh0KCk7XG4gICAgfVxuICB9KVxufTtcbmNsYXNzZXMuTnVtcGFkID0gTnVtcGFkO1xubW9iaXNjcm9sbC50aGVtZXMubnVtcGFkID0gbW9iaXNjcm9sbC50aGVtZXMuZnJhbWU7IC8vIERlY2ltYWwgcHJlc2V0XG4vLyAtLS1cblxudmFyIGRlY2ltYWxEZWZhdWx0cyA9IHtcbiAgZW50cnlNb2RlOiAndGVtcGxhdGUnLFxuICBtaW46IDAsXG4gIG1heDogOTkuOTksXG4gIG1heFNjYWxlOiA0LFxuICBwcmVmaXg6ICcnLFxuICBzdWZmaXg6ICcnLFxuICByZXR1cm5BZmZpeDogZmFsc2Vcbn07XG5cbnByZXNldHMkMS5kZWNpbWFsID0gZnVuY3Rpb24gKGluc3QpIHtcbiAgdmFyIG9yaWcgPSBleHRlbmQkMSh7fSwgaW5zdC5zZXR0aW5ncyksXG4gICAgICBjb25kaXRpb25hbERlZmF1bHRzID0ge1xuICAgIHNjYWxlOiBvcmlnLmVudHJ5TW9kZSA9PSAnZnJlZWZvcm0nID8gdW5kZWZpbmVkIDogMlxuICB9LFxuICAgICAgcyA9IGV4dGVuZCQxKGluc3Quc2V0dGluZ3MsIGRlY2ltYWxEZWZhdWx0cywgY29uZGl0aW9uYWxEZWZhdWx0cywgb3JpZyksXG4gICAgICBzY2FsZSA9IHMuc2NhbGUsXG4gICAgICBtaW4gPSArcy5taW4udG9GaXhlZChzY2FsZSksXG4gICAgICBtYXggPSArcy5tYXgudG9GaXhlZChzY2FsZSksXG4gICAgICBuZWdhdGl2ZU51bSA9IG1pbiA8IDAsXG4gICAgICB0aG91c2FuZFJlZ2V4ID0gbmV3IFJlZ0V4cChzLnRob3VzYW5kc1NlcGFyYXRvciwgJ2cnKSxcbiAgICAgIG1heEludExlbmd0aCA9IChNYXRoLmZsb29yKE1hdGgubWF4KG1heCwgTWF0aC5hYnMobWluKSkpICsgJycpLmxlbmd0aCArIDEsXG4gICAgICBmcmVlRW50cnkgPSBzLmVudHJ5TW9kZSA9PSAnZnJlZWZvcm0nO1xuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgZnJvbSB0aGUgZGlnaXRzXHJcbiAgICogQHBhcmFtIHtBcnJheX0gZGlnaXRBcnJheVxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNOZWdhdGl2ZVxyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdldE51bWJlcihkaWdpdEFycmF5LCBpc05lZ2F0aXZlKSB7XG4gICAgdmFyIHJldCA9ICtkaWdpdEFycmF5Lm1hcChmdW5jdGlvbiAodiwgaSkge1xuICAgICAgcmV0dXJuIChpID09PSAwICYmIHYgPT09ICcuJyA/ICcwJyA6ICcnKSArIHY7XG4gICAgfSkuam9pbignJyk7IC8vIGluIHRoZSBjYXNlIG9mIE5PVCB0aGUgZnJlZUVudHJ5IG1vZGUsIHRoZSBkZWNpbWFsIHBvaW50IHdvbnQgYmUgcGFydCBvZiB0aGUgZGlnaXRzIGFycmF5XG4gICAgLy8gaW4gdGhhdCBjYXNlIHRoZSB2YWx1ZSB3aWxsIG5lZWQgdG8gYmUgYWRqdXN0ZWQgdG8gdGhlIHJpZ2h0IHNjYWxlXG5cbiAgICBpZiAoIWZyZWVFbnRyeSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzY2FsZTsgaSsrKSB7XG4gICAgICAgIHJldCAvPSAxMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaXNOZWdhdGl2ZSA/IHJldCAqIC0xIDogcmV0O1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGZvcm1hdHRlZCB2YWx1ZSBmcm9tIHRoZSBhcnJheSBvZiBkaWdpdHNcclxuICAgKiBAcGFyYW0ge0FycmF5fSBkaWdpdEFycmF5XHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRGb3JtYXR0ZWQoZGlnaXRBcnJheSwgZm9ySW5wdXQpIHtcbiAgICB2YXIgbnVtYmVyU3RyID0gJyc7XG5cbiAgICBpZiAoZnJlZUVudHJ5ICYmIChzY2FsZSA9PT0gdW5kZWZpbmVkIHx8ICFmb3JJbnB1dCkpIHtcbiAgICAgIGlmIChkaWdpdEFycmF5WzBdID09PSAnLicpIHtcbiAgICAgICAgLy8gYWRkIG1pc3NpbmcgbGVhZGluZyB6ZXJvIHdoZW4gb25seSB0aGUgZGVjaW1hbCBwb2ludCBpcyBwcmVzc2VkXG4gICAgICAgIG51bWJlclN0ciArPSAnMCc7XG4gICAgICB9XG5cbiAgICAgIG51bWJlclN0ciArPSBkaWdpdEFycmF5LmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBudW1iZXJTdHIgPSBnZXROdW1iZXIoZGlnaXRBcnJheSkudG9GaXhlZChzY2FsZSk7XG4gICAgfSAvLyBzcGxpdCB0aGUgdmFsdWUgYnkgdGhlIGRlY2ltYWwgc2VwYXJhdG9yIHRvIGFkZCB0aG91c2FuZCBzZXBhcmF0b3JzIHRvIHRoZSBpbnRlZ2VyIHBhcnRcblxuXG4gICAgdmFyIHBhcnRzID0gbnVtYmVyU3RyLnNwbGl0KCcuJyksXG4gICAgICAgIGludGVnZXIgPSBwYXJ0c1swXS5yZXBsYWNlKC9cXEIoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCBzLnRob3VzYW5kc1NlcGFyYXRvciksXG4gICAgICAgIGRlYyA9IHBhcnRzWzFdID8gcy5kZWNpbWFsU2VwYXJhdG9yICsgcGFydHNbMV0gOiAnJzsgLy8gd2hlbiBkZWNpbWFsIHNlcGFyYXRvciBhbHNvIG5lZWRlZCB3aGVuIHRoZXJlIGlzIG5vIGRlY2ltYWwgcGFydCBpbiBmcmVlIGVudHJ5IG1vZGVcbiAgICAvLyBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gYWxzbyB1c2VkIGZvciB0aGUgZGlzcGxheWVkIG51bWJlciBvbiB0aGUgbnVtcGFkLCBub3Qgb25seSBmb3IgdGhlIGlucHV0XG5cbiAgICBpZiAocGFydHNbMV0gIT09IHVuZGVmaW5lZCAmJiAhcGFydHNbMV0ubGVuZ3RoICYmIGZyZWVFbnRyeSkge1xuICAgICAgZGVjID0gcy5kZWNpbWFsU2VwYXJhdG9yO1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlZ2VyICsgZGVjO1xuICB9IC8vIEV4dGVuZGVkIG1ldGhvZHNcbiAgLy8gLS0tXG5cblxuICBpbnN0LnNldFZhbCA9IGZ1bmN0aW9uICh2YWwsIGZpbGwsIGNoYW5nZSwgdGVtcCkge1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgdmFsID0gK3ZhbC5yZXBsYWNlKHMudGhvdXNhbmRzU2VwYXJhdG9yLCAnJykucmVwbGFjZShzLmRlY2ltYWxTZXBhcmF0b3IsICcuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3QuX3NldFZhbChjb25zdHJhaW4odmFsLCBtaW4sIG1heCksIGZpbGwsIGNoYW5nZSwgdGVtcCk7XG4gIH07XG5cbiAgaW5zdC5nZXRWYWwgPSBmdW5jdGlvbiAodGVtcCkge1xuICAgIHZhciB2YWwgPSBpbnN0Ll9nZXRWYWwodGVtcCksXG4gICAgICAgIHZhbE5yID0gKHZhbCArICcnKS5yZXBsYWNlKHRob3VzYW5kUmVnZXgsICcnKS5yZXBsYWNlKHMuZGVjaW1hbFNlcGFyYXRvciwgJy4nKTtcblxuICAgIHJldHVybiBpc051bWVyaWModmFsTnIpID8gK3ZhbE5yIDogdmFsO1xuICB9OyAvLyAtLS1cblxuXG4gIHZhciBudW1iZXJUZW1wbGF0ZSA9IEFycmF5KG1heEludExlbmd0aCkuam9pbignZCcpOyAvLyBpbiB0aGUgY2FzZSBvZiBmcmVlRW50cnksIHRoZSBkZWNpbWFsIHBvaW50IHNob3VsZCBub3QgYmUgcGFydCBvZiB0aGUgdGVtcGxhdGVcblxuICBpZiAoZnJlZUVudHJ5KSB7XG4gICAgaWYgKHNjYWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vICsyIGluZGV4IHJlcXVpcmVkOlxuICAgICAgLy8gLSAxIGZvciB0aGUgZGVjaW1hbCBwb2ludFxuICAgICAgLy8gLSAxIGZvciB0aGUgam9pbiBtZXRob2QsIHNpbmNlIHRoZSBcImRcInMgd2lsbCBiZSB0aGUgc2VwYXJhdG9ycyAoYW5kIHRoZXJlJ3Mgb25lIHNlcGFyYXRvciBsZXNzIHRoYW4gdmFsdWUpXG4gICAgICBudW1iZXJUZW1wbGF0ZSArPSBzY2FsZSA/IEFycmF5KHNjYWxlICsgMikuam9pbignZCcpIDogJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bWJlclRlbXBsYXRlICs9IEFycmF5KHMubWF4U2NhbGUgKyAyKS5qb2luKCdkJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vICsxIHJlcXVpcmVkIGZvciB0aGUgam9pbiBtZXRob2QsIHNpbmNlIHRoZSBcImRcInMgd2lsbCBiZSB0aGUgc2VwYXJhdG9ycyAoYW5kIHRoZXJlJ3Mgb25lIHNlcGFyYXRvciBsZXNzIHRoYW4gdmFsdWUpXG4gICAgbnVtYmVyVGVtcGxhdGUgKz0gc2NhbGUgPyAnLicgKyBBcnJheShzY2FsZSArIDEpLmpvaW4oJ2QnKSA6ICcnO1xuICB9XG5cbiAgdmFyIHRlbXBsYXRlID0gKG5lZ2F0aXZlTnVtID8gJ3tzaWdufScgOiAnJykgKyBzLnByZWZpeC5yZXBsYWNlKC9kL2csICdcXFxcZCcpICsgbnVtYmVyVGVtcGxhdGUgKyBzLnN1ZmZpeC5yZXBsYWNlKC9kL2csICdcXFxcZCcpO1xuICByZXR1cm4ge1xuICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZSxcbiAgICBsZWZ0S2V5OiBuZWdhdGl2ZU51bSA/IHtcbiAgICAgIHRleHQ6ICctLysnLFxuICAgICAgdmFyaWFibGU6ICdzaWduOi06JyxcbiAgICAgIHRyYWNrOiBmYWxzZSxcbiAgICAgIGtleXM6IFsxMDcsIDEwOSwgMTg3LCAxODldXG4gICAgfSA6IHVuZGVmaW5lZCxcbiAgICByaWdodEtleTogZnJlZUVudHJ5ID8ge1xuICAgICAgdGV4dDogcy5kZWNpbWFsU2VwYXJhdG9yLFxuICAgICAgdmFsdWU6ICcuJyxcbiAgICAgIGtleXM6IFsxMTAsIDE5MF1cbiAgICB9IDogdW5kZWZpbmVkLFxuICAgIGFsbG93TGVhZGluZ1plcm86IGZyZWVFbnRyeSxcbiAgICBwYXJzZVZhbHVlOiBmdW5jdGlvbiBwYXJzZVZhbHVlKHZhbHVlKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICBtLFxuICAgICAgICAgIHYgPSB2YWx1ZSB8fCBzLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICByZXQgPSBbXSxcbiAgICAgICAgICBmaXhTY2FsZSA9IHNjYWxlICE9PSB1bmRlZmluZWQgPyBzY2FsZSA6IHMubWF4U2NhbGU7XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gMCB8fCB2YWx1ZSA9PT0gJzAnKSB7XG4gICAgICAgIHJldHVybiBbMF07XG4gICAgICB9XG5cbiAgICAgIGlmICh2KSB7XG4gICAgICAgIHYgPSAodiArICcnKS5yZXBsYWNlKHRob3VzYW5kUmVnZXgsICcnKS5yZXBsYWNlKHMuZGVjaW1hbFNlcGFyYXRvciwgJy4nKTtcbiAgICAgICAgbSA9IHYubWF0Y2goL1xcZCtcXC4/XFxkKi9nKTtcblxuICAgICAgICBpZiAobSkge1xuICAgICAgICAgIG0gPSAoK21bMF0pLnRvRml4ZWQoZml4U2NhbGUpO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IG0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChtW2ldICE9ICcuJykge1xuICAgICAgICAgICAgICBpZiAoK21baV0pIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaCgrbVtpXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocmV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIE5vIGxlYWRpbmcgMHNcbiAgICAgICAgICAgICAgICAvLyBpbiBmcmVlRW50cnkgbW9kZSwgemVyb3MgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQgYXJlIG9ubHkgbmVjZXNzYXJ5IGlmIHRoZXJlIGFyZSBvdGhlciBub256ZXJvIGRpZ2l0cyBhZnRlciB0aGVtXG4gICAgICAgICAgICAgICAgLy8gZm9yIGV4YW1wbGUgMTAuMDAwMSAtIGRlY2ltYWwgemVyb3MgYXJlIHJlcXVpcmVkID0+IDEwLjAwMDEgPT4gWzEsIDAsIC4sIDAsIDAsIDAsIDFdXG4gICAgICAgICAgICAgICAgLy8gZm9yIGV4YW1wbGUgMTAuMTAwMCAtIGRlY2ltYWwgemVyb3MgYXJlIG5vdCByZXF1aXJlZCA9PiAxMC4xID0+IFsxLCAwLCAuLCAxXVxuICAgICAgICAgICAgICAgIHZhciBkZWNJbmRleCA9IG0uaW5kZXhPZignLicpO1xuICAgICAgICAgICAgICAgIHZhciBub25aZXJvID0gbS5sZW5ndGggPiBpICsgMSAmJiBtLnN1YnN0cmluZyhpICsgMSkubWF0Y2goL1sxLTldKy8pO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFmcmVlRW50cnkgfHwgaSA8IGRlY0luZGV4IHx8IG5vblplcm8pIHtcbiAgICAgICAgICAgICAgICAgIHJldC5wdXNoKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChmcmVlRW50cnkpIHtcbiAgICAgICAgICAgICAgLy8gaW4gdGhlIGNhc2Ugb2YgZnJlZUVudHJ5LCB0aGUgZGVjaW1hbCBwb2ludCBzaG91bGQgYmUgcGFydCBvZiB0aGUgaW5wdXQgZGlnaXRzXG4gICAgICAgICAgICAgIHJldC5wdXNoKCcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGRlY2ltYWxJbmRleCA9IG0uaW5kZXhPZignLicpOyAvLyBpZiB0aGVyZSBhcmUgbm8gZGlnaXRzIGFmdGVyIHRoZSBwb2ludCByZW1vdmUgdGhlIHBvaW50XG5cbiAgICAgICAgICBpZiAobS5sZW5ndGggPD0gZGVjaW1hbEluZGV4ICsgMSB8fCAhbS5zdWJzdHJpbmcoZGVjaW1hbEluZGV4ICsgMSkubWF0Y2goL1sxLTldKy8pKSB7XG4gICAgICAgICAgICByZXQuc3BsaWNlKHJldC5pbmRleE9mKCcuJyksIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgIC8vIG1ha2UgdGhlIHNpZ24gdGhlIGxhc3QgdGhpbmcgdG8gbWFuaXB1bGF0ZVxuICAgICAgICByZXQudW5zaGlmdCgnc2lnbjonICsgJy0nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuICAgIGZvcm1hdFZhbHVlOiBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh2YWx1ZSwgdmFyaWFibGVzKSB7XG4gICAgICB2YXIgdiA9IGdldEZvcm1hdHRlZCh2YWx1ZSwgdHJ1ZSksXG4gICAgICAgICAgbnIgPSBnZXROdW1iZXIodmFsdWUsIHZhcmlhYmxlcyAmJiB2YXJpYWJsZXMuc2lnbiA9PSAnLScpO1xuICAgICAgcmV0dXJuIChuciA8IDAgPyAnLScgOiAnJykgKyAocy5yZXR1cm5BZmZpeCA/IHMucHJlZml4ICsgdiArIHMuc3VmZml4IDogdik7XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoZGF0YSkge1xuICAgICAgdmFyIGksXG4gICAgICAgICAgZGlnaXRzID0gZGF0YS52YWx1ZXMsXG4gICAgICAgICAgdiA9IGdldEZvcm1hdHRlZChkaWdpdHMpLFxuICAgICAgICAgIG5yID0gZ2V0TnVtYmVyKGRpZ2l0cywgZGF0YS52YXJpYWJsZXMgJiYgZGF0YS52YXJpYWJsZXMuc2lnbiA9PSAnLScpLFxuICAgICAgICAgIGRpc2FibGVkID0gW10sXG4gICAgICAgICAgaW52YWxpZCA9IG5yID4gbWF4IHx8IG5yIDwgbWluIHx8IChzLmludmFsaWQgPyBpbnN0Ll9pbmRleE9mKHMuaW52YWxpZCwgbnIpICE9IC0xIDogZmFsc2UpO1xuXG4gICAgICBpZiAoIWRpZ2l0cy5sZW5ndGggJiYgIXMuYWxsb3dMZWFkaW5nWmVybyAmJiAhZnJlZUVudHJ5KSB7XG4gICAgICAgIGRpc2FibGVkLnB1c2goMCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWdpdHMubGVuZ3RoID49IG1heEludExlbmd0aCB8fCBkaWdpdHMuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgICBkaXNhYmxlZC5wdXNoKCcuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmcmVlRW50cnkpIHtcbiAgICAgICAgaWYgKGRpZ2l0cy5sZW5ndGggPT0gMSAmJiBkaWdpdHNbMF0gPT09IDApIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDw9IDk7IGkrKykge1xuICAgICAgICAgICAgZGlzYWJsZWQucHVzaChpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRpZ2l0cy5sZW5ndGggfHwgZGlnaXRzW2RpZ2l0cy5sZW5ndGggLSAxXSA9PSAnLicpIHtcbiAgICAgICAgICBpbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgfSAvLyBPbmx5IGFsbG93IG1heCBtYXhTY2FsZSBkZWNpbWFsIHZhbHVlc1xuXG5cbiAgICAgICAgdmFyIHNjYSA9IHNjYWxlICE9PSB1bmRlZmluZWQgPyBzY2FsZSA6IHMubWF4U2NhbGU7IC8vID49IG1lYW5pbmc6IHN0YXJ0aW5nIHplcm8gZGlnaXQgbWF5IGJlIG1pc3NpbmcsIHRoYXQncyB3aHlcblxuICAgICAgICBpZiAoZGlnaXRzLmxlbmd0aCA+PSBzY2EgKyAxICYmIGRpZ2l0c1tkaWdpdHMubGVuZ3RoIC0gc2NhIC0gMV0gPT0gJy4nKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8PSA5OyBpKyspIHtcbiAgICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIERpc3BsYXkgdGhlIGZvcm1hdHRlZCB2YWx1ZVxuXG5cbiAgICAgIGlmIChpbnN0LmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICQkMSgnLm1ic2MtbnAtZHNwJywgaW5zdC5fbWFya3VwKS5odG1sKChkYXRhLnZhcmlhYmxlcy5zaWduIHx8ICcnKSArIHMucHJlZml4ICsgdiArIHMuc3VmZml4IHx8ICcmbmJzcDsnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgICAgICBpbnZhbGlkOiBpbnZhbGlkXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07IC8vIC0tLVxuLy8gVGltZXNwYW4gcHJlc2V0XG4vLyAtLS1cblxuXG5mdW5jdGlvbiBnZXRTZWNvbmRzKHZhbHVlKSB7XG4gIHZhciBpID0gMCxcbiAgICAgIG0gPSAxLFxuICAgICAgcmV0ID0gMDtcblxuICB3aGlsZSAodmFsdWUubGVuZ3RoKSB7XG4gICAgaWYgKGkgPiAzKSB7XG4gICAgICBtID0gNjAgKiA2MDtcbiAgICB9IGVsc2UgaWYgKGkgPiAxKSB7XG4gICAgICBtID0gNjA7XG4gICAgfVxuXG4gICAgcmV0ID0gcmV0ICsgdmFsdWUucG9wKCkgKiBtICogKGkgJSAyID8gMTAgOiAxKTtcbiAgICBpKys7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG52YXIgcGFydHMgPSBbJ2gnLCAnbScsICdzJ10sXG4gICAgdGltZXNwYW5EZWZhdWx0cyA9IHtcbiAgbWluOiAwLFxuICBtYXg6IDM2MjQzOSxcbiAgLy85OSAqIDYwICogNjAgKyA5OSAqIDYwICsgOTlcbiAgZGVmYXVsdFZhbHVlOiAwLFxuICBob3VyVGV4dFNob3J0OiAnaCcsXG4gIG1pbnV0ZVRleHRTaG9ydDogJ20nLFxuICBzZWNUZXh0U2hvcnQ6ICdzJ1xufTtcblxucHJlc2V0cyQxLnRpbWVzcGFuID0gZnVuY3Rpb24gKGluc3QpIHtcbiAgdmFyIG9yaWcgPSBleHRlbmQkMSh7fSwgaW5zdC5zZXR0aW5ncyksXG4gICAgICBzID0gZXh0ZW5kJDEoaW5zdC5zZXR0aW5ncywgdGltZXNwYW5EZWZhdWx0cywgb3JpZyksXG4gICAgICBsYWJlbHMgPSB7XG4gICAgaDogcy5ob3VyVGV4dFNob3J0LnJlcGxhY2UoL2QvZywgJ1xcXFxkJyksXG4gICAgbTogcy5taW51dGVUZXh0U2hvcnQucmVwbGFjZSgvZC9nLCAnXFxcXGQnKSxcbiAgICBzOiBzLnNlY1RleHRTaG9ydC5yZXBsYWNlKC9kL2csICdcXFxcZCcpXG4gIH0sXG4gICAgICB0ZW1wbGF0ZSA9ICdkPHNwYW4gY2xhc3M9XCJtYnNjLW5wLXN1cCBtYnNjLW5wLXRpbWVcIj4nICsgbGFiZWxzLnMgKyAnPC9zcGFuPic7XG5cbiAgZnVuY3Rpb24gZm9ybWF0VGltZShzZWNvbmRzKSB7XG4gICAgdmFyIHAsXG4gICAgICAgIHJldCA9ICcnLFxuICAgICAgICBtID0gNjAgKiA2MDtcbiAgICAkJDEocGFydHMpLmVhY2goZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgIHAgPSBNYXRoLmZsb29yKHNlY29uZHMgLyBtKTtcbiAgICAgIHNlY29uZHMgLT0gcCAqIG07XG4gICAgICBtIC89IDYwO1xuXG4gICAgICBpZiAocCA+IDAgfHwgdiA9PSAncycgJiYgIXJldCkge1xuICAgICAgICByZXQgPSByZXQgKyAocmV0ID8gJyAnIDogJycpICsgcCArIGxhYmVsc1t2XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgaWYgKHMubWF4ID4gOSkge1xuICAgIHRlbXBsYXRlID0gJ2QnICsgdGVtcGxhdGU7XG4gIH1cblxuICBpZiAocy5tYXggPiA5OSkge1xuICAgIHRlbXBsYXRlID0gJzxzcGFuIGNsYXNzPVwibWJzYy1ucC10cy1tXCI+JyArIChzLm1heCA+IDYzOSA/ICdkJyA6ICcnKSArICdkPC9zcGFuPjxzcGFuIGNsYXNzPVwibWJzYy1ucC1zdXAgbWJzYy1ucC10aW1lXCI+JyArIGxhYmVscy5tICsgJzwvc3Bhbj4nICsgdGVtcGxhdGU7XG4gIH1cblxuICBpZiAocy5tYXggPiA2MDM5KSB7XG4gICAgdGVtcGxhdGUgPSAnPHNwYW4gY2xhc3M9XCJtYnNjLW5wLXRzLWhcIj4nICsgKHMubWF4ID4gMzg0MzkgPyAnZCcgOiAnJykgKyAnZDwvc3Bhbj48c3BhbiBjbGFzcz1cIm1ic2MtbnAtc3VwIG1ic2MtbnAtdGltZVwiPicgKyBsYWJlbHMuaCArICc8L3NwYW4+JyArIHRlbXBsYXRlO1xuICB9IC8vIEV4dGVuZGVkIG1ldGhvZHNcbiAgLy8gLS0tXG5cblxuICBpbnN0LnNldFZhbCA9IGZ1bmN0aW9uICh2YWwsIGZpbGwsIGNoYW5nZSwgdGVtcCkge1xuICAgIGlmIChpc051bWVyaWModmFsKSkge1xuICAgICAgdmFsID0gZm9ybWF0VGltZSh2YWwpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0Ll9zZXRWYWwodmFsLCBmaWxsLCBjaGFuZ2UsIHRlbXApO1xuICB9O1xuXG4gIGluc3QuZ2V0VmFsID0gZnVuY3Rpb24gKHRlbXApIHtcbiAgICByZXR1cm4gaW5zdC5faGFzVmFsdWUgfHwgdGVtcCA/IGdldFNlY29uZHMoaW5zdC5nZXRBcnJheVZhbCh0ZW1wKSkgOiBudWxsO1xuICB9OyAvLyAtLS1cblxuXG4gIHJldHVybiB7XG4gICAgdGVtcGxhdGU6IHRlbXBsYXRlLFxuICAgIHBhcnNlVmFsdWU6IGZ1bmN0aW9uIHBhcnNlVmFsdWUodmFsdWUpIHtcbiAgICAgIHZhciBwLFxuICAgICAgICAgIHZ2ID0gdmFsdWUgfHwgZm9ybWF0VGltZShzLmRlZmF1bHRWYWx1ZSksXG4gICAgICAgICAgcmV0ID0gW107XG5cbiAgICAgIGlmICh2dikge1xuICAgICAgICAkJDEocGFydHMpLmVhY2goZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgICAgICBwID0gbmV3IFJlZ0V4cCgnKFxcXFxkKyknICsgbGFiZWxzW3ZdLCAnZ2knKS5leGVjKHZ2KTtcblxuICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICBwID0gK3BbMV07XG5cbiAgICAgICAgICAgIGlmIChwID4gOSkge1xuICAgICAgICAgICAgICByZXQucHVzaChNYXRoLmZsb29yKHAgLyAxMCkpO1xuICAgICAgICAgICAgICByZXQucHVzaChwICUgMTApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHJldC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBObyBsZWFkaW5nIDBzXG4gICAgICAgICAgICAgICAgcmV0LnB1c2goMCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAocCB8fCByZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gbGVhZGluZyAwc1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKHApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXQucHVzaCgwKTtcbiAgICAgICAgICAgIHJldC5wdXNoKDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcbiAgICBmb3JtYXRWYWx1ZTogZnVuY3Rpb24gZm9ybWF0VmFsdWUodmFsdWUpIHtcbiAgICAgIHJldHVybiBmb3JtYXRUaW1lKGdldFNlY29uZHModmFsdWUpKTtcbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShkYXRhKSB7XG4gICAgICB2YXIgdmFsdWUgPSBkYXRhLnZhbHVlcyxcbiAgICAgICAgICB2ID0gZ2V0U2Vjb25kcyh2YWx1ZS5zbGljZSgwKSksXG4gICAgICAgICAgZGlzYWJsZWQgPSBbXTtcblxuICAgICAgaWYgKCF2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgZGlzYWJsZWQucHVzaCgwKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgICAgICBpbnZhbGlkOiB2ID4gcy5tYXggfHwgdiA8IHMubWluIHx8IChzLmludmFsaWQgPyBpbnN0Ll9pbmRleE9mKHMuaW52YWxpZCwgK3YpICE9IC0xIDogZmFsc2UpXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07IC8vIC0tLVxuLy8gVGltZSBwcmVzZXRcbi8vIC0tLVxuXG5cbnZhciB0aW1lRGVmYXVsdHMgPSB7XG4gIHRpbWVGb3JtYXQ6ICdoaDppaSBBJyxcbiAgYW1UZXh0OiAnYW0nLFxuICBwbVRleHQ6ICdwbSdcbn07XG5cbnByZXNldHMkMS50aW1lID0gZnVuY3Rpb24gKGluc3QpIHtcbiAgdmFyIG9yaWcgPSBleHRlbmQkMSh7fSwgaW5zdC5zZXR0aW5ncyksXG4gICAgICBzID0gZXh0ZW5kJDEoaW5zdC5zZXR0aW5ncywgdGltZURlZmF1bHRzLCBvcmlnKSxcbiAgICAgIHRpbWVGb3JtYXQgPSBzLnRpbWVGb3JtYXQuc3BsaXQoJzonKSxcbiAgICAgIGlzQW1QTSA9IHMudGltZUZvcm1hdC5tYXRjaCgvYS9pKSxcbiAgICAgIGFtID0gaXNBbVBNID8gaXNBbVBNWzBdID09ICdhJyA/IHMuYW1UZXh0IDogcy5hbVRleHQudG9VcHBlckNhc2UoKSA6ICcnLFxuICAgICAgcG0gPSBpc0FtUE0gPyBpc0FtUE1bMF0gPT0gJ2EnID8gcy5wbVRleHQgOiBzLnBtVGV4dC50b1VwcGVyQ2FzZSgpIDogJycsXG4gICAgICBsID0gMCxcbiAgICAgIG1pbkggPSBzLm1pbiA/ICcnICsgcy5taW4uZ2V0SG91cnMoKSA6ICcnLFxuICAgICAgbWF4SCA9IHMubWF4ID8gJycgKyBzLm1heC5nZXRIb3VycygpIDogJycsXG4gICAgICBtaW5NID0gcy5taW4gPyAnJyArIChzLm1pbi5nZXRNaW51dGVzKCkgPCAxMCA/ICcwJyArIHMubWluLmdldE1pbnV0ZXMoKSA6IHMubWluLmdldE1pbnV0ZXMoKSkgOiAnJyxcbiAgICAgIG1heE0gPSBzLm1heCA/ICcnICsgKHMubWF4LmdldE1pbnV0ZXMoKSA8IDEwID8gJzAnICsgcy5tYXguZ2V0TWludXRlcygpIDogcy5tYXguZ2V0TWludXRlcygpKSA6ICcnLFxuICAgICAgbWluUyA9IHMubWluID8gJycgKyAocy5taW4uZ2V0U2Vjb25kcygpIDwgMTAgPyAnMCcgKyBzLm1pbi5nZXRTZWNvbmRzKCkgOiBzLm1pbi5nZXRTZWNvbmRzKCkpIDogJycsXG4gICAgICBtYXhTID0gcy5tYXggPyAnJyArIChzLm1heC5nZXRTZWNvbmRzKCkgPCAxMCA/ICcwJyArIHMubWF4LmdldFNlY29uZHMoKSA6IHMubWF4LmdldFNlY29uZHMoKSkgOiAnJztcblxuICBpZiAocy5taW4pIHtcbiAgICBzLm1pbi5zZXRGdWxsWWVhcigyMDE0LCA3LCAyMCk7XG4gIH1cblxuICBpZiAocy5tYXgpIHtcbiAgICBzLm1heC5zZXRGdWxsWWVhcigyMDE0LCA3LCAyMCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRGb3JtYXR0ZWRUaW1lKHZhbHVlLCB2YXJpYWJsZXMpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgcmV0ID0gJyc7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgIHJldCArPSB2YWx1ZVtpXSArIChpICUgMiA9PSAodmFsdWUubGVuZ3RoICUgMiA9PSAxID8gMCA6IDEpICYmIGkgIT0gdmFsdWUubGVuZ3RoIC0gMSA/ICc6JyA6ICcnKTtcbiAgICB9XG5cbiAgICAkJDEuZWFjaCh2YXJpYWJsZXMsIGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICByZXQgKz0gJyAnICsgdjtcbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgZnVuY3Rpb24gZGlzYWJsZUJ1dHRvbnModmFsdWUpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgaXNNaW5ILFxuICAgICAgICBpc01heEgsXG4gICAgICAgIGlzTWluTSxcbiAgICAgICAgaXNNYXhNLFxuICAgICAgICBpbnZILFxuICAgICAgICBpbnZNLFxuICAgICAgICBpbnZTLFxuICAgICAgICBob3VyLFxuICAgICAgICBtaW51dGVzLFxuICAgICAgICBkaXNhYmxlZCA9IFtdLFxuICAgICAgICBkaWdpdE5yID0gMiAqIHRpbWVGb3JtYXQubGVuZ3RoO1xuICAgIGwgPSBkaWdpdE5yO1xuXG4gICAgaWYgKCF2YWx1ZS5sZW5ndGgpIHtcbiAgICAgIGlmIChpc0FtUE0pIHtcbiAgICAgICAgZGlzYWJsZWQucHVzaCgwKTtcbiAgICAgICAgZGlzYWJsZWQucHVzaChzLmxlZnRLZXkudmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBkaXNhYmxlZC5wdXNoKHMucmlnaHRLZXkudmFsdWUpO1xuICAgIH1cblxuICAgIGlmICghaXNBbVBNICYmIChkaWdpdE5yIC0gdmFsdWUubGVuZ3RoIDwgMiB8fCB2YWx1ZVswXSAhPSAxICYmICh2YWx1ZVswXSA+IDIgfHwgdmFsdWVbMV0gPiAzKSAmJiBkaWdpdE5yIC0gdmFsdWUubGVuZ3RoIDw9IDIpKSB7XG4gICAgICBkaXNhYmxlZC5wdXNoKCczMCcpO1xuICAgICAgZGlzYWJsZWQucHVzaCgnMDAnKTtcbiAgICB9XG5cbiAgICBpZiAoKGlzQW1QTSA/IHZhbHVlWzBdID4gMSB8fCB2YWx1ZVsxXSA+IDIgOiB2YWx1ZVswXSAhPSAxICYmICh2YWx1ZVswXSA+IDIgfHwgdmFsdWVbMV0gPiAzKSkgJiYgdmFsdWVbMF0pIHtcbiAgICAgIC8vIGlmIHRoZSBob3VyIG51bWJlciBpcyBub3QgYSB0d28gZGlnaXQgbnVtYmVyXG4gICAgICB2YWx1ZS51bnNoaWZ0KDApO1xuICAgICAgbCA9IGRpZ2l0TnIgLSAxO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZS5sZW5ndGggPT0gZGlnaXROcikge1xuICAgICAgZm9yIChpID0gMDsgaSA8PSA5OyArK2kpIHtcbiAgICAgICAgZGlzYWJsZWQucHVzaChpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbHVlLmxlbmd0aCA9PSAxICYmIGlzQW1QTSAmJiB2YWx1ZVswXSA9PSAxIHx8IHZhbHVlLmxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggJSAyID09PSAwIHx8ICFpc0FtUE0gJiYgdmFsdWVbMF0gPT0gMiAmJiB2YWx1ZVsxXSA+IDMgJiYgdmFsdWUubGVuZ3RoICUgMiA9PSAxKSB7XG4gICAgICBmb3IgKGkgPSA2OyBpIDw9IDk7ICsraSkge1xuICAgICAgICBkaXNhYmxlZC5wdXNoKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhvdXIgPSB2YWx1ZVsxXSAhPT0gdW5kZWZpbmVkID8gJycgKyB2YWx1ZVswXSArIHZhbHVlWzFdIDogJyc7XG4gICAgbWludXRlcyA9ICttYXhNID09ICsodmFsdWVbM10gIT09IHVuZGVmaW5lZCA/ICcnICsgdmFsdWVbMl0gKyB2YWx1ZVszXSA6ICcnKTtcblxuICAgIGlmIChzLmludmFsaWQpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzLmludmFsaWQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaW52SCA9IHMuaW52YWxpZFtpXS5nZXRIb3VycygpO1xuICAgICAgICBpbnZNID0gcy5pbnZhbGlkW2ldLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgaW52UyA9IHMuaW52YWxpZFtpXS5nZXRTZWNvbmRzKCk7XG5cbiAgICAgICAgaWYgKGludkggPT0gK2hvdXIpIHtcbiAgICAgICAgICBpZiAodGltZUZvcm1hdC5sZW5ndGggPT0gMiAmJiAoaW52TSA8IDEwID8gMCA6ICsoJycgKyBpbnZNKVswXSkgPT0gK3ZhbHVlWzJdKSB7XG4gICAgICAgICAgICAvLyBkaXNhYmxlIGludmFsaWQgbWludXRlc1xuICAgICAgICAgICAgZGlzYWJsZWQucHVzaChpbnZNIDwgMTAgPyBpbnZNIDogKygnJyArIGludk0pWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKGludlMgPCAxMCA/IDAgOiArKCcnICsgaW52UylbMF0pID09ICt2YWx1ZVs0XSkge1xuICAgICAgICAgICAgLy8gZGlzYWJsZSBpbnZhbGlkIHNlY1xuICAgICAgICAgICAgZGlzYWJsZWQucHVzaChpbnZTIDwgMTAgPyBpbnZTIDogKygnJyArIGludlMpWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzLm1pbiB8fCBzLm1heCkge1xuICAgICAgaXNNaW5IID0gK21pbkggPT0gK2hvdXI7XG4gICAgICBpc01heEggPSArbWF4SCA9PSAraG91cjtcbiAgICAgIGlzTWF4TSA9IGlzTWF4SCAmJiBtaW51dGVzO1xuICAgICAgaXNNaW5NID0gaXNNaW5IICYmIG1pbnV0ZXM7XG5cbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZm9yIChpID0gaXNBbVBNID8gMiA6IG1pbkggPiAxOSA/IG1pbkhbMF0gOiAzOyBpIDw9IChtaW5IWzBdID09IDEgPyA5IDogbWluSFswXSAtIDEpOyArK2kpIHtcbiAgICAgICAgICAvLyBkaXNhYmxlcyB2YWx1ZXMgbG93ZXIgdGhhbiBtaW4gYW5kIGxldmVzIHRoZSAxLDIgYnV0dG9uc1xuICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWluSCA+PSAxMCkge1xuICAgICAgICAgIGRpc2FibGVkLnB1c2goMCk7XG5cbiAgICAgICAgICBpZiAobWluSFswXSA9PSAyKSB7XG4gICAgICAgICAgICAvL2lmIDJ4IGhvdXIgaXMgbWluXG4gICAgICAgICAgICBmb3IgKGkgPSAzOyBpIDw9IDk7ICsraSkge1xuICAgICAgICAgICAgICBkaXNhYmxlZC5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXhIICYmIG1heEggPCAxMCB8fCBtaW5IICYmIG1pbkggPj0gMTApIHtcbiAgICAgICAgICAvL2Rpc2FibGVzIHZhbHVlcyBiZXR3ZWVuIG1pbiBhbmQgbWF4IHZhbHVlc1xuICAgICAgICAgIGZvciAoaSA9IG1heEggJiYgbWF4SCA8IDEwID8gK21heEhbMF0gKyAxIDogMDsgaSA8IChtaW5IICYmIG1pbkggPj0gMTAgPyBtaW5IWzBdIDogMTApOyArK2kpIHtcbiAgICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT0gMSkge1xuICAgICAgICBpZiAodmFsdWVbMF0gPT09IDApIHtcbiAgICAgICAgICAvLyBkaXNhYmxlIG1pbiB2YWx1ZXMgaWYgMjRoIGZvcm1hdCwgYW5kIHN0YXJ0cyB3aXRoIDBcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbWluSFswXTsgKytpKSB7XG4gICAgICAgICAgICAvL2tpdmV2ZSBtaW5IWzBdID09IDEgPyA5IDpcbiAgICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pbkggJiYgdmFsdWVbMF0gIT09IDAgJiYgKGlzQW1QTSA/IHZhbHVlWzBdID09IDEgOiB2YWx1ZVswXSA9PSAyKSkge1xuICAgICAgICAgIC8vIGRvbid0IGFsbG93IGxvd2VyIHZhbHVlcyBlbnRlcmVkLCBleC4gMjo1NlxuICAgICAgICAgIGZvciAoaSA9IGlzQW1QTSA/IDMgOiA0OyBpIDw9IDk7ICsraSkge1xuICAgICAgICAgICAgZGlzYWJsZWQucHVzaChpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWVbMF0gPT0gbWluSFswXSkge1xuICAgICAgICAgIC8vIGlzIG1pbiB2YWx1ZVxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtaW5IWzFdOyArK2kpIHtcbiAgICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlWzBdID09IG1heEhbMF0gJiYgIWlzQW1QTSkge1xuICAgICAgICAgIC8vIGlzIG1heCB2YWx1ZVxuICAgICAgICAgIGZvciAoaSA9ICttYXhIWzFdICsgMTsgaSA8PSA5OyArK2kpIHtcbiAgICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT0gMiAmJiAoaXNNaW5IIHx8IGlzTWF4SCkpIHtcbiAgICAgICAgZm9yIChpID0gaXNNYXhIID8gK21heE1bMF0gKyAxIDogMDsgaSA8IChpc01pbkggPyArbWluTVswXSA6IDEwKTsgKytpKSB7XG4gICAgICAgICAgZGlzYWJsZWQucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUubGVuZ3RoID09IDMgJiYgKGlzTWF4SCAmJiB2YWx1ZVsyXSA9PSBtYXhNWzBdIHx8IGlzTWluSCAmJiB2YWx1ZVsyXSA9PSBtaW5NWzBdKSkge1xuICAgICAgICBmb3IgKGkgPSBpc01heEggJiYgdmFsdWVbMl0gPT0gbWF4TVswXSA/ICttYXhNWzFdICsgMSA6IDA7IGkgPCAoaXNNaW5IICYmIHZhbHVlWzJdID09IG1pbk1bMF0gPyArbWluTVsxXSA6IDEwKTsgKytpKSB7XG4gICAgICAgICAgZGlzYWJsZWQucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodmFsdWUubGVuZ3RoID09IDQgJiYgKGlzTWluTSB8fCBpc01heE0pKSB7XG4gICAgICAgIGZvciAoaSA9IGlzTWF4TSA/ICttYXhTWzBdICsgMSA6IDA7IGkgPCAoaXNNaW5NID8gK21pblNbMF0gOiAxMCk7ICsraSkge1xuICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PSA1ICYmIChpc01pbk0gJiYgdmFsdWVbNF0gPT0gbWluU1swXSB8fCBpc01heE0gJiYgdmFsdWVbNF0gPT0gbWF4U1swXSkpIHtcbiAgICAgICAgZm9yIChpID0gaXNNYXhNICYmIHZhbHVlWzRdID09IG1heFNbMF0gPyArbWF4U1sxXSArIDEgOiAwOyBpIDwgKGlzTWluTSAmJiB2YWx1ZVs0XSA9PSBtaW5TWzBdID8gK21pblNbMV0gOiAxMCk7ICsraSkge1xuICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGlzYWJsZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBsYWNlaG9sZGVyOiAnLScsXG4gICAgYWxsb3dMZWFkaW5nWmVybzogdHJ1ZSxcbiAgICB0ZW1wbGF0ZTogKHRpbWVGb3JtYXQubGVuZ3RoID09IDMgPyAnZGQ6ZGQ6ZGQnIDogdGltZUZvcm1hdC5sZW5ndGggPT0gMiA/ICdkZDpkZCcgOiAnZGQnKSArIChpc0FtUE0gPyAnPHNwYW4gY2xhc3M9XCJtYnNjLW5wLXN1cFwiPnthbXBtOi0tfTwvc3Bhbj4nIDogJycpLFxuICAgIGxlZnRLZXk6IGlzQW1QTSA/IHtcbiAgICAgIHRleHQ6IGFtLFxuICAgICAgdmFyaWFibGU6ICdhbXBtOicgKyBhbSxcbiAgICAgIHZhbHVlOiAnMDAnXG4gICAgfSA6IHtcbiAgICAgIHRleHQ6ICc6MDAnLFxuICAgICAgdmFsdWU6ICcwMCdcbiAgICB9LFxuICAgIHJpZ2h0S2V5OiBpc0FtUE0gPyB7XG4gICAgICB0ZXh0OiBwbSxcbiAgICAgIHZhcmlhYmxlOiAnYW1wbTonICsgcG0sXG4gICAgICB2YWx1ZTogJzAwJ1xuICAgIH0gOiB7XG4gICAgICB0ZXh0OiAnOjMwJyxcbiAgICAgIHZhbHVlOiAnMzAnXG4gICAgfSxcbiAgICBwYXJzZVZhbHVlOiBmdW5jdGlvbiBwYXJzZVZhbHVlKHZhbHVlKSB7XG4gICAgICB2YXIgaSxcbiAgICAgICAgICBtLFxuICAgICAgICAgIHYgPSB2YWx1ZSB8fCBzLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICByZXQgPSBbXTtcblxuICAgICAgaWYgKHYpIHtcbiAgICAgICAgdiA9IHYgKyAnJztcbiAgICAgICAgbSA9IHYubWF0Y2goL1xcZC9nKTtcblxuICAgICAgICBpZiAobSkge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXQucHVzaCgrbVtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQW1QTSkge1xuICAgICAgICAgIHJldC5wdXNoKCdhbXBtOicgKyAodi5tYXRjaChuZXcgUmVnRXhwKHMucG1UZXh0LCAnZ2knKSkgPyBwbSA6IGFtKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuICAgIGZvcm1hdFZhbHVlOiBmdW5jdGlvbiBmb3JtYXRWYWx1ZSh2YWx1ZSwgdmFyaWFibGVzKSB7XG4gICAgICByZXR1cm4gZ2V0Rm9ybWF0dGVkVGltZSh2YWx1ZSwgdmFyaWFibGVzKTtcbiAgICB9LFxuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiB2YWxpZGF0ZShkYXRhKSB7XG4gICAgICB2YXIgdmFsdWUgPSBkYXRhLnZhbHVlcyxcbiAgICAgICAgICB2YXJpYWJsZXMgPSBkYXRhLnZhcmlhYmxlcyxcbiAgICAgICAgICBmb3JtYXR0ZWRUaW1lID0gZ2V0Rm9ybWF0dGVkVGltZSh2YWx1ZSwgdmFyaWFibGVzKSxcbiAgICAgICAgICBkID0gdmFsdWUubGVuZ3RoID49IDMgPyBuZXcgRGF0ZSgyMDE0LCA3LCAyMCwgJycgKyB2YWx1ZVswXSArICh2YWx1ZS5sZW5ndGggJSAyID09PSAwID8gdmFsdWVbMV0gOiAnJyksICcnICsgdmFsdWVbdmFsdWUubGVuZ3RoICUgMiA9PT0gMCA/IDIgOiAxXSArIHZhbHVlW3ZhbHVlLmxlbmd0aCAlIDIgPT09IDAgPyAzIDogMl0pIDogJyc7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXNhYmxlZDogZGlzYWJsZUJ1dHRvbnModmFsdWUpLFxuICAgICAgICBsZW5ndGg6IGwsXG4gICAgICAgIGludmFsaWQ6IChpc0FtUE0gPyAhbmV3IFJlZ0V4cCgnXigwP1sxLTldfDFbMDEyXSkoOlswLTVdXFxcXGQpPyg6WzAtNV1bMC05XSknICsgJyAoPzonICsgcy5hbVRleHQgKyAnfCcgKyBzLnBtVGV4dCArICcpJCcsICdpJykudGVzdChmb3JtYXR0ZWRUaW1lKSA6ICEvXihbMC0xXT9bMC05XXwyWzAtNF0pOihbMC01XVswLTldKSg6WzAtNV1bMC05XSk/JC8udGVzdChmb3JtYXR0ZWRUaW1lKSkgfHwgKHMuaW52YWxpZCA/IGluc3QuX2luZGV4T2Yocy5pbnZhbGlkLCBkKSAhPSAtMSA6IGZhbHNlKSB8fCAhKChzLm1pbiA/IHMubWluIDw9IGQgOiB0cnVlKSAmJiAocy5tYXggPyBkIDw9IHMubWF4IDogdHJ1ZSkpXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07IC8vIERhdGUgcHJlc2V0XG4vLyAtLS1cblxuXG52YXIgZGF0ZURlZmF1bHRzID0ge1xuICBkYXRlT3JkZXI6ICdtZHknLFxuICBkYXRlRm9ybWF0OiAnbW0vZGQveXknLFxuICBkZWxpbWl0ZXI6ICcvJ1xufTtcblxucHJlc2V0cyQxLmRhdGUgPSBmdW5jdGlvbiAoaW5zdCkge1xuICB2YXIgeWksXG4gICAgICBtaSxcbiAgICAgIGRpLFxuICAgICAgaSxcbiAgICAgIGluZGV4QXJyYXkgPSBbXSxcbiAgICAgIG9yaWcgPSBleHRlbmQkMSh7fSwgaW5zdC5zZXR0aW5ncyksXG4gICAgICBzID0gZXh0ZW5kJDEoaW5zdC5zZXR0aW5ncywgZGF0ZVRpbWVEZWZhdWx0cywgZGF0ZURlZmF1bHRzLCBvcmlnKSxcbiAgICAgIHRlbXBsID0gcy5kYXRlT3JkZXIsXG4gICAgICBtaW5NID0gcy5taW4gPyAnJyArIChzLmdldE1vbnRoKHMubWluKSArIDEpIDogMCxcbiAgICAgIG1heE0gPSBzLm1heCA/ICcnICsgKHMuZ2V0TW9udGgocy5tYXgpICsgMSkgOiAwLFxuICAgICAgbWluRCA9IHMubWluID8gJycgKyBzLmdldERheShzLm1pbikgOiAwLFxuICAgICAgbWF4RCA9IHMubWF4ID8gJycgKyBzLmdldERheShzLm1heCkgOiAwLFxuICAgICAgbWluWSA9IHMubWluID8gJycgKyBzLmdldFllYXIocy5taW4pIDogMCxcbiAgICAgIG1heFkgPSBzLm1heCA/ICcnICsgcy5nZXRZZWFyKHMubWF4KSA6IDA7XG4gIHRlbXBsID0gdGVtcGwucmVwbGFjZSgveSsvZ2ksICd5eXl5Jyk7XG4gIHRlbXBsID0gdGVtcGwucmVwbGFjZSgvbSsvZ2ksICdtbScpO1xuICB0ZW1wbCA9IHRlbXBsLnJlcGxhY2UoL2QrL2dpLCAnZGQnKTtcbiAgeWkgPSB0ZW1wbC50b1VwcGVyQ2FzZSgpLmluZGV4T2YoJ1knKTtcbiAgbWkgPSB0ZW1wbC50b1VwcGVyQ2FzZSgpLmluZGV4T2YoJ00nKTtcbiAgZGkgPSB0ZW1wbC50b1VwcGVyQ2FzZSgpLmluZGV4T2YoJ0QnKTtcbiAgdGVtcGwgPSAnJztcbiAgaW5kZXhBcnJheS5wdXNoKHtcbiAgICB2YWw6IHlpLFxuICAgIG46ICd5eXl5J1xuICB9LCB7XG4gICAgdmFsOiBtaSxcbiAgICBuOiAnbW0nXG4gIH0sIHtcbiAgICB2YWw6IGRpLFxuICAgIG46ICdkZCdcbiAgfSk7XG4gIGluZGV4QXJyYXkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhLnZhbCAtIGIudmFsO1xuICB9KTtcbiAgJCQxLmVhY2goaW5kZXhBcnJheSwgZnVuY3Rpb24gKGksIHYpIHtcbiAgICB0ZW1wbCArPSB2Lm47XG4gIH0pO1xuICB5aSA9IHRlbXBsLmluZGV4T2YoJ3knKTtcbiAgbWkgPSB0ZW1wbC5pbmRleE9mKCdtJyk7XG4gIGRpID0gdGVtcGwuaW5kZXhPZignZCcpO1xuICB0ZW1wbCA9ICcnO1xuXG4gIGZvciAoaSA9IDA7IGkgPCA4OyArK2kpIHtcbiAgICB0ZW1wbCArPSAnZCc7XG5cbiAgICBpZiAoaSArIDEgPT0geWkgfHwgaSArIDEgPT0gbWkgfHwgaSArIDEgPT0gZGkpIHtcbiAgICAgIHRlbXBsICs9IHMuZGVsaW1pdGVyO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzbGVhcFllYXIoeWVhcikge1xuICAgIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDA7XG4gIH1cblxuICBmdW5jdGlvbiBkaXNhYmxlQnV0dG9ucyh2YWx1ZSkge1xuICAgIHZhciBpLFxuICAgICAgICBqLFxuICAgICAgICBpbnZZLFxuICAgICAgICBpbnZNLFxuICAgICAgICBpbnZELFxuICAgICAgICBkaXNhYmxlZCA9IFtdLFxuICAgICAgICB5ZWFyID0gdmFsdWVbeWkgKyAzXSAhPT0gdW5kZWZpbmVkID8gJycgKyB2YWx1ZVt5aV0gKyB2YWx1ZVt5aSArIDFdICsgdmFsdWVbeWkgKyAyXSArIHZhbHVlW3lpICsgM10gOiAnJyxcbiAgICAgICAgbW9udGggPSB2YWx1ZVttaSArIDFdICE9PSB1bmRlZmluZWQgPyAnJyArIHZhbHVlW21pXSArIHZhbHVlW21pICsgMV0gOiAnJyxcbiAgICAgICAgZGF5ID0gdmFsdWVbZGkgKyAxXSAhPT0gdW5kZWZpbmVkID8gJycgKyB2YWx1ZVtkaV0gKyB2YWx1ZVtkaSArIDFdIDogJycsXG4gICAgICAgIG1heERheSA9ICcnICsgcy5nZXRNYXhEYXlPZk1vbnRoKHllYXIgfHwgMjAxMiwgbW9udGggLSAxIHx8IDApLFxuICAgICAgICAvLyBVc2UgYSBsZWFwIHllYXIgaWYgbm8geWVhciBwcmVzZW50IHRvIGFsbG93IGRheSAyOSB0byBiZSBlbmV0ZXJlZFxuICAgIGlzTWluID0gbWluWSA9PT0geWVhciAmJiArbWluTSA9PT0gK21vbnRoLFxuICAgICAgICBpc01heCA9IG1heFkgPT09IHllYXIgJiYgK21heE0gPT09ICttb250aDtcblxuICAgIGlmIChzLmludmFsaWQpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzLmludmFsaWQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaW52WSA9IHMuZ2V0WWVhcihzLmludmFsaWRbaV0pO1xuICAgICAgICBpbnZNID0gcy5nZXRNb250aChzLmludmFsaWRbaV0pO1xuICAgICAgICBpbnZEID0gcy5nZXREYXkocy5pbnZhbGlkW2ldKTtcblxuICAgICAgICBpZiAoaW52WSA9PSAreWVhciAmJiBpbnZNICsgMSA9PSArbW9udGgpIHtcbiAgICAgICAgICAvL2Rpc2FibGUgdGhlIGl2YWxpZCBkYXlcbiAgICAgICAgICBpZiAoKGludkQgPCAxMCA/IDAgOiArKCcnICsgaW52RClbMF0pID09ICt2YWx1ZVtkaV0pIHtcbiAgICAgICAgICAgIGRpc2FibGVkLnB1c2goaW52RCA8IDEwID8gaW52RCA6ICsoJycgKyBpbnZEKVsxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW52TSArIDEgPT0gK21vbnRoICYmIGludkQgPT0gK2RheSkge1xuICAgICAgICAgIC8vZGlzYWJsZSBpbnZhbGlkIHllYXJcbiAgICAgICAgICBpZiAoKCcnICsgaW52WSkuc3Vic3RyaW5nKDAsIDMpID09ICcnICsgdmFsdWVbeWldICsgdmFsdWVbeWkgKyAxXSArIHZhbHVlW3lpICsgMl0pIHtcbiAgICAgICAgICAgIGRpc2FibGVkLnB1c2goKCcnICsgaW52WSlbM10pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGludlkgPT0gK3llYXIgJiYgaW52RCA9PSArZGF5KSB7XG4gICAgICAgICAgLy9kaXNhYmxlIHRoZSBpdmFsaWQgbW9udGhcbiAgICAgICAgICBpZiAoKGludk0gPCAxMCA/IDAgOiArKCcnICsgKGludk0gKyAxKSlbMF0pID09ICt2YWx1ZVttaV0pIHtcbiAgICAgICAgICAgIGRpc2FibGVkLnB1c2goaW52TSA8IDEwID8gaW52TSA6ICsoJycgKyAoaW52TSArIDEpKVsxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIG1vbnRoIGNoZWNrXG5cblxuICAgIGlmIChkYXkgPT0gJzMxJyAmJiAodmFsdWUubGVuZ3RoID09IG1pIHx8IHZhbHVlLmxlbmd0aCA9PSBtaSArIDEpKSB7XG4gICAgICAvLyBkaXNhYmxlIDMwIGRheSBtb250aHNcbiAgICAgIGlmICh2YWx1ZVttaV0gIT0gMSkge1xuICAgICAgICBkaXNhYmxlZC5wdXNoKDIsIDQsIDYsIDksIDExKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc2FibGVkLnB1c2goMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRheSA9PSAnMzAnICYmIHZhbHVlW21pXSA9PT0gMCAmJiB2YWx1ZS5sZW5ndGggPD0gbWkgKyAxKSB7XG4gICAgICAvLyBkaXNhYmxlIGZlYnJ1YXJ5XG4gICAgICBkaXNhYmxlZC5wdXNoKDIpO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZS5sZW5ndGggPT0gbWkpIHtcbiAgICAgIC8vIGJlZm9yZSBtb250aCdzIGZpcnN0IGRpZ2l0IHNldCwgZGlzYWJsZSB2YWx1ZXMgb3V0c2lkZSBtaW4vbWF4XG4gICAgICBmb3IgKGkgPSBtYXhZID09PSB5ZWFyICYmICttYXhNIDwgMTAgPyAxIDogMjsgaSA8PSA5OyArK2kpIHtcbiAgICAgICAgZGlzYWJsZWQucHVzaChpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1pblkgPT09IHllYXIgJiYgK21pbk0gPj0gMTApIHtcbiAgICAgICAgZGlzYWJsZWQucHVzaCgwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmFsdWUubGVuZ3RoID09IG1pICsgMSkge1xuICAgICAgLy8gYmVmb3JlIG1vbnRoJ3Mgc2Vjb25kIGRpZ2l0IHNldFxuICAgICAgaWYgKHZhbHVlW21pXSA9PSAxKSB7XG4gICAgICAgIC8vIGlmIHR3byBkaWdpdCBtb250aCBudW1iZXJcbiAgICAgICAgZm9yIChpID0gbWF4WSA9PT0geWVhciA/ICttYXhNWzFdICsgMSA6IDM7IGkgPD0gOTsgKytpKSB7XG4gICAgICAgICAgZGlzYWJsZWQucHVzaChpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtaW5ZID09IHllYXIpIHtcbiAgICAgICAgICAvLyBpZiBtaW4geWVhciBkaWFibGUgbG93ZXIgdmFsdWVzXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8ICttaW5NWzFdOyArK2kpIHtcbiAgICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZVttaV0gPT09IDApIHtcbiAgICAgICAgLy9pZiBtb250aCBudW1iZXIgc3RhcnRzIHdpdGggMFxuICAgICAgICBkaXNhYmxlZC5wdXNoKDApO1xuXG4gICAgICAgIGlmIChtYXhZID09PSB5ZWFyIHx8IG1pblkgPT09IHllYXIpIHtcbiAgICAgICAgICAvLyBpZiBtaW4vbWF4IGRpYWJsZSBsb3dlci9ncmVhdGVyIHZhbHVlc1xuICAgICAgICAgIGZvciAoaSA9IG1heFkgPT09IHllYXIgPyArZGF5ID4gK21heEQgPyArbWF4TSA6ICttYXhNICsgMSA6IDA7IGkgPD0gKG1pblkgPT09IHllYXIgPyArZGF5IDwgK21pbkQgPyArbWluTSAtIDEgOiArbWluTSAtIDEgOiA5KTsgKytpKSB7XG4gICAgICAgICAgICBkaXNhYmxlZC5wdXNoKGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gZGF5IGNoZWNrXG5cblxuICAgIGlmICh2YWx1ZS5sZW5ndGggPT0gZGkpIHtcbiAgICAgIC8vIGJlZm9yZSBkYXkgZmlyc3QgZGlnaXQgc2V0XG4gICAgICBmb3IgKGkgPSBpc01heCA/ICgrbWF4RCA+IDEwID8gK21heERbMF0gOiAwKSArIDEgOiArbWF4RGF5WzBdICsgMTsgaSA8PSA5OyArK2kpIHtcbiAgICAgICAgZGlzYWJsZWQucHVzaChpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTWluKSB7XG4gICAgICAgIC8vIGlmIGlzIG1pbiB5ZWFyIGFuZCBtb250aCBkaXNhYmxlIGxvd2VyIHZhbHVlc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgKCttaW5EIDwgMTAgPyAwIDogbWluRFswXSk7ICsraSkge1xuICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmFsdWUubGVuZ3RoID09IGRpICsgMSkge1xuICAgICAgLy8gYmVmb3JlIGRheSBzZWNvbmQgZGlnaXQgc2V0XG4gICAgICBpZiAodmFsdWVbZGldID49IDMgfHwgbW9udGggPT0gJzAyJykge1xuICAgICAgICAvL2Rpc2FibGUgZ3JlYXRlciB2YWx1ZXMgdGhhbiB0aGUgbWF4RGF5J3Mgc2Vjb25kIGRpZ2l0XG4gICAgICAgIGZvciAoaSA9ICttYXhEYXlbMV0gKyAxOyBpIDw9IDk7ICsraSkge1xuICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzTWF4ICYmICttYXhEWzBdID09IHZhbHVlW2RpXSkge1xuICAgICAgICAvL2lmIG1heCB5ZWFyIGFuZCBtb250aCBkaXNhYmxlIGdyZWF0ZXIgdmFsdWVzXG4gICAgICAgIGZvciAoaSA9ICttYXhEWzFdICsgMTsgaSA8PSA5OyArK2kpIHtcbiAgICAgICAgICBkaXNhYmxlZC5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc01pbiAmJiBtaW5EWzBdID09IHZhbHVlW2RpXSkge1xuICAgICAgICAvL2lmIG1pbiB5ZWFyIGFuZCBtb250aCBkaXNhYmxlIGxvd2VyIHZhbHVlc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgK21pbkRbMV07ICsraSkge1xuICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHZhbHVlW2RpXSA9PT0gMCkge1xuICAgICAgICAvLyBpZiBtb250aCBmaXJzdCBkaWdpdCAwXG4gICAgICAgIGRpc2FibGVkLnB1c2goMCk7XG5cbiAgICAgICAgaWYgKGlzTWF4IHx8IGlzTWluKSB7XG4gICAgICAgICAgLy8gZGlzYWJsZSBncmVhdGVyL2xvd2VyIHZhbGllcyBpZiBtaW4gb3IgbWF4XG4gICAgICAgICAgZm9yIChpID0gaXNNYXggPyArbWF4RCArIDEgOiAxOyBpIDw9IChpc01pbiA/ICttaW5EIC0gMSA6IDkpOyArK2kpIHtcbiAgICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyB5ZWFyIGNoZWNrXG5cblxuICAgIGlmICh2YWx1ZVt5aSArIDJdICE9PSB1bmRlZmluZWQgJiYgbW9udGggPT0gJzAyJyAmJiBkYXkgPT0gJzI5Jykge1xuICAgICAgLy8gaWYgMjl0aCBhbmQgZmVicnVhcnkgdGhhbiBqdXN0IGxlYXAgeWVhcnMgYWxsb3dlZFxuICAgICAgZm9yIChqID0gKygnJyArIHZhbHVlW3lpXSArIHZhbHVlW3lpICsgMV0gKyB2YWx1ZVt5aSArIDJdICsgMCk7IGogPD0gKygnJyArIHZhbHVlW3lpXSArIHZhbHVlW3lpICsgMV0gKyB2YWx1ZVt5aSArIDJdICsgOSk7ICsraikge1xuICAgICAgICBkaXNhYmxlZC5wdXNoKCFpc2xlYXBZZWFyKGopID8gaiAlIDEwIDogJycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2YWx1ZS5sZW5ndGggPT0geWkpIHtcbiAgICAgIC8vIGJlZm9yZSB5ZWFyJ3MgZmlyc3QgZGlnaXQgc2V0XG4gICAgICBpZiAocy5taW4pIHtcbiAgICAgICAgLy8gZGlzYWJsZSBsb3dlciB2YWx1ZXNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8ICttaW5ZWzBdOyArK2kpIHtcbiAgICAgICAgICBkaXNhYmxlZC5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzLm1heCkge1xuICAgICAgICAvL2Rpc2FibGUgZ3JlYXRlciB2YWx1ZXNcbiAgICAgICAgZm9yIChpID0gK21heFlbMF0gKyAxOyBpIDw9IDk7ICsraSkge1xuICAgICAgICAgIGRpc2FibGVkLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGlzYWJsZWQucHVzaCgwKTtcbiAgICB9XG5cbiAgICBpZiAocy5taW4gfHwgcy5tYXgpIHtcbiAgICAgIGZvciAoaiA9IDE7IGogPCA0OyArK2opIHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PSB5aSArIGopIHtcbiAgICAgICAgICAvLyBiZWZvcmUgeWVhcidzIGktdGggZGlnaXQgc2V0XG4gICAgICAgICAgaWYgKHZhbHVlW3lpICsgaiAtIDFdID09ICttaW5ZW2ogLSAxXSAmJiAoaiA9PSAzID8gdmFsdWVbeWkgKyBqIC0gMl0gPT0gK21pbllbaiAtIDJdIDogdHJ1ZSkpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCArbWluWVtqXSArIChqID09IDMgJiYgdmFsdWVbbWkgKyAxXSAmJiArbWluTSA+ICttb250aCA/IDEgOiAwKTsgKytpKSB7XG4gICAgICAgICAgICAgIC8vaWYgbW9udGggbGVzcyB0aGFuIG1pbi1tb250aCB0aGFuIGRvZXNuJ3QgYWxsb3cgbWluWWVhclxuICAgICAgICAgICAgICBkaXNhYmxlZC5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWx1ZVt5aSArIGogLSAxXSA9PSArbWF4WVtqIC0gMV0gJiYgKGogPT0gMyA/IHZhbHVlW3lpICsgaiAtIDJdID09ICttYXhZW2ogLSAyXSA6IHRydWUpKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSArbWF4WVtqXSArIChqID09IDMgJiYgK21heE0gPCArbW9udGggPyAwIDogMSk7IGkgPD0gOTsgKytpKSB7XG4gICAgICAgICAgICAgIC8vaWYgbW9udGggZ3JlYXRlciB0aGFuIG1heC1tb250aCB0aGFuIGRvZXNuJ3QgYWxsb3cgbWF4WWVhclxuICAgICAgICAgICAgICBkaXNhYmxlZC5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkaXNhYmxlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGNEYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCsoJycgKyB2YWx1ZVt5aV0gKyB2YWx1ZVt5aSArIDFdICsgdmFsdWVbeWkgKyAyXSArIHZhbHVlW3lpICsgM10pLCArKCcnICsgdmFsdWVbbWldICsgdmFsdWVbbWkgKyAxXSkgLSAxLCArKCcnICsgdmFsdWVbZGldICsgdmFsdWVbZGkgKyAxXSkpO1xuICB9IC8vIEV4dGVuZGVkIG1ldGhvZHNcbiAgLy8gLS0tXG5cblxuICBpbnN0LmdldFZhbCA9IGZ1bmN0aW9uICh0ZW1wKSB7XG4gICAgcmV0dXJuIGluc3QuX2hhc1ZhbHVlIHx8IHRlbXAgPyBjYWxjRGF0ZShpbnN0LmdldEFycmF5VmFsKHRlbXApKSA6IG51bGw7XG4gIH07IC8vIC0tLVxuXG5cbiAgcmV0dXJuIHtcbiAgICBwbGFjZWhvbGRlcjogJy0nLFxuICAgIGZpbGw6ICdsdHInLFxuICAgIGFsbG93TGVhZGluZ1plcm86IHRydWUsXG4gICAgdGVtcGxhdGU6IHRlbXBsLFxuICAgIHBhcnNlVmFsdWU6IGZ1bmN0aW9uIHBhcnNlVmFsdWUodmFsdWUpIHtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIHJldCA9IFtdLFxuICAgICAgICAgIHYgPSB2YWx1ZSB8fCBzLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICBkID0gcGFyc2VEYXRlKHMuZGF0ZUZvcm1hdCwgdiwgcyk7XG5cbiAgICAgIGlmICh2KSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbmRleEFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgaWYgKC9tL2kudGVzdChpbmRleEFycmF5W2ldLm4pKSB7XG4gICAgICAgICAgICByZXQgPSByZXQuY29uY2F0KCgocy5nZXRNb250aChkKSA8IDkgPyAnMCcgOiAnJykgKyAocy5nZXRNb250aChkKSArIDEpKS5zcGxpdCgnJykpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoL2QvaS50ZXN0KGluZGV4QXJyYXlbaV0ubikpIHtcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoKChzLmdldERheShkKSA8IDEwID8gJzAnIDogJycpICsgcy5nZXREYXkoZCkpLnNwbGl0KCcnKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldCA9IHJldC5jb25jYXQoKHMuZ2V0WWVhcihkKSArICcnKS5zcGxpdCgnJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG4gICAgZm9ybWF0VmFsdWU6IGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RGF0ZShzLmRhdGVGb3JtYXQsIGNhbGNEYXRlKHZhbHVlKSwgcyk7XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gdmFsaWRhdGUoZGF0YSkge1xuICAgICAgdmFyIHZhbHVlID0gZGF0YS52YWx1ZXMsXG4gICAgICAgICAgZCA9IGNhbGNEYXRlKHZhbHVlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc2FibGVkOiBkaXNhYmxlQnV0dG9ucyh2YWx1ZSksXG4gICAgICAgIGludmFsaWQ6ICEoZCAhPSAnSW52YWxpZCBEYXRlJyAmJiAocy5taW4gPyBzLm1pbiA8PSBkIDogdHJ1ZSkgJiYgKHMubWF4ID8gZCA8PSBzLm1heCA6IHRydWUpKSB8fCAocy5pbnZhbGlkID8gaW5zdC5faW5kZXhPZihzLmludmFsaWQsIGQpICE9IC0xIDogZmFsc2UpXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07IC8vIC0tLVxuXG52YXIgTWJzY051bXBhZEJhc2UgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NOdW1wYWRCYXNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY051bXBhZEJhc2UoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMub3B0aW9uU2VydmljZSA9IG9wdGlvblNlcnZpY2U7XHJcbiAgICAgICAgX3RoaXMub25TZXQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMub25DbGVhciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5vbklucHV0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NOdW1wYWRCYXNlLnByb3RvdHlwZSwgXCJhbGxvd0xlYWRpbmdaZXJvXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NOdW1wYWRCYXNlLnByb3RvdHlwZSwgXCJkZWxldGVJY29uXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NOdW1wYWRCYXNlLnByb3RvdHlwZSwgXCJmaWxsXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NOdW1wYWRCYXNlLnByb3RvdHlwZSwgXCJsZWZ0S2V5XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NOdW1wYWRCYXNlLnByb3RvdHlwZSwgXCJtYXNrXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdjaGFyLXBsYWNlaG9sZGVyJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NOdW1wYWRCYXNlLnByb3RvdHlwZSwgXCJwbGFjZWhvbGRlckNoYXJcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY051bXBhZEJhc2UucHJvdG90eXBlLCBcInJpZ2h0S2V5XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NOdW1wYWRCYXNlLnByb3RvdHlwZSwgXCJ0ZW1wbGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcclxuICAgIF0sIE1ic2NOdW1wYWRCYXNlLnByb3RvdHlwZSwgXCJ2YWxpZGF0ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NOdW1wYWRCYXNlLnByb3RvdHlwZSwgXCJvblNldFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NOdW1wYWRCYXNlLnByb3RvdHlwZSwgXCJvbkNsZWFyXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY051bXBhZEJhc2UucHJvdG90eXBlLCBcIm9uSW5wdXRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY051bXBhZEJhc2UucHJvdG90eXBlLCBcImNhbmNlbFRleHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY051bXBhZEJhc2UucHJvdG90eXBlLCBcImNsZWFyVGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjTnVtcGFkQmFzZS5wcm90b3R5cGUsIFwic2V0VGV4dFwiLCB2b2lkIDApO1xyXG4gICAgTWJzY051bXBhZEJhc2UgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1ttYnNjLW4tYl0nIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMiwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksIF9fcGFyYW0oNCwgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBOZ1pvbmUsIE5nQ29udHJvbCwgTWJzY0lucHV0U2VydmljZSwgTWJzY09wdGlvbnNTZXJ2aWNlLCBWaWV3Q29udGFpbmVyUmVmXSlcclxuICAgIF0sIE1ic2NOdW1wYWRCYXNlKTtcclxuICAgIHJldHVybiBNYnNjTnVtcGFkQmFzZTtcclxufShNYnNjRnJhbWVCYXNlKSk7XHJcbnZhciBNYnNjTnVtcGFkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjTnVtcGFkLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY051bXBhZChpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5vcHRpb25zID0ge307XHJcbiAgICAgICAgX3RoaXMucHJlc2V0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY051bXBhZC5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTWJzY051bXBhZC5wcm90b3R5cGUuc2V0TmV3VmFsdWUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHZhciBpbm5lclZhbHVlID0gdGhpcy5pbnN0YW5jZS5nZXRWYWwoKTtcclxuICAgICAgICAgICAgaWYgKGlubmVyVmFsdWUgIT09IHYpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0VmFsKHYsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbnB1dFNlcnZpY2UgJiYgdGhpcy5faW5wdXRTZXJ2aWNlLmlucHV0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5wdXRTZXJ2aWNlLmlucHV0LmlubmVyVmFsdWUgPSB0aGlzLmluc3RhbmNlLl92YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNYnNjTnVtcGFkLnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHsgcHJlc2V0OiB0aGlzLnByZXNldCB9LCB0aGlzLm9wdGlvblNlcnZpY2UgPyB0aGlzLm9wdGlvblNlcnZpY2Uub3B0aW9ucyA6IHt9LCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaiwgdGhpcy5vcHRpb25FeHRlbnNpb25zKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IE51bXBhZCh0aGlzLmVsZW1lbnQsIG9wdGlvbnMpO1xyXG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0VmFsKHRoaXMuaW5pdGlhbFZhbHVlLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ21ic2Mtb3B0aW9ucycpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjTnVtcGFkLnByb3RvdHlwZSwgXCJvcHRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdtYnNjLW51bXBhZCcpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcclxuICAgIF0sIE1ic2NOdW1wYWQucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCdtYnNjLW51bXBhZENoYW5nZScpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjTnVtcGFkLnByb3RvdHlwZSwgXCJvbkNoYW5nZUVtaXR0ZXJcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NOdW1wYWQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBEaXJlY3RpdmUoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ1ttYnNjLW51bXBhZF0nLFxyXG4gICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgyLCBPcHRpb25hbCgpKSwgX19wYXJhbSgzLCBPcHRpb25hbCgpKSwgX19wYXJhbSg0LCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZSwgTmdDb250cm9sLCBNYnNjSW5wdXRTZXJ2aWNlLCBNYnNjT3B0aW9uc1NlcnZpY2UsIFZpZXdDb250YWluZXJSZWZdKVxyXG4gICAgXSwgTWJzY051bXBhZCk7XHJcbiAgICByZXR1cm4gTWJzY051bXBhZDtcclxufShNYnNjTnVtcGFkQmFzZSkpO1xyXG52YXIgTWJzY051bXBhZENvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY051bXBhZENvbXBvbmVudCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NOdW1wYWRDb21wb25lbnQoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIG51bGwpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZXJyb3JNZXNzYWdlID0gJyc7XHJcbiAgICAgICAgX3RoaXMucGxhY2Vob2xkZXIgPSAnJztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBNYnNjTnVtcGFkQ29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnNldFRoZW1lQ2xhc3NlcygpO1xyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ2ljb24nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY051bXBhZENvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5wdXRJY29uXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdpY29uLWFsaWduJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NOdW1wYWRDb21wb25lbnQucHJvdG90eXBlLCBcImljb25BbGlnblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjTnVtcGFkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjTnVtcGFkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlcnJvclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjTnVtcGFkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlcnJvck1lc3NhZ2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY051bXBhZENvbXBvbmVudC5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjTnVtcGFkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwbGFjZWhvbGRlclwiLCB2b2lkIDApO1xyXG4gICAgTWJzY051bXBhZENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1udW1wYWQnLFxyXG4gICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogSU5QVVRfVEVNUExBVEVcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDIsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDMsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDQsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLCBOZ0NvbnRyb2wsIE1ic2NJbnB1dFNlcnZpY2UsIE1ic2NPcHRpb25zU2VydmljZV0pXHJcbiAgICBdLCBNYnNjTnVtcGFkQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBNYnNjTnVtcGFkQ29tcG9uZW50O1xyXG59KE1ic2NOdW1wYWQpKTtcclxudmFyIE1ic2NOdW1wYWREZWNpbWFsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjTnVtcGFkRGVjaW1hbCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NOdW1wYWREZWNpbWFsKGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIHZpZXcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSB7fTtcclxuICAgICAgICBfdGhpcy5vbkNoYW5nZUVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMucHJlc2V0ID0gJ2RlY2ltYWwnO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjTnVtcGFkRGVjaW1hbC5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UgfHwgdiAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnbWJzYy1udW1wYWQtZGVjaW1hbCcpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcclxuICAgIF0sIE1ic2NOdW1wYWREZWNpbWFsLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCBudWxsKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY051bXBhZERlY2ltYWwucHJvdG90eXBlLCBcImRlY2ltYWxTZXBhcmF0b3JcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgTWJzY051bXBhZERlY2ltYWwucHJvdG90eXBlLCBcImRlZmF1bHRWYWx1ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjTnVtcGFkRGVjaW1hbC5wcm90b3R5cGUsIFwiZW50cnlNb2RlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgTWJzY051bXBhZERlY2ltYWwucHJvdG90eXBlLCBcImludmFsaWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgTWJzY051bXBhZERlY2ltYWwucHJvdG90eXBlLCBcInNjYWxlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIE1ic2NOdW1wYWREZWNpbWFsLnByb3RvdHlwZSwgXCJtYXhTY2FsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBNYnNjTnVtcGFkRGVjaW1hbC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIE1ic2NOdW1wYWREZWNpbWFsLnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY051bXBhZERlY2ltYWwucHJvdG90eXBlLCBcInByZWZpeFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY051bXBhZERlY2ltYWwucHJvdG90eXBlLCBcInJldHVybkFmZml4XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NOdW1wYWREZWNpbWFsLnByb3RvdHlwZSwgXCJzdWZmaXhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY051bXBhZERlY2ltYWwucHJvdG90eXBlLCBcInRob3VzYW5kc1NlcGFyYXRvclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnbWJzYy1vcHRpb25zJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NOdW1wYWREZWNpbWFsLnByb3RvdHlwZSwgXCJvcHRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoJ21ic2MtbnVtcGFkLWRlY2ltYWxDaGFuZ2UnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY051bXBhZERlY2ltYWwucHJvdG90eXBlLCBcIm9uQ2hhbmdlRW1pdHRlclwiLCB2b2lkIDApO1xyXG4gICAgTWJzY051bXBhZERlY2ltYWwgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBEaXJlY3RpdmUoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ1ttYnNjLW51bXBhZC1kZWNpbWFsXScsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCdcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDIsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDMsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDQsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLCBOZ0NvbnRyb2wsIE1ic2NJbnB1dFNlcnZpY2UsIE1ic2NPcHRpb25zU2VydmljZSwgVmlld0NvbnRhaW5lclJlZl0pXHJcbiAgICBdLCBNYnNjTnVtcGFkRGVjaW1hbCk7XHJcbiAgICByZXR1cm4gTWJzY051bXBhZERlY2ltYWw7XHJcbn0oTWJzY051bXBhZCkpO1xyXG52YXIgTWJzY051bXBhZERlY2ltYWxDb21wb25lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NOdW1wYWREZWNpbWFsQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY051bXBhZERlY2ltYWxDb21wb25lbnQoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIG51bGwpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZXJyb3JNZXNzYWdlID0gJyc7XHJcbiAgICAgICAgX3RoaXMucGxhY2Vob2xkZXIgPSAnJztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBNYnNjTnVtcGFkRGVjaW1hbENvbXBvbmVudC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0LmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zZXRUaGVtZUNsYXNzZXMoKTtcclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdpY29uJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NOdW1wYWREZWNpbWFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpbnB1dEljb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ2ljb24tYWxpZ24nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY051bXBhZERlY2ltYWxDb21wb25lbnQucHJvdG90eXBlLCBcImljb25BbGlnblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjTnVtcGFkRGVjaW1hbENvbXBvbmVudC5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY051bXBhZERlY2ltYWxDb21wb25lbnQucHJvdG90eXBlLCBcImVycm9yXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NOdW1wYWREZWNpbWFsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlcnJvck1lc3NhZ2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY051bXBhZERlY2ltYWxDb21wb25lbnQucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY051bXBhZERlY2ltYWxDb21wb25lbnQucHJvdG90eXBlLCBcInBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjTnVtcGFkRGVjaW1hbENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1udW1wYWQtZGVjaW1hbCcsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBJTlBVVF9URU1QTEFURVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMiwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksIF9fcGFyYW0oNCwgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBOZ1pvbmUsIE5nQ29udHJvbCwgTWJzY0lucHV0U2VydmljZSwgTWJzY09wdGlvbnNTZXJ2aWNlXSlcclxuICAgIF0sIE1ic2NOdW1wYWREZWNpbWFsQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBNYnNjTnVtcGFkRGVjaW1hbENvbXBvbmVudDtcclxufShNYnNjTnVtcGFkRGVjaW1hbCkpO1xyXG52YXIgTWJzY051bXBhZERhdGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NOdW1wYWREYXRlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY051bXBhZERhdGUoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY051bXBhZERhdGUucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmluc3RhbmNlIHx8IHYgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldE5ld1ZhbHVlUHJveHkodik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE1ic2NOdW1wYWREYXRlLnByb3RvdHlwZS5zZXROZXdWYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgdmFyIGlubmVyVmFsdWUgPSB0aGlzLmluc3RhbmNlLmdldFZhbCgpO1xyXG4gICAgICAgICAgICBpZiAoKGlubmVyVmFsdWUgJiYgIXYpIHx8XHJcbiAgICAgICAgICAgICAgICAoIWlubmVyVmFsdWUgJiYgdikgfHxcclxuICAgICAgICAgICAgICAgIChpbm5lclZhbHVlICYmIHYgJiYgaW5uZXJWYWx1ZS5nZXRUaW1lKCkgIT09IHYuZ2V0VGltZSgpKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodiwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lucHV0U2VydmljZSAmJiB0aGlzLl9pbnB1dFNlcnZpY2UuaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dFNlcnZpY2UuaW5wdXQuaW5uZXJWYWx1ZSA9IHRoaXMuaW5zdGFuY2UuX3ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1ic2NOdW1wYWREYXRlLnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHsgcHJlc2V0OiAnZGF0ZScgfSwgdGhpcy5vcHRpb25TZXJ2aWNlID8gdGhpcy5vcHRpb25TZXJ2aWNlLm9wdGlvbnMgOiB7fSwgdGhpcy5vcHRpb25zLCB0aGlzLmlubGluZU9wdGlvbnNPYmosIHRoaXMub3B0aW9uRXh0ZW5zaW9ucyk7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBOdW1wYWQodGhpcy5lbGVtZW50LCBvcHRpb25zKTtcclxuICAgICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmluaXRpYWxWYWx1ZSAhPT0gXCJcIikge1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNldFZhbCh0aGlzLmluaXRpYWxWYWx1ZSwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdtYnNjLW51bXBhZC1kYXRlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxyXG4gICAgXSwgTWJzY051bXBhZERhdGUucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjTnVtcGFkRGF0ZS5wcm90b3R5cGUsIFwiZGF0ZUZvcm1hdFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjTnVtcGFkRGF0ZS5wcm90b3R5cGUsIFwiZGF0ZU9yZGVyXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NOdW1wYWREYXRlLnByb3RvdHlwZSwgXCJkZWxpbWl0ZXJcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY051bXBhZERhdGUucHJvdG90eXBlLCBcImRlZmF1bHRWYWx1ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIE1ic2NOdW1wYWREYXRlLnByb3RvdHlwZSwgXCJpbnZhbGlkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXHJcbiAgICBdLCBNYnNjTnVtcGFkRGF0ZS5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIERhdGUpXHJcbiAgICBdLCBNYnNjTnVtcGFkRGF0ZS5wcm90b3R5cGUsIFwibWF4XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdtYnNjLW9wdGlvbnMnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY051bXBhZERhdGUucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgnbWJzYy1udW1wYWQtZGF0ZUNoYW5nZScpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjTnVtcGFkRGF0ZS5wcm90b3R5cGUsIFwib25DaGFuZ2VFbWl0dGVyXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjTnVtcGFkRGF0ZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIERpcmVjdGl2ZSh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW21ic2MtbnVtcGFkLWRhdGVdJyxcclxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJ1xyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMiwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksIF9fcGFyYW0oNCwgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBOZ1pvbmUsIE5nQ29udHJvbCwgTWJzY0lucHV0U2VydmljZSwgTWJzY09wdGlvbnNTZXJ2aWNlLCBWaWV3Q29udGFpbmVyUmVmXSlcclxuICAgIF0sIE1ic2NOdW1wYWREYXRlKTtcclxuICAgIHJldHVybiBNYnNjTnVtcGFkRGF0ZTtcclxufShNYnNjTnVtcGFkQmFzZSkpO1xyXG52YXIgTWJzY051bXBhZERhdGVDb21wb25lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NOdW1wYWREYXRlQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY051bXBhZERhdGVDb21wb25lbnQoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIG51bGwpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZXJyb3JNZXNzYWdlID0gJyc7XHJcbiAgICAgICAgX3RoaXMucGxhY2Vob2xkZXIgPSAnJztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBNYnNjTnVtcGFkRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0LmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zZXRUaGVtZUNsYXNzZXMoKTtcclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdpY29uJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NOdW1wYWREYXRlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpbnB1dEljb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ2ljb24tYWxpZ24nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY051bXBhZERhdGVDb21wb25lbnQucHJvdG90eXBlLCBcImljb25BbGlnblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjTnVtcGFkRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY051bXBhZERhdGVDb21wb25lbnQucHJvdG90eXBlLCBcImVycm9yXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NOdW1wYWREYXRlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlcnJvck1lc3NhZ2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY051bXBhZERhdGVDb21wb25lbnQucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY051bXBhZERhdGVDb21wb25lbnQucHJvdG90eXBlLCBcInBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjTnVtcGFkRGF0ZUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1udW1wYWQtZGF0ZScsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBJTlBVVF9URU1QTEFURVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMiwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksIF9fcGFyYW0oNCwgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBOZ1pvbmUsIE5nQ29udHJvbCwgTWJzY0lucHV0U2VydmljZSwgTWJzY09wdGlvbnNTZXJ2aWNlXSlcclxuICAgIF0sIE1ic2NOdW1wYWREYXRlQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBNYnNjTnVtcGFkRGF0ZUNvbXBvbmVudDtcclxufShNYnNjTnVtcGFkRGF0ZSkpO1xyXG52YXIgTWJzY051bXBhZFRpbWUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NOdW1wYWRUaW1lLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY051bXBhZFRpbWUoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY051bXBhZFRpbWUucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmluc3RhbmNlIHx8IHYgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldE5ld1ZhbHVlUHJveHkodik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE1ic2NOdW1wYWRUaW1lLnByb3RvdHlwZS5zZXROZXdWYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgdmFyIGlubmVyVmFsdWUgPSB0aGlzLmluc3RhbmNlLmdldFZhbCgpO1xyXG4gICAgICAgICAgICBpZiAoaW5uZXJWYWx1ZSAhPT0gdikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodiwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lucHV0U2VydmljZSAmJiB0aGlzLl9pbnB1dFNlcnZpY2UuaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dFNlcnZpY2UuaW5wdXQuaW5uZXJWYWx1ZSA9IHRoaXMuaW5zdGFuY2UuX3ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1ic2NOdW1wYWRUaW1lLnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHsgcHJlc2V0OiAndGltZScgfSwgdGhpcy5vcHRpb25TZXJ2aWNlID8gdGhpcy5vcHRpb25TZXJ2aWNlLm9wdGlvbnMgOiB7fSwgdGhpcy5vcHRpb25zLCB0aGlzLmlubGluZU9wdGlvbnNPYmosIHRoaXMub3B0aW9uRXh0ZW5zaW9ucyk7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBOdW1wYWQodGhpcy5lbGVtZW50LCBvcHRpb25zKTtcclxuICAgICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmluaXRpYWxWYWx1ZSAhPT0gXCJcIikge1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNldFZhbCh0aGlzLmluaXRpYWxWYWx1ZSwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdtYnNjLW51bXBhZC10aW1lJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxyXG4gICAgXSwgTWJzY051bXBhZFRpbWUucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjTnVtcGFkVGltZS5wcm90b3R5cGUsIFwiZGVmYXVsdFZhbHVlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgTWJzY051bXBhZFRpbWUucHJvdG90eXBlLCBcImludmFsaWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSlcclxuICAgIF0sIE1ic2NOdW1wYWRUaW1lLnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSlcclxuICAgIF0sIE1ic2NOdW1wYWRUaW1lLnByb3RvdHlwZSwgXCJtaW5cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY051bXBhZFRpbWUucHJvdG90eXBlLCBcInRpbWVGb3JtYXRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ21ic2Mtb3B0aW9ucycpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjTnVtcGFkVGltZS5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCdtYnNjLW51bXBhZC10aW1lQ2hhbmdlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NOdW1wYWRUaW1lLnByb3RvdHlwZSwgXCJvbkNoYW5nZUVtaXR0ZXJcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NOdW1wYWRUaW1lID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgRGlyZWN0aXZlKHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWJzYy1udW1wYWQtdGltZV0nLFxyXG4gICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgyLCBPcHRpb25hbCgpKSwgX19wYXJhbSgzLCBPcHRpb25hbCgpKSwgX19wYXJhbSg0LCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZSwgTmdDb250cm9sLCBNYnNjSW5wdXRTZXJ2aWNlLCBNYnNjT3B0aW9uc1NlcnZpY2UsIFZpZXdDb250YWluZXJSZWZdKVxyXG4gICAgXSwgTWJzY051bXBhZFRpbWUpO1xyXG4gICAgcmV0dXJuIE1ic2NOdW1wYWRUaW1lO1xyXG59KE1ic2NOdW1wYWRCYXNlKSk7XHJcbnZhciBNYnNjTnVtcGFkVGltZUNvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY051bXBhZFRpbWVDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjTnVtcGFkVGltZUNvbXBvbmVudChpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgbnVsbCkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5lcnJvck1lc3NhZ2UgPSAnJztcclxuICAgICAgICBfdGhpcy5wbGFjZWhvbGRlciA9ICcnO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE1ic2NOdW1wYWRUaW1lQ29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnNldFRoZW1lQ2xhc3NlcygpO1xyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ2ljb24nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY051bXBhZFRpbWVDb21wb25lbnQucHJvdG90eXBlLCBcImlucHV0SWNvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnaWNvbi1hbGlnbicpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjTnVtcGFkVGltZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiaWNvbkFsaWduXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NOdW1wYWRUaW1lQ29tcG9uZW50LnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjTnVtcGFkVGltZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZXJyb3JcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY051bXBhZFRpbWVDb21wb25lbnQucHJvdG90eXBlLCBcImVycm9yTWVzc2FnZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjTnVtcGFkVGltZUNvbXBvbmVudC5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjTnVtcGFkVGltZUNvbXBvbmVudC5wcm90b3R5cGUsIFwicGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NOdW1wYWRUaW1lQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLW51bXBhZC10aW1lJyxcclxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IElOUFVUX1RFTVBMQVRFXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgyLCBPcHRpb25hbCgpKSwgX19wYXJhbSgzLCBPcHRpb25hbCgpKSwgX19wYXJhbSg0LCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZSwgTmdDb250cm9sLCBNYnNjSW5wdXRTZXJ2aWNlLCBNYnNjT3B0aW9uc1NlcnZpY2VdKVxyXG4gICAgXSwgTWJzY051bXBhZFRpbWVDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIE1ic2NOdW1wYWRUaW1lQ29tcG9uZW50O1xyXG59KE1ic2NOdW1wYWRUaW1lKSk7XHJcbnZhciBNYnNjTnVtcGFkVGltZXNwYW4gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NOdW1wYWRUaW1lc3BhbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NOdW1wYWRUaW1lc3Bhbihpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCB2aWV3KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5vcHRpb25zID0ge307XHJcbiAgICAgICAgX3RoaXMub25DaGFuZ2VFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLnByZXNldCA9ICd0aW1lc3Bhbic7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NOdW1wYWRUaW1lc3Bhbi5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UgfHwgdiAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnbWJzYy1udW1wYWQtdGltZXNwYW4nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXHJcbiAgICBdLCBNYnNjTnVtcGFkVGltZXNwYW4ucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBNYnNjTnVtcGFkVGltZXNwYW4ucHJvdG90eXBlLCBcImRlZmF1bHRWYWx1ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIE1ic2NOdW1wYWRUaW1lc3Bhbi5wcm90b3R5cGUsIFwiaW52YWxpZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBNYnNjTnVtcGFkVGltZXNwYW4ucHJvdG90eXBlLCBcIm1pblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBNYnNjTnVtcGFkVGltZXNwYW4ucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnbWJzYy1vcHRpb25zJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NOdW1wYWRUaW1lc3Bhbi5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCdtYnNjLW51bXBhZC10aW1lc3BhbkNoYW5nZScpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjTnVtcGFkVGltZXNwYW4ucHJvdG90eXBlLCBcIm9uQ2hhbmdlRW1pdHRlclwiLCB2b2lkIDApO1xyXG4gICAgTWJzY051bXBhZFRpbWVzcGFuID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgRGlyZWN0aXZlKHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWJzYy1udW1wYWQtdGltZXNwYW5dJyxcclxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJ1xyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMiwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksIF9fcGFyYW0oNCwgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBOZ1pvbmUsIE5nQ29udHJvbCwgTWJzY0lucHV0U2VydmljZSwgTWJzY09wdGlvbnNTZXJ2aWNlLCBWaWV3Q29udGFpbmVyUmVmXSlcclxuICAgIF0sIE1ic2NOdW1wYWRUaW1lc3Bhbik7XHJcbiAgICByZXR1cm4gTWJzY051bXBhZFRpbWVzcGFuO1xyXG59KE1ic2NOdW1wYWQpKTtcclxudmFyIE1ic2NOdW1wYWRUaW1lc3BhbkNvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY051bXBhZFRpbWVzcGFuQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY051bXBhZFRpbWVzcGFuQ29tcG9uZW50KGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCBudWxsKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmVycm9yTWVzc2FnZSA9ICcnO1xyXG4gICAgICAgIF90aGlzLnBsYWNlaG9sZGVyID0gJyc7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgTWJzY051bXBhZFRpbWVzcGFuQ29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnNldFRoZW1lQ2xhc3NlcygpO1xyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ2ljb24nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY051bXBhZFRpbWVzcGFuQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpbnB1dEljb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ2ljb24tYWxpZ24nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY051bXBhZFRpbWVzcGFuQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpY29uQWxpZ25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY051bXBhZFRpbWVzcGFuQ29tcG9uZW50LnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjTnVtcGFkVGltZXNwYW5Db21wb25lbnQucHJvdG90eXBlLCBcImVycm9yXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NOdW1wYWRUaW1lc3BhbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiZXJyb3JNZXNzYWdlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NOdW1wYWRUaW1lc3BhbkNvbXBvbmVudC5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjTnVtcGFkVGltZXNwYW5Db21wb25lbnQucHJvdG90eXBlLCBcInBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjTnVtcGFkVGltZXNwYW5Db21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtbnVtcGFkLXRpbWVzcGFuJyxcclxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IElOUFVUX1RFTVBMQVRFXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgyLCBPcHRpb25hbCgpKSwgX19wYXJhbSgzLCBPcHRpb25hbCgpKSwgX19wYXJhbSg0LCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZSwgTmdDb250cm9sLCBNYnNjSW5wdXRTZXJ2aWNlLCBNYnNjT3B0aW9uc1NlcnZpY2VdKVxyXG4gICAgXSwgTWJzY051bXBhZFRpbWVzcGFuQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBNYnNjTnVtcGFkVGltZXNwYW5Db21wb25lbnQ7XHJcbn0oTWJzY051bXBhZFRpbWVzcGFuKSk7XHJcbnZhciBjb21wcyQxID0gW1xyXG4gICAgTWJzY051bXBhZCxcclxuICAgIE1ic2NOdW1wYWRCYXNlLFxyXG4gICAgTWJzY051bXBhZENvbXBvbmVudCxcclxuICAgIE1ic2NOdW1wYWREZWNpbWFsLFxyXG4gICAgTWJzY051bXBhZERlY2ltYWxDb21wb25lbnQsXHJcbiAgICBNYnNjTnVtcGFkRGF0ZSxcclxuICAgIE1ic2NOdW1wYWREYXRlQ29tcG9uZW50LFxyXG4gICAgTWJzY051bXBhZFRpbWUsXHJcbiAgICBNYnNjTnVtcGFkVGltZUNvbXBvbmVudCxcclxuICAgIE1ic2NOdW1wYWRUaW1lc3BhbixcclxuICAgIE1ic2NOdW1wYWRUaW1lc3BhbkNvbXBvbmVudFxyXG5dO1xyXG52YXIgTWJzY051bXBhZE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNYnNjTnVtcGFkTW9kdWxlKCkge1xyXG4gICAgfVxyXG4gICAgTWJzY051bXBhZE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE5nTW9kdWxlKHtcclxuICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgTWJzY0ZyYW1lQmFzZU1vZHVsZSwgTWJzY0lucHV0TW9kdWxlXSxcclxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBjb21wcyQxLFxyXG4gICAgICAgICAgICBleHBvcnRzOiBjb21wcyQxXHJcbiAgICAgICAgfSlcclxuICAgIF0sIE1ic2NOdW1wYWRNb2R1bGUpO1xyXG4gICAgcmV0dXJuIE1ic2NOdW1wYWRNb2R1bGU7XHJcbn0oKSk7XG5cbnZhciBPcHRpb25saXN0ID0gZnVuY3Rpb24gT3B0aW9ubGlzdChlbG0sIHNldHRpbmdzKSB7XG4gIHZhciB0aGF0ID0gdGhpczsgLy8gQ2FsbCB0aGUgcGFyZW50IGNvbnN0cnVjdG9yXG5cbiAgTmF2aWdhdGlvbkJhc2UuY2FsbCh0aGlzLCBlbG0sIHNldHRpbmdzLCB0cnVlKTtcbiAgLyoqXHJcbiAgICogT3B0aW9ubGlzdCBpbml0aWFsaXphdGlvbi5cclxuICAgKi9cblxuICB0aGF0Ll9fX2luaXQgPSBmdW5jdGlvbiAoKSB7fTsgLy8gQ29uc3RydWN0b3JcblxuXG4gIHRoYXQuaW5pdCgpO1xufTsgLy8gRGVmYXVsdHNcblxuT3B0aW9ubGlzdC5wcm90b3R5cGUgPSB7XG4gIF9jbGFzczogJ29wdGlvbmxpc3QnLFxuICBfaGFzRGVmOiB0cnVlLFxuICBfaGFzVGhlbWU6IHRydWUsXG4gIF9oYXNMYW5nOiB0cnVlLFxuICBfcmVzcG9uc2l2ZTogdHJ1ZSxcbiAgX2RlZmF1bHRzOiBleHRlbmQkMSh7fSwgTmF2aWdhdGlvbkJhc2UucHJvdG90eXBlLl9kZWZhdWx0cywge1xuICAgIHNlbGVjdDogJ211bHRpcGxlJyxcbiAgICB2YXJpYW50OiAnYScsXG4gICAgZGlzcGxheTogJ2lubGluZSdcbiAgfSlcbn07XG5jbGFzc2VzLk9wdGlvbmxpc3QgPSBPcHRpb25saXN0O1xubW9iaXNjcm9sbC50aGVtZXMub3B0aW9ubGlzdCA9IG1vYmlzY3JvbGwudGhlbWVzLm5hdmlnYXRpb247XG5cbnZhciBNYnNjT3B0aW9uSXRlbSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY09wdGlvbkl0ZW0sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjT3B0aW9uSXRlbShub3RpZnlJdGVtU2VydmljZSwgX2VsZW0pIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbm90aWZ5SXRlbVNlcnZpY2UsIF9lbGVtKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgTWJzY09wdGlvbkl0ZW0gPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ21ic2Mtb3B0aW9uLWl0ZW0nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxyXG4gICAgICAgICAgICBob3N0OiB7XHJcbiAgICAgICAgICAgICAgICAnW2F0dHIuZGF0YS1pY29uXSc6ICdpY29uJyxcclxuICAgICAgICAgICAgICAgICdbYXR0ci5kYXRhLWRpc2FibGVkXSc6ICdkaXNhYmxlZCcsXHJcbiAgICAgICAgICAgICAgICAnW2F0dHIuZGF0YS1zZWxlY3RlZF0nOiAnc2VsZWN0ZWQnLFxyXG4gICAgICAgICAgICAgICAgJ1thdHRyLmRhdGEtaWRdJzogJ2lkJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtNYnNjTm90aWZ5SXRlbVNlcnZpY2UsIEVsZW1lbnRSZWZdKVxyXG4gICAgXSwgTWJzY09wdGlvbkl0ZW0pO1xyXG4gICAgcmV0dXJuIE1ic2NPcHRpb25JdGVtO1xyXG59KE1ic2NOYXZJdGVtQmFzZSkpO1xyXG52YXIgTWJzY09wdGlvbmxpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NPcHRpb25saXN0LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY09wdGlvbmxpc3QoaW5pdGlhbEVsZW0sIHpvbmUsIG5vdGlmeUl0ZW1TZXJ2aWNlLCBvcHRpb25TZXJ2aWNlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIG5vdGlmeUl0ZW1TZXJ2aWNlKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLm9wdGlvblNlcnZpY2UgPSBvcHRpb25TZXJ2aWNlO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE1ic2NPcHRpb25saXN0LnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBvbkl0ZW1UYXAgPSB0aGlzLnRhcEhhbmRsZXIuYmluZCh0aGlzKTtcclxuICAgICAgICB2YXIgb25JdGVtVGFwVXNlciA9IHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMub25JdGVtVGFwO1xyXG4gICAgICAgIGlmIChvbkl0ZW1UYXBVc2VyKSB7XHJcbiAgICAgICAgICAgIG9uSXRlbVRhcCA9IGZ1bmN0aW9uIChldmVudCwgaW5zdCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudGFwSGFuZGxlcihldmVudCwgaW5zdCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gb25JdGVtVGFwVXNlcihldmVudCwgaW5zdCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvcHRpb25zID0gZXh0ZW5kJDEoe30sIHRoaXMub3B0aW9uU2VydmljZSA/IHRoaXMub3B0aW9uU2VydmljZS5vcHRpb25zIDoge30sIHRoaXMub3B0aW9ucywgdGhpcy5pbmxpbmVPcHRpb25zT2JqLCB7IG9uSXRlbVRhcDogb25JdGVtVGFwIH0pO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgT3B0aW9ubGlzdCh0aGlzLmluaXRpYWxFbGVtLm5hdGl2ZUVsZW1lbnQsIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMubm90aWZ5SXRlbVNlcnZpY2Uubm90aWZ5SW5zdGFuY2VSZWFkeSh0aGlzLmluc3RhbmNlKTtcclxuICAgICAgICB0aGlzLmFkZFJlbW92ZU9ic2VydmVyID0gdGhpcy5ub3RpZnlJdGVtU2VydmljZS5vbkFkZFJlbW92ZSgpLnN1YnNjcmliZShmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICBfdGhpcy5pbnN0YW5jZS5yZWZyZXNoKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTWJzY09wdGlvbmxpc3QucHJvdG90eXBlLm5nT25EZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMubm90aWZ5SXRlbVNlcnZpY2Uub25BZGRSZW1vdmUoKS51bnN1YnNjcmliZSh0aGlzLmFkZFJlbW92ZU9ic2VydmVyKTtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nT25EZXN0cm95LmNhbGwodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjT3B0aW9ubGlzdC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb250ZW50Q2hpbGRyZW4oTWJzY09wdGlvbkl0ZW0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXHJcbiAgICBdLCBNYnNjT3B0aW9ubGlzdC5wcm90b3R5cGUsIFwiaXRlbXNcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NPcHRpb25saXN0ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLW9wdGlvbmxpc3QnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxyXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtNYnNjTm90aWZ5SXRlbVNlcnZpY2VdLFxyXG4gICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnLFxyXG4gICAgICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtYnNjLWNsb2FrJyB9XHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgzLCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZSwgTWJzY05vdGlmeUl0ZW1TZXJ2aWNlLCBNYnNjT3B0aW9uc1NlcnZpY2VdKVxyXG4gICAgXSwgTWJzY09wdGlvbmxpc3QpO1xyXG4gICAgcmV0dXJuIE1ic2NPcHRpb25saXN0O1xyXG59KE1ic2NOYXZpZ2F0aW9uQmFzZSkpO1xyXG52YXIgTWJzY09wdGlvbmxpc3RNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWJzY09wdGlvbmxpc3RNb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBNYnNjT3B0aW9ubGlzdE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE5nTW9kdWxlKHtcclxuICAgICAgICAgICAgaW1wb3J0czogW01ic2NOYXZpZ2F0aW9uQmFzZU1vZHVsZV0sXHJcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01ic2NPcHRpb25JdGVtLCBNYnNjT3B0aW9ubGlzdF0sXHJcbiAgICAgICAgICAgIGV4cG9ydHM6IFtNYnNjT3B0aW9uSXRlbSwgTWJzY09wdGlvbmxpc3RdXHJcbiAgICAgICAgfSlcclxuICAgIF0sIE1ic2NPcHRpb25saXN0TW9kdWxlKTtcclxuICAgIHJldHVybiBNYnNjT3B0aW9ubGlzdE1vZHVsZTtcclxufSgpKTtcblxuLy8gLS0tXG5cbnZhciBQYWdlID0gZnVuY3Rpb24gUGFnZShlbCwgc2V0dGluZ3MpIHtcbiAgdmFyIGNzc0NsYXNzID0gJycsXG4gICAgICAkZWxtID0gJCQxKGVsKSxcbiAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgcyA9IHRoYXQuc2V0dGluZ3M7IC8vIENhbGwgdGhlIHBhcmVudCBjb25zdHJ1Y3RvclxuXG4gIEJhc2UuY2FsbCh0aGlzLCBlbCwgc2V0dGluZ3MsIHRydWUpO1xuICAvKipcclxuICAgKiBQYWdlIGluaXRpYWxpemF0aW9uLlxyXG4gICAqL1xuXG4gIHRoYXQuX2luaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN0eCA9IHMuY29udGV4dCxcbiAgICAgICAgJGN0eCA9ICQkMShjdHgpLFxuICAgICAgICAkdG9wTWVudSA9ICRjdHguZmluZCgnLm1ic2MtbXMtdG9wIC5tYnNjLW1zJyksXG4gICAgICAgICRib3R0b21NZW51ID0gJGN0eC5maW5kKCcubWJzYy1tcy1ib3R0b20gLm1ic2MtbXMnKSxcbiAgICAgICAgY3NzID0ge307XG5cbiAgICBpZiAoY3R4ID09ICdib2R5Jykge1xuICAgICAgJCQxKCdib2R5LGh0bWwnKS5hZGRDbGFzcygnbWJzYy1wYWdlLWN0eCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkY3R4LmFkZENsYXNzKCdtYnNjLXBhZ2UtY3R4Jyk7XG4gICAgfVxuXG4gICAgaWYgKGNzc0NsYXNzKSB7XG4gICAgICAkZWxtLnJlbW92ZUNsYXNzKGNzc0NsYXNzKTtcbiAgICB9XG5cbiAgICBpZiAoJHRvcE1lbnUubGVuZ3RoKSB7XG4gICAgICBjc3MucGFkZGluZ1RvcCA9ICR0b3BNZW51WzBdLm9mZnNldEhlaWdodDtcbiAgICB9XG5cbiAgICBpZiAoJGJvdHRvbU1lbnUubGVuZ3RoKSB7XG4gICAgICBjc3MucGFkZGluZ0JvdHRvbSA9ICRib3R0b21NZW51WzBdLm9mZnNldEhlaWdodDtcbiAgICB9XG5cbiAgICBjc3NDbGFzcyA9ICdtYnNjLXBhZ2UgbWJzYy0nICsgcy50aGVtZSArIChzLmJhc2VUaGVtZSA/ICcgbWJzYy0nICsgcy5iYXNlVGhlbWUgOiAnJykgKyAocy5ydGwgPyAnIG1ic2MtcnRsJyA6ICcgbWJzYy1sdHInKTtcbiAgICAkZWxtLmFkZENsYXNzKGNzc0NsYXNzKS5yZW1vdmVDbGFzcygnbWJzYy1jbG9haycpLmNzcyhjc3MpO1xuICB9O1xuICAvKipcclxuICAgKiBEZXN0cm95cyB0aGUgbW9iaXNjcm9sbCBpbnN0YW5jZS5cclxuICAgKi9cblxuXG4gIHRoYXQuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgJGVsbS5yZW1vdmVDbGFzcyhjc3NDbGFzcyk7XG4gIH07IC8vIENvbnN0cnVjdG9yXG5cblxuICBzID0gdGhhdC5zZXR0aW5ncztcbiAgdGhhdC5pbml0KCk7XG59OyAvLyBFeHRlbmQgZGVmYXVsdHNcblxuUGFnZS5wcm90b3R5cGUgPSB7XG4gIF9oYXNEZWY6IHRydWUsXG4gIF9oYXNUaGVtZTogdHJ1ZSxcbiAgX2hhc0xhbmc6IHRydWUsXG4gIF9jbGFzczogJ3BhZ2UnLFxuICBfZGVmYXVsdHM6IHtcbiAgICBjb250ZXh0OiAnYm9keSdcbiAgfVxufTtcbmNsYXNzZXMuUGFnZSA9IFBhZ2U7XG5tb2Jpc2Nyb2xsLnRoZW1lcy5wYWdlLm1vYmlzY3JvbGwgPSB7fTsgLy8gLS0tXG4vLyBQYWdlIGVuZFxuLy8gSW5pdCBtYnNjLXBhZ2UgZWxlbWVudHMgb24gcGFnZSBsb2FkIG9yIHdoZW4gbWJzYy1lbmhhbmNlIGV2ZW50IGlzIHRyaWdnZXJlc1xuXG5hdXRvSW5pdCgnW21ic2MtcGFnZV0nLCBQYWdlKTtcblxudmFyIE1ic2NQYWdlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjUGFnZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NQYWdlKGhvc3RFbGVtZW50LCBvcHRpb25zU2VydmljZSwgem9uZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGhvc3RFbGVtZW50LCB6b25lKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLm9wdGlvbnNTZXJ2aWNlID0gb3B0aW9uc1NlcnZpY2U7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgTWJzY1BhZ2UucHJvdG90eXBlLm5nT25Jbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvcHRpb25zT2JqID0gZXh0ZW5kJDEoe30sIHRoaXMub3B0aW9ucywgdGhpcy5pbmxpbmVPcHRpb25zT2JqKTtcclxuICAgICAgICB0aGlzLm9wdGlvbnNTZXJ2aWNlLm9wdGlvbnMgPSBvcHRpb25zT2JqO1xyXG4gICAgfTtcclxuICAgIE1ic2NQYWdlLnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHt9LCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaik7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBQYWdlKHRoaXMuaW5pdEVsZW0ubmF0aXZlRWxlbWVudCwgb3B0aW9ucyk7XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjUGFnZS5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjUGFnZS5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgVmlld0NoaWxkKCdpbml0RWxlbWVudCcsIHsgc3RhdGljOiBmYWxzZSB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcclxuICAgIF0sIE1ic2NQYWdlLnByb3RvdHlwZSwgXCJpbml0RWxlbVwiLCB2b2lkIDApO1xyXG4gICAgTWJzY1BhZ2UgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtcGFnZScsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnPGRpdiAjaW5pdEVsZW1lbnQ+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PjwvZGl2PicsXHJcbiAgICAgICAgICAgIHByb3ZpZGVyczogW01ic2NPcHRpb25zU2VydmljZV0sXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCdcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE1ic2NPcHRpb25zU2VydmljZSwgTmdab25lXSlcclxuICAgIF0sIE1ic2NQYWdlKTtcclxuICAgIHJldHVybiBNYnNjUGFnZTtcclxufShNYnNjQmFzZSkpO1xyXG52YXIgTWJzY05vdGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWJzY05vdGUoaW5pdGlhbEVsZW0pIHtcclxuICAgICAgICB0aGlzLmluaXRpYWxFbGVtID0gaW5pdGlhbEVsZW07XHJcbiAgICAgICAgdGhpcy5jb2xvciA9ICdwcmltYXJ5JztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjTm90ZS5wcm90b3R5cGUsIFwiY2xhc3NOYW1lc1wiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnbWJzYy1ub3RlIG1ic2Mtbm90ZS0nICsgdGhpcy5jb2xvcjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY05vdGUucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjTm90ZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1ub3RlJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+JyxcclxuICAgICAgICAgICAgaG9zdDoge1xyXG4gICAgICAgICAgICAgICAgJ1tjbGFzc10nOiAnY2xhc3NOYW1lcydcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGVzOiBbJzpob3N0IHsgZGlzcGxheTogYmxvY2s7IH0nXVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZl0pXHJcbiAgICBdLCBNYnNjTm90ZSk7XHJcbiAgICByZXR1cm4gTWJzY05vdGU7XHJcbn0oKSk7XHJcbnZhciBNYnNjQXZhdGFyID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1ic2NBdmF0YXIoKSB7XHJcbiAgICAgICAgdGhpcy5kcmFnZ2FibGUgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NBdmF0YXIucHJvdG90eXBlLCBcImRyYWdnYWJsZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjQXZhdGFyLnByb3RvdHlwZSwgXCJzcmNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY0F2YXRhci5wcm90b3R5cGUsIFwiYWx0XCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjQXZhdGFyID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLWF2YXRhcicsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnPGltZyBjbGFzcz1cIm1ic2MtYXZhdGFyXCIgW3NyY109XCJzcmNcIiBbYWx0XT1cImFsdFwiIFtkcmFnZ2FibGVdPVwiZHJhZ2dhYmxlXCIgLz4nXHJcbiAgICAgICAgfSlcclxuICAgIF0sIE1ic2NBdmF0YXIpO1xyXG4gICAgcmV0dXJuIE1ic2NBdmF0YXI7XHJcbn0oKSk7XHJcbnZhciBNYnNjUGFnZU1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNYnNjUGFnZU1vZHVsZSgpIHtcclxuICAgIH1cclxuICAgIE1ic2NQYWdlTW9kdWxlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgTmdNb2R1bGUoe1xyXG4gICAgICAgICAgICBpbXBvcnRzOiBbTWJzY0Jhc2VNb2R1bGVdLFxyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNYnNjUGFnZSwgTWJzY05vdGUsIE1ic2NBdmF0YXJdLFxyXG4gICAgICAgICAgICBleHBvcnRzOiBbTWJzY1BhZ2UsIE1ic2NOb3RlLCBNYnNjQXZhdGFyXVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBNYnNjUGFnZU1vZHVsZSk7XHJcbiAgICByZXR1cm4gTWJzY1BhZ2VNb2R1bGU7XHJcbn0oKSk7XG5cbnZhciBNYnNjUG9wdXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NQb3B1cCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NQb3B1cChpbml0aWFsRWxlbSwgb3B0aW9uU2VydmljZSwgem9uZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLm9wdGlvblNlcnZpY2UgPSBvcHRpb25TZXJ2aWNlO1xyXG4gICAgICAgIF90aGlzLm9uQmVmb3JlQ2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMub25CZWZvcmVTaG93ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm9uQ2FuY2VsID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm9uQ2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMub25EZXN0cm95ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm9uRmlsbCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5vbk1hcmt1cFJlYWR5ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm9uUG9zaXRpb24gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMub25TaG93ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm9uU2V0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE1ic2NQb3B1cC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZ2V0SW5saW5lRXZlbnRzKCk7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBleHRlbmQkMSh7fSwgdGhpcy5vcHRpb25TZXJ2aWNlID8gdGhpcy5vcHRpb25TZXJ2aWNlLm9wdGlvbnMgOiB7fSwgdGhpcy5vcHRpb25zLCB0aGlzLmlubGluZU9wdGlvbnNPYmopO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgUG9wdXAodGhpcy5pbml0aWFsRWxlbS5uYXRpdmVFbGVtZW50LCBvcHRpb25zKTtcclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdvcHRpb25zJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NQb3B1cC5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjUG9wdXAucHJvdG90eXBlLCBcImFuY2hvclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjUG9wdXAucHJvdG90eXBlLCBcImFuaW1hdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBNYnNjUG9wdXAucHJvdG90eXBlLCBcImJ1dHRvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NQb3B1cC5wcm90b3R5cGUsIFwiY2xvc2VPbk92ZXJsYXlUYXBcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY1BvcHVwLnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjUG9wdXAucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NQb3B1cC5wcm90b3R5cGUsIFwiZGlzcGxheVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjUG9wdXAucHJvdG90eXBlLCBcImZvY3VzT25DbG9zZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY1BvcHVwLnByb3RvdHlwZSwgXCJmb2N1c1RyYXBcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY1BvcHVwLnByb3RvdHlwZSwgXCJoZWFkZXJUZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjUG9wdXAucHJvdG90eXBlLCBcInNob3dPbkZvY3VzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjUG9wdXAucHJvdG90eXBlLCBcInNob3dPblRhcFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY1BvcHVwLnByb3RvdHlwZSwgXCJ0b3VjaFVpXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NQb3B1cC5wcm90b3R5cGUsIFwib2tUZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NQb3B1cC5wcm90b3R5cGUsIFwiY2FuY2VsVGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NQb3B1cC5wcm90b3R5cGUsIFwib25CZWZvcmVDbG9zZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NQb3B1cC5wcm90b3R5cGUsIFwib25CZWZvcmVTaG93XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY1BvcHVwLnByb3RvdHlwZSwgXCJvbkNhbmNlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NQb3B1cC5wcm90b3R5cGUsIFwib25DbG9zZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NQb3B1cC5wcm90b3R5cGUsIFwib25EZXN0cm95XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY1BvcHVwLnByb3RvdHlwZSwgXCJvbkZpbGxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjUG9wdXAucHJvdG90eXBlLCBcIm9uTWFya3VwUmVhZHlcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjUG9wdXAucHJvdG90eXBlLCBcIm9uUG9zaXRpb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjUG9wdXAucHJvdG90eXBlLCBcIm9uU2hvd1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NQb3B1cC5wcm90b3R5cGUsIFwib25TZXRcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NQb3B1cCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1wb3B1cCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxuZy1jb250ZW50PjwvbmctY29udGVudD5cIixcclxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJyxcclxuICAgICAgICAgICAgaG9zdDogeyAnY2xhc3MnOiAnbWJzYy1jbG9haycgfVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMSwgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBNYnNjT3B0aW9uc1NlcnZpY2UsIE5nWm9uZV0pXHJcbiAgICBdLCBNYnNjUG9wdXApO1xyXG4gICAgcmV0dXJuIE1ic2NQb3B1cDtcclxufShNYnNjQmFzZSkpO1xyXG52YXIgTWJzY1dpZGdldCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY1dpZGdldCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NXaWRnZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgTWJzY1dpZGdldCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy13aWRnZXQnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogXCI8bmctY29udGVudD48L25nLWNvbnRlbnQ+XCIsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXHJcbiAgICAgICAgICAgIGhvc3Q6IHsgJ2NsYXNzJzogJ21ic2MtY2xvYWsnIH1cclxuICAgICAgICB9KVxyXG4gICAgXSwgTWJzY1dpZGdldCk7XHJcbiAgICByZXR1cm4gTWJzY1dpZGdldDtcclxufShNYnNjUG9wdXApKTtcclxudmFyIE1ic2NQb3B1cE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNYnNjUG9wdXBNb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBNYnNjUG9wdXBNb2R1bGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBOZ01vZHVsZSh7XHJcbiAgICAgICAgICAgIGltcG9ydHM6IFtNYnNjQmFzZU1vZHVsZV0sXHJcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01ic2NQb3B1cCwgTWJzY1dpZGdldF0sXHJcbiAgICAgICAgICAgIGV4cG9ydHM6IFtNYnNjUG9wdXAsIE1ic2NXaWRnZXRdXHJcbiAgICAgICAgfSlcclxuICAgIF0sIE1ic2NQb3B1cE1vZHVsZSk7XHJcbiAgICByZXR1cm4gTWJzY1BvcHVwTW9kdWxlO1xyXG59KCkpO1xuXG52YXIgUmFuZ2VQaWNrZXIgPSBTY3JvbGxlcjtcbnZhciBkZWZhdWx0cyRjID0ge1xuICBhdXRvQ29ycmVjdDogdHJ1ZSxcbiAgc2hvd1NlbGVjdG9yOiB0cnVlLFxuICBtaW5SYW5nZTogMSxcbiAgcmFuZ2VUYXA6IHRydWVcbn07XG5cbnByZXNldHMucmFuZ2UgPSBmdW5jdGlvbiAoaW5zdCkge1xuICAvLyBQcml2YXRlIGZ1bmN0aW9uc1xuICAvLyAtLS1cbiAgZnVuY3Rpb24gbm9ybWFsaXplKGQsIHJlZikge1xuICAgIGlmIChkKSB7XG4gICAgICBkLnNldEZ1bGxZZWFyKHJlZi5nZXRGdWxsWWVhcigpKTtcbiAgICAgIGQuc2V0TW9udGgocmVmLmdldE1vbnRoKCkpO1xuICAgICAgZC5zZXREYXRlKHJlZi5nZXREYXRlKCkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVRpbWUoZGF0ZSwgaXNFbmQpIHtcbiAgICB2YXIgbyA9IGluc3QuX29yZGVyLFxuICAgICAgICBkID0gbmV3IERhdGUoZGF0ZSk7XG5cbiAgICBpZiAoby5oID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGQuc2V0SG91cnMoaXNFbmQgPyAyMyA6IDApO1xuICAgIH1cblxuICAgIGlmIChvLmkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZC5zZXRNaW51dGVzKGlzRW5kID8gNTkgOiAwKTtcbiAgICB9XG5cbiAgICBpZiAoby5zID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGQuc2V0U2Vjb25kcyhpc0VuZCA/IDU5IDogMCk7XG4gICAgfVxuXG4gICAgZC5zZXRNaWxsaXNlY29uZHMoaXNFbmQgPyA5OTkgOiAwKTtcbiAgICByZXR1cm4gZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUlucHV0cyhjaGFuZ2UpIHtcbiAgICBpbnN0Ll9zdGFydERhdGUgPSBzdGFydERhdGUgPSB0ZW1wU3RhcnREYXRlO1xuICAgIGluc3QuX2VuZERhdGUgPSBlbmREYXRlID0gdGVtcEVuZERhdGU7XG5cbiAgICBpZiAocy5zdGFydElucHV0KSB7XG4gICAgICAkJDEocy5zdGFydElucHV0KS52YWwoaW5zdC5zdGFydFZhbCk7XG5cbiAgICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICAgJCQxKHMuc3RhcnRJbnB1dCkudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHMuZW5kSW5wdXQpIHtcbiAgICAgICQkMShzLmVuZElucHV0KS52YWwoaW5zdC5lbmRWYWwpO1xuXG4gICAgICBpZiAoY2hhbmdlKSB7XG4gICAgICAgICQkMShzLmVuZElucHV0KS50cmlnZ2VyKCdjaGFuZ2UnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGREYXlzKGQsIGRheXMpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoZC5nZXRGdWxsWWVhcigpLCBkLmdldE1vbnRoKCksIGQuZ2V0RGF0ZSgpICsgZGF5cyk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1JhbmdlU2l6ZShjdXJyKSB7XG4gICAgaWYgKGhhc1RpbWUpIHtcbiAgICAgIC8vIENoZWNrIGV4YWN0IHRpbWVzIGluIG1pbGxpc2Vjb25kcyBmb3IgbWluIGFuZCBtYXggcmFuZ2VzXG4gICAgICBpZiAodGVtcEVuZERhdGUgLSB0ZW1wU3RhcnREYXRlID4gcy5tYXhSYW5nZSAtIDEpIHtcbiAgICAgICAgaWYgKGN1cnIpIHtcbiAgICAgICAgICB0ZW1wU3RhcnREYXRlID0gbmV3IERhdGUoTWF0aC5tYXgobWluRGF0ZSwgdGVtcEVuZERhdGUgLSBzLm1heFJhbmdlICsgMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRlbXBFbmREYXRlID0gbmV3IERhdGUoTWF0aC5taW4obWF4RGF0ZSwgK3RlbXBTdGFydERhdGUgKyBzLm1heFJhbmdlIC0gMSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZW1wRW5kRGF0ZSAtIHRlbXBTdGFydERhdGUgPCBzLm1pblJhbmdlIC0gMSkge1xuICAgICAgICBpZiAoY3Vycikge1xuICAgICAgICAgIHRlbXBTdGFydERhdGUgPSBuZXcgRGF0ZShNYXRoLm1heChtaW5EYXRlLCB0ZW1wRW5kRGF0ZSAtIHMubWluUmFuZ2UgKyAxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGVtcEVuZERhdGUgPSBuZXcgRGF0ZShNYXRoLm1pbihtYXhEYXRlLCArdGVtcFN0YXJ0RGF0ZSArIHMubWluUmFuZ2UgLSAxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV29yayB3aXRoIGRheXMgb25seSwgbm90IG1pbGxpc2Vjb25kcy4gVGhpcyB3YXkgZGF5bGlnaHQgc2F2aW5nIHRpbWVzIGFyZSBoYW5kbGVkXG4gICAgICBpZiAoTWF0aC5jZWlsKCh0ZW1wRW5kRGF0ZSAtIHRlbXBTdGFydERhdGUpIC8gb25lRGF5KSA+IG1heERheXMpIHtcbiAgICAgICAgaWYgKGN1cnIpIHtcbiAgICAgICAgICB0ZW1wU3RhcnREYXRlID0gbm9ybWFsaXplVGltZShNYXRoLm1heChtaW5EYXRlLCBhZGREYXlzKHRlbXBFbmREYXRlLCAxIC0gbWF4RGF5cykpLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGVtcEVuZERhdGUgPSBub3JtYWxpemVUaW1lKE1hdGgubWluKG1heERhdGUsIGFkZERheXModGVtcFN0YXJ0RGF0ZSwgbWF4RGF5cyAtIDEpKSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKE1hdGguY2VpbCgodGVtcEVuZERhdGUgLSB0ZW1wU3RhcnREYXRlKSAvIG9uZURheSkgPCBtaW5EYXlzKSB7XG4gICAgICAgIGlmIChjdXJyKSB7XG4gICAgICAgICAgdGVtcFN0YXJ0RGF0ZSA9IG5vcm1hbGl6ZVRpbWUoTWF0aC5tYXgobWluRGF0ZSwgYWRkRGF5cyh0ZW1wRW5kRGF0ZSwgMSAtIG1pbkRheXMpKSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRlbXBFbmREYXRlID0gbm9ybWFsaXplVGltZShNYXRoLm1pbihtYXhEYXRlLCBhZGREYXlzKHRlbXBTdGFydERhdGUsIG1pbkRheXMgLSAxKSksIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGUoZGF0ZXMsIHVpKSB7XG4gICAgdmFyIHJldCA9IHRydWU7XG5cbiAgICBpZiAoZGF0ZXMgJiYgdGVtcFN0YXJ0RGF0ZSAmJiB0ZW1wRW5kRGF0ZSkge1xuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayB0aGlzIDIgdGltZXMsIGJlY2F1c2UgdGhlXG4gICAgICAvLyBjb3JyZWN0ZWQgcmFuZ2UgaXMgY29uc3RyYWluZWQgYnkgbWluL21heCBkYXRlc1xuICAgICAgY2hlY2tSYW5nZVNpemUoY3Vycik7XG4gICAgICBjaGVja1JhbmdlU2l6ZSghY3Vycik7XG4gICAgfVxuXG4gICAgaWYgKCF0ZW1wU3RhcnREYXRlIHx8ICF0ZW1wRW5kRGF0ZSkge1xuICAgICAgcmV0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHVpKSB7XG4gICAgICBoaWdobGlnaHREYXlzKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGNEYXlOcigpIHtcbiAgICByZXR1cm4gdGVtcFN0YXJ0RGF0ZSAmJiB0ZW1wRW5kRGF0ZSA/IE1hdGgubWF4KDEsIE1hdGgucm91bmQoKG5ldyBEYXRlKHRlbXBFbmREYXRlKS5zZXRIb3VycygwLCAwLCAwLCAwKSAtIG5ldyBEYXRlKHRlbXBTdGFydERhdGUpLnNldEhvdXJzKDAsIDAsIDAsIDApKSAvIDg2NDAwMDAwKSArIDEpIDogMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdFRhYih0YWIpIHtcbiAgICB0YWIuYWRkQ2xhc3Moc2VsZWN0ZWRDbGFzcykuYXR0cignYXJpYS1jaGVja2VkJywgJ3RydWUnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEFjdGl2ZVRhYigpIHtcbiAgICBpZiAoc2hvd1NlbGVjdG9yICYmIGN0eCkge1xuICAgICAgJCQxKCcubWJzYy1yYW5nZS1idG4nLCBjdHgpLnJlbW92ZUNsYXNzKHNlbGVjdGVkQ2xhc3MpLnJlbW92ZUF0dHIoJ2FyaWEtY2hlY2tlZCcpO1xuICAgICAgc2VsZWN0VGFiKCQkMSgnLm1ic2MtcmFuZ2UtYnRuJywgY3R4KS5lcShjdXJyKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGlnaGxpZ2h0RGF5cygpIHtcbiAgICB2YXIgc3RhcnQsXG4gICAgICAgIHN0YXJ0VCxcbiAgICAgICAgZW5kLFxuICAgICAgICBlbmRULFxuICAgICAgICBobCxcbiAgICAgICAgbnIgPSAwLFxuICAgICAgICBzdGFydENsYXNzID0gYXV0b0NoYW5nZSB8fCAhY3VyciA/ICcgbWJzYy1jYWwtZGF5LWhsIG1ic2MtY2FsLXNlbC1zdGFydCcgOiAnIG1ic2MtY2FsLXNlbC1zdGFydCcsXG4gICAgICAgIGVuZENsYXNzID0gYXV0b0NoYW5nZSB8fCBjdXJyID8gJyBtYnNjLWNhbC1kYXktaGwgbWJzYy1jYWwtc2VsLWVuZCcgOiAnIG1ic2MtY2FsLXNlbC1lbmQnO1xuICAgIGluc3Quc3RhcnRWYWwgPSB0ZW1wU3RhcnREYXRlID8gZm9ybWF0RGF0ZShmb3JtYXQsIHRlbXBTdGFydERhdGUsIHMpIDogJyc7XG4gICAgaW5zdC5lbmRWYWwgPSB0ZW1wRW5kRGF0ZSA/IGZvcm1hdERhdGUoZm9ybWF0LCB0ZW1wRW5kRGF0ZSwgcykgOiAnJztcblxuICAgIGlmIChjdHgpIHtcbiAgICAgICQkMSgnLm1ic2MtcmFuZ2UtYnRuLXYtc3RhcnQnLCBjdHgpLmh0bWwoaW5zdC5zdGFydFZhbCB8fCAnJm5ic3A7Jyk7XG4gICAgICAkJDEoJy5tYnNjLXJhbmdlLWJ0bi12LWVuZCcsIGN0eCkuaHRtbChpbnN0LmVuZFZhbCB8fCAnJm5ic3A7Jyk7IC8vIEhpZ2hsaWdodCBkYXRlc1xuXG4gICAgICBzdGFydCA9IHRlbXBTdGFydERhdGUgPyBuZXcgRGF0ZSh0ZW1wU3RhcnREYXRlKSA6IG51bGw7XG4gICAgICBlbmQgPSB0ZW1wRW5kRGF0ZSA/IG5ldyBEYXRlKHRlbXBFbmREYXRlKSA6IG51bGw7XG5cbiAgICAgIGlmICghc3RhcnQgJiYgZW5kKSB7XG4gICAgICAgIHN0YXJ0ID0gbmV3IERhdGUoZW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFlbmQgJiYgc3RhcnQpIHtcbiAgICAgICAgZW5kID0gbmV3IERhdGUoc3RhcnQpO1xuICAgICAgfVxuXG4gICAgICBobCA9IGN1cnIgPyBlbmQgOiBzdGFydDtcbiAgICAgICQkMSgnLm1ic2MtY2FsLWRheS1waWNrZXIgLm1ic2MtY2FsLWRheS1obCcsIGN0eCkucmVtb3ZlQ2xhc3MoaGlnaGxpZ2h0Q2xhc3MpO1xuICAgICAgJCQxKCcubWJzYy1jYWwtZGF5LXBpY2tlciAubWJzYy1zZWxlY3RlZCcsIGN0eCkucmVtb3ZlQ2xhc3MoJ21ic2MtY2FsLXNlbC1zdGFydCBtYnNjLWNhbC1zZWwtZW5kICcgKyBzZWxlY3RlZENsYXNzKS5yZW1vdmVBdHRyKCdhcmlhLXNlbGVjdGVkJyk7XG5cbiAgICAgIGlmIChzdGFydCAmJiBlbmQpIHtcbiAgICAgICAgc3RhcnRUID0gc3RhcnQuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICAgIGVuZFQgPSBlbmQuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG5cbiAgICAgICAgd2hpbGUgKGVuZCA+PSBzdGFydCAmJiBuciA8IDEyNikge1xuICAgICAgICAgICQkMSgnLm1ic2MtY2FsLWRheVtkYXRhLWZ1bGw9XCInICsgaGwuZ2V0RnVsbFllYXIoKSArICctJyArIChobC5nZXRNb250aCgpICsgMSkgKyAnLScgKyBobC5nZXREYXRlKCkgKyAnXCJdJywgY3R4KS5hZGRDbGFzcyhzZWxlY3RlZENsYXNzICsgJyAnICsgKGhsLmdldFRpbWUoKSA9PT0gc3RhcnRUID8gc3RhcnRDbGFzcyA6ICcnKSArIChobC5nZXRUaW1lKCkgPT09IGVuZFQgPyBlbmRDbGFzcyA6ICcnKSkuYXR0cignYXJpYS1zZWxlY3RlZCcsICd0cnVlJyk7XG4gICAgICAgICAgaGwuc2V0RGF0ZShobC5nZXREYXRlKCkgKyAoY3VyciA/IC0xIDogMSkpO1xuICAgICAgICAgIGhsLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgICAgIG5yKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRUaW1lSW5mbyhkLCBlbmQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaDogZCA/IGQuZ2V0SG91cnMoKSA6IGVuZCA/IDIzIDogMCxcbiAgICAgIGk6IGQgPyBkLmdldE1pbnV0ZXMoKSA6IGVuZCA/IDU5IDogMCxcbiAgICAgIHM6IGQgPyBkLmdldFNlY29uZHMoKSA6IGVuZCA/IDU5IDogMFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZURhdGVzKCkge1xuICAgIGlmICh0ZW1wU3RhcnREYXRlKSB7XG4gICAgICBpbml0ID0gdHJ1ZTtcbiAgICAgIGluc3Quc2V0RGF0ZSh0ZW1wU3RhcnREYXRlLCBmYWxzZSwgMCwgdHJ1ZSk7XG4gICAgICB0ZW1wU3RhcnREYXRlID0gaW5zdC5nZXREYXRlKHRydWUpO1xuICAgIH1cblxuICAgIGlmICh0ZW1wRW5kRGF0ZSkge1xuICAgICAgaW5pdCA9IHRydWU7XG4gICAgICBpbnN0LnNldERhdGUodGVtcEVuZERhdGUsIGZhbHNlLCAwLCB0cnVlKTtcbiAgICAgIHRlbXBFbmREYXRlID0gaW5zdC5nZXREYXRlKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQnRuQ2xpY2soZXYpIHtcbiAgICBpZiAodGVzdFRvdWNoKGV2LCB0aGlzKSkge1xuICAgICAgaW5zdC5fc2hvd0RheVBpY2tlcigpO1xuXG4gICAgICBpbnN0LnNldEFjdGl2ZURhdGUoJCQxKHRoaXMpLmF0dHIoJ2RhdGEtc2VsZWN0JykpO1xuICAgIH1cbiAgfSAvLyAtLS1cblxuXG4gIHZhciBiYXNlLFxuICAgICAgY3R4LFxuICAgICAgZGF5Q2hhbmdlLFxuICAgICAgZm9ybWF0LFxuICAgICAgaGFzVGltZSxcbiAgICAgIGluaXQsXG4gICAgICBtYXhEYXRlLFxuICAgICAgbWluRGF0ZSxcbiAgICAgIHNldCxcbiAgICAgIHRlbXBTdGFydERhdGUsXG4gICAgICB0ZW1wU3RhcnRUaW1lLFxuICAgICAgdGVtcEVuZERhdGUsXG4gICAgICB0ZW1wRW5kVGltZSxcbiAgICAgIHRpbWVPbmx5LFxuICAgICAgc2hvd1NlbGVjdG9yLFxuICAgICAgc3RhcnREYXRlID0gaW5zdC5fc3RhcnREYXRlLFxuICAgICAgZW5kRGF0ZSA9IGluc3QuX2VuZERhdGUsXG4gICAgICBjdXJyID0gMCxcbiAgICAgIG5vdyA9IG5ldyBEYXRlKCksXG4gICAgICBvcmlnID0gZXh0ZW5kJDEoe30sIGluc3Quc2V0dGluZ3MpLFxuICAgICAgcyA9IGV4dGVuZCQxKGluc3Quc2V0dGluZ3MsIGRlZmF1bHRzJGMsIG9yaWcpLFxuICAgICAgc3RhcnRBbmNob3IgPSBzLmFuY2hvcixcbiAgICAgIGF1dG9DaGFuZ2UgPSBzLnJhbmdlVGFwLFxuICAgICAgb25lRGF5ID0gMjQgKiA2MCAqIDYwICogMTAwMCxcbiAgICAgIG1pbkRheXMgPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwocy5taW5SYW5nZSAvIG9uZURheSkpLFxuICAgICAgbWF4RGF5cyA9IE1hdGgubWF4KDEsIE1hdGguY2VpbChzLm1heFJhbmdlIC8gb25lRGF5KSksXG4gICAgICBkaXNhYmxlZENsYXNzID0gJ21ic2MtZGlzYWJsZWQgJyArIChzLmRpc2FibGVkQ2xhc3MgfHwgJycpLFxuICAgICAgc2VsZWN0ZWRDbGFzcyA9ICdtYnNjLXNlbGVjdGVkICcgKyAocy5zZWxlY3RlZENsYXNzIHx8ICcnKSxcbiAgICAgIGhpZ2hsaWdodENsYXNzID0gJ21ic2MtY2FsLWRheS1obCcsXG4gICAgICBkZWYgPSBzLmRlZmF1bHRWYWx1ZSA9PT0gbnVsbCA/IFtdIDogcy5kZWZhdWx0VmFsdWUgfHwgW25ldyBEYXRlKG5vdy5zZXRIb3VycygwLCAwLCAwLCAwKSksIG5ldyBEYXRlKG5vdy5nZXRGdWxsWWVhcigpLCBub3cuZ2V0TW9udGgoKSwgbm93LmdldERhdGUoKSArIDYsIDIzLCA1OSwgNTksIDk5OSldO1xuXG4gIGlmIChhdXRvQ2hhbmdlKSB7XG4gICAgcy50YWJzID0gdHJ1ZTtcbiAgfVxuXG4gIGJhc2UgPSBDYWxlbmRhckJhc2UuY2FsbCh0aGlzLCBpbnN0KTtcbiAgZm9ybWF0ID0gaW5zdC5fZm9ybWF0O1xuICBoYXNUaW1lID0gL3RpbWUvaS50ZXN0KHMuY29udHJvbHMuam9pbignLCcpKTtcbiAgdGltZU9ubHkgPSBzLmNvbnRyb2xzLmpvaW4oJycpID09PSAndGltZSc7XG4gIHNob3dTZWxlY3RvciA9IHMuc2hvd1NlbGVjdG9yO1xuICBtYXhEYXRlID0gcy5tYXggPyBub3JtYWxpemVUaW1lKG1ha2VEYXRlKHMubWF4LCBmb3JtYXQsIHMpLCB0cnVlKSA6IEluZmluaXR5O1xuICBtaW5EYXRlID0gcy5taW4gPyBub3JtYWxpemVUaW1lKG1ha2VEYXRlKHMubWluLCBmb3JtYXQsIHMpLCBmYWxzZSkgOiAtSW5maW5pdHk7XG4gIGRlZlswXSA9IG1ha2VEYXRlKGRlZlswXSwgZm9ybWF0LCBzLCBzLmlzb1BhcnRzKTtcbiAgZGVmWzFdID0gbWFrZURhdGUoZGVmWzFdLCBmb3JtYXQsIHMsIHMuaXNvUGFydHMpO1xuXG4gIGlmIChzLnN0YXJ0SW5wdXQpIHtcbiAgICBpbnN0LmF0dGFjaFNob3coJCQxKHMuc3RhcnRJbnB1dCksIGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnIgPSAwO1xuICAgICAgcy5hbmNob3IgPSBzdGFydEFuY2hvciB8fCAkJDEocy5zdGFydElucHV0KTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChzLmVuZElucHV0KSB7XG4gICAgaW5zdC5hdHRhY2hTaG93KCQkMShzLmVuZElucHV0KSwgZnVuY3Rpb24gKCkge1xuICAgICAgY3VyciA9IDE7XG4gICAgICBzLmFuY2hvciA9IHN0YXJ0QW5jaG9yIHx8ICQkMShzLmVuZElucHV0KTtcbiAgICB9KTtcbiAgfVxuXG4gIGluc3QuX2dldERheVByb3BzID0gZnVuY3Rpb24gKGQsIHByb3BzKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGVtcFN0YXJ0RGF0ZSA/IG5ldyBEYXRlKHRlbXBTdGFydERhdGUuZ2V0RnVsbFllYXIoKSwgdGVtcFN0YXJ0RGF0ZS5nZXRNb250aCgpLCB0ZW1wU3RhcnREYXRlLmdldERhdGUoKSkgOiBudWxsLFxuICAgICAgICBlbmQgPSB0ZW1wRW5kRGF0ZSA/IG5ldyBEYXRlKHRlbXBFbmREYXRlLmdldEZ1bGxZZWFyKCksIHRlbXBFbmREYXRlLmdldE1vbnRoKCksIHRlbXBFbmREYXRlLmdldERhdGUoKSkgOiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICBzZWxlY3RlZDogc3RhcnQgJiYgZW5kICYmIGQgPj0gc3RhcnQgJiYgZCA8PSB0ZW1wRW5kRGF0ZSxcbiAgICAgIGNzc0NsYXNzOiBwcm9wcy5jc3NDbGFzcyArICcgJyArICgoYXV0b0NoYW5nZSB8fCAhY3VycikgJiYgc3RhcnQgJiYgc3RhcnQuZ2V0VGltZSgpID09PSBkLmdldFRpbWUoKSB8fCAoYXV0b0NoYW5nZSB8fCBjdXJyKSAmJiBlbmQgJiYgZW5kLmdldFRpbWUoKSA9PT0gZC5nZXRUaW1lKCkgPyBoaWdobGlnaHRDbGFzcyA6ICcnKSArIChzdGFydCAmJiBzdGFydC5nZXRUaW1lKCkgPT09IGQuZ2V0VGltZSgpID8gJyBtYnNjLWNhbC1zZWwtc3RhcnQnIDogJycpICsgKGVuZCAmJiBlbmQuZ2V0VGltZSgpID09PSBkLmdldFRpbWUoKSA/ICcgbWJzYy1jYWwtc2VsLWVuZCcgOiAnJylcbiAgICB9O1xuICB9OyAvLyBFeHRlbmRlZCBtZXRob2RzXG4gIC8vIC0tLVxuXG5cbiAgaW5zdC5zZXRWYWwgPSBmdW5jdGlvbiAodmFsdWVzLCBmaWxsLCBjaGFuZ2UsIHRlbXAsIHRpbWUpIHtcbiAgICB2YXIgdiA9IHZhbHVlcyB8fCBbXSxcbiAgICAgICAgZCA9IHZhbHVlcztcbiAgICB0ZW1wU3RhcnREYXRlID0gbWFrZURhdGUodlswXSwgZm9ybWF0LCBzLCBzLmlzb1BhcnRzKTtcbiAgICB0ZW1wRW5kRGF0ZSA9IG1ha2VEYXRlKHZbMV0sIGZvcm1hdCwgcywgcy5pc29QYXJ0cyk7XG4gICAgdmFsaWRhdGVEYXRlcygpO1xuICAgIGluc3Quc3RhcnRWYWwgPSB0ZW1wU3RhcnREYXRlID8gZm9ybWF0RGF0ZShmb3JtYXQsIHRlbXBTdGFydERhdGUsIHMpIDogJyc7XG4gICAgaW5zdC5lbmRWYWwgPSB0ZW1wRW5kRGF0ZSA/IGZvcm1hdERhdGUoZm9ybWF0LCB0ZW1wRW5kRGF0ZSwgcykgOiAnJztcbiAgICBkID0gYmFzZS5wYXJzZVZhbHVlKGN1cnIgPyB0ZW1wRW5kRGF0ZSA6IHRlbXBTdGFydERhdGUsIGluc3QpO1xuXG4gICAgaWYgKCF0ZW1wKSB7XG4gICAgICBpbnN0Ll9zdGFydERhdGUgPSBzdGFydERhdGUgPSB0ZW1wU3RhcnREYXRlO1xuICAgICAgaW5zdC5fZW5kRGF0ZSA9IGVuZERhdGUgPSB0ZW1wRW5kRGF0ZTtcbiAgICB9XG5cbiAgICBzZXQgPSB0cnVlO1xuXG4gICAgaW5zdC5fc2V0VmFsKGQsIGZpbGwsIGNoYW5nZSwgdGVtcCwgdGltZSk7XG4gIH07XG5cbiAgaW5zdC5nZXRWYWwgPSBmdW5jdGlvbiAodGVtcCkge1xuICAgIHJldHVybiB0ZW1wID8gW3JldHVybkRhdGUodGVtcFN0YXJ0RGF0ZSwgcywgZm9ybWF0KSwgcmV0dXJuRGF0ZSh0ZW1wRW5kRGF0ZSwgcywgZm9ybWF0KV0gOiBpbnN0Ll9oYXNWYWx1ZSA/IFtyZXR1cm5EYXRlKHN0YXJ0RGF0ZSwgcywgZm9ybWF0KSwgcmV0dXJuRGF0ZShlbmREYXRlLCBzLCBmb3JtYXQpXSA6IG51bGw7XG4gIH07XG5cbiAgaW5zdC5zZXRBY3RpdmVEYXRlID0gZnVuY3Rpb24gKGFjdGl2ZSkge1xuICAgIHZhciBobDsgLy9pZiAoIWF1dG9DaGFuZ2UpIHtcblxuICAgIGN1cnIgPSBhY3RpdmUgPT0gJ3N0YXJ0JyA/IDAgOiAxOyAvL31cblxuICAgIGhsID0gYWN0aXZlID09ICdzdGFydCcgPyB0ZW1wU3RhcnREYXRlIDogdGVtcEVuZERhdGU7XG5cbiAgICBpZiAoaW5zdC5pc1Zpc2libGUoKSkge1xuICAgICAgLy9pZiAoIWF1dG9DaGFuZ2UpIHtcbiAgICAgIHNldEFjdGl2ZVRhYigpO1xuXG4gICAgICBpZiAoIWF1dG9DaGFuZ2UpIHtcbiAgICAgICAgJCQxKCcubWJzYy1jYWwtdGFibGUgLm1ic2MtY2FsLWRheS1obCcsIGN0eCkucmVtb3ZlQ2xhc3MoaGlnaGxpZ2h0Q2xhc3MpO1xuXG4gICAgICAgIGlmIChobCkge1xuICAgICAgICAgICQkMSgnLm1ic2MtY2FsLWRheVtkYXRhLWZ1bGw9XCInICsgaGwuZ2V0RnVsbFllYXIoKSArICctJyArIChobC5nZXRNb250aCgpICsgMSkgKyAnLScgKyBobC5nZXREYXRlKCkgKyAnXCJdJywgY3R4KS5hZGRDbGFzcyhoaWdobGlnaHRDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhsKSB7XG4gICAgICAgIGluaXQgPSB0cnVlO1xuICAgICAgICBpbnN0LnNldERhdGUoaGwsIGZhbHNlLCAxMDAwLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgaW5zdC5nZXRWYWx1ZSA9IGluc3QuZ2V0VmFsOyAvLyAtLS1cbiAgLy8gLS0tXG5cbiAgcmV0dXJuIGV4dGVuZCQxKHt9LCBiYXNlLCB7XG4gICAgaGlnaGxpZ2h0OiBmYWxzZSxcbiAgICBvdXRlck1vbnRoQ2hhbmdlOiBmYWxzZSxcbiAgICBmb3JtYXRWYWx1ZTogZnVuY3Rpb24gZm9ybWF0VmFsdWUoKSB7XG4gICAgICByZXR1cm4gaW5zdC5zdGFydFZhbCArIChzLmVuZElucHV0ID8gJycgOiBpbnN0LmVuZFZhbCA/ICcgLSAnICsgaW5zdC5lbmRWYWwgOiAnJyk7XG4gICAgfSxcbiAgICBwYXJzZVZhbHVlOiBmdW5jdGlvbiBwYXJzZVZhbHVlKHYpIHtcbiAgICAgIHZhciBwYXJ0cyA9IHYgPyB2LnNwbGl0KCcgLSAnKSA6IFtdLFxuICAgICAgICAgIHN0YXJ0VmFsID0gcy5zdGFydElucHV0ID8gJCQxKHMuc3RhcnRJbnB1dCkudmFsKCkgOiBwYXJ0c1swXSxcbiAgICAgICAgICBlbmRWYWwgPSBzLmVuZElucHV0ID8gJCQxKHMuZW5kSW5wdXQpLnZhbCgpIDogcGFydHNbMV07XG4gICAgICBzLmRlZmF1bHRWYWx1ZSA9IGRlZlsxXTsgLy8gdXNlZCBieSBwYXJzZURhdGVcblxuICAgICAgZW5kRGF0ZSA9IGVuZFZhbCA/IHBhcnNlRGF0ZShmb3JtYXQsIGVuZFZhbCwgcykgOiBkZWZbMV07XG4gICAgICBzLmRlZmF1bHRWYWx1ZSA9IGRlZlswXTsgLy8gdXNlZCBieSBwYXJzZURhdGVcblxuICAgICAgc3RhcnREYXRlID0gc3RhcnRWYWwgPyBwYXJzZURhdGUoZm9ybWF0LCBzdGFydFZhbCwgcykgOiBkZWZbMl07XG4gICAgICBzLmRlZmF1bHRWYWx1ZSA9IGRlZltjdXJyXTtcbiAgICAgIGluc3Quc3RhcnRWYWwgPSBzdGFydERhdGUgPyBmb3JtYXREYXRlKGZvcm1hdCwgc3RhcnREYXRlLCBzKSA6ICcnO1xuICAgICAgaW5zdC5lbmRWYWwgPSBlbmREYXRlID8gZm9ybWF0RGF0ZShmb3JtYXQsIGVuZERhdGUsIHMpIDogJyc7XG4gICAgICBpbnN0Ll9zdGFydERhdGUgPSBzdGFydERhdGU7XG4gICAgICBpbnN0Ll9lbmREYXRlID0gZW5kRGF0ZTtcbiAgICAgIHJldHVybiBiYXNlLnBhcnNlVmFsdWUoY3VyciA/IGVuZERhdGUgOiBzdGFydERhdGUsIGluc3QpO1xuICAgIH0sXG4gICAgb25GaWxsOiBmdW5jdGlvbiBvbkZpbGwoZXYpIHtcbiAgICAgIHVwZGF0ZUlucHV0cyhldi5jaGFuZ2UpO1xuICAgIH0sXG4gICAgb25CZWZvcmVDbG9zZTogZnVuY3Rpb24gb25CZWZvcmVDbG9zZShldikge1xuICAgICAgLy8gRG9uJ3QgYWxsb3cgaW52YWxpZCBzZWxlY3Rpb25cbiAgICAgIGlmIChldi5idXR0b24gPT09ICdzZXQnICYmICF2YWxpZGF0ZSh0cnVlLCB0cnVlKSkge1xuICAgICAgICBpbnN0LnNldEFjdGl2ZURhdGUoY3VyciA/ICdzdGFydCcgOiAnZW5kJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uSGlkZTogZnVuY3Rpb24gb25IaWRlKCkge1xuICAgICAgYmFzZS5vbkhpZGUuY2FsbChpbnN0KTtcbiAgICAgIGN1cnIgPSAwO1xuICAgICAgY3R4ID0gbnVsbDtcbiAgICAgIHMuYW5jaG9yID0gc3RhcnRBbmNob3I7XG4gICAgfSxcbiAgICBvbkNsZWFyOiBmdW5jdGlvbiBvbkNsZWFyKCkge1xuICAgICAgaWYgKGF1dG9DaGFuZ2UpIHtcbiAgICAgICAgY3VyciA9IDA7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkJlZm9yZVNob3c6IGZ1bmN0aW9uIG9uQmVmb3JlU2hvdygpIHtcbiAgICAgIHRlbXBTdGFydERhdGUgPSBzdGFydERhdGUgfHwgZGVmWzBdO1xuICAgICAgdGVtcEVuZERhdGUgPSBlbmREYXRlIHx8IGRlZlsxXTtcbiAgICAgIHRlbXBTdGFydFRpbWUgPSBzZXRUaW1lSW5mbyh0ZW1wU3RhcnREYXRlLCAwKTtcbiAgICAgIHRlbXBFbmRUaW1lID0gc2V0VGltZUluZm8odGVtcEVuZERhdGUsIDEpO1xuXG4gICAgICBpZiAocy5jb3VudGVyKSB7XG4gICAgICAgIHMuaGVhZGVyVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgbnIgPSBjYWxjRGF5TnIoKTtcbiAgICAgICAgICByZXR1cm4gKG5yID4gMSA/IHMuc2VsZWN0ZWRQbHVyYWxUZXh0IHx8IHMuc2VsZWN0ZWRUZXh0IDogcy5zZWxlY3RlZFRleHQpLnJlcGxhY2UoL3tjb3VudH0vLCBucik7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHNldCA9IHRydWU7XG4gICAgfSxcbiAgICBvbk1hcmt1cFJlYWR5OiBmdW5jdGlvbiBvbk1hcmt1cFJlYWR5KGV2KSB7XG4gICAgICB2YXIgaHRtbDsgLy8gVmFsaWRhdGUgc3RhcnQgZW5kIGVuZCBkYXRlc1xuXG4gICAgICB2YWxpZGF0ZURhdGVzKCk7IC8vIFNldCB0aGUgY3VycmVudCBkYXRlIChzdGFydCBvciBlbmQpXG5cbiAgICAgIGlmIChjdXJyICYmIHRlbXBFbmREYXRlIHx8ICFjdXJyICYmIHRlbXBTdGFydERhdGUpIHtcbiAgICAgICAgaW5pdCA9IHRydWU7XG4gICAgICAgIGluc3Quc2V0RGF0ZShjdXJyID8gdGVtcEVuZERhdGUgOiB0ZW1wU3RhcnREYXRlLCBmYWxzZSwgMCwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGhpZ2hsaWdodERheXMoKTsgLy8gQ2FsbCBjYWxiYXNlXG5cbiAgICAgIGJhc2Uub25NYXJrdXBSZWFkeS5jYWxsKHRoaXMsIGV2KTtcbiAgICAgIGN0eCA9ICQkMShldi50YXJnZXQpO1xuICAgICAgY3R4LmFkZENsYXNzKCdtYnNjLXJhbmdlJyk7XG5cbiAgICAgIGlmIChzaG93U2VsZWN0b3IpIHtcbiAgICAgICAgaHRtbCA9ICc8ZGl2IGNsYXNzPVwibWJzYy1yYW5nZS1idG4tdFwiIHJvbGU9XCJyYWRpb2dyb3VwXCI+JyArICc8ZGl2IGNsYXNzPVwibWJzYy1yYW5nZS1idG4tYyBtYnNjLXJhbmdlLWJ0bi1zdGFydFwiPjxkaXYgcm9sZT1cInJhZGlvXCIgZGF0YS1zZWxlY3Q9XCJzdGFydFwiIGNsYXNzPVwibWJzYy1mci1idG4tZSBtYnNjLWZyLWJ0bi1uaGwgbWJzYy1yYW5nZS1idG5cIj4nICsgcy5mcm9tVGV4dCArICc8ZGl2IGNsYXNzPVwibWJzYy1yYW5nZS1idG4tdiBtYnNjLXJhbmdlLWJ0bi12LXN0YXJ0XCI+JyArIChpbnN0LnN0YXJ0VmFsIHx8ICcmbmJzcDsnKSArICc8L2Rpdj48L2Rpdj48L2Rpdj4nICsgJzxkaXYgY2xhc3M9XCJtYnNjLXJhbmdlLWJ0bi1jIG1ic2MtcmFuZ2UtYnRuLWVuZFwiPjxkaXYgcm9sZT1cInJhZGlvXCIgZGF0YS1zZWxlY3Q9XCJlbmRcIiBjbGFzcz1cIm1ic2MtZnItYnRuLWUgbWJzYy1mci1idG4tbmhsIG1ic2MtcmFuZ2UtYnRuXCI+JyArIHMudG9UZXh0ICsgJzxkaXYgY2xhc3M9XCJtYnNjLXJhbmdlLWJ0bi12IG1ic2MtcmFuZ2UtYnRuLXYtZW5kXCI+JyArIChpbnN0LmVuZFZhbCB8fCAnJm5ic3A7JykgKyAnPC9kaXY+PC9kaXY+PC9kaXY+JyArICc8L2Rpdj4nO1xuXG4gICAgICAgIGlmIChzLmhlYWRlclRleHQpIHtcbiAgICAgICAgICAkJDEoJy5tYnNjLWZyLWhkcicsIGN0eCkuYWZ0ZXIoaHRtbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJCQxKCcubWJzYy1mci13JywgY3R4KS5wcmVwZW5kKGh0bWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0QWN0aXZlVGFiKCk7XG4gICAgICB9XG5cbiAgICAgICQkMSgnLm1ic2MtcmFuZ2UtYnRuJywgY3R4KS5lYWNoKGZ1bmN0aW9uIChpLCBlbCkge1xuICAgICAgICBsaXN0ZW4oZWwsICd0b3VjaHN0YXJ0Jywgb25CdG5DbGljaywge1xuICAgICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGxpc3RlbihlbCwgJ2NsaWNrJywgb25CdG5DbGljayk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIG9uRGF5Q2hhbmdlOiBmdW5jdGlvbiBvbkRheUNoYW5nZShkYXkpIHtcbiAgICAgIGRheS5hY3RpdmUgPSBjdXJyID8gJ2VuZCcgOiAnc3RhcnQnO1xuICAgICAgZGF5Q2hhbmdlID0gdHJ1ZTtcbiAgICB9LFxuICAgIG9uU2V0RGF0ZTogZnVuY3Rpb24gb25TZXREYXRlKGRheSkge1xuICAgICAgdmFyIGQ7XG5cbiAgICAgIGlmICghaW5pdCkge1xuICAgICAgICBkID0gbm9ybWFsaXplVGltZShkYXkuZGF0ZSwgY3Vycik7XG5cbiAgICAgICAgaWYgKCFzZXQgfHwgZGF5Q2hhbmdlKSB7XG4gICAgICAgICAgaWYgKGF1dG9DaGFuZ2UgJiYgZGF5Q2hhbmdlKSB7XG4gICAgICAgICAgICBpZiAoY3VyciA9PSAxICYmIGQgPCB0ZW1wU3RhcnREYXRlKSB7XG4gICAgICAgICAgICAgIGN1cnIgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3Vycikge1xuICAgICAgICAgICAgICBkLnNldEhvdXJzKHRlbXBFbmRUaW1lLmgsIHRlbXBFbmRUaW1lLmksIHRlbXBFbmRUaW1lLnMsIDk5OSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkLnNldEhvdXJzKHRlbXBTdGFydFRpbWUuaCwgdGVtcFN0YXJ0VGltZS5pLCB0ZW1wU3RhcnRUaW1lLnMsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjdXJyKSB7XG4gICAgICAgICAgICB0ZW1wRW5kRGF0ZSA9IG5ldyBEYXRlKGQpO1xuICAgICAgICAgICAgdGVtcEVuZFRpbWUgPSBzZXRUaW1lSW5mbyh0ZW1wRW5kRGF0ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRlbXBTdGFydERhdGUgPSBuZXcgRGF0ZShkKTtcbiAgICAgICAgICAgIHRlbXBTdGFydFRpbWUgPSBzZXRUaW1lSW5mbyh0ZW1wU3RhcnREYXRlKTtcbiAgICAgICAgICB9IC8vIE1ha2Ugc3VyZSB0aW1lcyBhcmUgb24gdGhlIHNhbWUgZGF5IGZvciBjb21wYXJpc29uXG5cblxuICAgICAgICAgIGlmICh0aW1lT25seSAmJiBzLmF1dG9Db3JyZWN0KSB7XG4gICAgICAgICAgICBub3JtYWxpemUodGVtcFN0YXJ0RGF0ZSwgZCk7XG4gICAgICAgICAgICBub3JtYWxpemUodGVtcEVuZERhdGUsIGQpO1xuICAgICAgICAgIH0gLy8gU2V0IGVuZCBkYXRlIG9uIHN0YXJ0IHNlbGVjdGlvbiBpZiByYW5nZVRhcCBpcyBlbmFibGVkXG5cblxuICAgICAgICAgIGlmIChhdXRvQ2hhbmdlICYmIGRheUNoYW5nZSAmJiAhY3Vycikge1xuICAgICAgICAgICAgLy90ZW1wRW5kRGF0ZSA9IG5ldyBEYXRlKGQuc2V0SG91cnMoMjMsIDU5LCA1OSwgOTk5KSk7XG4gICAgICAgICAgICB0ZW1wRW5kRGF0ZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aW1lT25seSAmJiAhcy5hdXRvQ29ycmVjdCAmJiB0ZW1wRW5kRGF0ZSA8IHRlbXBTdGFydERhdGUpIHtcbiAgICAgICAgLy8gU2V0IGVuZCB0aW1lIHRvIG5leHQgZGF5XG4gICAgICAgIHRlbXBFbmREYXRlID0gbmV3IERhdGUodGVtcEVuZERhdGUuc2V0RGF0ZSh0ZW1wRW5kRGF0ZS5nZXREYXRlKCkgKyAxKSk7XG4gICAgICB9IC8vIFZhbGlkYXRlIG1pbi9tYXggcmFuZ2VzXG5cblxuICAgICAgaW5zdC5faXNWYWxpZCA9IHZhbGlkYXRlKHNldCB8fCBkYXlDaGFuZ2UgfHwgcy5hdXRvQ29ycmVjdCwgIWluaXQpO1xuICAgICAgZGF5LmFjdGl2ZSA9IGN1cnIgPyAnZW5kJyA6ICdzdGFydCc7IC8vIFRvZ2dsZSBzdGFydC9lbmQgaWYgcmFuZ2VUYXAgaXMgZW5hYmxlZFxuXG4gICAgICBpZiAoIWluaXQgJiYgYXV0b0NoYW5nZSkge1xuICAgICAgICBpZiAoZGF5Q2hhbmdlKSB7XG4gICAgICAgICAgY3VyciA9IGN1cnIgPyAwIDogMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEFjdGl2ZVRhYigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5zdC5pc1Zpc2libGUoKSkge1xuICAgICAgICAvLyBEaXNhYmxlIHNldCBidXR0b25cbiAgICAgICAgaWYgKGluc3QuX2lzVmFsaWQpIHtcbiAgICAgICAgICAkJDEoJy5tYnNjLWZyLWJ0bi1zIC5tYnNjLWZyLWJ0bicsIGluc3QuX21hcmt1cCkucmVtb3ZlQ2xhc3MoZGlzYWJsZWRDbGFzcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJCQxKCcubWJzYy1mci1idG4tcyAubWJzYy1mci1idG4nLCBpbnN0Ll9tYXJrdXApLmFkZENsYXNzKGRpc2FibGVkQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRheUNoYW5nZSA9IGZhbHNlO1xuICAgICAgc2V0ID0gZmFsc2U7XG4gICAgICBpbml0ID0gZmFsc2U7XG4gICAgfSxcbiAgICBvblRhYkNoYW5nZTogZnVuY3Rpb24gb25UYWJDaGFuZ2UoZXYpIHtcbiAgICAgIGlmIChldi50YWIgIT0gJ2NhbGVuZGFyJykge1xuICAgICAgICBpbnN0LnNldERhdGUoY3VyciA/IHRlbXBFbmREYXRlIDogdGVtcFN0YXJ0RGF0ZSwgZmFsc2UsIDEwMDAsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICB2YWxpZGF0ZSh0cnVlLCB0cnVlKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIFJBTkdFX1NVQl9URU1QTEFURSA9IFwiPG1ic2MtaW5wdXRcXG4gICAgW2NvbnRyb2xOZ109XFxcImZhbHNlXFxcIiBbbmFtZV09XFxcIm5hbWVcXFwiIFt0aGVtZV09XFxcInRoZW1lXFxcIiBbZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCIgW3BsYWNlaG9sZGVyXT1cXFwicGxhY2Vob2xkZXJcXFwiXFxuICAgIFtlcnJvcl09XFxcImVycm9yXFxcIiBbZXJyb3JNZXNzYWdlXT1cXFwiZXJyb3JNZXNzYWdlXFxcIiBcXG4gICAgW2ljb25dPVxcXCJpbnB1dEljb25cXFwiIFtpY29uLWFsaWduXT1cXFwiaWNvbkFsaWduXFxcIj5cXG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxcbjwvbWJzYy1pbnB1dD5cIjtcclxudmFyIE1ic2NSYW5nZVN0YXJ0Q29tcG9uZW50ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1ic2NSYW5nZVN0YXJ0Q29tcG9uZW50KGhvc3QsIHBhcmVudCwgem9uZSwgY29udHJvbCkge1xyXG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgdGhpcy56b25lID0gem9uZTtcclxuICAgICAgICB0aGlzLmNvbnRyb2wgPSBjb250cm9sO1xyXG4gICAgICAgIHRoaXMudGhlbWUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5lcnJvck1lc3NhZ2UgPSAnJztcclxuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gJyc7XHJcbiAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLm9sZEFjY2Vzc29yID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKHZhbHVlKSB7IH07XHJcbiAgICAgICAgdGhpcy5vblRvdWNoID0gZnVuY3Rpb24gKCkgeyB9O1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbFNldCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jaGVja0FjY2Vzc29yKCk7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY1JhbmdlU3RhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImVsZW1lbnRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgaSA9ICQkMSh0aGlzLmhvc3QubmF0aXZlRWxlbWVudCkuZmluZCgnaW5wdXQnKTtcclxuICAgICAgICAgICAgcmV0dXJuIGlbMF07XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBNYnNjUmFuZ2VTdGFydENvbXBvbmVudC5wcm90b3R5cGUuY2hlY2tBY2Nlc3NvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5jb250cm9sKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2wudmFsdWVBY2Nlc3NvciAhPT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbGRBY2Nlc3NvciA9IHRoaXMuY29udHJvbC52YWx1ZUFjY2Vzc29yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY29udHJvbC52YWx1ZUFjY2Vzc29yID0gdGhpcztcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTWJzY1JhbmdlU3RhcnRDb21wb25lbnQucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICQkMSh0aGlzLmVsZW1lbnQpLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnpvbmUucnVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBhcnIgPSBfdGhpcy5wYXJlbnQuaW5zdGFuY2UuZ2V0VmFsKCksIHZhbHVlID0gYXJyID8gYXJyW190aGlzLnJhbmdlSW5kZXhdIDogdW5kZWZpbmVkLCBjdXJyZW50ID0gdW5kZWZpbmVkLCB2YWx1ZVRleHQgPSBfdGhpcy5wYXJlbnQuaW5zdGFuY2VbX3RoaXMucmFuZ2VJbmRleCA9PT0gMCA/ICdzdGFydFZhbCcgOiAnZW5kVmFsJ107XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJyICYmIHZhbHVlICYmIF90aGlzLmVsZW1lbnQudmFsdWUgIT09IHZhbHVlVGV4dCAmJiBfdGhpcy5wYXJlbnQuZW5hYmxlTWFudWFsRWRpdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdBcnIgPSBuZXcgQXJyYXkoMiksIG90aGVySW5kZXggPSBfdGhpcy5yYW5nZUluZGV4ID09PSAxID8gMCA6IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3QXJyW190aGlzLnJhbmdlSW5kZXhdID0gX3RoaXMuZWxlbWVudC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdBcnJbb3RoZXJJbmRleF0gPSBhcnJbb3RoZXJJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucGFyZW50Lmluc3RhbmNlLnNldFZhbChuZXdBcnIsIHRydWUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmNvbnRyb2wgJiYgX3RoaXMuY29udHJvbC52YWx1ZSAmJiBfdGhpcy5jb250cm9sLnZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IF90aGlzLmNvbnRyb2wudmFsdWVbX3RoaXMucmFuZ2VJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLmNvbnRyb2wgJiYgX3RoaXMuY29udHJvbC52YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gX3RoaXMuY29udHJvbC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmNvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0RhdGVFcXVhbChjdXJyZW50LCB2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uQ2hhbmdlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnRyb2wuY29udHJvbC5wYXRjaFZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgTWJzY1JhbmdlU3RhcnRDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmhhbmRsZUNoYW5nZSgpO1xyXG4gICAgICAgIHRoaXMuY2hlY2tBY2Nlc3NvcigpO1xyXG4gICAgfTtcclxuICAgIE1ic2NSYW5nZVN0YXJ0Q29tcG9uZW50LnByb3RvdHlwZS5yZWdpc3Rlck9uQ2hhbmdlID0gZnVuY3Rpb24gKGZuKSB7XHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xyXG4gICAgfTtcclxuICAgIE1ic2NSYW5nZVN0YXJ0Q29tcG9uZW50LnByb3RvdHlwZS5yZWdpc3Rlck9uVG91Y2hlZCA9IGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgIHRoaXMub25Ub3VjaCA9IGZuO1xyXG4gICAgfTtcclxuICAgIE1ic2NSYW5nZVN0YXJ0Q29tcG9uZW50LnByb3RvdHlwZS5zZXREaXNhYmxlZFN0YXRlID0gZnVuY3Rpb24gKGlzRGlzYWJsZWQpIHtcclxuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcclxuICAgICAgICBpZiAodGhpcy5vbGRBY2Nlc3NvciAmJiB0aGlzLm9sZEFjY2Vzc29yLnNldERpc2FibGVkU3RhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5vbGRBY2Nlc3Nvci5zZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNYnNjUmFuZ2VTdGFydENvbXBvbmVudC5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgdmFyIGFycl8xID0gdGhpcy5wYXJlbnQuaW5zdGFuY2UuZ2V0VmFsKCksIHZhbCA9IChhcnJfMSAmJiBhcnJfMS5sZW5ndGgpID8gYXJyXzFbdGhpcy5yYW5nZUluZGV4XSA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgaWYgKCFpc0RhdGVFcXVhbCh2LCB2YWwpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXJyXzEgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhcnJfMSA9IGFycl8xIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGFycl8xW3RoaXMucmFuZ2VJbmRleF0gPSB2O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuaW5zdGFuY2Uuc2V0VmFsKGFycl8xLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbml0aWFsU2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnBhcmVudC5pbnN0YW5jZS5zZXRWYWwoYXJyXzEsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaW5pdGlhbFNldCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ2ljb24nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1JhbmdlU3RhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImlucHV0SWNvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnaWNvbi1hbGlnbicpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjUmFuZ2VTdGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiaWNvbkFsaWduXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NSYW5nZVN0YXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjUmFuZ2VTdGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwiZXJyb3JcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1JhbmdlU3RhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImVycm9yTWVzc2FnZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY1JhbmdlU3RhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NSYW5nZVN0YXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJwbGFjZWhvbGRlclwiLCB2b2lkIDApO1xyXG4gICAgTWJzY1JhbmdlU3RhcnRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtcmFuZ2Utc3RhcnQnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogUkFOR0VfU1VCX1RFTVBMQVRFXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgxLCBJbmplY3QoZm9yd2FyZFJlZihmdW5jdGlvbiAoKSB7IHJldHVybiBNYnNjUmFuZ2VDb21wb25lbnQ7IH0pKSksIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBNYnNjUmFuZ2VDb21wb25lbnQsIE5nWm9uZSwgTmdDb250cm9sXSlcclxuICAgIF0sIE1ic2NSYW5nZVN0YXJ0Q29tcG9uZW50KTtcclxuICAgIHJldHVybiBNYnNjUmFuZ2VTdGFydENvbXBvbmVudDtcclxufSgpKTtcclxudmFyIE1ic2NSYW5nZUVuZENvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY1JhbmdlRW5kQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY1JhbmdlRW5kQ29tcG9uZW50KGVsLCBwYXJlbnQsIHpvbmUsIGNvbnRyb2wpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBlbCwgcGFyZW50LCB6b25lLCBjb250cm9sKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnJhbmdlSW5kZXggPSAxO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE1ic2NSYW5nZUVuZENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1yYW5nZS1lbmQnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogUkFOR0VfU1VCX1RFTVBMQVRFLFxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMSwgSW5qZWN0KGZvcndhcmRSZWYoZnVuY3Rpb24gKCkgeyByZXR1cm4gTWJzY1JhbmdlQ29tcG9uZW50OyB9KSkpLCBfX3BhcmFtKDMsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTWJzY1JhbmdlQ29tcG9uZW50LCBOZ1pvbmUsIE5nQ29udHJvbF0pXHJcbiAgICBdLCBNYnNjUmFuZ2VFbmRDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIE1ic2NSYW5nZUVuZENvbXBvbmVudDtcclxufShNYnNjUmFuZ2VTdGFydENvbXBvbmVudCkpO1xyXG52YXIgTWJzY1JhbmdlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjUmFuZ2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjUmFuZ2UoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMub3B0aW9uU2VydmljZSA9IG9wdGlvblNlcnZpY2U7XHJcbiAgICAgICAgX3RoaXMub25TZXREYXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm9uQ2VsbEhvdmVySW4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMub25DZWxsSG92ZXJPdXQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMub25EYXlDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY1JhbmdlLnByb3RvdHlwZSwgXCJlbmRJbnB1dFwiLCB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHY7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFzSW5wdXQgPSAkJDEodikuZmluZCgnaW5wdXQnKTtcclxuICAgICAgICAgICAgICAgIGlmIChoYXNJbnB1dC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gaGFzSW5wdXRbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZW5kSW5wdXQgPSBlbGVtZW50O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NSYW5nZS5wcm90b3R5cGUsIFwic3RhcnRJbnB1dFwiLCB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHY7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFzSW5wdXQgPSAkJDEodikuZmluZCgnaW5wdXQnKTtcclxuICAgICAgICAgICAgICAgIGlmIChoYXNJbnB1dC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ID0gaGFzSW5wdXRbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRJbnB1dCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY1JhbmdlLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB0aGlzLnNldE5ld1ZhbHVlUHJveHkodik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBNYnNjUmFuZ2UucHJvdG90eXBlLnNldE5ld1ZhbHVlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBpZiAoIWRlZXBFcXVhbHNBcnJheSh2LCB0aGlzLmluc3RhbmNlLmdldFZhbCgpKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodiwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lucHV0U2VydmljZSAmJiB0aGlzLl9pbnB1dFNlcnZpY2UuaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dFNlcnZpY2UuaW5wdXQuaW5uZXJWYWx1ZSA9IHRoaXMuaW5zdGFuY2UuX3ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjUmFuZ2UucHJvdG90eXBlLCBcIm9wdGlvbkV4dGVuc2lvbnNcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB2YXIgZXh0ZXJuYWxPbkNsb3NlID0gdGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5vbkNsb3NlO1xyXG4gICAgICAgICAgICB2YXIgZXh0ZXJuYWxPbkZpbGwgPSB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm9uRmlsbDtcclxuICAgICAgICAgICAgdmFyIG9uQ2xvc2VFbWl0dGVyID0gdGhpcy5vbkNsb3NlO1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgb25GaWxsOiBmdW5jdGlvbiAoZXZlbnQsIGluc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLl93cmFwcGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vbGRBY2Nlc3Nvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub2xkQWNjZXNzb3Iud3JpdGVWYWx1ZShldmVudC52YWx1ZVRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRlcm5hbE9uRmlsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlcm5hbE9uRmlsbChldmVudCwgaW5zdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIG9uQ2xvc2U6IGZ1bmN0aW9uIChldmVudCwgaW5zdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uVG91Y2goKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0ZXJuYWxPbkNsb3NlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVybmFsT25DbG9zZShldmVudCwgaW5zdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvbkNsb3NlRW1pdHRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5pbnN0ID0gaW5zdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DbG9zZUVtaXR0ZXIuZW1pdChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTWJzY1JhbmdlLnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHtcclxuICAgICAgICAgICAgcHJlc2V0OiAncmFuZ2UnLFxyXG4gICAgICAgICAgICBza2lwU2hvdzogdGhpcy5fd3JhcHBlclxyXG4gICAgICAgIH0sIHRoaXMub3B0aW9uU2VydmljZSA/IHRoaXMub3B0aW9uU2VydmljZS5vcHRpb25zIDoge30sIHRoaXMub3B0aW9ucywgdGhpcy5pbmxpbmVPcHRpb25zT2JqLCB7XHJcbiAgICAgICAgICAgIGVuZElucHV0OiB0aGlzLl93cmFwcGVyID8gdGhpcy5lbmQuZWxlbWVudCA6IHRoaXMuX2VuZElucHV0LFxyXG4gICAgICAgICAgICBzdGFydElucHV0OiB0aGlzLl93cmFwcGVyID8gdGhpcy5zdGFydC5lbGVtZW50IDogdGhpcy5fc3RhcnRJbnB1dFxyXG4gICAgICAgIH0sIHRoaXMub3B0aW9uRXh0ZW5zaW9ucyk7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBSYW5nZVBpY2tlcih0aGlzLl93cmFwcGVyID8gdGhpcy5pbml0aWFsRWxlbS5uYXRpdmVFbGVtZW50IDogdGhpcy5lbGVtZW50LCBvcHRpb25zKTtcclxuICAgICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodGhpcy5pbml0aWFsVmFsdWUsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTWJzY1JhbmdlLnByb3RvdHlwZS5uZ0FmdGVyQ29udGVudEluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhcnQgfHwgdGhpcy5lbmQpIHtcclxuICAgICAgICAgICAgdGhpcy5fd3JhcHBlciA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl93cmFwcGVyID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1ic2NSYW5nZS5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMuX3dyYXBwZXIpIHtcclxuICAgICAgICAgICAgJCQxKHRoaXMuc3RhcnQuZWxlbWVudCkub24oJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnpvbmUucnVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBfdGhpcy5pbnN0YW5jZS5nZXRWYWwoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRlZXBFcXVhbHNBcnJheShfdGhpcy5jb250cm9sLnZhbHVlLCB2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uQ2hhbmdlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbnRyb2wuY29udHJvbC5wYXRjaFZhbHVlKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25DaGFuZ2VFbWl0dGVyLmVtaXQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgJCQxKHRoaXMuZW5kLmVsZW1lbnQpLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy56b25lLnJ1bihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gX3RoaXMuaW5zdGFuY2UuZ2V0VmFsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmNvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWVwRXF1YWxzQXJyYXkoX3RoaXMuY29udHJvbC52YWx1ZSwgdmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbkNoYW5nZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb250cm9sLmNvbnRyb2wucGF0Y2hWYWx1ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlci5lbWl0KHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgdGhhdF8xID0gdGhpcztcclxuICAgICAgICAgICAgJCQxKHRoaXMuZWxlbWVudCkub24oJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoYXRfMS56b25lLnJ1bihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXRfMS5lbGVtZW50LnZhbHVlICE9PSB0aGF0XzEuaW5zdGFuY2UuX3ZhbHVlICYmIHRoYXRfMS5lbmFibGVNYW51YWxFZGl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gdGhhdF8xLmVsZW1lbnQudmFsdWUgJiYgdGhhdF8xLmVsZW1lbnQudmFsdWUuc3BsaXQoJyAtICcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdF8xLmluc3RhbmNlLnNldFZhbCh2LCB0cnVlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhhdF8xLmluc3RhbmNlLmdldFZhbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdF8xLmNvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXRfMS5vbkNoYW5nZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0XzEuY29udHJvbC5jb250cm9sLnBhdGNoVmFsdWUodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdF8xLm9uQ2hhbmdlRW1pdHRlci5lbWl0KHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY1JhbmdlLnByb3RvdHlwZSwgXCJhdXRvQ29ycmVjdFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIE1ic2NSYW5nZS5wcm90b3R5cGUsIFwiY29udHJvbHNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXHJcbiAgICBdLCBNYnNjUmFuZ2UucHJvdG90eXBlLCBcImVuZElucHV0XCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBNYnNjUmFuZ2UucHJvdG90eXBlLCBcIm1heFJhbmdlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIE1ic2NSYW5nZS5wcm90b3R5cGUsIFwibWluUmFuZ2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NSYW5nZS5wcm90b3R5cGUsIFwic2hvd1NlbGVjdG9yXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxyXG4gICAgXSwgTWJzY1JhbmdlLnByb3RvdHlwZSwgXCJzdGFydElucHV0XCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjUmFuZ2UucHJvdG90eXBlLCBcImZyb21UZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NSYW5nZS5wcm90b3R5cGUsIFwidG9UZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY1JhbmdlLnByb3RvdHlwZSwgXCJvblNldERhdGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjUmFuZ2UucHJvdG90eXBlLCBcIm9uQ2VsbEhvdmVySW5cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjUmFuZ2UucHJvdG90eXBlLCBcIm9uQ2VsbEhvdmVyT3V0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY1JhbmdlLnByb3RvdHlwZSwgXCJvbkRheUNoYW5nZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29udGVudENoaWxkKE1ic2NSYW5nZVN0YXJ0Q29tcG9uZW50LCB7IHN0YXRpYzogZmFsc2UgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE1ic2NSYW5nZVN0YXJ0Q29tcG9uZW50KVxyXG4gICAgXSwgTWJzY1JhbmdlLnByb3RvdHlwZSwgXCJzdGFydFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29udGVudENoaWxkKE1ic2NSYW5nZUVuZENvbXBvbmVudCwgeyBzdGF0aWM6IGZhbHNlIH0pLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBNYnNjUmFuZ2VFbmRDb21wb25lbnQpXHJcbiAgICBdLCBNYnNjUmFuZ2UucHJvdG90eXBlLCBcImVuZFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnbWJzYy1vcHRpb25zJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NSYW5nZS5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnbWJzYy1yYW5nZScpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtBcnJheV0pXHJcbiAgICBdLCBNYnNjUmFuZ2UucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCdtYnNjLXJhbmdlQ2hhbmdlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NSYW5nZS5wcm90b3R5cGUsIFwib25DaGFuZ2VFbWl0dGVyXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjUmFuZ2UgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBEaXJlY3RpdmUoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ1ttYnNjLXJhbmdlXScsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCdcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDIsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDMsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDQsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLCBOZ0NvbnRyb2wsIE1ic2NJbnB1dFNlcnZpY2UsIE1ic2NPcHRpb25zU2VydmljZSwgVmlld0NvbnRhaW5lclJlZl0pXHJcbiAgICBdLCBNYnNjUmFuZ2UpO1xyXG4gICAgcmV0dXJuIE1ic2NSYW5nZTtcclxufShNYnNjQ2FsQmFzZSkpO1xyXG52YXIgTWJzY1JhbmdlQ29tcG9uZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjUmFuZ2VDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjUmFuZ2VDb21wb25lbnQoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIG51bGwpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZXJyb3JNZXNzYWdlID0gJyc7XHJcbiAgICAgICAgX3RoaXMucGxhY2Vob2xkZXIgPSAnJztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBNYnNjUmFuZ2VDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2V0VGhlbWVDbGFzc2VzKCk7XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnaWNvbicpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjUmFuZ2VDb21wb25lbnQucHJvdG90eXBlLCBcImlucHV0SWNvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnaWNvbi1hbGlnbicpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjUmFuZ2VDb21wb25lbnQucHJvdG90eXBlLCBcImljb25BbGlnblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjUmFuZ2VDb21wb25lbnQucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NSYW5nZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZXJyb3JcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1JhbmdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlcnJvck1lc3NhZ2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY1JhbmdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvcHRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NSYW5nZUNvbXBvbmVudC5wcm90b3R5cGUsIFwicGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NSYW5nZUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1yYW5nZScsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxuZy1jb250ZW50IHNlbGVjdD1cXFwibWJzYy1yYW5nZS1zdGFydFxcXCI+PC9uZy1jb250ZW50PlxcbiAgICA8bmctY29udGVudCBzZWxlY3Q9XFxcIm1ic2MtcmFuZ2UtZW5kXFxcIj48L25nLWNvbnRlbnQ+XFxuICAgIDxtYnNjLWlucHV0ICpuZ0lmPVxcXCIhX3dyYXBwZXIgJiYgKCFpbmxpbmUgfHwgc2hvd0lucHV0KVxcXCIgXFxuICAgICAgICBbY29udHJvbE5nXT1cXFwiZmFsc2VcXFwiIFtuYW1lXT1cXFwibmFtZVxcXCIgW3RoZW1lXT1cXFwidGhlbWVcXFwiIFtkaXNhYmxlZF09XFxcImRpc2FibGVkXFxcIiBbZHJvcGRvd25dPVxcXCJkcm9wZG93blxcXCIgW3BsYWNlaG9sZGVyXT1cXFwicGxhY2Vob2xkZXJcXFwiXFxuICAgICAgICBbZXJyb3JdPVxcXCJlcnJvclxcXCIgW2Vycm9yTWVzc2FnZV09XFxcImVycm9yTWVzc2FnZVxcXCIgXFxuICAgICAgICBbaWNvbl09XFxcImlucHV0SWNvblxcXCIgW2ljb24tYWxpZ25dPVxcXCJpY29uQWxpZ25cXFwiPlxcbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxcbiAgICA8L21ic2MtaW5wdXQ+XCIsXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgyLCBPcHRpb25hbCgpKSwgX19wYXJhbSgzLCBPcHRpb25hbCgpKSwgX19wYXJhbSg0LCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZSwgTmdDb250cm9sLCBNYnNjSW5wdXRTZXJ2aWNlLCBNYnNjT3B0aW9uc1NlcnZpY2VdKVxyXG4gICAgXSwgTWJzY1JhbmdlQ29tcG9uZW50KTtcclxuICAgIHJldHVybiBNYnNjUmFuZ2VDb21wb25lbnQ7XHJcbn0oTWJzY1JhbmdlKSk7XHJcbnZhciBNYnNjUmFuZ2VNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWJzY1JhbmdlTW9kdWxlKCkge1xyXG4gICAgfVxyXG4gICAgTWJzY1JhbmdlTW9kdWxlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgTmdNb2R1bGUoe1xyXG4gICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBNYnNjQ2FsQmFzZU1vZHVsZSwgTWJzY0lucHV0TW9kdWxlXSxcclxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWJzY1JhbmdlU3RhcnRDb21wb25lbnQsIE1ic2NSYW5nZUVuZENvbXBvbmVudCwgTWJzY1JhbmdlLCBNYnNjUmFuZ2VDb21wb25lbnRdLFxyXG4gICAgICAgICAgICBleHBvcnRzOiBbTWJzY1JhbmdlU3RhcnRDb21wb25lbnQsIE1ic2NSYW5nZUVuZENvbXBvbmVudCwgTWJzY1JhbmdlLCBNYnNjUmFuZ2VDb21wb25lbnRdXHJcbiAgICAgICAgfSlcclxuICAgIF0sIE1ic2NSYW5nZU1vZHVsZSk7XHJcbiAgICByZXR1cm4gTWJzY1JhbmdlTW9kdWxlO1xyXG59KCkpO1xuXG52YXIgTWJzY1Njcm9sbGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjU2Nyb2xsZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjU2Nyb2xsZXIoaW5pdGlhbEVsZW1lbnQsIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtZW50LCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMub3B0aW9uU2VydmljZSA9IG9wdGlvblNlcnZpY2U7XHJcbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY1Njcm9sbGVyLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCB7XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB0aGlzLnNldE5ld1ZhbHVlUHJveHkodik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBNYnNjU2Nyb2xsZXIucHJvdG90eXBlLnNldE5ld1ZhbHVlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB2YXIgaW5uZXJWYWx1ZSA9IHRoaXMuaW5zdGFuY2UuZ2V0VmFsKCk7XHJcbiAgICAgICAgICAgIGlmIChpbm5lclZhbHVlICE9PSB2KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNldFZhbCh2LCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5wdXRTZXJ2aWNlICYmIHRoaXMuX2lucHV0U2VydmljZS5pbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lucHV0U2VydmljZS5pbnB1dC5pbm5lclZhbHVlID0gdGhpcy5pbnN0YW5jZS5fdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTWJzY1Njcm9sbGVyLnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHt9LCB0aGlzLm9wdGlvblNlcnZpY2UgPyB0aGlzLm9wdGlvblNlcnZpY2Uub3B0aW9ucyA6IHt9LCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaiwgdGhpcy5vcHRpb25FeHRlbnNpb25zKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IFNjcm9sbGVyKHRoaXMuZWxlbWVudCwgb3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodGhpcy5pbml0aWFsVmFsdWUsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnbWJzYy1vcHRpb25zJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NTY3JvbGxlci5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnbWJzYy1zY3JvbGxlcicpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcclxuICAgIF0sIE1ic2NTY3JvbGxlci5wcm90b3R5cGUsIFwidmFsdWVcIiwgbnVsbCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoJ21ic2Mtc2Nyb2xsZXJDaGFuZ2UnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY1Njcm9sbGVyLnByb3RvdHlwZSwgXCJvbkNoYW5nZUVtaXR0ZXJcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NTY3JvbGxlciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIERpcmVjdGl2ZSh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW21ic2Mtc2Nyb2xsZXJdJyxcclxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJ1xyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMiwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksIF9fcGFyYW0oNCwgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBOZ1pvbmUsIE5nQ29udHJvbCwgTWJzY0lucHV0U2VydmljZSwgTWJzY09wdGlvbnNTZXJ2aWNlLCBWaWV3Q29udGFpbmVyUmVmXSlcclxuICAgIF0sIE1ic2NTY3JvbGxlcik7XHJcbiAgICByZXR1cm4gTWJzY1Njcm9sbGVyO1xyXG59KE1ic2NTY3JvbGxlckJhc2UpKTtcclxudmFyIE1ic2NTY3JvbGxlckNvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY1Njcm9sbGVyQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY1Njcm9sbGVyQ29tcG9uZW50KGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCBudWxsKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmVycm9yTWVzc2FnZSA9ICcnO1xyXG4gICAgICAgIF90aGlzLnBsYWNlaG9sZGVyID0gJyc7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgTWJzY1Njcm9sbGVyQ29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnNldFRoZW1lQ2xhc3NlcygpO1xyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ2ljb24nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1Njcm9sbGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpbnB1dEljb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ2ljb24tYWxpZ24nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1Njcm9sbGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpY29uQWxpZ25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1Njcm9sbGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjU2Nyb2xsZXJDb21wb25lbnQucHJvdG90eXBlLCBcImVycm9yXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NTY3JvbGxlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZXJyb3JNZXNzYWdlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NTY3JvbGxlckNvbXBvbmVudC5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjU2Nyb2xsZXJDb21wb25lbnQucHJvdG90eXBlLCBcInBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjU2Nyb2xsZXJDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ21ic2Mtc2Nyb2xsZXInLFxyXG4gICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogSU5QVVRfVEVNUExBVEVcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDIsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDMsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDQsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLCBOZ0NvbnRyb2wsIE1ic2NJbnB1dFNlcnZpY2UsIE1ic2NPcHRpb25zU2VydmljZV0pXHJcbiAgICBdLCBNYnNjU2Nyb2xsZXJDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIE1ic2NTY3JvbGxlckNvbXBvbmVudDtcclxufShNYnNjU2Nyb2xsZXIpKTtcclxudmFyIE1ic2NTY3JvbGxlck1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNYnNjU2Nyb2xsZXJNb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBNYnNjU2Nyb2xsZXJNb2R1bGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBOZ01vZHVsZSh7XHJcbiAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIE1ic2NTY3JvbGxlckJhc2VNb2R1bGUsIE1ic2NJbnB1dE1vZHVsZV0sXHJcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01ic2NTY3JvbGxlciwgTWJzY1Njcm9sbGVyQ29tcG9uZW50XSxcclxuICAgICAgICAgICAgZXhwb3J0czogW01ic2NTY3JvbGxlciwgTWJzY1Njcm9sbGVyQ29tcG9uZW50XVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBNYnNjU2Nyb2xsZXJNb2R1bGUpO1xyXG4gICAgcmV0dXJuIE1ic2NTY3JvbGxlck1vZHVsZTtcclxufSgpKTtcblxudmFyIE1ic2NTY3JvbGxWaWV3ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjU2Nyb2xsVmlldywgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NTY3JvbGxWaWV3KGluaXRpYWxFbGVtLCB6b25lLCBub3RpZnlJdGVtU2VydmljZSwgb3B0aW9uU2VydmljZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBub3RpZnlJdGVtU2VydmljZSkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5vcHRpb25TZXJ2aWNlID0gb3B0aW9uU2VydmljZTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBNYnNjU2Nyb2xsVmlldy5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCQxKHt9LCB0aGlzLm9wdGlvblNlcnZpY2UgPyB0aGlzLm9wdGlvblNlcnZpY2Uub3B0aW9ucyA6IHt9LCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaik7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBTY3JvbGxWaWV3KHRoaXMuaW5pdGlhbEVsZW0ubmF0aXZlRWxlbWVudCwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5ub3RpZnlJdGVtU2VydmljZS5ub3RpZnlJbnN0YW5jZVJlYWR5KHRoaXMuaW5zdGFuY2UpO1xyXG4gICAgICAgIHRoaXMuYWRkUmVtb3ZlT2JzZXJ2ZXIgPSB0aGlzLm5vdGlmeUl0ZW1TZXJ2aWNlLm9uQWRkUmVtb3ZlKCkuc3Vic2NyaWJlKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmluc3RhbmNlLnJlZnJlc2goKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBNYnNjU2Nyb2xsVmlldy5wcm90b3R5cGUubmdPbkRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5ub3RpZnlJdGVtU2VydmljZS5vbkFkZFJlbW92ZSgpLnVuc3Vic2NyaWJlKHRoaXMuYWRkUmVtb3ZlT2JzZXJ2ZXIpO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdPbkRlc3Ryb3kuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdtYnNjLW9wdGlvbnMnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY1Njcm9sbFZpZXcucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NTY3JvbGxWaWV3ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgRGlyZWN0aXZlKHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWJzYy1zY3JvbGx2aWV3XScsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXHJcbiAgICAgICAgICAgIHByb3ZpZGVyczogW01ic2NOb3RpZnlJdGVtU2VydmljZV0sXHJcbiAgICAgICAgICAgIGhvc3Q6IHsgJ2NsYXNzJzogJ21ic2MtY2xvYWsnIH1cclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDMsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLCBNYnNjTm90aWZ5SXRlbVNlcnZpY2UsIE1ic2NPcHRpb25zU2VydmljZV0pXHJcbiAgICBdLCBNYnNjU2Nyb2xsVmlldyk7XHJcbiAgICByZXR1cm4gTWJzY1Njcm9sbFZpZXc7XHJcbn0oTWJzY1Njcm9sbFZpZXdCYXNlKSk7XHJcbnZhciBNYnNjU2Nyb2xsVmlld0l0ZW0gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NTY3JvbGxWaWV3SXRlbSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NTY3JvbGxWaWV3SXRlbShpbml0aWFsRWxlbSwgbm90aWZ5SXRlbVNlcnZpY2UpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgbm90aWZ5SXRlbVNlcnZpY2UsIGluaXRpYWxFbGVtKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgTWJzY1Njcm9sbFZpZXdJdGVtID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgRGlyZWN0aXZlKHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWJzYy1zY3JvbGx2aWV3LWl0ZW1dJyxcclxuICAgICAgICAgICAgaG9zdDoge1xyXG4gICAgICAgICAgICAgICAgJ1thdHRyLmRhdGEtaWRdJzogJ2lkJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBNYnNjTm90aWZ5SXRlbVNlcnZpY2VdKVxyXG4gICAgXSwgTWJzY1Njcm9sbFZpZXdJdGVtKTtcclxuICAgIHJldHVybiBNYnNjU2Nyb2xsVmlld0l0ZW07XHJcbn0oTWJzY1Njcm9sbEl0ZW1CYXNlKSk7XHJcbnZhciBNYnNjU2Nyb2xsVmlld0NvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY1Njcm9sbFZpZXdDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjU2Nyb2xsVmlld0NvbXBvbmVudChpbml0aWFsRWxlbSwgem9uZSwgbm90aWZ5SXRlbVNlcnZpY2UsIG9wdGlvblNlcnZpY2UpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIG5vdGlmeUl0ZW1TZXJ2aWNlLCBvcHRpb25TZXJ2aWNlKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnb3B0aW9ucycpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjU2Nyb2xsVmlld0NvbXBvbmVudC5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgTWJzY1Njcm9sbFZpZXdDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ21ic2Mtc2Nyb2xsdmlldycsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBcIjxuZy1jb250ZW50PjwvbmctY29udGVudD5cIixcclxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbTWJzY05vdGlmeUl0ZW1TZXJ2aWNlXVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBOZ1pvbmUsIE1ic2NOb3RpZnlJdGVtU2VydmljZSwgTWJzY09wdGlvbnNTZXJ2aWNlXSlcclxuICAgIF0sIE1ic2NTY3JvbGxWaWV3Q29tcG9uZW50KTtcclxuICAgIHJldHVybiBNYnNjU2Nyb2xsVmlld0NvbXBvbmVudDtcclxufShNYnNjU2Nyb2xsVmlldykpO1xyXG52YXIgTWJzY1Njcm9sbFZpZXdJdGVtQ29tcG9uZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjU2Nyb2xsVmlld0l0ZW1Db21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjU2Nyb2xsVmlld0l0ZW1Db21wb25lbnQoaW5pdGlhbEVsZW0sIG5vdGlmeUl0ZW1TZXJ2aWNlKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCBub3RpZnlJdGVtU2VydmljZSkgfHwgdGhpcztcclxuICAgIH1cclxuICAgIE1ic2NTY3JvbGxWaWV3SXRlbUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy1zY3JvbGx2aWV3LWl0ZW0nLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxyXG4gICAgICAgICAgICBob3N0OiB7XHJcbiAgICAgICAgICAgICAgICAnW2F0dHIuZGF0YS1pZF0nOiAnaWQnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE1ic2NOb3RpZnlJdGVtU2VydmljZV0pXHJcbiAgICBdLCBNYnNjU2Nyb2xsVmlld0l0ZW1Db21wb25lbnQpO1xyXG4gICAgcmV0dXJuIE1ic2NTY3JvbGxWaWV3SXRlbUNvbXBvbmVudDtcclxufShNYnNjU2Nyb2xsVmlld0l0ZW0pKTtcclxudmFyIE1ic2NTY3JvbGxWaWV3TW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1ic2NTY3JvbGxWaWV3TW9kdWxlKCkge1xyXG4gICAgfVxyXG4gICAgTWJzY1Njcm9sbFZpZXdNb2R1bGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBOZ01vZHVsZSh7XHJcbiAgICAgICAgICAgIGltcG9ydHM6IFtNYnNjU2Nyb2xsVmlld0Jhc2VNb2R1bGVdLFxyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNYnNjU2Nyb2xsVmlldywgTWJzY1Njcm9sbFZpZXdDb21wb25lbnQsIE1ic2NTY3JvbGxWaWV3SXRlbSwgTWJzY1Njcm9sbFZpZXdJdGVtQ29tcG9uZW50XSxcclxuICAgICAgICAgICAgZXhwb3J0czogW01ic2NTY3JvbGxWaWV3LCBNYnNjU2Nyb2xsVmlld0NvbXBvbmVudCwgTWJzY1Njcm9sbFZpZXdJdGVtLCBNYnNjU2Nyb2xsVmlld0l0ZW1Db21wb25lbnRdXHJcbiAgICAgICAgfSlcclxuICAgIF0sIE1ic2NTY3JvbGxWaWV3TW9kdWxlKTtcclxuICAgIHJldHVybiBNYnNjU2Nyb2xsVmlld01vZHVsZTtcclxufSgpKTtcblxudmFyIFNlbGVjdCQxID0gU2Nyb2xsZXI7XG52YXIgZGVmYXVsdHMkZCA9IHtcbiAgaW5wdXRDbGFzczogJycsXG4gIHJ0bDogZmFsc2UsXG4gIHNob3dJbnB1dDogdHJ1ZSxcbiAgZ3JvdXBMYWJlbDogJ0dyb3VwcycsXG4gIGRhdGFIdG1sOiAnaHRtbCcsXG4gIGRhdGFUZXh0OiAndGV4dCcsXG4gIGRhdGFWYWx1ZTogJ3ZhbHVlJyxcbiAgZGF0YUdyb3VwOiAnZ3JvdXAnLFxuICBkYXRhRGlzYWJsZWQ6ICdkaXNhYmxlZCcsXG4gIGZpbHRlclBsYWNlaG9sZGVyVGV4dDogJ1R5cGUgdG8gZmlsdGVyJyxcbiAgZmlsdGVyRW1wdHlUZXh0OiAnTm8gcmVzdWx0cycsXG4gIGZpbHRlckNsZWFySWNvbjogJ21hdGVyaWFsLWNsb3NlJ1xufTtcblxucHJlc2V0cy5zZWxlY3QgPSBmdW5jdGlvbiAoaW5zdCwgc2V0dGluZ3MpIHtcbiAgdmFyICRpbnB1dCxcbiAgICAgIGRhdGFBcnJheSxcbiAgICAgIGZpbHRlckxlbmd0aCxcbiAgICAgIGZpbHRlclRleHQsXG4gICAgICBncm91cCxcbiAgICAgIGdyb3VwQXJyYXksXG4gICAgICBncm91cFdoZWVsLFxuICAgICAgZ3JvdXBzLFxuICAgICAgZ3JvdXBXaGVlbElkeCxcbiAgICAgIGhhc1JlbW90ZURhdGEsXG4gICAgICBvcHRpb24sXG4gICAgICBvcHRpb25BcnJheSxcbiAgICAgIG9wdGlvbldoZWVsLFxuICAgICAgb3B0aW9uV2hlZWxJZHgsXG4gICAgICBwcmV2ZW50LFxuICAgICAgZGVmYXVsdFZhbHVlID0gJycsXG4gICAgICBzZWxlY3RlZFRleHRzID0ge30sXG4gICAgICBhbmltVGltZSA9IDEwMDAsXG4gICAgICBlbG0gPSB0aGlzLFxuICAgICAgJGVsbSA9ICQkMShlbG0pLFxuICAgICAgb3JpZyA9IGV4dGVuZCQxKHt9LCBpbnN0LnNldHRpbmdzKSxcbiAgICAgIHMgPSBleHRlbmQkMShpbnN0LnNldHRpbmdzLCBkZWZhdWx0cyRkLCBvcmlnKSxcbiAgICAgICRmaWx0ZXJFbXB0eSA9ICQkMSgnPGRpdiBjbGFzcz1cIm1ic2Mtc2VsLWVtcHR5XCI+JyArIHMuZmlsdGVyRW1wdHlUZXh0ICsgJzwvZGl2PicpLFxuICAgICAgb3JpZ1JlYWRPbmx5ID0gcy5yZWFkb25seSxcbiAgICAgIG9wdGlvbnMgPSB7fSxcbiAgICAgIGxheW91dCA9IHMubGF5b3V0IHx8ICgvdG9wfGJvdHRvbXxpbmxpbmUvLnRlc3Qocy5kaXNwbGF5KSB8fCBzLmZpbHRlciA/ICdsaXF1aWQnIDogJycpLFxuICAgICAgaXNMaXF1aWQgPSBsYXlvdXQgPT0gJ2xpcXVpZCcgfHwgIXMudG91Y2hVaSxcbiAgICAgIG11bHRpcGxlID0gaXNOdW1lcmljKHMuc2VsZWN0KSA/IHMuc2VsZWN0IDogcy5zZWxlY3QgPT0gJ211bHRpcGxlJyB8fCAkZWxtLnByb3AoJ211bHRpcGxlJyksXG4gICAgICB0YXBTZWxlY3QgPSBtdWx0aXBsZSB8fCAocy5maWx0ZXIgfHwgcy50YXBTZWxlY3QgPyAxIDogZmFsc2UpLFxuICAgICAgaWQgPSB0aGlzLmlkICsgJ19kdW1teScsXG4gICAgICBsYmwgPSAkJDEoJ2xhYmVsW2Zvcj1cIicgKyB0aGlzLmlkICsgJ1wiXScpLmF0dHIoJ2ZvcicsIGlkKSxcbiAgICAgIGxhYmVsID0gcy5sYWJlbCAhPT0gdW5kZWZpbmVkID8gcy5sYWJlbCA6IGxibC5sZW5ndGggPyBsYmwudGV4dCgpIDogJGVsbS5hdHRyKCduYW1lJyksXG4gICAgICBncm91cFNldHVwID0gcy5ncm91cCxcbiAgICAgIGhhc0RhdGEgPSAhIXMuZGF0YSxcbiAgICAgIGhhc0dyb3VwcyA9IGhhc0RhdGEgPyAhIXMuZ3JvdXAgOiAkJDEoJ29wdGdyb3VwJywgJGVsbSkubGVuZ3RoLFxuICAgICAgaGFzR3JvdXBXaGVlbCA9IGhhc0dyb3VwcyAmJiBncm91cFNldHVwICYmIGdyb3VwU2V0dXAuZ3JvdXBXaGVlbCAhPT0gZmFsc2UsXG4gICAgICBncm91cFNlcCA9IGhhc0dyb3VwcyAmJiBncm91cFNldHVwICYmIGhhc0dyb3VwV2hlZWwgJiYgZ3JvdXBTZXR1cC5jbHVzdGVyZWQgPT09IHRydWUsXG4gICAgICBncm91cEhkciA9IGhhc0dyb3VwcyAmJiAoIWdyb3VwU2V0dXAgfHwgZ3JvdXBTZXR1cC5oZWFkZXIgIT09IGZhbHNlICYmICFncm91cFNlcCksXG4gICAgICB2YWx1ZXMgPSAkZWxtLnZhbCgpIHx8IChtdWx0aXBsZSA/IFtdIDogWycnXSksXG4gICAgICBpbnZhbGlkID0gW107XG5cbiAgZnVuY3Rpb24gcHJlcGFyZURhdGEoZmlsdGVyKSB7XG4gICAgdmFyIGdyLFxuICAgICAgICBodG1sLFxuICAgICAgICBsYmwsXG4gICAgICAgIG9wdCxcbiAgICAgICAgdHh0LFxuICAgICAgICB2YWwsXG4gICAgICAgIGwgPSAwLFxuICAgICAgICBjID0gMCxcbiAgICAgICAgZ3JvdXBJbmRleGVzID0ge307XG4gICAgb3B0aW9ucyA9IHt9O1xuICAgIGdyb3VwcyA9IHt9O1xuICAgIG9wdGlvbkFycmF5ID0gW107XG4gICAgZ3JvdXBBcnJheSA9IFtdOyAvLyBSZXNldCBpbnZhbGlkc1xuXG4gICAgaW52YWxpZC5sZW5ndGggPSAwO1xuXG4gICAgaWYgKGhhc0RhdGEpIHtcbiAgICAgICQkMS5lYWNoKGRhdGFBcnJheSwgZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgICAgdHh0ID0gdltzLmRhdGFUZXh0XSArICcnOyAvLyBDb252ZXJ0IHRvIHN0cmluZ1xuXG4gICAgICAgIGh0bWwgPSB2W3MuZGF0YUh0bWxdO1xuICAgICAgICB2YWwgPSB2W3MuZGF0YVZhbHVlXTtcbiAgICAgICAgbGJsID0gdltzLmRhdGFHcm91cF07XG4gICAgICAgIG9wdCA9IHtcbiAgICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICAgIGh0bWw6IGh0bWwsXG4gICAgICAgICAgdGV4dDogdHh0LFxuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIGNzc0NsYXNzOiBncm91cEhkciA/ICdtYnNjLXNlbC1nci1pdG0nIDogJydcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9uc1t2YWxdID0gb3B0O1xuXG4gICAgICAgIGlmICghZmlsdGVyIHx8IG1hdGNoZXNGaWx0ZXIodHh0LCBmaWx0ZXIpKSB7XG4gICAgICAgICAgb3B0aW9uQXJyYXkucHVzaChvcHQpO1xuXG4gICAgICAgICAgaWYgKGhhc0dyb3Vwcykge1xuICAgICAgICAgICAgaWYgKGdyb3VwSW5kZXhlc1tsYmxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZ3IgPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogbGJsLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IFtdLFxuICAgICAgICAgICAgICAgIGluZGV4OiBjXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGdyb3Vwc1tjXSA9IGdyO1xuICAgICAgICAgICAgICBncm91cEluZGV4ZXNbbGJsXSA9IGM7XG4gICAgICAgICAgICAgIGdyb3VwQXJyYXkucHVzaChncik7XG4gICAgICAgICAgICAgIGMrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGdyID0gZ3JvdXBzW2dyb3VwSW5kZXhlc1tsYmxdXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGdyb3VwU2VwKSB7XG4gICAgICAgICAgICAgIG9wdC5pbmRleCA9IGdyLm9wdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcHQuZ3JvdXAgPSBncm91cEluZGV4ZXNbbGJsXTtcbiAgICAgICAgICAgIGdyLm9wdGlvbnMucHVzaChvcHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2W3MuZGF0YURpc2FibGVkXSkge1xuICAgICAgICAgICAgaW52YWxpZC5wdXNoKHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhc0dyb3Vwcykge1xuICAgICAgICB2YXIgYWRkR3JvdXAgPSB0cnVlO1xuICAgICAgICAkJDEoJ29wdGdyb3VwJywgJGVsbSkuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIGdyb3Vwc1tpXSA9IHtcbiAgICAgICAgICAgIHRleHQ6IHRoaXMubGFiZWwsXG4gICAgICAgICAgICB2YWx1ZTogaSxcbiAgICAgICAgICAgIG9wdGlvbnM6IFtdLFxuICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICB9O1xuICAgICAgICAgIGFkZEdyb3VwID0gdHJ1ZTtcbiAgICAgICAgICAkJDEoJ29wdGlvbicsIHRoaXMpLmVhY2goZnVuY3Rpb24gKGopIHtcbiAgICAgICAgICAgIG9wdCA9IHtcbiAgICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgICAgICAgICAgIHRleHQ6IHRoaXMudGV4dCxcbiAgICAgICAgICAgICAgaW5kZXg6IGdyb3VwU2VwID8gaiA6IGwrKyxcbiAgICAgICAgICAgICAgZ3JvdXA6IGksXG4gICAgICAgICAgICAgIGNzc0NsYXNzOiBncm91cEhkciA/ICdtYnNjLXNlbC1nci1pdG0nIDogJydcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvcHRpb25zW3RoaXMudmFsdWVdID0gb3B0O1xuXG4gICAgICAgICAgICBpZiAoIWZpbHRlciB8fCBtYXRjaGVzRmlsdGVyKHRoaXMudGV4dCwgZmlsdGVyKSkge1xuICAgICAgICAgICAgICBpZiAoYWRkR3JvdXApIHtcbiAgICAgICAgICAgICAgICBncm91cEFycmF5LnB1c2goZ3JvdXBzW2ldKTtcbiAgICAgICAgICAgICAgICBhZGRHcm91cCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb3B0aW9uQXJyYXkucHVzaChvcHQpO1xuICAgICAgICAgICAgICBncm91cHNbaV0ub3B0aW9ucy5wdXNoKG9wdCk7XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBpbnZhbGlkLnB1c2godGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkJDEoJ29wdGlvbicsICRlbG0pLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICBvcHQgPSB7XG4gICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgICAgICAgIHRleHQ6IHRoaXMudGV4dCxcbiAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgfTtcbiAgICAgICAgICBvcHRpb25zW3RoaXMudmFsdWVdID0gb3B0O1xuXG4gICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgbWF0Y2hlc0ZpbHRlcih0aGlzLnRleHQsIGZpbHRlcikpIHtcbiAgICAgICAgICAgIG9wdGlvbkFycmF5LnB1c2gob3B0KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgaW52YWxpZC5wdXNoKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHMuZGVmYXVsdFZhbHVlKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSBzLmRlZmF1bHRWYWx1ZTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbkFycmF5Lmxlbmd0aCkge1xuICAgICAgZGVmYXVsdFZhbHVlID0gb3B0aW9uQXJyYXlbMF0udmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgIH1cblxuICAgIGlmIChncm91cEhkcikge1xuICAgICAgb3B0aW9uQXJyYXkgPSBbXTtcbiAgICAgIGwgPSAwO1xuICAgICAgJCQxLmVhY2goZ3JvdXBzLCBmdW5jdGlvbiAoaSwgZ3IpIHtcbiAgICAgICAgaWYgKGdyLm9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gJ19fZ3JvdXAnICsgaTtcbiAgICAgICAgICBvcHQgPSB7XG4gICAgICAgICAgICB0ZXh0OiBnci50ZXh0LFxuICAgICAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgICAgIGdyb3VwOiBpLFxuICAgICAgICAgICAgaW5kZXg6IGwrKyxcbiAgICAgICAgICAgIGNzc0NsYXNzOiAnbWJzYy1zZWwtZ3InXG4gICAgICAgICAgfTtcbiAgICAgICAgICBvcHRpb25zW3ZhbF0gPSBvcHQ7XG4gICAgICAgICAgb3B0aW9uQXJyYXkucHVzaChvcHQpO1xuICAgICAgICAgIGludmFsaWQucHVzaChvcHQudmFsdWUpO1xuICAgICAgICAgICQkMS5lYWNoKGdyLm9wdGlvbnMsIGZ1bmN0aW9uIChqLCBvcHQpIHtcbiAgICAgICAgICAgIG9wdC5pbmRleCA9IGwrKztcbiAgICAgICAgICAgIG9wdGlvbkFycmF5LnB1c2gob3B0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCRmaWx0ZXJFbXB0eSkge1xuICAgICAgaWYgKG9wdGlvbkFycmF5Lmxlbmd0aCkge1xuICAgICAgICAkZmlsdGVyRW1wdHkucmVtb3ZlQ2xhc3MoJ21ic2Mtc2VsLWVtcHR5LXYnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRmaWx0ZXJFbXB0eS5hZGRDbGFzcygnbWJzYy1zZWwtZW1wdHktdicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlblZhbHVlcyhkYXRhLCB0YXBTZWxlY3QsIGxhYmVsLCBtdWx0aXBsZSwgY3NzQ2xhc3MpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgdmFsdWVzID0gW107XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzLnB1c2goe1xuICAgICAgICB2YWx1ZTogZGF0YVtpXS52YWx1ZSxcbiAgICAgICAgZGlzcGxheTogZGF0YVtpXS5odG1sIHx8IGRhdGFbaV0udGV4dCxcbiAgICAgICAgY3NzQ2xhc3M6IGRhdGFbaV0uY3NzQ2xhc3NcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjaXJjdWxhcjogZmFsc2UsXG4gICAgICBtdWx0aXBsZTogdGFwU2VsZWN0ICYmICFtdWx0aXBsZSA/IDEgOiBtdWx0aXBsZSxcbiAgICAgIGNzc0NsYXNzOiAodGFwU2VsZWN0ICYmICFtdWx0aXBsZSA/ICdtYnNjLXNlbC1vbmUnIDogJycpICsgJyAnICsgY3NzQ2xhc3MsXG4gICAgICBkYXRhOiB2YWx1ZXMsXG4gICAgICBsYWJlbDogbGFiZWxcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuR3JvdXBXaGVlbCgpIHtcbiAgICByZXR1cm4gZ2VuVmFsdWVzKGdyb3VwQXJyYXksIHRhcFNlbGVjdCwgcy5ncm91cExhYmVsLCBmYWxzZSwgJ21ic2Mtc2VsLWdyLXdobCcpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuT3B0V2hlZWwoKSB7XG4gICAgcmV0dXJuIGdlblZhbHVlcyhncm91cFNlcCAmJiBncm91cHNbZ3JvdXBdID8gZ3JvdXBzW2dyb3VwXS5vcHRpb25zIDogb3B0aW9uQXJyYXksIHRhcFNlbGVjdCwgbGFiZWwsIG11bHRpcGxlLCAnJyk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5XaGVlbHMoKSB7XG4gICAgdmFyIHcgPSBbW11dO1xuXG4gICAgaWYgKGhhc0dyb3VwV2hlZWwpIHtcbiAgICAgIGdyb3VwV2hlZWwgPSBnZW5Hcm91cFdoZWVsKCk7XG5cbiAgICAgIGlmIChpc0xpcXVpZCkge1xuICAgICAgICB3WzBdW2dyb3VwV2hlZWxJZHhdID0gZ3JvdXBXaGVlbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdbZ3JvdXBXaGVlbElkeF0gPSBbZ3JvdXBXaGVlbF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgb3B0aW9uV2hlZWwgPSBnZW5PcHRXaGVlbCgpO1xuXG4gICAgaWYgKGlzTGlxdWlkKSB7XG4gICAgICB3WzBdW29wdGlvbldoZWVsSWR4XSA9IG9wdGlvbldoZWVsO1xuICAgIH0gZWxzZSB7XG4gICAgICB3W29wdGlvbldoZWVsSWR4XSA9IFtvcHRpb25XaGVlbF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHc7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRPcHRpb24odikge1xuICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgaWYgKHYgJiYgaXNTdHJpbmcodikpIHtcbiAgICAgICAgdiA9IHYuc3BsaXQoJywnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCQkMS5pc0FycmF5KHYpKSB7XG4gICAgICAgIHYgPSB2WzBdO1xuICAgICAgfVxuICAgIH1cblxuICAgIG9wdGlvbiA9IHYgPT09IHVuZGVmaW5lZCB8fCB2ID09PSBudWxsIHx8IHYgPT09ICcnID8gZGVmYXVsdFZhbHVlIDogdjtcblxuICAgIGlmICghb3B0aW9uc1tvcHRpb25dICYmIG9wdGlvbkFycmF5ICYmIG9wdGlvbkFycmF5Lmxlbmd0aCkge1xuICAgICAgb3B0aW9uID0gb3B0aW9uQXJyYXlbMF0udmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGhhc0dyb3VwV2hlZWwpIHtcbiAgICAgIGdyb3VwID0gb3B0aW9uc1tvcHRpb25dID8gb3B0aW9uc1tvcHRpb25dLmdyb3VwIDogbnVsbDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUZXh0KG9wdCkge1xuICAgIHJldHVybiBzZWxlY3RlZFRleHRzW29wdF0gfHwgKG9wdGlvbnNbb3B0XSA/IG9wdGlvbnNbb3B0XS50ZXh0IDogJycpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VmFsdWUoZCwgaW5zdCwgZmlsbCkge1xuICAgIHZhciBpLFxuICAgICAgICBvcHQsXG4gICAgICAgIHNlbCA9IFtdLFxuICAgICAgICBzZWxlY3RlZCA9IGZpbGwgPyBpbnN0Ll9zZWxlY3RlZCA6IGluc3QuX3RlbXBTZWxlY3RlZDtcblxuICAgIGlmICh0YXBTZWxlY3QpIHtcbiAgICAgIGZvciAoaSBpbiBzZWxlY3RlZFtvcHRpb25XaGVlbElkeF0pIHtcbiAgICAgICAgc2VsLnB1c2goZ2V0VGV4dChpKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWwuam9pbignLCAnKTtcbiAgICB9XG5cbiAgICBvcHQgPSBkW29wdGlvbldoZWVsSWR4XTtcbiAgICByZXR1cm4gZ2V0VGV4dChvcHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25GaWxsKCkge1xuICAgIHZhciBpLFxuICAgICAgICBodG1sID0gJycsXG4gICAgICAgIHZhbCA9IGluc3QuZ2V0VmFsKCksXG4gICAgICAgIHR4dCA9IHMuZm9ybWF0VmFsdWUuY2FsbChlbG0sIGluc3QuZ2V0QXJyYXlWYWwoKSwgaW5zdCwgdHJ1ZSk7XG5cbiAgICBpZiAoIShzLmZpbHRlciAmJiBzLmRpc3BsYXkgPT0gJ2lubGluZScpKSB7XG4gICAgICAkaW5wdXQudmFsKHR4dCk7XG4gICAgfSAvLyBJZiB3ZSBoYXZlIGEgbmF0aXZlIHNlbGVjdCwgYnV0IGRhdGEgd2FzIHBhc3NlZCBpbiBzZXR0aW5nLFxuICAgIC8vIGNyZWF0ZSBhbiBvcHRpb24gdGFnIHdpdGggdGhlIHNlbGVjdGVkIHZhbHVlXG5cblxuICAgIGlmICgkZWxtLmlzKCdzZWxlY3QnKSAmJiBoYXNEYXRhKSB7XG4gICAgICBpZiAobXVsdGlwbGUpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGh0bWwgKz0gJzxvcHRpb24gdmFsdWU9XCInICsgdmFsW2ldICsgJ1wiPicgKyBnZXRUZXh0KHZhbFtpXSkgKyAnPC9vcHRpb24+JztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHRtbCA9ICc8b3B0aW9uIHZhbHVlPVwiJyArICh2YWwgPT09IG51bGwgPyAnJyA6IHZhbCkgKyAnXCI+JyArIHR4dCArICc8L29wdGlvbj4nO1xuICAgICAgfVxuXG4gICAgICAkZWxtLmh0bWwoaHRtbCk7XG4gICAgfVxuXG4gICAgaWYgKGVsbSAhPT0gJGlucHV0WzBdKSB7XG4gICAgICAvLyBpZiB0aGUgdGFyZ2V0IGlzIHRoZSBzYW1lLCB3ZSBzaG91bGQgbm90IG92ZXJ3cml0ZSBpdFxuICAgICAgJGVsbS52YWwodmFsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGFuZ2VXaGVlbCgpIHtcbiAgICB2YXIgd2hlZWxzID0ge307XG4gICAgd2hlZWxzW29wdGlvbldoZWVsSWR4XSA9IGdlbk9wdFdoZWVsKCk7XG4gICAgcHJldmVudCA9IHRydWU7XG4gICAgaW5zdC5jaGFuZ2VXaGVlbCh3aGVlbHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF0Y2hlc0ZpbHRlcihzdHIsIGZpbHRlcikge1xuICAgIGZpbHRlciA9IGZpbHRlci5yZXBsYWNlKC9bLS9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7IC8vIGVzY2FwZSB0aGUgc3BlY2lhbCBjaGFyYWN0ZXJzXG5cbiAgICByZXR1cm4gc3RyLm1hdGNoKG5ldyBSZWdFeHAoZmlsdGVyLCAnaWcnKSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREYXRhKGRhdGEpIHtcbiAgICByZXR1cm4gcy5kYXRhLmRhdGFGaWVsZCA/IGRhdGFbcy5kYXRhLmRhdGFGaWVsZF0gOiBzLmRhdGEucHJvY2Vzc1Jlc3BvbnNlID8gcy5kYXRhLnByb2Nlc3NSZXNwb25zZShkYXRhKSA6IGRhdGE7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlV2hlZWxzKGZpbHRlcikge1xuICAgIHZhciB3aGVlbHMgPSB7fTtcbiAgICBwcmVwYXJlRGF0YShmaWx0ZXIpO1xuICAgIGdldE9wdGlvbihvcHRpb24pO1xuICAgIHMud2hlZWxzID0gZ2VuV2hlZWxzKCk7XG4gICAgd2hlZWxzW29wdGlvbldoZWVsSWR4XSA9IG9wdGlvbldoZWVsO1xuICAgIGluc3QuX3RlbXBXaGVlbEFycmF5W29wdGlvbldoZWVsSWR4XSA9IG9wdGlvbjtcblxuICAgIGlmIChoYXNHcm91cFdoZWVsKSB7XG4gICAgICB3aGVlbHNbZ3JvdXBXaGVlbElkeF0gPSBncm91cFdoZWVsO1xuICAgICAgaW5zdC5fdGVtcFdoZWVsQXJyYXlbZ3JvdXBXaGVlbElkeF0gPSBncm91cDtcbiAgICB9XG5cbiAgICBpbnN0LmNoYW5nZVdoZWVsKHdoZWVscywgMCwgdHJ1ZSk7XG4gICAgb25GaWxsKCk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmlnZ2VyT25GaWx0ZXIodmFsdWUpIHtcbiAgICByZXR1cm4gaW5zdC50cmlnZ2VyKCdvbkZpbHRlcicsIHtcbiAgICAgIGZpbHRlclRleHQ6IHZhbHVlXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBsb2FkR3JvdXBPcHRpb25zKHZhbHVlcykge1xuICAgIGlmICh2YWx1ZXNbZ3JvdXBXaGVlbElkeF0gIT0gZ3JvdXApIHtcbiAgICAgIGdyb3VwID0gdmFsdWVzW2dyb3VwV2hlZWxJZHhdO1xuICAgICAgb3B0aW9uID0gZ3JvdXBzW2dyb3VwXS5vcHRpb25zWzBdLnZhbHVlO1xuICAgICAgdmFsdWVzW29wdGlvbldoZWVsSWR4XSA9IG9wdGlvbjtcblxuICAgICAgaWYgKGdyb3VwU2VwKSB7XG4gICAgICAgIGNoYW5nZVdoZWVsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0LnNldEFycmF5VmFsKHZhbHVlcywgZmFsc2UsIGZhbHNlLCB0cnVlLCBhbmltVGltZSk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIEV4dGVuZGVkIG1ldGhvZHNcbiAgLy8gLS0tXG5cblxuICBpbnN0LnNldFZhbCA9IGZ1bmN0aW9uICh2YWwsIGZpbGwsIGNoYW5nZSwgdGVtcCwgdGltZSkge1xuICAgIGlmICh0YXBTZWxlY3QpIHtcbiAgICAgIGlmICh2YWwgIT09IG51bGwgJiYgdmFsICE9PSB1bmRlZmluZWQgJiYgIW11bHRpcGxlKSB7XG4gICAgICAgIHZhbCA9IFt2YWxdO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFsICYmIGlzU3RyaW5nKHZhbCkpIHtcbiAgICAgICAgdmFsID0gdmFsLnNwbGl0KCcsJyk7XG4gICAgICB9XG5cbiAgICAgIGluc3QuX3RlbXBTZWxlY3RlZFtvcHRpb25XaGVlbElkeF0gPSBhcnJheVRvT2JqZWN0KHZhbCk7XG5cbiAgICAgIGlmICghdGVtcCkge1xuICAgICAgICBpbnN0Ll9zZWxlY3RlZFtvcHRpb25XaGVlbElkeF0gPSBhcnJheVRvT2JqZWN0KHZhbCk7XG4gICAgICB9XG5cbiAgICAgIHZhbCA9IHZhbCA/IHZhbFswXSA6IG51bGw7XG5cbiAgICAgIGlmIChoYXNHcm91cFdoZWVsKSB7XG4gICAgICAgIHZhciBvcHQgPSBvcHRpb25zW3ZhbF0sXG4gICAgICAgICAgICBnciA9IG9wdCAmJiBvcHQuZ3JvdXA7XG4gICAgICAgIGluc3QuX3RlbXBTZWxlY3RlZFtncm91cFdoZWVsSWR4XSA9IGFycmF5VG9PYmplY3QoW2dyXSk7XG5cbiAgICAgICAgaWYgKCF0ZW1wKSB7XG4gICAgICAgICAgaW5zdC5fc2VsZWN0ZWRbZ3JvdXBXaGVlbElkeF0gPSBhcnJheVRvT2JqZWN0KFtncl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW5zdC5fc2V0VmFsKHZhbCwgZmlsbCwgY2hhbmdlLCB0ZW1wLCB0aW1lKTtcbiAgfTtcblxuICBpbnN0LmdldFZhbCA9IGZ1bmN0aW9uICh0ZW1wLCBncm91cCkge1xuICAgIHZhciB2YWw7XG5cbiAgICBpZiAodGFwU2VsZWN0KSB7XG4gICAgICB2YWwgPSBvYmplY3RUb0FycmF5KHRlbXAgPyBpbnN0Ll90ZW1wU2VsZWN0ZWRbb3B0aW9uV2hlZWxJZHhdIDogaW5zdC5fc2VsZWN0ZWRbb3B0aW9uV2hlZWxJZHhdKTtcbiAgICAgIHZhbCA9IG11bHRpcGxlID8gdmFsIDogdmFsLmxlbmd0aCA/IHZhbFswXSA6IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IHRlbXAgPyBpbnN0Ll90ZW1wV2hlZWxBcnJheSA6IGluc3QuX2hhc1ZhbHVlID8gaW5zdC5fd2hlZWxBcnJheSA6IG51bGw7XG4gICAgICB2YWwgPSB2YWwgPyB2YWxbb3B0aW9uV2hlZWxJZHhdIDogbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbXVsdGlwbGUgPyB2YWwgOiB2YWwgIT09IHVuZGVmaW5lZCA/IGhhc0dyb3VwcyAmJiBncm91cCA/IFtvcHRpb25zW3ZhbF0gPyBvcHRpb25zW3ZhbF0uZ3JvdXAgOiBudWxsLCB2YWxdIDogdmFsIDogbnVsbDtcbiAgfTtcblxuICBpbnN0LnJlZnJlc2ggPSBmdW5jdGlvbiAoZGF0YSwgZmlsdGVyLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcblxuICAgIGlmIChkYXRhKSB7XG4gICAgICBkYXRhQXJyYXkgPSBkYXRhO1xuXG4gICAgICBpZiAoIWhhc1JlbW90ZURhdGEpIHtcbiAgICAgICAgLy8gU2F2ZSBkYXRhLCBvdGhlcndpc2UgaXQgd2lsbCBnZXQgbG9zdCBvbiBhbiBvcHRpb24gY2FsbCxcbiAgICAgICAgLy8gYW5kIGZpbHRlcmluZyBkb2VzIG5vdCB3b3JrIGFzIHdlbGwgYWZ0ZXIgYXN5bmMgZGF0YSB1cGRhdGVcbiAgICAgICAgcy5kYXRhID0gZGF0YTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCQkMS5pc0FycmF5KHMuZGF0YSkpIHtcbiAgICAgIGRhdGFBcnJheSA9IHMuZGF0YTtcbiAgICB9XG5cbiAgICBpZiAoIWRhdGEgJiYgaGFzUmVtb3RlRGF0YSAmJiBmaWx0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmVsb2FkIHRoZSBkYXRhIGZyb20gcmVtb3RlIHNvdXJjZVxuICAgICAgZ2V0SnNvbihzLmRhdGEudXJsLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBkYXRhQXJyYXkgPSBnZXREYXRhKGRhdGEpO1xuICAgICAgICBwcmVwYXJlV2hlZWxzKCk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9LCBzLmRhdGEuZGF0YVR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVwYXJlV2hlZWxzKGZpbHRlcik7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfTsgLy8gLS0tXG4gIC8vIEluaXRzXG4gIC8vIC0tLVxuXG5cbiAgaWYgKCFzZXR0aW5ncy5pbnZhbGlkKSB7XG4gICAgcy5pbnZhbGlkID0gaW52YWxpZDtcbiAgfVxuXG4gIGlmIChoYXNHcm91cFdoZWVsKSB7XG4gICAgZ3JvdXBXaGVlbElkeCA9IDA7XG4gICAgb3B0aW9uV2hlZWxJZHggPSAxO1xuICB9IGVsc2Uge1xuICAgIGdyb3VwV2hlZWxJZHggPSAtMTtcbiAgICBvcHRpb25XaGVlbElkeCA9IDA7XG4gIH1cblxuICBpZiAodGFwU2VsZWN0KSB7XG4gICAgaWYgKG11bHRpcGxlICYmICRlbG0uaXMoJ3NlbGVjdCcpKSB7XG4gICAgICAkZWxtLnByb3AoJ211bHRpcGxlJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlcyAmJiBpc1N0cmluZyh2YWx1ZXMpKSB7XG4gICAgICB2YWx1ZXMgPSB2YWx1ZXMuc3BsaXQoJywnKTtcbiAgICB9XG5cbiAgICBpbnN0Ll9zZWxlY3RlZFtvcHRpb25XaGVlbElkeF0gPSBhcnJheVRvT2JqZWN0KHZhbHVlcyk7XG4gIH0gLy8gUmVtb3ZlIGR1bW15IGVsZW1lbnQgaWYgZXhpc3RzXG5cblxuICBpZiAoaW5zdC5fJGlucHV0KSB7XG4gICAgaW5zdC5fJGlucHV0LnJlbW92ZSgpO1xuICB9IC8vIENoZWNrIGlmIG1vYmlzY3JvbGwgZm9ybSBhbHJlYWR5IGluaXRpYWxpemVkIHRoaXMgc2VsZWN0XG5cblxuICBpZiAoJGVsbS5uZXh0KCkuaXMoJy5tYnNjLXNlbGVjdC1pbnB1dCcpKSB7XG4gICAgJGlucHV0ID0gJGVsbS5uZXh0KCkucmVtb3ZlQXR0cigndGFiaW5kZXgnKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAocy5pbnB1dCkge1xuICAgICAgJGlucHV0ID0gJCQxKHMuaW5wdXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgZHVtbXkgaW5wdXRcbiAgICAgIGlmIChzLmZpbHRlciAmJiBzLmRpc3BsYXkgPT0gJ2lubGluZScpIHtcbiAgICAgICAgaW5zdC5fJGlucHV0ID0gJCQxKCc8ZGl2IGNsYXNzPVwibWJzYy1zZWwtaW5wdXQtd3JhcFwiPjxpbnB1dCB0eXBlPVwidGV4dFwiIGlkPVwiJyArIGlkICsgJ1wiIGNsYXNzPVwibWJzYy1zZWxlY3QtaW5wdXQgbWJzYy1jb250cm9sICcgKyBzLmlucHV0Q2xhc3MgKyAnXCIgcmVhZG9ubHkgLz48L2Rpdj4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRpbnB1dCA9ICQkMSgnPGlucHV0IHR5cGU9XCJ0ZXh0XCIgaWQ9XCInICsgaWQgKyAnXCIgY2xhc3M9XCJtYnNjLXNlbGVjdC1pbnB1dCBtYnNjLWNvbnRyb2wgJyArIHMuaW5wdXRDbGFzcyArICdcIiByZWFkb25seSAvPicpO1xuICAgICAgICBpbnN0Ll8kaW5wdXQgPSAkaW5wdXQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChzLnNob3dJbnB1dCkge1xuICAgICAgICBpbnN0Ll8kaW5wdXQuaW5zZXJ0QWZ0ZXIoJGVsbSk7XG5cbiAgICAgICAgaWYgKCEkaW5wdXQpIHtcbiAgICAgICAgICAkaW5wdXQgPSBpbnN0Ll8kaW5wdXQuZmluZCgnIycgKyBpZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gU2hvdyBzY3JvbGxlciBvbiBpbnB1dCB0YXBcblxuXG4gIGluc3QuYXR0YWNoU2hvdygkaW5wdXQuYXR0cigncGxhY2Vob2xkZXInLCBzLnBsYWNlaG9sZGVyIHx8ICcnKSk7XG5cbiAgaWYgKCRpbnB1dFswXSAhPT0gZWxtKSB7XG4gICAgJGVsbS5hZGRDbGFzcygnbWJzYy1zZWwtaGRuJykuYXR0cigndGFiaW5kZXgnLCAtMSk7XG5cbiAgICBpZiAoIXMuc2hvd0lucHV0KSB7XG4gICAgICAkZWxtLmF0dHIoJ2RhdGEtZW5oYW5jZScsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBpZiAodGFwU2VsZWN0ICYmICEocy5yb3dzICUgMikpIHtcbiAgICBzLnJvd3MgPSBzLnJvd3MgLSAxO1xuICB9XG5cbiAgaWYgKHMuZmlsdGVyKSB7XG4gICAgZmlsdGVyTGVuZ3RoID0gcy5maWx0ZXIubWluTGVuZ3RoIHx8IDA7XG4gIH1cblxuICBoYXNSZW1vdGVEYXRhID0gcy5kYXRhICYmIHMuZGF0YS51cmw7XG5cbiAgaWYgKGhhc1JlbW90ZURhdGEpIHtcbiAgICBpbnN0LnJlZnJlc2goKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaGFzRGF0YSkge1xuICAgICAgZGF0YUFycmF5ID0gcy5kYXRhO1xuICAgIH1cblxuICAgIHByZXBhcmVEYXRhKCk7XG4gICAgZ2V0T3B0aW9uKCRlbG0udmFsKCkpO1xuICB9IC8vIC0tLVxuXG5cbiAgcmV0dXJuIHtcbiAgICBsYXlvdXQ6IGxheW91dCxcbiAgICBoZWFkZXJUZXh0OiBmYWxzZSxcbiAgICBhbmNob3I6ICRpbnB1dCxcbiAgICBjb21wQ2xhc3M6ICdtYnNjLXNjIG1ic2Mtc2VsJyArICh0YXBTZWxlY3QgPyAnIG1ic2Mtc2VsLW11bHRpJyA6ICcnKSxcbiAgICBzZXRPblRhcDogaGFzR3JvdXBXaGVlbCA/IFtmYWxzZSwgdHJ1ZV0gOiB0cnVlLFxuICAgIGZvcm1hdFZhbHVlOiBmb3JtYXRWYWx1ZSxcbiAgICB0YXBTZWxlY3Q6IHRhcFNlbGVjdCxcbiAgICBwYXJzZVZhbHVlOiBmdW5jdGlvbiBwYXJzZVZhbHVlKHZhbCkge1xuICAgICAgZ2V0T3B0aW9uKHZhbCA9PT0gdW5kZWZpbmVkID8gJGVsbS52YWwoKSA6IHZhbCk7XG4gICAgICByZXR1cm4gaGFzR3JvdXBXaGVlbCA/IFtncm91cCwgb3B0aW9uXSA6IFtvcHRpb25dO1xuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKGRhdGEpIHtcbiAgICAgIHZhciBpbmRleCA9IGRhdGEuaW5kZXgsXG4gICAgICAgICAgZGlzYWJsZWQgPSBbXTtcbiAgICAgIGRpc2FibGVkW29wdGlvbldoZWVsSWR4XSA9IHMuaW52YWxpZDtcblxuICAgICAgaWYgKGdyb3VwU2VwICYmICFwcmV2ZW50ICYmIGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2hhbmdlV2hlZWwoKTtcbiAgICAgIH1cblxuICAgICAgcHJldmVudCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkXG4gICAgICB9O1xuICAgIH0sXG4gICAgb25SZWFkOiBvbkZpbGwsXG4gICAgb25GaWxsOiBvbkZpbGwsXG4gICAgb25NYXJrdXBSZWFkeTogZnVuY3Rpb24gb25NYXJrdXBSZWFkeShldmVudCwgaW5zdCkge1xuICAgICAgaWYgKHMuZmlsdGVyKSB7XG4gICAgICAgIHZhciAkZmlsdGVySW5wdXQsXG4gICAgICAgICAgICBkZWJvdW5jZSxcbiAgICAgICAgICAgIGZpbHRlcklucHV0LFxuICAgICAgICAgICAgJGNvbnQgPSAkJDEoJy5tYnNjLWZyLXcnLCBldmVudC50YXJnZXQpLFxuICAgICAgICAgICAgJGZpbHRlckNsZWFyID0gJCQxKCc8c3BhbiBjbGFzcz1cIm1ic2Mtc2VsLWZpbHRlci1jbGVhciBtYnNjLWljIG1ic2MtaWMtJyArIHMuZmlsdGVyQ2xlYXJJY29uICsgJ1wiPjwvc3Bhbj4nKTtcblxuICAgICAgICBpZiAocy5kaXNwbGF5ID09ICdpbmxpbmUnKSB7XG4gICAgICAgICAgJGZpbHRlcklucHV0ID0gJGlucHV0O1xuICAgICAgICAgICRpbnB1dC5wYXJlbnQoKS5maW5kKCcubWJzYy1zZWwtZmlsdGVyLWNsZWFyJykucmVtb3ZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJGNvbnQuZmluZCgnLm1ic2MtZnItYycpLmJlZm9yZSgnPGRpdiBjbGFzcz1cIm1ic2MtaW5wdXQgbWJzYy1zZWwtZmlsdGVyLWNvbnQgbWJzYy1jb250cm9sLXcgbWJzYy0nICsgcy50aGVtZSArIChzLmJhc2VUaGVtZSA/ICcgbWJzYy0nICsgcy5iYXNlVGhlbWUgOiAnJykgKyAnXCI+PHNwYW4gY2xhc3M9XCJtYnNjLWlucHV0LXdyYXBcIj48aW5wdXQgdGFiaW5kZXg9XCIwXCIgdHlwZT1cInRleHRcIiBjbGFzcz1cIm1ic2Mtc2VsLWZpbHRlci1pbnB1dCBtYnNjLWNvbnRyb2xcIi8+PC9zcGFuPjwvZGl2PicpO1xuICAgICAgICAgICRmaWx0ZXJJbnB1dCA9ICRjb250LmZpbmQoJy5tYnNjLXNlbC1maWx0ZXItaW5wdXQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbHRlclRleHQgPSBudWxsO1xuICAgICAgICBmaWx0ZXJJbnB1dCA9ICRmaWx0ZXJJbnB1dFswXTtcbiAgICAgICAgJGZpbHRlcklucHV0LnByb3AoJ3JlYWRvbmx5JywgZmFsc2UpLmF0dHIoJ3BsYWNlaG9sZGVyJywgcy5maWx0ZXJQbGFjZWhvbGRlclRleHQpLnBhcmVudCgpLmFwcGVuZCgkZmlsdGVyQ2xlYXIpO1xuICAgICAgICAkY29udC5maW5kKCcubWJzYy1mci1jJykucHJlcGVuZCgkZmlsdGVyRW1wdHkpOyAvLyBXaWxsIGZvY3VzIGluIHRoZSBpbnB1dCBvbiBzaG93XG5cbiAgICAgICAgaW5zdC5fYWN0aXZlRWxtID0gZmlsdGVySW5wdXQ7XG4gICAgICAgIGluc3QudGFwKCRmaWx0ZXJDbGVhciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGZpbHRlclRleHQgPSBudWxsO1xuICAgICAgICAgIGZpbHRlcklucHV0LnZhbHVlID0gJyc7XG4gICAgICAgICAgaW5zdC5yZWZyZXNoKCk7XG4gICAgICAgICAgJGZpbHRlckNsZWFyLnJlbW92ZUNsYXNzKCdtYnNjLXNlbC1maWx0ZXItc2hvdy1jbGVhcicpO1xuICAgICAgICAgIHRyaWdnZXJPbkZpbHRlcignJyk7XG4gICAgICAgIH0pO1xuICAgICAgICAkZmlsdGVySW5wdXQub24oJ2tleWRvd24nLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAvLyBFbnRlciBhbmQgRXNjXG4gICAgICAgICAgaWYgKGV2LmtleUNvZGUgPT0gMTMgfHwgZXYua2V5Q29kZSA9PSAyNykge1xuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBmaWx0ZXJJbnB1dC5ibHVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KS5vbignaW5wdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGRlYm91bmNlKTtcblxuICAgICAgICAgIGlmIChmaWx0ZXJJbnB1dC52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICRmaWx0ZXJDbGVhci5hZGRDbGFzcygnbWJzYy1zZWwtZmlsdGVyLXNob3ctY2xlYXInKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJGZpbHRlckNsZWFyLnJlbW92ZUNsYXNzKCdtYnNjLXNlbC1maWx0ZXItc2hvdy1jbGVhcicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlYm91bmNlID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyVGV4dCA9PT0gZmlsdGVySW5wdXQudmFsdWUgfHwgdHJpZ2dlck9uRmlsdGVyKGZpbHRlcklucHV0LnZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaWx0ZXJUZXh0ID0gZmlsdGVySW5wdXQudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChmaWx0ZXJUZXh0Lmxlbmd0aCA+PSBmaWx0ZXJMZW5ndGggfHwgIWZpbHRlclRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGlmIChoYXNSZW1vdGVEYXRhICYmIHMuZGF0YS5yZW1vdGVGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICBnZXRKc29uKHMuZGF0YS51cmwgKyBlbmNvZGVVUklDb21wb25lbnQoZmlsdGVyVGV4dCksIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICBpbnN0LnJlZnJlc2goZ2V0RGF0YShkYXRhKSk7XG4gICAgICAgICAgICAgICAgfSwgcy5kYXRhLmRhdGFUeXBlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnN0LnJlZnJlc2godW5kZWZpbmVkLCBmaWx0ZXJUZXh0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDUwMCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25CZWZvcmVTaG93OiBmdW5jdGlvbiBvbkJlZm9yZVNob3coKSB7XG4gICAgICBpZiAobXVsdGlwbGUgJiYgcy5jb3VudGVyKSB7XG4gICAgICAgIHMuaGVhZGVyVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgICAgICAkJDEuZWFjaChpbnN0Ll90ZW1wU2VsZWN0ZWRbb3B0aW9uV2hlZWxJZHhdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsZW5ndGgrKztcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gKGxlbmd0aCA+IDEgPyBzLnNlbGVjdGVkUGx1cmFsVGV4dCB8fCBzLnNlbGVjdGVkVGV4dCA6IHMuc2VsZWN0ZWRUZXh0KS5yZXBsYWNlKC97Y291bnR9LywgbGVuZ3RoKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZ2V0T3B0aW9uKCRlbG0udmFsKCkpO1xuXG4gICAgICBpZiAodGFwU2VsZWN0ICYmIGhhc0dyb3VwV2hlZWwpIHtcbiAgICAgICAgaW5zdC5fc2VsZWN0ZWRbZ3JvdXBXaGVlbElkeF0gPSBhcnJheVRvT2JqZWN0KFtncm91cF0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocy5maWx0ZXIpIHtcbiAgICAgICAgcHJlcGFyZURhdGEodW5kZWZpbmVkKTtcbiAgICAgIH1cblxuICAgICAgaW5zdC5zZXR0aW5ncy53aGVlbHMgPSBnZW5XaGVlbHMoKTtcbiAgICAgIHByZXZlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgb25XaGVlbEdlc3R1cmVTdGFydDogZnVuY3Rpb24gb25XaGVlbEdlc3R1cmVTdGFydChldikge1xuICAgICAgaWYgKGV2LmluZGV4ID09IGdyb3VwV2hlZWxJZHgpIHtcbiAgICAgICAgcy5yZWFkb25seSA9IFtmYWxzZSwgdHJ1ZV07XG4gICAgICB9XG4gICAgfSxcbiAgICBvbldoZWVsQW5pbWF0aW9uRW5kOiBmdW5jdGlvbiBvbldoZWVsQW5pbWF0aW9uRW5kKGV2KSB7XG4gICAgICB2YXIgdmFsdWVzID0gaW5zdC5nZXRBcnJheVZhbCh0cnVlKTtcblxuICAgICAgaWYgKGV2LmluZGV4ID09IGdyb3VwV2hlZWxJZHgpIHtcbiAgICAgICAgcy5yZWFkb25seSA9IG9yaWdSZWFkT25seTtcblxuICAgICAgICBpZiAoIXRhcFNlbGVjdCkge1xuICAgICAgICAgIGxvYWRHcm91cE9wdGlvbnModmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChldi5pbmRleCA9PSBvcHRpb25XaGVlbElkeCAmJiB2YWx1ZXNbb3B0aW9uV2hlZWxJZHhdICE9IG9wdGlvbikge1xuICAgICAgICBvcHRpb24gPSB2YWx1ZXNbb3B0aW9uV2hlZWxJZHhdO1xuXG4gICAgICAgIGlmIChoYXNHcm91cFdoZWVsICYmIG9wdGlvbnNbb3B0aW9uXSAmJiBvcHRpb25zW29wdGlvbl0uZ3JvdXAgIT0gZ3JvdXApIHtcbiAgICAgICAgICBncm91cCA9IG9wdGlvbnNbb3B0aW9uXS5ncm91cDtcbiAgICAgICAgICB2YWx1ZXNbZ3JvdXBXaGVlbElkeF0gPSBncm91cDtcbiAgICAgICAgICBpbnN0Ll90ZW1wU2VsZWN0ZWRbZ3JvdXBXaGVlbElkeF0gPSBhcnJheVRvT2JqZWN0KFtncm91cF0pO1xuICAgICAgICAgIGluc3Quc2V0QXJyYXlWYWwodmFsdWVzLCBmYWxzZSwgZmFsc2UsIHRydWUsIGFuaW1UaW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgb25JdGVtVGFwOiBmdW5jdGlvbiBvbkl0ZW1UYXAoZXYpIHtcbiAgICAgIHZhciB2YWx1ZXM7XG5cbiAgICAgIGlmIChldi5pbmRleCA9PSBvcHRpb25XaGVlbElkeCkge1xuICAgICAgICBzZWxlY3RlZFRleHRzW2V2LnZhbHVlXSA9IG9wdGlvbnNbZXYudmFsdWVdLnRleHQ7XG5cbiAgICAgICAgaWYgKHRhcFNlbGVjdCAmJiAhbXVsdGlwbGUgJiYgZXYuc2VsZWN0ZWQpIHtcbiAgICAgICAgICBpbnN0Ll9wcmV2SXRlbVRhcCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChldi5pbmRleCA9PSBncm91cFdoZWVsSWR4ICYmIHRhcFNlbGVjdCkge1xuICAgICAgICBpZiAoZXYuc2VsZWN0ZWQpIHtcbiAgICAgICAgICBpbnN0Ll9wcmV2SXRlbVRhcCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWVzID0gaW5zdC5nZXRBcnJheVZhbCh0cnVlKTtcbiAgICAgICAgdmFsdWVzW2dyb3VwV2hlZWxJZHhdID0gZXYudmFsdWU7XG4gICAgICAgIGxvYWRHcm91cE9wdGlvbnModmFsdWVzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uQ2xvc2U6IGZ1bmN0aW9uIG9uQ2xvc2UoKSB7XG4gICAgICBpZiAoaGFzUmVtb3RlRGF0YSAmJiBzLmRhdGEucmVtb3RlRmlsdGVyICYmIGZpbHRlclRleHQpIHtcbiAgICAgICAgaW5zdC5yZWZyZXNoKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkRlc3Ryb3k6IGZ1bmN0aW9uIG9uRGVzdHJveSgpIHtcbiAgICAgIC8vIFJlbW92ZSBkdW1teSBpbnB1dFxuICAgICAgaWYgKGluc3QuXyRpbnB1dCkge1xuICAgICAgICBpbnN0Ll8kaW5wdXQucmVtb3ZlKCk7XG4gICAgICB9IC8vIFJldmVydCBzZWxlY3QgYXR0cmlidXRlcyBhbmQgY2xhc3Nlc1xuXG5cbiAgICAgICRlbG0ucmVtb3ZlQ2xhc3MoJ21ic2Mtc2VsLWhkbicpLnJlbW92ZUF0dHIoJ3RhYmluZGV4Jyk7XG4gICAgfVxuICB9O1xufTtcblxudmFyIE1ic2NTZWxlY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NTZWxlY3QsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjU2VsZWN0KGluaXRpYWxFbGVtZW50LCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIHZpZXcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbWVudCwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCB2aWV3KSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLm9wdGlvblNlcnZpY2UgPSBvcHRpb25TZXJ2aWNlO1xyXG4gICAgICAgIF90aGlzLnBsYWNlaG9sZGVyID0gJyc7XHJcbiAgICAgICAgX3RoaXMub25GaWx0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIF90aGlzLm9uQ2hhbmdlRW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWJzY1NlbGVjdC5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRyb2wpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTWJzY1NlbGVjdC5wcm90b3R5cGUucmVmcmVzaERhdGEgPSBmdW5jdGlvbiAobmV3RGF0YSkge1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2UucmVmcmVzaChuZXdEYXRhKTtcclxuICAgIH07XHJcbiAgICBNYnNjU2VsZWN0LnByb3RvdHlwZS5pbml0Q29udHJvbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XHJcbiAgICAgICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ3N0cmluZycgJiYgdGFyZ2V0Ll9lbGVtZW50UmVmICYmIHRhcmdldC5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcclxuICAgICAgICAgICAgICAgIHZhciBpbnB1dFVuZGVyID0gJCQxKCdpbnB1dCcsIHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRVbmRlci5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBpbnB1dFVuZGVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgY29udGVudElucHV0ID0gJCQxKCdpbnB1dCcsIHRoaXMuaW5pdGlhbEVsZW0ubmF0aXZlRWxlbWVudCkubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAoY29udGVudElucHV0KSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0aGlzLmVsZW1lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0YXJnZXQgJiYgdGhpcy5pbml0aWFsRWxlbS5uYXRpdmVFbGVtZW50Lm5vZGVOYW1lID09PSAnSU9OLUlOUFVUJykge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5pbml0aWFsRWxlbS5uYXRpdmVFbGVtZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvcHRpb25zID0gZXh0ZW5kJDEoeyBwcmVzZXQ6ICdzZWxlY3QnLCBpbnB1dDogdGFyZ2V0IH0sIHRoaXMub3B0aW9uU2VydmljZSA/IHRoaXMub3B0aW9uU2VydmljZS5vcHRpb25zIDoge30sIHRoaXMub3B0aW9ucywgdGhpcy5pbmxpbmVPcHRpb25zT2JqLCB0aGlzLm9wdGlvbkV4dGVuc2lvbnMpO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgU2VsZWN0JDEodGhpcy5lbGVtZW50LCBvcHRpb25zKTtcclxuICAgICAgICBpZiAodGhpcy5pbml0aWFsVmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNldFZhbCh0aGlzLmluaXRpYWxWYWx1ZSwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNYnNjU2VsZWN0LnByb3RvdHlwZS5zZXRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZWxlbWVudCA9IHRoaXMuaW5pdGlhbEVsZW0ubmF0aXZlRWxlbWVudDtcclxuICAgICAgICB2YXIgY29udGVudFNlbGVjdCA9ICQkMSgnc2VsZWN0JywgdGhpcy5pbml0aWFsRWxlbS5uYXRpdmVFbGVtZW50KTtcclxuICAgICAgICBpZiAoY29udGVudFNlbGVjdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50ID0gY29udGVudFNlbGVjdFswXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuc2V0RWxlbWVudC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNYnNjU2VsZWN0LnByb3RvdHlwZS5uZ09uSW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmlzTXVsdGkgPSB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnNlbGVjdCAmJiB0aGlzLm9wdGlvbnMuc2VsZWN0ICE9PSAnc2luZ2xlJztcclxuICAgICAgICB0aGlzLmNsb25lRGljdGlvbmFyeS5kYXRhID0gW107XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ09uSW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIE1ic2NTZWxlY3QucHJvdG90eXBlLnNldE5ld1ZhbHVlID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB2YXIgY2hhbmdlZCA9IHZvaWQgMDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNNdWx0aSkge1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlZCA9ICFkZWVwRXF1YWxzQXJyYXkodiwgdGhpcy5pbnN0YW5jZS5nZXRWYWwoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5uZXJWYWx1ZSA9IHRoaXMuaW5zdGFuY2UuZ2V0VmFsKCk7XHJcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gaW5uZXJWYWx1ZSAhPT0gdjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodiwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lucHV0U2VydmljZSAmJiB0aGlzLl9pbnB1dFNlcnZpY2UuaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dFNlcnZpY2UuaW5wdXQuaW5uZXJWYWx1ZSA9IHRoaXMuaW5zdGFuY2UuX3ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NTZWxlY3QucHJvdG90eXBlLCBcImNvdW50ZXJcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ21ic2MtZGF0YScpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjU2VsZWN0LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NTZWxlY3QucHJvdG90eXBlLCBcImRhdGFUZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NTZWxlY3QucHJvdG90eXBlLCBcImRhdGFHcm91cFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjU2VsZWN0LnByb3RvdHlwZSwgXCJkYXRhVmFsdWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NTZWxlY3QucHJvdG90eXBlLCBcImZpbHRlclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjU2VsZWN0LnByb3RvdHlwZSwgXCJmaWx0ZXJQbGFjZWhvbGRlclRleHRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1NlbGVjdC5wcm90b3R5cGUsIFwiZmlsdGVyRW1wdHlUZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NTZWxlY3QucHJvdG90eXBlLCBcImdyb3VwXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NTZWxlY3QucHJvdG90eXBlLCBcImdyb3VwTGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1NlbGVjdC5wcm90b3R5cGUsIFwiaW5wdXRDbGFzc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIE1ic2NTZWxlY3QucHJvdG90eXBlLCBcImludmFsaWRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1NlbGVjdC5wcm90b3R5cGUsIFwibGFiZWxcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1NlbGVjdC5wcm90b3R5cGUsIFwicGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY1NlbGVjdC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjU2VsZWN0LnByb3RvdHlwZSwgXCJzaG93SW5wdXRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjU2VsZWN0LnByb3RvdHlwZSwgXCJvbkZpbHRlclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnbWJzYy1vcHRpb25zJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NTZWxlY3QucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ21ic2MtdGFyZ2V0JyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NTZWxlY3QucHJvdG90eXBlLCBcInRhcmdldFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnbWJzYy1zZWxlY3QnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXHJcbiAgICBdLCBNYnNjU2VsZWN0LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCBudWxsKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgnbWJzYy1zZWxlY3RDaGFuZ2UnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY1NlbGVjdC5wcm90b3R5cGUsIFwib25DaGFuZ2VFbWl0dGVyXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjU2VsZWN0ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgRGlyZWN0aXZlKHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWJzYy1zZWxlY3RdJyxcclxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJ1xyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMiwgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19wYXJhbSgzLCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX3BhcmFtKDQsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLFxyXG4gICAgICAgICAgICBOZ0NvbnRyb2wsXHJcbiAgICAgICAgICAgIE1ic2NJbnB1dFNlcnZpY2UsXHJcbiAgICAgICAgICAgIE1ic2NPcHRpb25zU2VydmljZSxcclxuICAgICAgICAgICAgVmlld0NvbnRhaW5lclJlZl0pXHJcbiAgICBdLCBNYnNjU2VsZWN0KTtcclxuICAgIHJldHVybiBNYnNjU2VsZWN0O1xyXG59KE1ic2NTY3JvbGxlckJhc2UpKTtcclxudmFyIE1ic2NTZWxlY3RDb21wb25lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NTZWxlY3RDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjU2VsZWN0Q29tcG9uZW50KGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCBudWxsKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmVycm9yTWVzc2FnZSA9ICcnO1xyXG4gICAgICAgIF90aGlzLmRyb3Bkb3duID0gdHJ1ZTtcclxuICAgICAgICBfdGhpcy5wbGFjZWhvbGRlciA9ICcnO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE1ic2NTZWxlY3RDb21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2V0VGhlbWVDbGFzc2VzKCk7XHJcbiAgICB9O1xyXG4gICAgTWJzY1NlbGVjdENvbXBvbmVudC5wcm90b3R5cGUubmdPbkluaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ09uSW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIGlmICh0aGlzLmlubGluZSkge1xyXG4gICAgICAgICAgICB2YXIgc2hvd0lucHV0ID0gdGhpcy5zaG93SW5wdXQgfHwgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuc2hvd0lucHV0KTtcclxuICAgICAgICAgICAgdmFyIGZpbHRlciA9IHRoaXMuZmlsdGVyIHx8ICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmZpbHRlcik7XHJcbiAgICAgICAgICAgIGlmIChzaG93SW5wdXQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbmxpbmVPcHRpb25zT2JqLnNob3dJbnB1dCA9IHRoaXMuc2hvd0lucHV0ID0gISFmaWx0ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnaWNvbicpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjU2VsZWN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJpbnB1dEljb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ2ljb24tYWxpZ24nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1NlbGVjdENvbXBvbmVudC5wcm90b3R5cGUsIFwiaWNvbkFsaWduXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NTZWxlY3RDb21wb25lbnQucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NTZWxlY3RDb21wb25lbnQucHJvdG90eXBlLCBcImVycm9yXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NTZWxlY3RDb21wb25lbnQucHJvdG90eXBlLCBcImVycm9yTWVzc2FnZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjU2VsZWN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJvcHRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NTZWxlY3RDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NTZWxlY3RDb21wb25lbnQucHJvdG90eXBlLCBcImRyb3Bkb3duXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NTZWxlY3RDb21wb25lbnQucHJvdG90eXBlLCBcInBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjU2VsZWN0Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLXNlbGVjdCcsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBJTlBVVF9URU1QTEFURVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMiwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksIF9fcGFyYW0oNCwgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBOZ1pvbmUsIE5nQ29udHJvbCwgTWJzY0lucHV0U2VydmljZSwgTWJzY09wdGlvbnNTZXJ2aWNlXSlcclxuICAgIF0sIE1ic2NTZWxlY3RDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIE1ic2NTZWxlY3RDb21wb25lbnQ7XHJcbn0oTWJzY1NlbGVjdCkpO1xyXG52YXIgTWJzY1NlbGVjdE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNYnNjU2VsZWN0TW9kdWxlKCkge1xyXG4gICAgfVxyXG4gICAgTWJzY1NlbGVjdE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE5nTW9kdWxlKHtcclxuICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgTWJzY1Njcm9sbGVyQmFzZU1vZHVsZSwgTWJzY0lucHV0TW9kdWxlXSxcclxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWJzY1NlbGVjdCwgTWJzY1NlbGVjdENvbXBvbmVudF0sXHJcbiAgICAgICAgICAgIGV4cG9ydHM6IFtNYnNjU2VsZWN0LCBNYnNjU2VsZWN0Q29tcG9uZW50XVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBNYnNjU2VsZWN0TW9kdWxlKTtcclxuICAgIHJldHVybiBNYnNjU2VsZWN0TW9kdWxlO1xyXG59KCkpO1xuXG52YXIgVGltZXIgPSBTY3JvbGxlcjtcbnZhciBkZWZhdWx0cyRlID0ge1xuICBhdXRvc3RhcnQ6IGZhbHNlLFxuICBzdGVwOiAxLFxuICAvLyBpbiBzZWNvbmRzXG4gIHVzZVNob3J0TGFiZWxzOiBmYWxzZSxcbiAgLy8gTG9jYWxpemF0aW9uXG4gIGxhYmVsczogWydZZWFycycsICdNb250aHMnLCAnRGF5cycsICdIb3VycycsICdNaW51dGVzJywgJ1NlY29uZHMnLCAnJ10sXG4gIGxhYmVsc1Nob3J0OiBbJ1lycycsICdNdGhzJywgJ0RheXMnLCAnSHJzJywgJ01pbnMnLCAnU2VjcycsICcnXSxcbiAgc3RhcnRUZXh0OiAnU3RhcnQnLFxuICBzdG9wVGV4dDogJ1N0b3AnLFxuICByZXNldFRleHQ6ICdSZXNldCcsXG4gIGxhcFRleHQ6ICdMYXAnLFxuICBoaWRlVGV4dDogJ0hpZGUnLFxuICBtb2RlOiAnY291bnRkb3duJ1xufTtcblxucHJlc2V0cy50aW1lciA9IGZ1bmN0aW9uIChpbnN0KSB7XG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIGEgZGF0ZSB0byBVVENcclxuICAgKiBAcGFyYW0gICBkICAgKERhdGUpICBEYXRlIHRvIGNvbnZlcnRcclxuICAgKiBAcmV0dXJuICAgICAgKERhdGUpICBEYXRlIGNvbnZlcnRlZCB0byBVVENcclxuICAgKi9cbiAgZnVuY3Rpb24gdG9VdGMoZCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShkLmdldFVUQ0Z1bGxZZWFyKCksIGQuZ2V0VVRDTW9udGgoKSwgZC5nZXRVVENEYXRlKCksIGQuZ2V0VVRDSG91cnMoKSwgZC5nZXRVVENNaW51dGVzKCksIGQuZ2V0VVRDU2Vjb25kcygpLCBkLmdldFVUQ01pbGxpc2Vjb25kcygpKTtcbiAgfVxuICAvKipcclxuICAgKiBDYWxjdWxhdGVzIHRoZSBwYXJ0cyBvZiB0aGUgdGltZSBkaWZmZXJuY2VcclxuICAgKiBAcGFyYW0gICB0aW1lICAgIChJbnRlZ2VyKSAgIFRpbWUgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICogQHJldHVybiAgICAgICAgICAoT2JqZWN0KSAgICBUaW1lIHNwbGl0dGVkIHRvIHRoZSByZXF1aXJlZCBwYXJ0cyAoeWVhcnMsIG1vbnRocywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRQYXJ0cyh0aW1lKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuXG4gICAgaWYgKGRhdGVNb2RlICYmIG9ialttYXhdLmluZGV4ID4gb2JqLmRheXMuaW5kZXgpIHtcbiAgICAgIHZhciBpLFxuICAgICAgICAgIHYsXG4gICAgICAgICAgbyxcbiAgICAgICAgICBwcmV2LFxuICAgICAgICAgIG5vdyA9IG5ldyBEYXRlKCksXG4gICAgICAgICAgZDIgPSB1cCA/IG5vdyA6IG9yaWdUaW1lLFxuICAgICAgICAgIGQxID0gdXAgPyBvcmlnVGltZSA6IG5vdztcbiAgICAgIGQxID0gdG9VdGMoZDEpO1xuICAgICAgZDIgPSB0b1V0YyhkMik7XG4gICAgICByZXQueWVhcnMgPSBkMi5nZXRGdWxsWWVhcigpIC0gZDEuZ2V0RnVsbFllYXIoKTtcbiAgICAgIHJldC5tb250aHMgPSBkMi5nZXRNb250aCgpIC0gZDEuZ2V0TW9udGgoKTtcbiAgICAgIHJldC5kYXlzID0gZDIuZ2V0RGF0ZSgpIC0gZDEuZ2V0RGF0ZSgpO1xuICAgICAgcmV0LmhvdXJzID0gZDIuZ2V0SG91cnMoKSAtIGQxLmdldEhvdXJzKCk7XG4gICAgICByZXQubWludXRlcyA9IGQyLmdldE1pbnV0ZXMoKSAtIGQxLmdldE1pbnV0ZXMoKTtcbiAgICAgIHJldC5zZWNvbmRzID0gZDIuZ2V0U2Vjb25kcygpIC0gZDEuZ2V0U2Vjb25kcygpO1xuICAgICAgcmV0LmZyYWN0ID0gKGQyLmdldE1pbGxpc2Vjb25kcygpIC0gZDEuZ2V0TWlsbGlzZWNvbmRzKCkpIC8gMTA7XG5cbiAgICAgIGZvciAoaSA9IHVuaXF1ZS5sZW5ndGg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgdiA9IHVuaXF1ZVtpIC0gMV07XG4gICAgICAgIG8gPSBvYmpbdl07XG4gICAgICAgIHByZXYgPSB1bmlxdWVbJCQxLmluQXJyYXkodiwgdW5pcXVlKSAtIDFdO1xuXG4gICAgICAgIGlmIChvYmpbcHJldl0gJiYgcmV0W3ZdIDwgMCkge1xuICAgICAgICAgIHJldFtwcmV2XS0tO1xuICAgICAgICAgIHJldFt2XSArPSBwcmV2ID09ICdtb250aHMnID8gMzIgLSBuZXcgRGF0ZShkMi5nZXRGdWxsWWVhcigpLCBkMi5nZXRNb250aCgpLCAzMikuZ2V0RGF0ZSgpIDogby51bnRpbCArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1heCA9PSAnbW9udGhzJykge1xuICAgICAgICByZXQubW9udGhzICs9IHJldC55ZWFycyAqIDEyO1xuICAgICAgICBkZWxldGUgcmV0LnllYXJzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAkJDEodW5pcXVlKS5lYWNoKGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICAgIGlmIChvYmpbdl0uaW5kZXggPD0gb2JqW21heF0uaW5kZXgpIHtcbiAgICAgICAgICByZXRbdl0gPSBNYXRoLmZsb29yKHRpbWUgLyBvYmpbdl0ubGltaXQpO1xuICAgICAgICAgIHRpbWUgLT0gcmV0W3ZdICogb2JqW3ZdLmxpbWl0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlcyBhIHNwZWNpZmljIHdoZWVsXHJcbiAgICogQHBhcmFtICAgdiAgIChTdHJpbmcpICBVbmlxdWUgaWRlbnRpZmllclxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2VuV2hlZWwodikge1xuICAgIHZhciBzdCA9IDEsXG4gICAgICAgIG8gPSBvYmpbdl0sXG4gICAgICAgIHdoID0gby53aGVlbCxcbiAgICAgICAgcHJlZml4ID0gby5wcmVmaXgsXG4gICAgICAgIGZyb20gPSAwLFxuICAgICAgICB1bnRpbCA9IG8udW50aWwsXG4gICAgICAgIG5leHQgPSBvYmpbdW5pcXVlWyQkMS5pbkFycmF5KHYsIHVuaXF1ZSkgLSAxXV07XG5cbiAgICBpZiAoby5pbmRleCA8PSBvYmpbbWF4XS5pbmRleCAmJiAoIW5leHQgfHwgbmV4dC5saW1pdCA+IHN0ZXApKSB7XG4gICAgICBpZiAoIXdoZWVsc1t2XSkge1xuICAgICAgICB3WzBdLnB1c2god2gpO1xuICAgICAgfVxuXG4gICAgICB3aGVlbHNbdl0gPSAxO1xuICAgICAgd2guZGF0YSA9IFtdO1xuICAgICAgd2gubGFiZWwgPSBvLmxhYmVsIHx8ICcnO1xuICAgICAgd2guY3NzQ2xhc3MgPSAnbWJzYy10aW1lci13aGwtJyArIHY7XG5cbiAgICAgIGlmIChzdGVwID49IG8ubGltaXQpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHN0ZXBzIG9uIGxhc3Qgd2hlZWxcbiAgICAgICAgc3QgPSBNYXRoLm1heChNYXRoLnJvdW5kKHN0ZXAgLyBvLmxpbWl0KSwgMSk7XG4gICAgICAgIHRzdGVwID0gc3QgKiBvLmxpbWl0OyAvLyBUaW1lciBpcyBjYWxjdWxhdGVkIHdpdGggcm91bmRlZCBzdGVwXG4gICAgICB9XG5cbiAgICAgIGlmICh2ID09IG1heCkge1xuICAgICAgICB3aC5taW4gPSAwO1xuXG4gICAgICAgIHdoLmRhdGEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogaSxcbiAgICAgICAgICAgIGRpc3BsYXk6IGdlblZhbHVlKGksIHByZWZpeCwgby5sYWJlbClcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHdoLmdldEluZGV4ID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IGZyb207IGkgPD0gdW50aWw7IGkgKz0gc3QpIHtcbiAgICAgICAgICB3aC5kYXRhLnB1c2goe1xuICAgICAgICAgICAgdmFsdWU6IGksXG4gICAgICAgICAgICBkaXNwbGF5OiBnZW5WYWx1ZShpLCBwcmVmaXgsIG8ubGFiZWwpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5WYWx1ZShpLCBwcmVmaXgsIGxibCkge1xuICAgIHJldHVybiAocHJlZml4IHx8ICcnKSArIChpIDwgMTAgPyAnMCcgOiAnJykgKyBpICsgJzxzcGFuIGNsYXNzPVwibWJzYy10aW1lci1sYmxcIj4nICsgbGJsICsgJzwvc3Bhbj4nO1xuICB9XG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIHRoZSB0aW1lIGludG8gYXJyYXkgY29udGFpbmluZyB0aGUgcGFydHNcclxuICAgKiBAcGFyYW0gICB0aW1lICAgIChJbnRlZ2VyKSAgIFRpbWUgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICogQHJldHVybiAgICAgICAgICAoQXJyYXkpICAgICBUaW1lIHNwbGl0dGVkIHRvIHRoZSByZXF1aXJlZCBwYXJ0cyAoeWVhcnMsIG1vbnRocywgZGF5cywgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMpXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRBcnJheSh0aW1lKSB7XG4gICAgdmFyIGFyciA9IFtdLFxuICAgICAgICBzdCxcbiAgICAgICAgcCA9IGdldFBhcnRzKHRpbWUpO1xuICAgICQkMSh1bmlxdWUpLmVhY2goZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgIGlmICh3aGVlbHNbdl0pIHtcbiAgICAgICAgc3QgPSBNYXRoLm1heChNYXRoLnJvdW5kKHN0ZXAgLyBvYmpbdl0ubGltaXQpLCAxKTtcbiAgICAgICAgYXJyLnB1c2goTWF0aC5yb3VuZChwW3ZdIC8gc3QpICogc3QpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhcnI7XG4gIH1cbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlcyB0aGUgdGltZVxyXG4gICAqIEBwYXJhbSAgIHJlc2V0ICAgKEJvb2xlYW4pICAgUmVzZXQgdGhlIHRpbWVyIG9yIG5vdFxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gY2FsY1RpbWUocmVzZXQpIHtcbiAgICBpZiAoZGF0ZU1vZGUpIHtcbiAgICAgIHRpbWUgPSBvcmlnVGltZSAtIG5ldyBEYXRlKCk7XG5cbiAgICAgIGlmICh0aW1lIDwgMCkge1xuICAgICAgICB0aW1lICo9IC0xO1xuICAgICAgICB1cCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aW1lciA9IDA7XG4gICAgICBpbmZpbml0ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKG9yaWdUaW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGluZmluaXQgPSBmYWxzZTtcbiAgICAgIHRpbWUgPSBvcmlnVGltZSAqIDEwMDA7XG4gICAgICB1cCA9IHMubW9kZSAhPSAnY291bnRkb3duJztcblxuICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgIHRpbWVyID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGltZSA9IDA7XG4gICAgICB1cCA9IHMubW9kZSAhPSAnY291bnRkb3duJztcbiAgICAgIGluZmluaXQgPSB1cDtcblxuICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgIHRpbWVyID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVVSSgpIHtcbiAgICBpZiAocnVubmluZykge1xuICAgICAgJCQxKCcubWJzYy1mci13JywgY3R4KS5hZGRDbGFzcygnbWJzYy10aW1lci1ydW5uaW5nIG1ic2MtdGltZXItbG9ja2VkJyk7XG4gICAgICAkJDEoJy5tYnNjLXRpbWVyLWJ0bi10b2dnbGUtYyA+IGRpdicsIGN0eCkudGV4dChzLnN0b3BUZXh0KTtcblxuICAgICAgaWYgKGluc3QuYnV0dG9ucy5zdGFydC5pY29uKSB7XG4gICAgICAgICQkMSgnLm1ic2MtdGltZXItYnRuLXRvZ2dsZS1jID4gZGl2JywgY3R4KS5yZW1vdmVDbGFzcygnbWJzYy1pYy0nICsgaW5zdC5idXR0b25zLnN0YXJ0Lmljb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5zdC5idXR0b25zLnN0b3AuaWNvbikge1xuICAgICAgICAkJDEoJy5tYnNjLXRpbWVyLWJ0bi10b2dnbGUtYyA+IGRpdicsIGN0eCkuYWRkQ2xhc3MoJ21ic2MtaWMtJyArIGluc3QuYnV0dG9ucy5zdG9wLmljb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAocy5tb2RlID09ICdzdG9wd2F0Y2gnKSB7XG4gICAgICAgICQkMSgnLm1ic2MtdGltZXItYnRuLXJlc2V0bGFwLWMgPiBkaXYnLCBjdHgpLnRleHQocy5sYXBUZXh0KTtcblxuICAgICAgICBpZiAoaW5zdC5idXR0b25zLnJlc2V0Lmljb24pIHtcbiAgICAgICAgICAkJDEoJy5tYnNjLXRpbWVyLWJ0bi1yZXNldGxhcC1jID4gZGl2JywgY3R4KS5yZW1vdmVDbGFzcygnbWJzYy1pYy0nICsgaW5zdC5idXR0b25zLnJlc2V0Lmljb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluc3QuYnV0dG9ucy5sYXAuaWNvbikge1xuICAgICAgICAgICQkMSgnLm1ic2MtdGltZXItYnRuLXJlc2V0bGFwLWMgPiBkaXYnLCBjdHgpLmFkZENsYXNzKCdtYnNjLWljLScgKyBpbnN0LmJ1dHRvbnMubGFwLmljb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICQkMSgnLm1ic2MtZnItdycsIGN0eCkucmVtb3ZlQ2xhc3MoJ21ic2MtdGltZXItcnVubmluZycpO1xuICAgICAgJCQxKCcubWJzYy10aW1lci1idG4tdG9nZ2xlLWMgPiBkaXYnLCBjdHgpLnRleHQocy5zdGFydFRleHQpO1xuXG4gICAgICBpZiAoaW5zdC5idXR0b25zLnN0YXJ0Lmljb24pIHtcbiAgICAgICAgJCQxKCcubWJzYy10aW1lci1idG4tdG9nZ2xlLWMgPiBkaXYnLCBjdHgpLmFkZENsYXNzKCdtYnNjLWljLScgKyBpbnN0LmJ1dHRvbnMuc3RhcnQuaWNvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnN0LmJ1dHRvbnMuc3RvcC5pY29uKSB7XG4gICAgICAgICQkMSgnLm1ic2MtdGltZXItYnRuLXRvZ2dsZS1jID4gZGl2JywgY3R4KS5yZW1vdmVDbGFzcygnbWJzYy1pYy0nICsgaW5zdC5idXR0b25zLnN0b3AuaWNvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzLm1vZGUgPT0gJ3N0b3B3YXRjaCcpIHtcbiAgICAgICAgJCQxKCcubWJzYy10aW1lci1idG4tcmVzZXRsYXAtYyA+IGRpdicsIGN0eCkudGV4dChzLnJlc2V0VGV4dCk7XG5cbiAgICAgICAgaWYgKGluc3QuYnV0dG9ucy5yZXNldC5pY29uKSB7XG4gICAgICAgICAgJCQxKCcubWJzYy10aW1lci1idG4tcmVzZXRsYXAtYyA+IGRpdicsIGN0eCkuYWRkQ2xhc3MoJ21ic2MtaWMtJyArIGluc3QuYnV0dG9ucy5yZXNldC5pY29uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnN0LmJ1dHRvbnMubGFwLmljb24pIHtcbiAgICAgICAgICAkJDEoJy5tYnNjLXRpbWVyLWJ0bi1yZXNldGxhcC1jID4gZGl2JywgY3R4KS5yZW1vdmVDbGFzcygnbWJzYy1pYy0nICsgaW5zdC5idXR0b25zLmxhcC5pY29uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBpLFxuICAgICAgaW50ZXJ2YWwsXG4gICAgICB0c3RlcCxcbiAgICAgIHN0YXJ0VGltZSxcbiAgICAgIHN0YXJ0ZWQsXG4gICAgICBlbGxhcHNlZCxcbiAgICAgIHRpbWUsXG4gICAgICB0aW1lcixcbiAgICAgIHVwLFxuICAgICAgY3R4LFxuICAgICAgbGFwLFxuICAgICAgb3JpZyA9IGV4dGVuZCQxKHt9LCBpbnN0LnNldHRpbmdzKSxcbiAgICAgIHMgPSBleHRlbmQkMShpbnN0LnNldHRpbmdzLCBkZWZhdWx0cyRlLCBvcmlnKSxcbiAgICAgIGxibHMgPSBzLnVzZVNob3J0TGFiZWxzID8gcy5sYWJlbHNTaG9ydCA6IHMubGFiZWxzLFxuICAgICAgYW5pbVRpbWUgPSAxMDAwLFxuICAgICAgYnV0dG9ucyA9IFsncmVzZXRsYXAnLCAndG9nZ2xlJ10sXG4gICAgICB1bmlxdWUgPSBbJ3llYXJzJywgJ21vbnRocycsICdkYXlzJywgJ2hvdXJzJywgJ21pbnV0ZXMnLCAnc2Vjb25kcycsICdmcmFjdCddLFxuICAgICAgb2JqID0ge1xuICAgICd5ZWFycyc6IHtcbiAgICAgIGluZGV4OiA2LFxuICAgICAgdW50aWw6IDEwLFxuICAgICAgbGltaXQ6IDEwMDAgKiA2MCAqIDYwICogMjQgKiAzNjUsXG4gICAgICBsYWJlbDogbGJsc1swXSxcbiAgICAgIHdoZWVsOiB7fVxuICAgIH0sXG4gICAgJ21vbnRocyc6IHtcbiAgICAgIGluZGV4OiA1LFxuICAgICAgdW50aWw6IDExLFxuICAgICAgbGltaXQ6IDEwMDAgKiA2MCAqIDYwICogMjQgKiAzMCxcbiAgICAgIGxhYmVsOiBsYmxzWzFdLFxuICAgICAgd2hlZWw6IHt9XG4gICAgfSxcbiAgICAnZGF5cyc6IHtcbiAgICAgIGluZGV4OiA0LFxuICAgICAgdW50aWw6IDMxLFxuICAgICAgbGltaXQ6IDEwMDAgKiA2MCAqIDYwICogMjQsXG4gICAgICBsYWJlbDogbGJsc1syXSxcbiAgICAgIHdoZWVsOiB7fVxuICAgIH0sXG4gICAgJ2hvdXJzJzoge1xuICAgICAgaW5kZXg6IDMsXG4gICAgICB1bnRpbDogMjMsXG4gICAgICBsaW1pdDogMTAwMCAqIDYwICogNjAsXG4gICAgICBsYWJlbDogbGJsc1szXSxcbiAgICAgIHdoZWVsOiB7fVxuICAgIH0sXG4gICAgJ21pbnV0ZXMnOiB7XG4gICAgICBpbmRleDogMixcbiAgICAgIHVudGlsOiA1OSxcbiAgICAgIGxpbWl0OiAxMDAwICogNjAsXG4gICAgICBsYWJlbDogbGJsc1s0XSxcbiAgICAgIHdoZWVsOiB7fVxuICAgIH0sXG4gICAgJ3NlY29uZHMnOiB7XG4gICAgICBpbmRleDogMSxcbiAgICAgIHVudGlsOiA1OSxcbiAgICAgIGxpbWl0OiAxMDAwLFxuICAgICAgbGFiZWw6IGxibHNbNV0sXG4gICAgICB3aGVlbDoge31cbiAgICB9LFxuICAgICdmcmFjdCc6IHtcbiAgICAgIGluZGV4OiAwLFxuICAgICAgdW50aWw6IDk5LFxuICAgICAgbGltaXQ6IDEwLFxuICAgICAgbGFiZWw6IGxibHNbNl0sXG4gICAgICBwcmVmaXg6ICcuJyxcbiAgICAgIHdoZWVsOiB7fVxuICAgIH1cbiAgfSxcbiAgICAgIHdoZWVscyA9IHt9LFxuICAgICAgbGFwcyA9IFtdLFxuICAgICAgbGFzdExhcCA9IDAsXG4gICAgICBydW5uaW5nID0gZmFsc2UsXG4gICAgICBzdG9wcGVkID0gdHJ1ZSxcbiAgICAgIGluZmluaXQgPSBmYWxzZSxcbiAgICAgIHN0ZXAgPSBNYXRoLm1heCgxMCwgcy5zdGVwICogMTAwMCksXG4gICAgICBtYXggPSBzLm1heFdoZWVsLFxuICAgICAgbG9ja2VkID0gcy5tb2RlID09ICdzdG9wd2F0Y2gnIHx8IGRhdGVNb2RlLFxuICAgICAgb3JpZ1RpbWUgPSBzLnRhcmdldFRpbWUsXG4gICAgICBkYXRlTW9kZSA9IG9yaWdUaW1lICYmIG9yaWdUaW1lLmdldFRpbWUgIT09IHVuZGVmaW5lZCxcbiAgICAgIHcgPSBbW11dOyAvLyBFeHRlbmRlZCBtZXRob2RzXG4gIC8vIC0tLVxuICAvLyBTdGFydCB0aGUgY291bnRlclxuXG4gIGluc3Quc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHN0b3BwZWQpIHtcbiAgICAgIGluc3QucmVzZXQoKTtcbiAgICB9XG5cbiAgICBpZiAoIXJ1bm5pbmcpIHtcbiAgICAgIGNhbGNUaW1lKCk7XG5cbiAgICAgIGlmICghaW5maW5pdCAmJiB0aW1lciA+PSB0aW1lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcnVubmluZyA9IHRydWU7XG4gICAgICBzdG9wcGVkID0gZmFsc2U7XG4gICAgICBzdGFydGVkID0gbmV3IERhdGUoKTtcbiAgICAgIHN0YXJ0VGltZSA9IHRpbWVyO1xuICAgICAgcy5yZWFkb25seSA9IHRydWU7XG4gICAgICBpbnN0LnNldFZhbChnZXRBcnJheSh1cCA/IHRpbWVyIDogdGltZSAtIHRpbWVyKSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UsIDEwMCk7XG4gICAgICBpbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGltZXIgPSBuZXcgRGF0ZSgpIC0gc3RhcnRlZCArIHN0YXJ0VGltZTtcbiAgICAgICAgaW5zdC5zZXRWYWwoZ2V0QXJyYXkodXAgPyB0aW1lciA6IHRpbWUgLSB0aW1lciksIHRydWUsIHRydWUsIGZhbHNlLCBNYXRoLm1pbigxMDAsIHRzdGVwIC0gMTApKTtcblxuICAgICAgICBpZiAoIWluZmluaXQgJiYgdGltZXIgKyB0c3RlcCA+PSB0aW1lKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBEbyBsYXN0IHRpY2sgd2l0aCBwcmVjaXNpb25cbiAgICAgICAgICAgIGluc3Quc3RvcCgpO1xuICAgICAgICAgICAgdGltZXIgPSB0aW1lO1xuICAgICAgICAgICAgaW5zdC5zZXRWYWwoZ2V0QXJyYXkodXAgPyB0aW1lciA6IDApLCB0cnVlLCB0cnVlLCBmYWxzZSwgMTAwKTtcbiAgICAgICAgICAgIGluc3QudHJpZ2dlcignb25GaW5pc2gnLCB7XG4gICAgICAgICAgICAgIHRpbWU6IHRpbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgfSwgdGltZSAtIHRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgfSwgdHN0ZXApO1xuICAgICAgdXBkYXRlVUkoKTtcbiAgICAgIGluc3QudHJpZ2dlcignb25TdGFydCcpO1xuICAgIH1cbiAgfTsgLy8gU3RvcCB0aGUgY291bnRlclxuXG5cbiAgaW5zdC5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChydW5uaW5nKSB7XG4gICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgICBjbGVhckludGVydmFsKGludGVydmFsKTsgLy8gVGltZSBjb3JyZWN0aW9uXG5cbiAgICAgIHRpbWVyID0gbmV3IERhdGUoKSAtIHN0YXJ0ZWQgKyBzdGFydFRpbWU7XG4gICAgICB1cGRhdGVVSSgpO1xuICAgICAgaW5zdC50cmlnZ2VyKCdvblN0b3AnLCB7XG4gICAgICAgIGVsbGFwc2VkOiB0aW1lclxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGluc3QudG9nZ2xlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChydW5uaW5nKSB7XG4gICAgICBpbnN0LnN0b3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdC5zdGFydCgpO1xuICAgIH1cbiAgfTsgLy8gUmVzZXQgdGhlIGNvdW50ZXJcblxuXG4gIGluc3QucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaW5zdC5zdG9wKCk7XG4gICAgdGltZXIgPSAwO1xuICAgIGxhcHMgPSBbXTtcbiAgICBsYXN0TGFwID0gMDtcbiAgICBpbnN0LnNldFZhbChnZXRBcnJheSh1cCA/IDAgOiB0aW1lKSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UsIGFuaW1UaW1lKTtcbiAgICBpbnN0LnNldHRpbmdzLnJlYWRvbmx5ID0gbG9ja2VkO1xuICAgIHN0b3BwZWQgPSB0cnVlO1xuXG4gICAgaWYgKCFsb2NrZWQpIHtcbiAgICAgICQkMSgnLm1ic2MtZnItdycsIGN0eCkucmVtb3ZlQ2xhc3MoJ21ic2MtdGltZXItbG9ja2VkJyk7XG4gICAgfVxuXG4gICAgaW5zdC50cmlnZ2VyKCdvblJlc2V0Jyk7XG4gIH07IC8vIExhcFxuXG5cbiAgaW5zdC5sYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgIGVsbGFwc2VkID0gbmV3IERhdGUoKSAtIHN0YXJ0ZWQgKyBzdGFydFRpbWU7XG4gICAgICBsYXAgPSBlbGxhcHNlZCAtIGxhc3RMYXA7XG4gICAgICBsYXN0TGFwID0gZWxsYXBzZWQ7XG4gICAgICBsYXBzLnB1c2goZWxsYXBzZWQpO1xuICAgICAgaW5zdC50cmlnZ2VyKCdvbkxhcCcsIHtcbiAgICAgICAgZWxsYXBzZWQ6IGVsbGFwc2VkLFxuICAgICAgICBsYXA6IGxhcCxcbiAgICAgICAgbGFwczogbGFwc1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGluc3QucmVzZXRsYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHJ1bm5pbmcgJiYgcy5tb2RlID09ICdzdG9wd2F0Y2gnKSB7XG4gICAgICBpbnN0LmxhcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0LnJlc2V0KCk7XG4gICAgfVxuICB9O1xuXG4gIGluc3QuZ2V0VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGltZTtcbiAgfTtcblxuICBpbnN0LnNldFRpbWUgPSBmdW5jdGlvbiAodCkge1xuICAgIG9yaWdUaW1lID0gdCAvIDEwMDA7XG4gICAgdGltZSA9IHQ7XG4gIH07XG5cbiAgaW5zdC5nZXRFbGxhcHNlZFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHN0b3BwZWQgPyAwIDogcnVubmluZyA/IG5ldyBEYXRlKCkgLSBzdGFydGVkICsgc3RhcnRUaW1lIDogdGltZXI7XG4gIH07XG5cbiAgaW5zdC5zZXRFbGxhcHNlZFRpbWUgPSBmdW5jdGlvbiAodCwgY2hhbmdlKSB7XG4gICAgaWYgKCFzdG9wcGVkKSB7XG4gICAgICBzdGFydFRpbWUgPSB0aW1lciA9IHQ7XG4gICAgICBzdGFydGVkID0gbmV3IERhdGUoKTtcbiAgICAgIGluc3Quc2V0VmFsKGdldEFycmF5KHVwID8gdGltZXIgOiB0aW1lIC0gdGltZXIpLCB0cnVlLCBjaGFuZ2UsIGZhbHNlLCBhbmltVGltZSk7XG4gICAgfVxuICB9OyAvLyAtLS1cbiAgLy8gQ29uc3RydWN0b3JcblxuXG4gIGNhbGNUaW1lKHRydWUpO1xuXG4gIGlmICghbWF4ICYmICF0aW1lKSB7XG4gICAgbWF4ID0gJ21pbnV0ZXMnO1xuICB9XG5cbiAgaWYgKHMuZGlzcGxheSAhPT0gJ2lubGluZScpIHtcbiAgICBidXR0b25zLnVuc2hpZnQoJ2hpZGUnKTtcbiAgfSAvLyBEZXRlcm1pbmUgbWF4aW11bSB3aGVlbFxuXG5cbiAgaWYgKCFtYXgpIHtcbiAgICAkJDEodW5pcXVlKS5lYWNoKGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICBpZiAoIW1heCAmJiB0aW1lID49IG9ialt2XS5saW1pdCkge1xuICAgICAgICBtYXggPSB2O1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gLy8gR2VuZXJhdGUgd2hlZWxzXG5cblxuICAkJDEodW5pcXVlKS5lYWNoKGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgZ2VuV2hlZWwodik7XG4gIH0pO1xuICB0c3RlcCA9IE1hdGgubWF4KDk3LCB0c3RlcCk7IC8vIHRpbWVyIHN0ZXAgY2Fubm90IGJlIGxlc3MgdGhlbiAxMDAgbXNcblxuICBpZiAocy5hdXRvc3RhcnQpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGluc3Quc3RhcnQoKTtcbiAgICB9LCAwKTtcbiAgfVxuXG4gIGluc3QuaGFuZGxlcnMudG9nZ2xlID0gaW5zdC50b2dnbGU7XG4gIGluc3QuaGFuZGxlcnMuc3RhcnQgPSBpbnN0LnN0YXJ0O1xuICBpbnN0LmhhbmRsZXJzLnN0b3AgPSBpbnN0LnN0b3A7XG4gIGluc3QuaGFuZGxlcnMucmVzZXRsYXAgPSBpbnN0LnJlc2V0bGFwO1xuICBpbnN0LmhhbmRsZXJzLnJlc2V0ID0gaW5zdC5yZXNldDtcbiAgaW5zdC5oYW5kbGVycy5sYXAgPSBpbnN0LmxhcDtcbiAgaW5zdC5idXR0b25zLnRvZ2dsZSA9IHtcbiAgICBwYXJlbnRDbGFzczogJ21ic2MtdGltZXItYnRuLXRvZ2dsZS1jJyxcbiAgICB0ZXh0OiBzLnN0YXJ0VGV4dCxcbiAgICBpY29uOiBzLnN0YXJ0SWNvbixcbiAgICBoYW5kbGVyOiAndG9nZ2xlJ1xuICB9O1xuICBpbnN0LmJ1dHRvbnMuc3RhcnQgPSB7XG4gICAgdGV4dDogcy5zdGFydFRleHQsXG4gICAgaWNvbjogcy5zdGFydEljb24sXG4gICAgaGFuZGxlcjogJ3N0YXJ0J1xuICB9O1xuICBpbnN0LmJ1dHRvbnMuc3RvcCA9IHtcbiAgICB0ZXh0OiBzLnN0b3BUZXh0LFxuICAgIGljb246IHMuc3RvcEljb24sXG4gICAgaGFuZGxlcjogJ3N0b3AnXG4gIH07XG4gIGluc3QuYnV0dG9ucy5yZXNldCA9IHtcbiAgICB0ZXh0OiBzLnJlc2V0VGV4dCxcbiAgICBpY29uOiBzLnJlc2V0SWNvbixcbiAgICBoYW5kbGVyOiAncmVzZXQnXG4gIH07XG4gIGluc3QuYnV0dG9ucy5sYXAgPSB7XG4gICAgdGV4dDogcy5sYXBUZXh0LFxuICAgIGljb246IHMubGFwSWNvbixcbiAgICBoYW5kbGVyOiAnbGFwJ1xuICB9O1xuICBpbnN0LmJ1dHRvbnMucmVzZXRsYXAgPSB7XG4gICAgcGFyZW50Q2xhc3M6ICdtYnNjLXRpbWVyLWJ0bi1yZXNldGxhcC1jJyxcbiAgICB0ZXh0OiBzLnJlc2V0VGV4dCxcbiAgICBpY29uOiBzLnJlc2V0SWNvbixcbiAgICBoYW5kbGVyOiAncmVzZXRsYXAnXG4gIH07XG4gIGluc3QuYnV0dG9ucy5oaWRlID0ge1xuICAgIHBhcmVudENsYXNzOiAnbWJzYy10aW1lci1idG4taGlkZS1jJyxcbiAgICB0ZXh0OiBzLmhpZGVUZXh0LFxuICAgIGljb246IHMuY2xvc2VJY29uLFxuICAgIGhhbmRsZXI6ICdjYW5jZWwnXG4gIH07IC8vIFJldHVybiBzZXR0aW5nc1xuXG4gIHJldHVybiB7XG4gICAgbWluV2lkdGg6IDEwMCxcbiAgICB3aGVlbHM6IHcsXG4gICAgaGVhZGVyVGV4dDogZmFsc2UsXG4gICAgcmVhZG9ubHk6IGxvY2tlZCxcbiAgICBidXR0b25zOiBidXR0b25zLFxuICAgIGNvbXBDbGFzczogJ21ic2MtdGltZXIgbWJzYy1zYycsXG4gICAgcGFyc2VWYWx1ZTogZnVuY3Rpb24gcGFyc2VWYWx1ZSgpIHtcbiAgICAgIHJldHVybiBnZXRBcnJheSh1cCA/IDAgOiB0aW1lKTtcbiAgICB9LFxuICAgIGZvcm1hdFZhbHVlOiBmdW5jdGlvbiBmb3JtYXRWYWx1ZShkKSB7XG4gICAgICB2YXIgcmV0ID0gJycsXG4gICAgICAgICAgaiA9IDA7XG4gICAgICAkJDEodW5pcXVlKS5lYWNoKGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICAgIGlmICh2ID09ICdmcmFjdCcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAod2hlZWxzW3ZdKSB7XG4gICAgICAgICAgcmV0ICs9IGRbal0gKyAodiA9PSAnc2Vjb25kcycgJiYgd2hlZWxzLmZyYWN0ID8gJy4nICsgZFtqICsgMV0gOiAnJykgKyAnICcgKyBsYmxzW2ldICsgJyAnO1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKGRhdGEpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBkYXRhLnZhbHVlcyxcbiAgICAgICAgICBpID0gZGF0YS5pbmRleCxcbiAgICAgICAgICBqID0gMDtcblxuICAgICAgaWYgKHN0b3BwZWQgJiYgaSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9yaWdUaW1lID0gMDtcbiAgICAgICAgJCQxKHVuaXF1ZSkuZWFjaChmdW5jdGlvbiAoaSwgdikge1xuICAgICAgICAgIGlmICh3aGVlbHNbdl0pIHtcbiAgICAgICAgICAgIG9yaWdUaW1lICs9IG9ialt2XS5saW1pdCAqIHZhbHVlc1tqXTtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvcmlnVGltZSAvPSAxMDAwO1xuICAgICAgICBjYWxjVGltZSh0cnVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uQmVmb3JlU2hvdzogZnVuY3Rpb24gb25CZWZvcmVTaG93KCkge1xuICAgICAgcy5zaG93TGFiZWwgPSB0cnVlO1xuICAgIH0sXG4gICAgb25NYXJrdXBSZWFkeTogZnVuY3Rpb24gb25NYXJrdXBSZWFkeShldikge1xuICAgICAgY3R4ID0gJCQxKGV2LnRhcmdldCk7XG4gICAgICB1cGRhdGVVSSgpO1xuXG4gICAgICBpZiAobG9ja2VkKSB7XG4gICAgICAgICQkMSgnLm1ic2MtZnItdycsIGN0eCkuYWRkQ2xhc3MoJ21ic2MtdGltZXItbG9ja2VkJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvblBvc2l0aW9uOiBmdW5jdGlvbiBvblBvc2l0aW9uKGV2KSB7XG4gICAgICAvLyBGb3JjZSB3aWR0aCB0byBmaXQgYnV0dG9uc1xuICAgICAgJCQxKCcubWJzYy1mci13JywgZXYudGFyZ2V0KS5jc3MoJ21pbi13aWR0aCcsIDApLmNzcygnbWluLXdpZHRoJywgJCQxKCcubWJzYy1mci1idG4tY29udCcsIGV2LnRhcmdldClbMF0ub2Zmc2V0V2lkdGgpO1xuICAgIH0sXG4gICAgb25EZXN0cm95OiBmdW5jdGlvbiBvbkRlc3Ryb3koKSB7XG4gICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICB9XG4gIH07XG59O1xuXG52YXIgTWJzY1RpbWVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjVGltZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjVGltZXIoaW5pdGlhbEVsZW1lbnQsIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtZW50LCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMub3B0aW9uU2VydmljZSA9IG9wdGlvblNlcnZpY2U7XHJcbiAgICAgICAgX3RoaXMub25MYXAgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMub25GaW5pc2ggPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgX3RoaXMub25SZXNldCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5vblN0YXJ0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIF90aGlzLm9uU3RvcCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuICAgICAgICBfdGhpcy5vcHRpb25zID0ge307XHJcbiAgICAgICAgX3RoaXMub25DaGFuZ2VFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjVGltZXIucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE1ic2NUaW1lci5wcm90b3R5cGUuc2V0TmV3VmFsdWUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pbnN0YW5jZS5fdGltZXIgfHwgTWF0aC5hYnModGhpcy5pbnN0YW5jZS5fdGltZXIgLSB2KSA+IDEwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNldEVsbGFwc2VkVGltZSh2LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5wdXRTZXJ2aWNlICYmIHRoaXMuX2lucHV0U2VydmljZS5pbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lucHV0U2VydmljZS5pbnB1dC5pbm5lclZhbHVlID0gdGhpcy5pbnN0YW5jZS5fdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTWJzY1RpbWVyLnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgICAgICQkMSh0aGlzLmVsZW1lbnQpLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoYXQuem9uZS5ydW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhhdC5pbnN0YW5jZS5fdGltZXIgPSB0aGF0Lmluc3RhbmNlLmdldEVsbGFwc2VkVGltZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoYXQuY29udHJvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuY29udHJvbC5jb250cm9sLnBhdGNoVmFsdWUodGhhdC5pbnN0YW5jZS5fdGltZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5vbkNoYW5nZUVtaXR0ZXIuZW1pdCh0aGF0Lmluc3RhbmNlLl90aW1lcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE1ic2NUaW1lci5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBleHRlbmQkMSh7IHByZXNldDogJ3RpbWVyJyB9LCB0aGlzLm9wdGlvblNlcnZpY2UgPyB0aGlzLm9wdGlvblNlcnZpY2Uub3B0aW9ucyA6IHt9LCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaiwgdGhpcy5vcHRpb25FeHRlbnNpb25zKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IFRpbWVyKHRoaXMuZWxlbWVudCwgb3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodGhpcy5pbml0aWFsVmFsdWUsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY1RpbWVyLnByb3RvdHlwZSwgXCJhdXRvc3RhcnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1RpbWVyLnByb3RvdHlwZSwgXCJtYXhXaGVlbFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjVGltZXIucHJvdG90eXBlLCBcIm1vZGVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxyXG4gICAgXSwgTWJzY1RpbWVyLnByb3RvdHlwZSwgXCJzdGVwXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcclxuICAgIF0sIE1ic2NUaW1lci5wcm90b3R5cGUsIFwidGFyZ2V0VGltZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY1RpbWVyLnByb3RvdHlwZSwgXCJ1c2VTaG9ydExhYmVsc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjVGltZXIucHJvdG90eXBlLCBcImhpZGVUZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgTWJzY1RpbWVyLnByb3RvdHlwZSwgXCJsYWJlbHNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBNYnNjVGltZXIucHJvdG90eXBlLCBcImxhYmVsc1Nob3J0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NUaW1lci5wcm90b3R5cGUsIFwibGFwVGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjVGltZXIucHJvdG90eXBlLCBcInJlc2V0VGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjVGltZXIucHJvdG90eXBlLCBcInN0YXJ0VGV4dFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjVGltZXIucHJvdG90eXBlLCBcInN0b3BUZXh0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY1RpbWVyLnByb3RvdHlwZSwgXCJvbkxhcFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NUaW1lci5wcm90b3R5cGUsIFwib25GaW5pc2hcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjVGltZXIucHJvdG90eXBlLCBcIm9uUmVzZXRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjVGltZXIucHJvdG90eXBlLCBcIm9uU3RhcnRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjVGltZXIucHJvdG90eXBlLCBcIm9uU3RvcFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnbWJzYy1vcHRpb25zJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NUaW1lci5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnbWJzYy10aW1lcicpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcclxuICAgIF0sIE1ic2NUaW1lci5wcm90b3R5cGUsIFwidmFsdWVcIiwgbnVsbCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBPdXRwdXQoJ21ic2MtdGltZXJDaGFuZ2UnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxyXG4gICAgXSwgTWJzY1RpbWVyLnByb3RvdHlwZSwgXCJvbkNoYW5nZUVtaXR0ZXJcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NUaW1lciA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIERpcmVjdGl2ZSh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnW21ic2MtdGltZXJdJyxcclxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJ1xyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMiwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksIF9fcGFyYW0oNCwgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBOZ1pvbmUsIE5nQ29udHJvbCwgTWJzY0lucHV0U2VydmljZSwgTWJzY09wdGlvbnNTZXJ2aWNlLCBWaWV3Q29udGFpbmVyUmVmXSlcclxuICAgIF0sIE1ic2NUaW1lcik7XHJcbiAgICByZXR1cm4gTWJzY1RpbWVyO1xyXG59KE1ic2NTY3JvbGxlckJhc2UpKTtcclxudmFyIE1ic2NUaW1lckNvbXBvbmVudCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY1RpbWVyQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY1RpbWVyQ29tcG9uZW50KGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlLCBudWxsKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmVycm9yTWVzc2FnZSA9ICcnO1xyXG4gICAgICAgIF90aGlzLnBsYWNlaG9sZGVyID0gJyc7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgTWJzY1RpbWVyQ29tcG9uZW50LnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5uZ0FmdGVyVmlld0luaXQuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLnNldFRoZW1lQ2xhc3NlcygpO1xyXG4gICAgfTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ2ljb24nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1RpbWVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpbnB1dEljb25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ2ljb24tYWxpZ24nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1RpbWVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpY29uQWxpZ25cIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1RpbWVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXHJcbiAgICBdLCBNYnNjVGltZXJDb21wb25lbnQucHJvdG90eXBlLCBcImVycm9yXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NUaW1lckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZXJyb3JNZXNzYWdlXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NUaW1lckNvbXBvbmVudC5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjVGltZXJDb21wb25lbnQucHJvdG90eXBlLCBcInBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjVGltZXJDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ21ic2MtdGltZXInLFxyXG4gICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogSU5QVVRfVEVNUExBVEVcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDIsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDMsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDQsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLCBOZ0NvbnRyb2wsIE1ic2NJbnB1dFNlcnZpY2UsIE1ic2NPcHRpb25zU2VydmljZV0pXHJcbiAgICBdLCBNYnNjVGltZXJDb21wb25lbnQpO1xyXG4gICAgcmV0dXJuIE1ic2NUaW1lckNvbXBvbmVudDtcclxufShNYnNjVGltZXIpKTtcclxudmFyIE1ic2NUaW1lck1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNYnNjVGltZXJNb2R1bGUoKSB7XHJcbiAgICB9XHJcbiAgICBNYnNjVGltZXJNb2R1bGUgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBOZ01vZHVsZSh7XHJcbiAgICAgICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIE1ic2NTY3JvbGxlckJhc2VNb2R1bGUsIE1ic2NJbnB1dE1vZHVsZV0sXHJcbiAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW01ic2NUaW1lciwgTWJzY1RpbWVyQ29tcG9uZW50XSxcclxuICAgICAgICAgICAgZXhwb3J0czogW01ic2NUaW1lciwgTWJzY1RpbWVyQ29tcG9uZW50XVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBNYnNjVGltZXJNb2R1bGUpO1xyXG4gICAgcmV0dXJuIE1ic2NUaW1lck1vZHVsZTtcclxufSgpKTtcblxudmFyIFRpbWVzcGFuID0gU2Nyb2xsZXI7XG52YXIgZGVmYXVsdHMkZiA9IHtcbiAgd2hlZWxPcmRlcjogJ2hoaWlzcycsXG4gIHVzZVNob3J0TGFiZWxzOiBmYWxzZSxcbiAgbWluOiAwLFxuICBtYXg6IEluZmluaXR5LFxuICAvLyBMb2NhbGl6YXRpb25cbiAgbGFiZWxzOiBbJ1llYXJzJywgJ01vbnRocycsICdEYXlzJywgJ0hvdXJzJywgJ01pbnV0ZXMnLCAnU2Vjb25kcyddLFxuICAvLywgJyddLFxuICBsYWJlbHNTaG9ydDogWydZcnMnLCAnTXRocycsICdEYXlzJywgJ0hycycsICdNaW5zJywgJ1NlY3MnXSAvLywgJyddXG5cbn07XG5cbnByZXNldHMudGltZXNwYW4gPSBmdW5jdGlvbiAoaW5zdCkge1xuICAvKipcclxuICAgKiBDYWxjdWxhdGVzIHRoZSBwYXJ0cyBvZiB0aGUgdGltZSBkaWZmZXJuY2UuXHJcbiAgICogQHBhcmFtIHtJbnRlZ2VyfSB0aW1lIC0gVGltZSBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICogQHJldHVybiB7T2JqZWN0fSAtIFRpbWUgc3BsaXR0ZWQgdG8gdGhlIHJlcXVpcmVkIHBhcnRzICh5ZWFycywgbW9udGhzLCBkYXlzLCBob3VycywgbWludXRlcywgc2Vjb25kcykuXHJcbiAgICovXG4gIGZ1bmN0aW9uIGdldFBhcnRzKHRpbWUpIHtcbiAgICB2YXIgcmV0ID0ge307XG4gICAgJCQxKHVuaXF1ZSkuZWFjaChmdW5jdGlvbiAoaSwgdikge1xuICAgICAgcmV0W3ZdID0gd2hlZWxzW3ZdID8gTWF0aC5mbG9vcih0aW1lIC8gb2JqW3ZdLmxpbWl0KSA6IDA7XG4gICAgICB0aW1lIC09IHJldFt2XSAqIG9ialt2XS5saW1pdDtcbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIC8qKlxyXG4gICAqIEdlbmVyYXRlcyBhIHNwZWNpZmljIHdoZWVsLlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2IC0gVW5pcXVlIGlkZW50aWZpZXIuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBnZW5XaGVlbCh2KSB7XG4gICAgdmFyIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgICAgc3QgPSBzdGVwc1t3aGVlbHNbdl0gLSAxXSB8fCAxLFxuICAgICAgICBvID0gb2JqW3ZdLFxuICAgICAgICBsYmwgPSBvLmxhYmVsLFxuICAgICAgICB3ID0gby53aGVlbDtcbiAgICB3LmRhdGEgPSBbXTtcbiAgICB3LmxhYmVsID0gby5sYWJlbDtcblxuICAgIGlmIChvcmQubWF0Y2gobmV3IFJlZ0V4cChvLnJlICsgby5yZSwgJ2knKSkpIHtcbiAgICAgIGxlYWRpbmcgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh2ID09IG1heCkge1xuICAgICAgdy5taW4gPSBtaW5QYXJ0c1t2XTtcbiAgICAgIHcubWF4ID0gbWF4UGFydHNbdl07XG5cbiAgICAgIHcuZGF0YSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IGkgKiBzdCxcbiAgICAgICAgICBkaXNwbGF5OiBnZW5WYWx1ZShpICogc3QsIGxlYWRpbmcsIGxibClcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIHcuZ2V0SW5kZXggPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2IC8gc3QpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgaSA8PSBvLnVudGlsOyBpICs9IHN0KSB7XG4gICAgICAgIHcuZGF0YS5wdXNoKHtcbiAgICAgICAgICB2YWx1ZTogaSxcbiAgICAgICAgICBkaXNwbGF5OiBnZW5WYWx1ZShpLCBsZWFkaW5nLCBsYmwpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlblZhbHVlKGksIGxlYWRpbmcsIGxibCkge1xuICAgIHJldHVybiAoaSA8IDEwICYmIGxlYWRpbmcgPyAnMCcgOiAnJykgKyBpICsgJzxzcGFuIGNsYXNzPVwibWJzYy10cy1sYmxcIj4nICsgbGJsICsgJzwvc3Bhbj4nO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsY1RpbWUoYXJyKSB7XG4gICAgdmFyIGogPSAwLFxuICAgICAgICB0aW1lID0gMDtcbiAgICAkJDEuZWFjaChvLCBmdW5jdGlvbiAoaSwgdikge1xuICAgICAgaWYgKCFpc05hTigrYXJyW2pdKSkge1xuICAgICAgICB0aW1lICs9IG9ialt2LnZdLmxpbWl0ICogYXJyW2ldO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RlcCh2LCBzdCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKHYgLyBzdCkgKiBzdDtcbiAgfVxuXG4gIHZhciBpLFxuICAgICAgaixcbiAgICAgIHAsXG4gICAgICBtaW5QYXJ0cyxcbiAgICAgIG1heFBhcnRzLFxuICAgICAgb3JpZyA9IGV4dGVuZCQxKHt9LCBpbnN0LnNldHRpbmdzKSxcbiAgICAgIHMgPSBleHRlbmQkMShpbnN0LnNldHRpbmdzLCBkZWZhdWx0cyRmLCBvcmlnKSxcbiAgICAgIG9yZCA9IHMud2hlZWxPcmRlcixcbiAgICAgIGxibHMgPSBzLnVzZVNob3J0TGFiZWxzID8gcy5sYWJlbHNTaG9ydCA6IHMubGFiZWxzLFxuICAgICAgdW5pcXVlID0gWyd5ZWFycycsICdtb250aHMnLCAnZGF5cycsICdob3VycycsICdtaW51dGVzJywgJ3NlY29uZHMnXSxcbiAgICAgIC8vLCAnZnJhY3QnXSxcbiAgb2JqID0ge1xuICAgICd5ZWFycyc6IHtcbiAgICAgIG9yZDogMCxcbiAgICAgIGluZGV4OiA2LFxuICAgICAgdW50aWw6IDEwLFxuICAgICAgbGltaXQ6IDEwMDAgKiA2MCAqIDYwICogMjQgKiAzNjUsXG4gICAgICBsYWJlbDogbGJsc1swXSxcbiAgICAgIHJlOiAneScsXG4gICAgICB3aGVlbDoge31cbiAgICB9LFxuICAgICdtb250aHMnOiB7XG4gICAgICBvcmQ6IDEsXG4gICAgICBpbmRleDogNSxcbiAgICAgIHVudGlsOiAxMSxcbiAgICAgIGxpbWl0OiAxMDAwICogNjAgKiA2MCAqIDI0ICogMzAsXG4gICAgICBsYWJlbDogbGJsc1sxXSxcbiAgICAgIHJlOiAnbScsXG4gICAgICB3aGVlbDoge31cbiAgICB9LFxuICAgICdkYXlzJzoge1xuICAgICAgb3JkOiAyLFxuICAgICAgaW5kZXg6IDQsXG4gICAgICB1bnRpbDogMzEsXG4gICAgICBsaW1pdDogMTAwMCAqIDYwICogNjAgKiAyNCxcbiAgICAgIGxhYmVsOiBsYmxzWzJdLFxuICAgICAgcmU6ICdkJyxcbiAgICAgIHdoZWVsOiB7fVxuICAgIH0sXG4gICAgJ2hvdXJzJzoge1xuICAgICAgb3JkOiAzLFxuICAgICAgaW5kZXg6IDMsXG4gICAgICB1bnRpbDogMjMsXG4gICAgICBsaW1pdDogMTAwMCAqIDYwICogNjAsXG4gICAgICBsYWJlbDogbGJsc1szXSxcbiAgICAgIHJlOiAnaCcsXG4gICAgICB3aGVlbDoge31cbiAgICB9LFxuICAgICdtaW51dGVzJzoge1xuICAgICAgb3JkOiA0LFxuICAgICAgaW5kZXg6IDIsXG4gICAgICB1bnRpbDogNTksXG4gICAgICBsaW1pdDogMTAwMCAqIDYwLFxuICAgICAgbGFiZWw6IGxibHNbNF0sXG4gICAgICByZTogJ2knLFxuICAgICAgd2hlZWw6IHt9XG4gICAgfSxcbiAgICAnc2Vjb25kcyc6IHtcbiAgICAgIG9yZDogNSxcbiAgICAgIGluZGV4OiAxLFxuICAgICAgdW50aWw6IDU5LFxuICAgICAgbGltaXQ6IDEwMDAsXG4gICAgICBsYWJlbDogbGJsc1s1XSxcbiAgICAgIHJlOiAncycsXG4gICAgICB3aGVlbDoge31cbiAgICB9IC8vLFxuICAgIC8vJ2ZyYWN0JzogeyBpbmRleDogMCwgdW50aWw6IDk5LCBsaW1pdDogMTAsIGxhYmVsOiBsYmxzWzZdLCBwcmVmaXg6ICcuJywgc2hvcnQ6ICd1JyB9XG5cbiAgfSxcbiAgICAgIG8gPSBbXSxcbiAgICAgIHN0ZXBzID0gcy5zdGVwcyB8fCBbXSxcbiAgICAgIHdoZWVscyA9IHt9LFxuICAgICAgbWF4ID0gJ3NlY29uZHMnLFxuICAgICAgZGVmYXVsdFZhbCA9IHMuZGVmYXVsdFZhbHVlIHx8IE1hdGgubWF4KHMubWluLCBNYXRoLm1pbigwLCBzLm1heCkpLFxuICAgICAgdyA9IFtbXV07IC8vIENvbnN0cnVjdG9yXG4gIC8vIEdlbmVyYXRlIHdoZWVsc1xuXG4gICQkMSh1bmlxdWUpLmVhY2goZnVuY3Rpb24gKGksIHYpIHtcbiAgICBqID0gb3JkLnNlYXJjaChuZXcgUmVnRXhwKG9ialt2XS5yZSwgJ2knKSk7XG5cbiAgICBpZiAoaiA+IC0xKSB7XG4gICAgICBvLnB1c2goe1xuICAgICAgICBvOiBqLFxuICAgICAgICB2OiB2XG4gICAgICB9KTtcblxuICAgICAgaWYgKG9ialt2XS5pbmRleCA+IG9ialttYXhdLmluZGV4KSB7XG4gICAgICAgIG1heCA9IHY7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgby5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEubyA+IGIubyA/IDEgOiAtMTtcbiAgfSk7XG4gICQkMS5lYWNoKG8sIGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgd2hlZWxzW3Yudl0gPSBpICsgMTtcbiAgICB3WzBdLnB1c2gob2JqW3Yudl0ud2hlZWwpO1xuICB9KTtcbiAgbWluUGFydHMgPSBnZXRQYXJ0cyhzLm1pbik7XG4gIG1heFBhcnRzID0gZ2V0UGFydHMocy5tYXgpO1xuICAkJDEuZWFjaChvLCBmdW5jdGlvbiAoaSwgdikge1xuICAgIGdlbldoZWVsKHYudik7XG4gIH0pOyAvLyBFeHRlbmRlZCBtZXRob2RzXG4gIC8vIC0tLVxuXG4gIGluc3QuZ2V0VmFsID0gZnVuY3Rpb24gKHRlbXAsIGZvcm1hdHRlZCkge1xuICAgIHJldHVybiBmb3JtYXR0ZWQgPyBpbnN0Ll9nZXRWYWwodGVtcCkgOiBpbnN0Ll9oYXNWYWx1ZSB8fCB0ZW1wID8gY2FsY1RpbWUoaW5zdC5nZXRBcnJheVZhbCh0ZW1wKSkgOiBudWxsO1xuICB9OyAvLyAtLS1cbiAgLy8gUmV0dXJuIHNldHRpbmdzXG5cblxuICByZXR1cm4ge1xuICAgIG1pbldpZHRoOiAxMDAsXG4gICAgc2hvd0xhYmVsOiB0cnVlLFxuICAgIHdoZWVsczogdyxcbiAgICBjb21wQ2xhc3M6ICdtYnNjLXRzIG1ic2Mtc2MnLFxuICAgIHBhcnNlVmFsdWU6IGZ1bmN0aW9uIHBhcnNlVmFsdWUodmFsKSB7XG4gICAgICB2YXIgcmV0ID0gW10sXG4gICAgICAgICAgbTtcblxuICAgICAgaWYgKGlzTnVtZXJpYyh2YWwpIHx8ICF2YWwpIHtcbiAgICAgICAgcCA9IGdldFBhcnRzKHZhbCB8fCBkZWZhdWx0VmFsKTtcbiAgICAgICAgJCQxLmVhY2gobywgZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgICAgICByZXQucHVzaChwW3Yudl0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQkMS5lYWNoKG8sIGZ1bmN0aW9uIChpLCB2KSB7XG4gICAgICAgICAgbSA9IG5ldyBSZWdFeHAoJyhcXFxcZCspXFxcXHM/KCcgKyBzLmxhYmVsc1tvYmpbdi52XS5vcmRdICsgJ3wnICsgcy5sYWJlbHNTaG9ydFtvYmpbdi52XS5vcmRdICsgJyknLCAnZ2knKS5leGVjKHZhbCk7XG4gICAgICAgICAgcmV0LnB1c2gobSA/IG1bMV0gOiAwKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgICQkMShyZXQpLmVhY2goZnVuY3Rpb24gKGksIHYpIHtcbiAgICAgICAgLy8gU3RlcHNcbiAgICAgICAgcmV0W2ldID0gc3RlcCh2LCBzdGVwc1tpXSB8fCAxKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuICAgIGZvcm1hdFZhbHVlOiBmdW5jdGlvbiBmb3JtYXRWYWx1ZShkKSB7XG4gICAgICB2YXIgcmV0ID0gJyc7XG4gICAgICAkJDEuZWFjaChvLCBmdW5jdGlvbiAoaSwgdikge1xuICAgICAgICByZXQgKz0gK2RbaV0gPyBkW2ldICsgJyAnICsgb2JqW3Yudl0ubGFiZWwgKyAnICcgOiAnJztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJldCA/IHJldC5yZXBsYWNlKC9cXHMrJC9nLCAnJykgOiAwO1xuICAgIH0sXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uIHZhbGlkYXRlKGRhdGEpIHtcbiAgICAgIHZhciBwLFxuICAgICAgICAgIGksXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgZGlzLFxuICAgICAgICAgIHZhbHVlcyA9IGRhdGEudmFsdWVzLFxuICAgICAgICAgIGRpciA9IGRhdGEuZGlyZWN0aW9uLFxuICAgICAgICAgIGRpc2FibGVkID0gW10sXG4gICAgICAgICAgbWF4cHJvcCA9IHRydWUsXG4gICAgICAgICAgbWlucHJvcCA9IHRydWU7XG4gICAgICAkJDEodW5pcXVlKS5lYWNoKGZ1bmN0aW9uICh4LCB2KSB7XG4gICAgICAgIGlmICh3aGVlbHNbdl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGluZGV4ID0gd2hlZWxzW3ZdIC0gMTtcbiAgICAgICAgICBkaXNhYmxlZFtpbmRleF0gPSBbXTtcbiAgICAgICAgICBkaXMgPSB7fTtcblxuICAgICAgICAgIGlmICh2ICE9IG1heCkge1xuICAgICAgICAgICAgaWYgKG1heHByb3ApIHtcbiAgICAgICAgICAgICAgZm9yIChpID0gbWF4UGFydHNbdl0gKyAxOyBpIDw9IG9ialt2XS51bnRpbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGlzW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWlucHJvcCkge1xuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbWluUGFydHNbdl07IGkrKykge1xuICAgICAgICAgICAgICAgIGRpc1tpXSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gaW5zdC5nZXRWYWxpZFZhbHVlKGluZGV4LCB2YWx1ZXNbaW5kZXhdLCBkaXIsIGRpcyk7XG4gICAgICAgICAgcCA9IGdldFBhcnRzKGNhbGNUaW1lKHZhbHVlcykpO1xuICAgICAgICAgIG1heHByb3AgPSBtYXhwcm9wICYmIHBbdl0gPT0gbWF4UGFydHNbdl07XG4gICAgICAgICAgbWlucHJvcCA9IG1pbnByb3AgJiYgcFt2XSA9PSBtaW5QYXJ0c1t2XTtcbiAgICAgICAgICAkJDEuZWFjaChkaXMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICBkaXNhYmxlZFtpbmRleF0ucHVzaChpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXNhYmxlZDogZGlzYWJsZWRcbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcblxudmFyIE1ic2NUaW1lc3BhbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoTWJzY1RpbWVzcGFuLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWJzY1RpbWVzcGFuKGluaXRpYWxFbGVtZW50LCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIHZpZXcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBpbml0aWFsRWxlbWVudCwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCB2aWV3KSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLm9wdGlvblNlcnZpY2UgPSBvcHRpb25TZXJ2aWNlO1xyXG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSB7fTtcclxuICAgICAgICBfdGhpcy5vbkNoYW5nZUVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1ic2NUaW1lc3Bhbi5wcm90b3R5cGUsIFwidmFsdWVcIiwge1xyXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHYpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXROZXdWYWx1ZVByb3h5KHYpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgTWJzY1RpbWVzcGFuLnByb3RvdHlwZS5zZXROZXdWYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgdmFyIGlubmVyVmFsdWUgPSB0aGlzLmluc3RhbmNlLmdldFZhbCgpO1xyXG4gICAgICAgICAgICBpZiAoaW5uZXJWYWx1ZSAhPT0gdikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodiwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2lucHV0U2VydmljZSAmJiB0aGlzLl9pbnB1dFNlcnZpY2UuaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnB1dFNlcnZpY2UuaW5wdXQuaW5uZXJWYWx1ZSA9IHRoaXMuaW5zdGFuY2UuX3ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1ic2NUaW1lc3Bhbi5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBleHRlbmQkMSh7IHByZXNldDogJ3RpbWVzcGFuJyB9LCB0aGlzLm9wdGlvblNlcnZpY2UgPyB0aGlzLm9wdGlvblNlcnZpY2Uub3B0aW9ucyA6IHt9LCB0aGlzLm9wdGlvbnMsIHRoaXMuaW5saW5lT3B0aW9uc09iaiwgdGhpcy5vcHRpb25FeHRlbnNpb25zKTtcclxuICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IFRpbWVzcGFuKHRoaXMuZWxlbWVudCwgb3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodGhpcy5pbml0aWFsVmFsdWUsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBNYnNjVGltZXNwYW4ucHJvdG90eXBlLCBcImRlZmF1bHRWYWx1ZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBNYnNjVGltZXNwYW4ucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXHJcbiAgICBdLCBNYnNjVGltZXNwYW4ucHJvdG90eXBlLCBcIm1pblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIE1ic2NUaW1lc3Bhbi5wcm90b3R5cGUsIFwic3RlcHNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NUaW1lc3Bhbi5wcm90b3R5cGUsIFwidXNlU2hvcnRMYWJlbHNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1RpbWVzcGFuLnByb3RvdHlwZSwgXCJ3aGVlbE9yZGVyXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgTWJzY1RpbWVzcGFuLnByb3RvdHlwZSwgXCJsYWJlbHNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBNYnNjVGltZXNwYW4ucHJvdG90eXBlLCBcImxhYmVsc1Nob3J0XCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdtYnNjLW9wdGlvbnMnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY1RpbWVzcGFuLnByb3RvdHlwZSwgXCJvcHRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdtYnNjLXRpbWVzcGFuJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOdW1iZXJdKVxyXG4gICAgXSwgTWJzY1RpbWVzcGFuLnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCBudWxsKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE91dHB1dCgnbWJzYy10aW1lc3BhbkNoYW5nZScpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXHJcbiAgICBdLCBNYnNjVGltZXNwYW4ucHJvdG90eXBlLCBcIm9uQ2hhbmdlRW1pdHRlclwiLCB2b2lkIDApO1xyXG4gICAgTWJzY1RpbWVzcGFuID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgRGlyZWN0aXZlKHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdbbWJzYy10aW1lc3Bhbl0nLFxyXG4gICAgICAgICAgICBleHBvcnRBczogJ21vYmlzY3JvbGwnXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgyLCBPcHRpb25hbCgpKSwgX19wYXJhbSgzLCBPcHRpb25hbCgpKSwgX19wYXJhbSg0LCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZSwgTmdDb250cm9sLCBNYnNjSW5wdXRTZXJ2aWNlLCBNYnNjT3B0aW9uc1NlcnZpY2UsIFZpZXdDb250YWluZXJSZWZdKVxyXG4gICAgXSwgTWJzY1RpbWVzcGFuKTtcclxuICAgIHJldHVybiBNYnNjVGltZXNwYW47XHJcbn0oTWJzY1Njcm9sbGVyQmFzZSkpO1xyXG52YXIgTWJzY1RpbWVzcGFuQ29tcG9uZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjVGltZXNwYW5Db21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjVGltZXNwYW5Db21wb25lbnQoaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtLCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIG9wdGlvblNlcnZpY2UsIG51bGwpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZXJyb3JNZXNzYWdlID0gJyc7XHJcbiAgICAgICAgX3RoaXMucGxhY2Vob2xkZXIgPSAnJztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBNYnNjVGltZXNwYW5Db21wb25lbnQucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLm5nQWZ0ZXJWaWV3SW5pdC5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc2V0VGhlbWVDbGFzc2VzKCk7XHJcbiAgICB9O1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnaWNvbicpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjVGltZXNwYW5Db21wb25lbnQucHJvdG90eXBlLCBcImlucHV0SWNvblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnaWNvbi1hbGlnbicpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjVGltZXNwYW5Db21wb25lbnQucHJvdG90eXBlLCBcImljb25BbGlnblwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjVGltZXNwYW5Db21wb25lbnQucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcclxuICAgIF0sIE1ic2NUaW1lc3BhbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiZXJyb3JcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1RpbWVzcGFuQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlcnJvck1lc3NhZ2VcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY1RpbWVzcGFuQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvcHRpb25zXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NUaW1lc3BhbkNvbXBvbmVudC5wcm90b3R5cGUsIFwicGxhY2Vob2xkZXJcIiwgdm9pZCAwKTtcclxuICAgIE1ic2NUaW1lc3BhbkNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnbWJzYy10aW1lc3BhbicsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCcsXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiBJTlBVVF9URU1QTEFURVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIF9fcGFyYW0oMiwgT3B0aW9uYWwoKSksIF9fcGFyYW0oMywgT3B0aW9uYWwoKSksIF9fcGFyYW0oNCwgT3B0aW9uYWwoKSksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBOZ1pvbmUsIE5nQ29udHJvbCwgTWJzY0lucHV0U2VydmljZSwgTWJzY09wdGlvbnNTZXJ2aWNlXSlcclxuICAgIF0sIE1ic2NUaW1lc3BhbkNvbXBvbmVudCk7XHJcbiAgICByZXR1cm4gTWJzY1RpbWVzcGFuQ29tcG9uZW50O1xyXG59KE1ic2NUaW1lc3BhbikpO1xyXG52YXIgTWJzY1RpbWVzcGFuTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1ic2NUaW1lc3Bhbk1vZHVsZSgpIHtcclxuICAgIH1cclxuICAgIE1ic2NUaW1lc3Bhbk1vZHVsZSA9IF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIE5nTW9kdWxlKHtcclxuICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgTWJzY1Njcm9sbGVyQmFzZU1vZHVsZSwgTWJzY0lucHV0TW9kdWxlXSxcclxuICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbTWJzY1RpbWVzcGFuLCBNYnNjVGltZXNwYW5Db21wb25lbnRdLFxyXG4gICAgICAgICAgICBleHBvcnRzOiBbTWJzY1RpbWVzcGFuLCBNYnNjVGltZXNwYW5Db21wb25lbnRdXHJcbiAgICAgICAgfSlcclxuICAgIF0sIE1ic2NUaW1lc3Bhbk1vZHVsZSk7XHJcbiAgICByZXR1cm4gTWJzY1RpbWVzcGFuTW9kdWxlO1xyXG59KCkpO1xuXG52YXIgVHJlZWxpc3QgPSBTY3JvbGxlcjtcbnByZXNldHMudHJlZWxpc3QgPSBMaXN0O1xuXG52YXIgTWJzY1RyZWVsaXN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNYnNjVHJlZWxpc3QsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNYnNjVHJlZWxpc3QoaW5pdGlhbEVsZW1lbnQsIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgdmlldykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGluaXRpYWxFbGVtZW50LCB6b25lLCBjb250cm9sLCBpbnB1dFNlcnZpY2UsIHZpZXcpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMub3B0aW9uU2VydmljZSA9IG9wdGlvblNlcnZpY2U7XHJcbiAgICAgICAgX3RoaXMucGxhY2Vob2xkZXIgPSAnJztcclxuICAgICAgICBfdGhpcy5vcHRpb25zID0ge307XHJcbiAgICAgICAgX3RoaXMub25DaGFuZ2VFbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYnNjVHJlZWxpc3QucHJvdG90eXBlLCBcInZhbHVlXCIsIHtcclxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0TmV3VmFsdWVQcm94eSh2KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE1ic2NUcmVlbGlzdC5wcm90b3R5cGUuaW5pdENvbnRyb2wgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XHJcbiAgICAgICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ3N0cmluZycgJiYgdGFyZ2V0Ll9lbGVtZW50UmVmICYmIHRhcmdldC5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0YXJnZXQuZ2V0SW5wdXRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuZ2V0SW5wdXRFbGVtZW50KCkudGhlbihmdW5jdGlvbiAoaW5wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlT3B0aW9ucyh7IGlucHV0OiBpbnAgfSwgdHJ1ZSwgZmFsc2UsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvcHRpb25zID0gZXh0ZW5kJDEoeyBwcmVzZXQ6ICd0cmVlbGlzdCcsIGlucHV0OiB0YXJnZXQgfSwgdGhpcy5vcHRpb25TZXJ2aWNlID8gdGhpcy5vcHRpb25TZXJ2aWNlLm9wdGlvbnMgOiB7fSwgdGhpcy5vcHRpb25zLCB0aGlzLmlubGluZU9wdGlvbnNPYmosIHRoaXMub3B0aW9uRXh0ZW5zaW9ucyk7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBUcmVlbGlzdCh0aGlzLmVsZW1lbnQsIG9wdGlvbnMpO1xyXG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0VmFsKHRoaXMuaW5pdGlhbFZhbHVlLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1ic2NUcmVlbGlzdC5wcm90b3R5cGUuc2V0TmV3VmFsdWUgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlICYmIHRoaXMuaW5zdGFuY2UuZ2V0VmFsKCkgIT09IHYpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRWYWwodiwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faW5wdXRTZXJ2aWNlICYmIHRoaXMuX2lucHV0U2VydmljZS5pbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW5wdXRTZXJ2aWNlLmlucHV0LmlubmVyVmFsdWUgPSB0aGlzLmluc3RhbmNlLl92YWx1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgTWJzY1RyZWVsaXN0LnByb3RvdHlwZSwgXCJkZWZhdWx0VmFsdWVcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1RyZWVsaXN0LnByb3RvdHlwZSwgXCJpbnB1dENsYXNzXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgTWJzY1RyZWVsaXN0LnByb3RvdHlwZSwgXCJpbnZhbGlkXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxyXG4gICAgXSwgTWJzY1RyZWVsaXN0LnByb3RvdHlwZSwgXCJsYWJlbHNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1RyZWVsaXN0LnByb3RvdHlwZSwgXCJwbGFjZWhvbGRlclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY1RyZWVsaXN0LnByb3RvdHlwZSwgXCJzaG93SW5wdXRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ21ic2MtZGF0YScpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcclxuICAgIF0sIE1ic2NUcmVlbGlzdC5wcm90b3R5cGUsIFwid2hlZWxBcnJheVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnbWJzYy1vcHRpb25zJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcclxuICAgIF0sIE1ic2NUcmVlbGlzdC5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgnbWJzYy10YXJnZXQnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxyXG4gICAgXSwgTWJzY1RyZWVsaXN0LnByb3RvdHlwZSwgXCJ0YXJnZXRcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ21ic2MtdHJlZWxpc3QnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXHJcbiAgICBdLCBNYnNjVHJlZWxpc3QucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgT3V0cHV0KCdtYnNjLXRyZWVsaXN0Q2hhbmdlJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcclxuICAgIF0sIE1ic2NUcmVlbGlzdC5wcm90b3R5cGUsIFwib25DaGFuZ2VFbWl0dGVyXCIsIHZvaWQgMCk7XHJcbiAgICBNYnNjVHJlZWxpc3QgPSBfX2RlY29yYXRlKFtcclxuICAgICAgICBEaXJlY3RpdmUoe1xyXG4gICAgICAgICAgICBzZWxlY3RvcjogJ1ttYnNjLXRyZWVsaXN0XScsXHJcbiAgICAgICAgICAgIGV4cG9ydEFzOiAnbW9iaXNjcm9sbCdcclxuICAgICAgICB9KSxcclxuICAgICAgICBfX3BhcmFtKDIsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDMsIE9wdGlvbmFsKCkpLCBfX3BhcmFtKDQsIE9wdGlvbmFsKCkpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRWxlbWVudFJlZiwgTmdab25lLCBOZ0NvbnRyb2wsIE1ic2NJbnB1dFNlcnZpY2UsIE1ic2NPcHRpb25zU2VydmljZSwgVmlld0NvbnRhaW5lclJlZl0pXHJcbiAgICBdLCBNYnNjVHJlZWxpc3QpO1xyXG4gICAgcmV0dXJuIE1ic2NUcmVlbGlzdDtcclxufShNYnNjU2Nyb2xsZXJCYXNlKSk7XHJcbnZhciBNYnNjVHJlZWxpc3RDb21wb25lbnQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1ic2NUcmVlbGlzdENvbXBvbmVudCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1ic2NUcmVlbGlzdENvbXBvbmVudChpbml0aWFsRWxlbSwgem9uZSwgY29udHJvbCwgaW5wdXRTZXJ2aWNlLCBvcHRpb25TZXJ2aWNlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbEVsZW0sIHpvbmUsIGNvbnRyb2wsIGlucHV0U2VydmljZSwgb3B0aW9uU2VydmljZSwgbnVsbCkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5lcnJvck1lc3NhZ2UgPSAnJztcclxuICAgICAgICBfdGhpcy5wbGFjZWhvbGRlciA9ICcnO1xyXG4gICAgICAgIF90aGlzLnNob3dJbnB1dCA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmlubGluZU9wdGlvbnNPYmogPSB7XHJcbiAgICAgICAgICAgIHNob3dJbnB1dDogZmFsc2VcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIE1ic2NUcmVlbGlzdENvbXBvbmVudC5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUubmdBZnRlclZpZXdJbml0LmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zZXRUaGVtZUNsYXNzZXMoKTtcclxuICAgIH07XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdpY29uJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NUcmVlbGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5wdXRJY29uXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCdpY29uLWFsaWduJyksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NUcmVlbGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiaWNvbkFsaWduXCIsIHZvaWQgMCk7XHJcbiAgICBfX2RlY29yYXRlKFtcclxuICAgICAgICBJbnB1dCQxKCksXHJcbiAgICAgICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcclxuICAgIF0sIE1ic2NUcmVlbGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxyXG4gICAgXSwgTWJzY1RyZWVsaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJlcnJvclwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXHJcbiAgICBdLCBNYnNjVHJlZWxpc3RDb21wb25lbnQucHJvdG90eXBlLCBcImVycm9yTWVzc2FnZVwiLCB2b2lkIDApO1xyXG4gICAgX19kZWNvcmF0ZShbXHJcbiAgICAgICAgSW5wdXQkMSgpLFxyXG4gICAgICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXHJcbiAgICBdLCBNYnNjVHJlZWxpc3RDb21wb25lbnQucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoJ2RhdGEnKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXHJcbiAgICBdLCBNYnNjVHJlZWxpc3RDb21wb25lbnQucHJvdG90eXBlLCBcIndoZWVsQXJyYXlcIiwgdm9pZCAwKTtcclxuICAgIF9fZGVjb3JhdGUoW1xyXG4gICAgICAgIElucHV0JDEoKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxyXG4gICAgXSwgTWJzY1RyZWVsaXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJwbGFjZWhvbGRlclwiLCB2b2lkIDApO1xyXG4gICAgTWJzY1RyZWVsaXN0Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgc2VsZWN0b3I6ICdtYnNjLXRyZWVsaXN0JyxcclxuICAgICAgICAgICAgZXhwb3J0QXM6ICdtb2Jpc2Nyb2xsJyxcclxuICAgICAgICAgICAgdGVtcGxhdGU6IElOUFVUX1RFTVBMQVRFXHJcbiAgICAgICAgfSksXHJcbiAgICAgICAgX19wYXJhbSgyLCBPcHRpb25hbCgpKSwgX19wYXJhbSgzLCBPcHRpb25hbCgpKSwgX19wYXJhbSg0LCBPcHRpb25hbCgpKSxcclxuICAgICAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsIE5nWm9uZSwgTmdDb250cm9sLCBNYnNjSW5wdXRTZXJ2aWNlLCBNYnNjT3B0aW9uc1NlcnZpY2VdKVxyXG4gICAgXSwgTWJzY1RyZWVsaXN0Q29tcG9uZW50KTtcclxuICAgIHJldHVybiBNYnNjVHJlZWxpc3RDb21wb25lbnQ7XHJcbn0oTWJzY1RyZWVsaXN0KSk7XHJcbnZhciBNYnNjVHJlZWxpc3RNb2R1bGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWJzY1RyZWVsaXN0TW9kdWxlKCkge1xyXG4gICAgfVxyXG4gICAgTWJzY1RyZWVsaXN0TW9kdWxlID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgTmdNb2R1bGUoe1xyXG4gICAgICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBNYnNjU2Nyb2xsZXJCYXNlTW9kdWxlLCBNYnNjSW5wdXRNb2R1bGVdLFxyXG4gICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtNYnNjVHJlZWxpc3QsIE1ic2NUcmVlbGlzdENvbXBvbmVudF0sXHJcbiAgICAgICAgICAgIGV4cG9ydHM6IFtNYnNjVHJlZWxpc3QsIE1ic2NUcmVlbGlzdENvbXBvbmVudF1cclxuICAgICAgICB9KVxyXG4gICAgXSwgTWJzY1RyZWVsaXN0TW9kdWxlKTtcclxuICAgIHJldHVybiBNYnNjVHJlZWxpc3RNb2R1bGU7XHJcbn0oKSk7XG5cbnZhciBkaXJlY3RpdmVzID0gW1xyXG4gICAgTWJzY0lucHV0LFxyXG4gICAgTWJzY0NhbGVuZGFyLCBNYnNjQ2FsZW5kYXJDb21wb25lbnQsXHJcbiAgICBNYnNjQ2FyZCwgTWJzY0NhcmRDb21wb25lbnQsIE1ic2NDYXJkQ29udGVudCwgTWJzY0NhcmRGb290ZXIsIE1ic2NDYXJkSGVhZGVyLCBNYnNjQ2FyZFN1YnRpdGxlLCBNYnNjQ2FyZFRpdGxlLFxyXG4gICAgTWJzY0NvbG9yLCBNYnNjQ29sb3JDb21wb25lbnQsXHJcbiAgICBNYnNjRGF0ZSwgTWJzY1RpbWUsIE1ic2NEYXRldGltZSwgTWJzY0RhdGVDb21wb25lbnQsIE1ic2NUaW1lQ29tcG9uZW50LCBNYnNjRGF0ZXRpbWVDb21wb25lbnQsXHJcbiAgICBNYnNjRXZlbnRjYWxlbmRhciwgTWJzY0V2ZW50Y2FsZW5kYXJDb21wb25lbnQsXHJcbiAgICBNYnNjRm9ybSwgTWJzY1JhdGluZywgTWJzY0Ryb3Bkb3duLCBNYnNjVGV4dGFyZWEsIE1ic2NCdXR0b24sIE1ic2NDaGVja2JveCwgTWJzY1N3aXRjaCwgTWJzY1N0ZXBwZXIsIE1ic2NQcm9ncmVzcywgTWJzY1NsaWRlciwgTWJzY1JhZGlvLCBNYnNjUmFkaW9Hcm91cCwgTWJzY1NlZ21lbnRlZEdyb3VwLCBNYnNjU2VnbWVudGVkLCBNYnNjRm9ybUdyb3VwLCBNYnNjRm9ybUdyb3VwVGl0bGUsIE1ic2NGb3JtR3JvdXBDb250ZW50LCBNYnNjQWNjb3JkaW9uLFxyXG4gICAgTWJzY0ltYWdlLCBNYnNjSW1hZ2VDb21wb25lbnQsIE1ic2NJbWFnZUl0ZW0sXHJcbiAgICBNYnNjTGlzdHZpZXcsIE1ic2NMaXN0dmlld1N1Ymxpc3QsIE1ic2NMaXN0dmlld0l0ZW0sIE1ic2NMaXN0dmlld0hlYWRlcixcclxuICAgIE1ic2NNZWFzdXJlbWVudCwgTWJzY0Rpc3RhbmNlLCBNYnNjRm9yY2UsIE1ic2NNYXNzLCBNYnNjU3BlZWQsIE1ic2NUZW1wZXJhdHVyZSwgTWJzY01lYXN1cmVtZW50Q29tcG9uZW50LCBNYnNjVGVtcGVyYXR1cmVDb21wb25lbnQsIE1ic2NGb3JjZUNvbXBvbmVudCwgTWJzY1NwZWVkQ29tcG9uZW50LCBNYnNjTWFzc0NvbXBvbmVudCwgTWJzY0Rpc3RhbmNlQ29tcG9uZW50LFxyXG4gICAgTWJzY05hdiwgTWJzY0JvdHRvbU5hdiwgTWJzY0hhbWJ1cmdlck5hdiwgTWJzY1RhYk5hdiwgTWJzY05hdkl0ZW0sXHJcbiAgICBNYnNjTnVtYmVyLCBNYnNjTnVtYmVyQ29tcG9uZW50LFxyXG4gICAgTWJzY051bXBhZCwgTWJzY051bXBhZERlY2ltYWwsIE1ic2NOdW1wYWREYXRlLCBNYnNjTnVtcGFkVGltZSwgTWJzY051bXBhZFRpbWVzcGFuLCBNYnNjTnVtcGFkQ29tcG9uZW50LCBNYnNjTnVtcGFkRGF0ZUNvbXBvbmVudCwgTWJzY051bXBhZERlY2ltYWxDb21wb25lbnQsIE1ic2NOdW1wYWRUaW1lQ29tcG9uZW50LCBNYnNjTnVtcGFkVGltZXNwYW5Db21wb25lbnQsXHJcbiAgICBNYnNjT3B0aW9ubGlzdCwgTWJzY09wdGlvbkl0ZW0sXHJcbiAgICBNYnNjUGFnZSwgTWJzY05vdGUsIE1ic2NBdmF0YXIsXHJcbiAgICBNYnNjUG9wdXAsIE1ic2NXaWRnZXQsXHJcbiAgICBNYnNjUmFuZ2UsIE1ic2NSYW5nZUNvbXBvbmVudCwgTWJzY1JhbmdlU3RhcnRDb21wb25lbnQsIE1ic2NSYW5nZUVuZENvbXBvbmVudCxcclxuICAgIE1ic2NTY3JvbGxlciwgTWJzY1Njcm9sbGVyQ29tcG9uZW50LFxyXG4gICAgTWJzY1Njcm9sbFZpZXcsIE1ic2NTY3JvbGxWaWV3SXRlbSwgTWJzY1Njcm9sbFZpZXdDb21wb25lbnQsIE1ic2NTY3JvbGxWaWV3SXRlbUNvbXBvbmVudCxcclxuICAgIE1ic2NTZWxlY3QsIE1ic2NTZWxlY3RDb21wb25lbnQsXHJcbiAgICBNYnNjVGltZXIsIE1ic2NUaW1lckNvbXBvbmVudCxcclxuICAgIE1ic2NUaW1lc3BhbiwgTWJzY1RpbWVzcGFuQ29tcG9uZW50LFxyXG4gICAgTWJzY1RyZWVsaXN0LCBNYnNjVHJlZWxpc3RDb21wb25lbnQsXHJcbl07XHJcbnZhciBtb2R1bGVzID0gW1xyXG4gICAgTWJzY0lucHV0TW9kdWxlLFxyXG4gICAgTWJzY0NhbGVuZGFyTW9kdWxlLFxyXG4gICAgTWJzY0NhcmRNb2R1bGUsXHJcbiAgICBNYnNjQ29sb3JNb2R1bGUsXHJcbiAgICBNYnNjRGF0ZXRpbWVNb2R1bGUsXHJcbiAgICBNYnNjRXZlbnRjYWxlbmRhck1vZHVsZSxcclxuICAgIE1ic2NGb3Jtc01vZHVsZSxcclxuICAgIE1ic2NJbWFnZU1vZHVsZSxcclxuICAgIE1ic2NMaXN0dmlld01vZHVsZSxcclxuICAgIE1ic2NNZWFzdXJlbWVudE1vZHVsZSxcclxuICAgIE1ic2NOYXZpZ2F0aW9uTW9kdWxlLFxyXG4gICAgTWJzY051bWJlck1vZHVsZSxcclxuICAgIE1ic2NOdW1wYWRNb2R1bGUsXHJcbiAgICBNYnNjT3B0aW9ubGlzdE1vZHVsZSxcclxuICAgIE1ic2NQYWdlTW9kdWxlLFxyXG4gICAgTWJzY1BvcHVwTW9kdWxlLFxyXG4gICAgTWJzY1JhbmdlTW9kdWxlLFxyXG4gICAgTWJzY1Njcm9sbGVyTW9kdWxlLFxyXG4gICAgTWJzY1Njcm9sbFZpZXdNb2R1bGUsXHJcbiAgICBNYnNjU2VsZWN0TW9kdWxlLFxyXG4gICAgTWJzY1RpbWVyTW9kdWxlLFxyXG4gICAgTWJzY1RpbWVzcGFuTW9kdWxlLFxyXG4gICAgTWJzY1RyZWVsaXN0TW9kdWxlLFxyXG5dO1xyXG52YXIgTWJzY01vZHVsZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNYnNjTW9kdWxlKCkge1xyXG4gICAgfVxyXG4gICAgTWJzY01vZHVsZV8xID0gTWJzY01vZHVsZTtcclxuICAgIE1ic2NNb2R1bGUuZm9yUm9vdCA9IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBuZ01vZHVsZTogTWJzY01vZHVsZV8xLFxyXG4gICAgICAgICAgICBwcm92aWRlcnM6IFt7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogTWJzY1JvdXRlclRva2VuLFxyXG4gICAgICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBjb25maWcuYW5ndWxhclJvdXRlclxyXG4gICAgICAgICAgICAgICAgfV1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIHZhciBNYnNjTW9kdWxlXzE7XHJcbiAgICBNYnNjTW9kdWxlID0gTWJzY01vZHVsZV8xID0gX19kZWNvcmF0ZShbXHJcbiAgICAgICAgTmdNb2R1bGUoe1xyXG4gICAgICAgICAgICBpbXBvcnRzOiBbRm9ybXNNb2R1bGUsIENvbW1vbk1vZHVsZSwgbW9kdWxlc10sXHJcbiAgICAgICAgICAgIGV4cG9ydHM6IFtkaXJlY3RpdmVzLCBtb2R1bGVzXVxyXG4gICAgICAgIH0pXHJcbiAgICBdLCBNYnNjTW9kdWxlKTtcclxuICAgIHJldHVybiBNYnNjTW9kdWxlO1xyXG59KCkpO1xuXG4vLyBBcmFiaWNcblxuZnVuY3Rpb24gaW50UGFydChmbG9hdE51bSkge1xuICBpZiAoZmxvYXROdW0gPCAtMC4wMDAwMDAxKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbChmbG9hdE51bSAtIDAuMDAwMDAwMSk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5mbG9vcihmbG9hdE51bSArIDAuMDAwMDAwMSk7XG59XG5cbmZ1bmN0aW9uIGhpanJpVG9HcmVnb3JpYW4oaFksIGhNLCBoRCkge1xuICBoWSA9IHBhcnNlSW50KGhZKTtcbiAgaE0gPSBwYXJzZUludChoTSk7XG4gIGhEID0gcGFyc2VJbnQoaEQpO1xuICB2YXIgamQsXG4gICAgICBsLFxuICAgICAgaixcbiAgICAgIG4sXG4gICAgICBpLFxuICAgICAgayxcbiAgICAgIGdyZWdEYXRlID0gbmV3IEFycmF5KDMpO1xuICBqZCA9IGludFBhcnQoKDExICogaFkgKyAzKSAvIDMwKSArIDM1NCAqIGhZICsgMzAgKiBoTSAtIGludFBhcnQoKGhNIC0gMSkgLyAyKSArIGhEICsgMTk0ODQ0MCAtIDM4NTtcblxuICBpZiAoamQgPiAyMjk5MTYwKSB7XG4gICAgbCA9IGpkICsgNjg1Njk7XG4gICAgbiA9IGludFBhcnQoNCAqIGwgLyAxNDYwOTcpO1xuICAgIGwgPSBsIC0gaW50UGFydCgoMTQ2MDk3ICogbiArIDMpIC8gNCk7XG4gICAgaSA9IGludFBhcnQoNDAwMCAqIChsICsgMSkgLyAxNDYxMDAxKTtcbiAgICBsID0gbCAtIGludFBhcnQoMTQ2MSAqIGkgLyA0KSArIDMxO1xuICAgIGogPSBpbnRQYXJ0KDgwICogbCAvIDI0NDcpO1xuICAgIGhEID0gbCAtIGludFBhcnQoMjQ0NyAqIGogLyA4MCk7XG4gICAgbCA9IGludFBhcnQoaiAvIDExKTtcbiAgICBoTSA9IGogKyAyIC0gMTIgKiBsO1xuICAgIGhZID0gMTAwICogKG4gLSA0OSkgKyBpICsgbDtcbiAgfSBlbHNlIHtcbiAgICBqID0gamQgKyAxNDAyO1xuICAgIGsgPSBpbnRQYXJ0KChqIC0gMSkgLyAxNDYxKTtcbiAgICBsID0gaiAtIDE0NjEgKiBrO1xuICAgIG4gPSBpbnRQYXJ0KChsIC0gMSkgLyAzNjUpIC0gaW50UGFydChsIC8gMTQ2MSk7XG4gICAgaSA9IGwgLSAzNjUgKiBuICsgMzA7XG4gICAgaiA9IGludFBhcnQoODAgKiBpIC8gMjQ0Nyk7XG4gICAgaEQgPSBpIC0gaW50UGFydCgyNDQ3ICogaiAvIDgwKTtcbiAgICBpID0gaW50UGFydChqIC8gMTEpO1xuICAgIGhNID0gaiArIDIgLSAxMiAqIGk7XG4gICAgaFkgPSA0ICogayArIG4gKyBpIC0gNDcxNjtcbiAgfVxuXG4gIGdyZWdEYXRlWzJdID0gaEQ7XG4gIGdyZWdEYXRlWzFdID0gaE07XG4gIGdyZWdEYXRlWzBdID0gaFk7XG4gIHJldHVybiBncmVnRGF0ZTtcbn1cblxuZnVuY3Rpb24gZ3JlZ29yaWFuVG9IaWpyaShnWSwgZ00sIGdEKSB7XG4gIGdZID0gcGFyc2VJbnQoZ1kpO1xuICBnTSA9IHBhcnNlSW50KGdNKTtcbiAgZ0QgPSBwYXJzZUludChnRCk7XG4gIHZhciBqZCxcbiAgICAgIGwsXG4gICAgICBqLFxuICAgICAgbixcbiAgICAgIGhpanJpRGF0ZSA9IG5ldyBBcnJheSgwLCAwLCAwKTtcblxuICBpZiAoZ1kgPiAxNTgyIHx8IGdZID09IDE1ODIgJiYgZ00gPiAxMCB8fCBnWSA9PSAxNTgyICYmIGdNID09IDEwICYmIGdEID4gMTQpIHtcbiAgICBqZCA9IGludFBhcnQoMTQ2MSAqIChnWSArIDQ4MDAgKyBpbnRQYXJ0KChnTSAtIDE0KSAvIDEyKSkgLyA0KSArIGludFBhcnQoMzY3ICogKGdNIC0gMiAtIDEyICogaW50UGFydCgoZ00gLSAxNCkgLyAxMikpIC8gMTIpIC0gaW50UGFydCgzICogaW50UGFydCgoZ1kgKyA0OTAwICsgaW50UGFydCgoZ00gLSAxNCkgLyAxMikpIC8gMTAwKSAvIDQpICsgZ0QgLSAzMjA3NTtcbiAgfSBlbHNlIHtcbiAgICBqZCA9IDM2NyAqIGdZIC0gaW50UGFydCg3ICogKGdZICsgNTAwMSArIGludFBhcnQoKGdNIC0gOSkgLyA3KSkgLyA0KSArIGludFBhcnQoMjc1ICogZ00gLyA5KSArIGdEICsgMTcyOTc3NztcbiAgfVxuXG4gIGwgPSBqZCAtIDE5NDg0NDAgKyAxMDYzMjtcbiAgbiA9IGludFBhcnQoKGwgLSAxKSAvIDEwNjMxKTtcbiAgbCA9IGwgLSAxMDYzMSAqIG4gKyAzNTQ7XG4gIGogPSBpbnRQYXJ0KCgxMDk4NSAtIGwpIC8gNTMxNikgKiBpbnRQYXJ0KDUwICogbCAvIDE3NzE5KSArIGludFBhcnQobCAvIDU2NzApICogaW50UGFydCg0MyAqIGwgLyAxNTIzOCk7XG4gIGwgPSBsIC0gaW50UGFydCgoMzAgLSBqKSAvIDE1KSAqIGludFBhcnQoMTc3MTkgKiBqIC8gNTApIC0gaW50UGFydChqIC8gMTYpICogaW50UGFydCgxNTIzOCAqIGogLyA0MykgKyAyOTtcbiAgZ00gPSBpbnRQYXJ0KDI0ICogbCAvIDcwOSk7XG4gIGdEID0gbCAtIGludFBhcnQoNzA5ICogZ00gLyAyNCk7XG4gIGdZID0gMzAgKiBuICsgaiAtIDMwO1xuICBoaWpyaURhdGVbMl0gPSBnRDtcbiAgaGlqcmlEYXRlWzFdID0gZ007XG4gIGhpanJpRGF0ZVswXSA9IGdZO1xuICByZXR1cm4gaGlqcmlEYXRlO1xufVxuXG5jYWxlbmRhcnMuaGlqcmkgPSB7XG4gIGdldFllYXI6IGZ1bmN0aW9uIGdldFllYXIoZGF0ZSkge1xuICAgIHJldHVybiBncmVnb3JpYW5Ub0hpanJpKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpICsgMSwgZGF0ZS5nZXREYXRlKCkpWzBdO1xuICB9LFxuICBnZXRNb250aDogZnVuY3Rpb24gZ2V0TW9udGgoZGF0ZSkge1xuICAgIHJldHVybiAtLWdyZWdvcmlhblRvSGlqcmkoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCkgKyAxLCBkYXRlLmdldERhdGUoKSlbMV07XG4gIH0sXG4gIGdldERheTogZnVuY3Rpb24gZ2V0RGF5KGRhdGUpIHtcbiAgICByZXR1cm4gZ3JlZ29yaWFuVG9IaWpyaShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSArIDEsIGRhdGUuZ2V0RGF0ZSgpKVsyXTtcbiAgfSxcbiAgZ2V0RGF0ZTogZnVuY3Rpb24gZ2V0RGF0ZSh5LCBtLCBkLCBoLCBpLCBzLCB1KSB7XG4gICAgaWYgKG0gPCAwKSB7XG4gICAgICB5ICs9IE1hdGguZmxvb3IobSAvIDEyKTtcbiAgICAgIG0gPSBtICUgMTIgPyAxMiArIG0gJSAxMiA6IDA7XG4gICAgfVxuXG4gICAgaWYgKG0gPiAxMSkge1xuICAgICAgeSArPSBNYXRoLmZsb29yKG0gLyAxMik7XG4gICAgICBtID0gbSAlIDEyO1xuICAgIH1cblxuICAgIHZhciBncmVnb3JpYW5EYXRlID0gaGlqcmlUb0dyZWdvcmlhbih5LCArbSArIDEsIGQpO1xuICAgIHJldHVybiBuZXcgRGF0ZShncmVnb3JpYW5EYXRlWzBdLCBncmVnb3JpYW5EYXRlWzFdIC0gMSwgZ3JlZ29yaWFuRGF0ZVsyXSwgaCB8fCAwLCBpIHx8IDAsIHMgfHwgMCwgdSB8fCAwKTtcbiAgfSxcbiAgZ2V0TWF4RGF5T2ZNb250aDogZnVuY3Rpb24gZ2V0TWF4RGF5T2ZNb250aChoWSwgaE0pIHtcbiAgICBpZiAoaE0gPCAwKSB7XG4gICAgICBoWSArPSBNYXRoLmZsb29yKGhNIC8gMTIpO1xuICAgICAgaE0gPSBoTSAlIDEyID8gMTIgKyBoTSAlIDEyIDogMDtcbiAgICB9XG5cbiAgICBpZiAoaE0gPiAxMSkge1xuICAgICAgaFkgKz0gTWF0aC5mbG9vcihoTSAvIDEyKTtcbiAgICAgIGhNID0gaE0gJSAxMjtcbiAgICB9XG5cbiAgICB2YXIgZGF5c1Blck1vbnRoID0gWzMwLCAyOSwgMzAsIDI5LCAzMCwgMjksIDMwLCAyOSwgMzAsIDI5LCAzMCwgMjldLFxuICAgICAgICBsZWFwWWVhciA9IChoWSAqIDExICsgMTQpICUgMzAgPCAxMTtcbiAgICByZXR1cm4gZGF5c1Blck1vbnRoW2hNXSArIChoTSA9PT0gMTEgJiYgbGVhcFllYXIgPyAxIDogMCk7XG4gIH1cbn07XG5cbi8vIEFyYWJpY1xubW9iaXNjcm9sbC5pMThuLmFyID0ge1xuICAvLyBDb3JlXG4gIHJ0bDogdHJ1ZSxcbiAgLy8gUmlnaHQgdG8gbGVmdCBtb2RlXG4gIHNldFRleHQ6ICfYqti52YrZitmGJyxcbiAgY2FuY2VsVGV4dDogJ9il2YTYutin2KEnLFxuICBjbGVhclRleHQ6ICfZhdiz2K0nLFxuICBzZWxlY3RlZFRleHQ6ICd7Y291bnR9INin2YTZhdit2K/YrycsXG4gIC8vIERhdGV0aW1lIGNvbXBvbmVudFxuICBkYXRlRm9ybWF0OiAnZGQvbW0veXknLFxuICBkYXlOYW1lczogWyfYp9mE2KPYrdivJywgJ9in2YTYp9ir2YbZitmGJywgJ9in2YTYq9mE2KfYq9in2KEnLCAn2KfZhNij2LHYqNi52KfYoScsICfYp9mE2K7ZhdmK2LMnLCAn2KfZhNis2YXYudipJywgJ9in2YTYs9io2KonXSxcbiAgZGF5TmFtZXNTaG9ydDogWyfYo9it2K8nLCAn2KfYq9mG2YrZhicsICfYq9mE2KfYq9in2KEnLCAn2KPYsdio2LnYp9ihJywgJ9iu2YXZitizJywgJ9is2YXYudipJywgJ9iz2KjYqiddLFxuICBkYXlOYW1lc01pbjogWyfYrScsICfZhicsICfYqycsICfYsScsICfYricsICfYrCcsICfYsyddLFxuICBkYXlUZXh0OiAn2YrZiNmFJyxcbiAgaG91clRleHQ6ICfYs9in2LnYp9iqJyxcbiAgbWludXRlVGV4dDogJ9in2YTYr9mC2KfYptmCJyxcbiAgbW9udGhOYW1lczogWyfZitmG2KfZitixJywgJ9mB2KjYsdin2YrYsScsICfZhdin2LHYsycsICfYp9io2LHZitmEJywgJ9mF2KfZitmIJywgJ9mK2YjZhtmK2YgnLCAn2YrZiNmE2YrZiCcsICfYo9i62LPYt9izJywgJ9iz2KjYqtmF2KjYsScsICfYo9mD2KrZiNio2LEnLCAn2YbZiNmB2YXYqNixJywgJ9iv2YrYs9mF2KjYsSddLFxuICBtb250aE5hbWVzU2hvcnQ6IFsn2YrZhtin2YrYsScsICfZgdio2LHYp9mK2LEnLCAn2YXYp9ix2LMnLCAn2KfYqNix2YrZhCcsICfZhdin2YrZiCcsICfZitmI2YbZitmIJywgJ9mK2YjZhNmK2YgnLCAn2KPYutiz2LfYsycsICfYs9io2KrZhdio2LEnLCAn2KPZg9iq2YjYqNixJywgJ9mG2YjZgdmF2KjYsScsICfYr9mK2LPZhdio2LEnXSxcbiAgbW9udGhUZXh0OiAn2LTZh9ixJyxcbiAgc2VjVGV4dDogJ9ir2YjYp9mG2YonLFxuICBhbVRleHQ6ICfYtScsXG4gIHBtVGV4dDogJ9mFJyxcbiAgdGltZUZvcm1hdDogJ2hoOmlpIEEnLFxuICB5ZWFyVGV4dDogJ9i52KfZhScsXG4gIG5vd1RleHQ6ICfYp9mE2KLZhicsXG4gIC8vIENhbGVuZGFyIGNvbXBvbmVudFxuICBmaXJzdERheTogMCxcbiAgZGF0ZVRleHQ6ICfYqtin2LHZitiuJyxcbiAgdGltZVRleHQ6ICfZiNmC2KonLFxuICBjbG9zZVRleHQ6ICfYpdi62YTYp9mCJyxcbiAgdG9kYXlUZXh0OiAn2KfZhNmK2YjZhScsXG4gIHByZXZNb250aFRleHQ6ICfYp9mE2LTZh9ixINin2YTYs9in2KjZgicsXG4gIG5leHRNb250aFRleHQ6ICfYp9mE2LTZh9ixINin2YTZgtin2K/ZhScsXG4gIHByZXZZZWFyVGV4dDogJ9in2YTYs9mG2Ycg2KfZhNiz2KfYqNmC2KknLFxuICBuZXh0WWVhclRleHQ6ICfYp9mE2LnYp9mFINin2YTZgtin2K/ZhScsXG4gIGFsbERheVRleHQ6ICfYp9mE2YrZiNmFINmD2YTZhycsXG4gIG5vRXZlbnRzVGV4dDogJ9mE2Kcg2KrZiNis2K8g2KfYrdiv2KfYqycsXG4gIC8vIEV2ZW50IGNhbGVuZGFyXG4gIGV2ZW50VGV4dDogJ9in2YTYrdiv2KsnLFxuICBldmVudHNUZXh0OiAn2KPYrdiv2KfYqycsXG4gIG1vcmVFdmVudHNUZXh0OiAn2YjYp9it2K8g2KLYrtixJyxcbiAgbW9yZUV2ZW50c1BsdXJhbFRleHQ6ICfYp9ir2YbYp9mGINii2K7Ysdin2YYge2NvdW50fScsXG4gIC8vIERhdGVyYW5nZSBjb21wb25lbnRcbiAgZnJvbVRleHQ6ICfZitio2K/YpycsXG4gIHRvVGV4dDogJ9mK2YbYqtmH2YonLFxuICAvLyBNZWFzdXJlbWVudCBjb21wb25lbnRzXG4gIHdob2xlVGV4dDogJ9mD2KfZhdmEJyxcbiAgZnJhY3Rpb25UZXh0OiAn2KzYstihJyxcbiAgdW5pdFRleHQ6ICfZiNit2K/YqScsXG4gIC8vIE51bXBhZCBkYXRlXG4gIGRlbGltaXRlcjogJy8nLFxuICAvLyBOdW1wYWQgZGVjaW1hbFxuICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXG4gIHRob3VzYW5kc1NlcGFyYXRvcjogJywnLFxuICAvLyBUaW1lciAvIFRpbWVzcGFuIGNvbXBvbmVudFxuICBsYWJlbHM6IFsn2LPZhtmI2KfYqicsICfYo9i02YfYsScsICfYo9mK2KfZhScsICfYs9in2LnYqScsICfYr9mC2KfYptmCJywgJ9ir2YjYp9mG2YonLCAnJ10sXG4gIGxhYmVsc1Nob3J0OiBbJ9iz2YbZiNin2KonLCAn2KPYtNmH2LEnLCAn2KPZitin2YUnLCAn2LPYp9i52KknLCAn2K/Zgtin2KbZgicsICfYq9mI2KfZhtmKJywgJyddLFxuICAvLyBUaW1lciBjb21wb25lbnRcbiAgc3RhcnRUZXh0OiAn2KjYr9ihJyxcbiAgc3RvcFRleHQ6ICfYpdmK2YLYp9mBJyxcbiAgcmVzZXRUZXh0OiAn2KXYudin2K/YqSDYttio2LcnLFxuICBsYXBUZXh0OiAn2KfZhNiv2YjYsdipJyxcbiAgaGlkZVRleHQ6ICfYpdiu2YHYp9ihJyxcbiAgLy8gRm9ybXNcbiAgb2ZmVGV4dDogJ9il2YrZgtin2YEnLFxuICBvblRleHQ6ICfYqti02LrZitmEJyxcbiAgLy8gTGlzdHZpZXdcbiAgYmFja1RleHQ6ICfYsdis2YjYuScsXG4gIHVuZG9UZXh0OiAn2KrYsdin2KzYuSdcbn07XG5cbnZhciB0aGVtZXMkMSA9IG1vYmlzY3JvbGwudGhlbWVzO1xudGhlbWVzJDEuZnJhbWUuaW9zID0ge1xuICBkaXNwbGF5OiAnYm90dG9tJyxcbiAgLy8gZnJhbWVcbiAgaGVhZGVyVGV4dDogZmFsc2UsXG4gIC8vIGZyYW1lXG4gIGJ0bldpZHRoOiBmYWxzZSxcbiAgLy8gZnJhbWVcbiAgZGVsZXRlSWNvbjogJ2lvcy1iYWNrc3BhY2UnLFxuICAvLyBudW1wYWRcbiAgc2Nyb2xsM2Q6IG9zICE9ICd3cCcgJiYgKG9zICE9ICdhbmRyb2lkJyB8fCBtYWpvclZlcnNpb24gPiA3KVxufTtcbnRoZW1lcyQxLnNjcm9sbGVyLmlvcyA9IGV4dGVuZCQxKHt9LCB0aGVtZXMkMS5mcmFtZS5pb3MsIHtcbiAgcm93czogNSxcbiAgLy8gc2Nyb2xsZXJcbiAgaGVpZ2h0OiAzNCxcbiAgLy8gc2Nyb2xsZXJcbiAgbWluV2lkdGg6IDU1LFxuICAvLyBzY3JvbGxlclxuICBzZWxlY3RlZExpbmVIZWlnaHQ6IHRydWUsXG4gIC8vIHNjcm9sbGVyXG4gIHNlbGVjdGVkTGluZUJvcmRlcjogMSxcbiAgLy8gc2Nyb2xsZXJcbiAgc2hvd0xhYmVsOiBmYWxzZSxcbiAgLy8gc2Nyb2xsZXJcbiAgdXNlU2hvcnRMYWJlbHM6IHRydWUsXG4gIC8vIHRpbWVzcGFuL3RpbWVyXG4gIGJ0blBsdXNDbGFzczogJ21ic2MtaWMgbWJzYy1pYy1hcnJvdy1kb3duNScsXG4gIC8vIHNjcm9sbGVyXG4gIGJ0bk1pbnVzQ2xhc3M6ICdtYnNjLWljIG1ic2MtaWMtYXJyb3ctdXA1JyxcbiAgLy8gc2Nyb2xsZXJcbiAgY2hlY2tJY29uOiAnaW9uLWlvczctY2hlY2ttYXJrLWVtcHR5JyxcbiAgLy8gc2VsZWN0XG4gIGZpbHRlckNsZWFySWNvbjogJ2lvbi1jbG9zZS1jaXJjbGVkJyxcbiAgLy8gc2VsZWN0XG4gIGRhdGVEaXNwbGF5OiAnTU1keXknLFxuICAvLyBkYXRlXG4gIGJ0bkNhbFByZXZDbGFzczogJ21ic2MtaWMgbWJzYy1pYy1hcnJvdy1sZWZ0NScsXG4gIC8vIGNhbGVuZGFyXG4gIGJ0bkNhbE5leHRDbGFzczogJ21ic2MtaWMgbWJzYy1pYy1hcnJvdy1yaWdodDUnIC8vIGNhbGVuZGFyXG5cbn0pO1xudGhlbWVzJDEubGlzdHZpZXcuaW9zID0ge1xuICBsZWZ0QXJyb3dDbGFzczogJ21ic2MtaWMtaW9uLWlvczctYXJyb3ctYmFjaycsXG4gIHJpZ2h0QXJyb3dDbGFzczogJ21ic2MtaWMtaW9uLWlvczctYXJyb3ctZm9yd2FyZCdcbn07XG50aGVtZXMkMS5mb3JtLmlvcyA9IHt9O1xuXG52YXIgdGhlbWVzJDIgPSBtb2Jpc2Nyb2xsLnRoZW1lcztcbnRoZW1lcyQyLmZyYW1lLmJvb3RzdHJhcCA9IHtcbiAgZGlzYWJsZWRDbGFzczogJ2Rpc2FibGVkJyxcbiAgc2VsZWN0ZWRDbGFzczogJ2J0bi1wcmltYXJ5JyxcbiAgc2VsZWN0ZWRUYWJDbGFzczogJ2FjdGl2ZScsXG4gIHRhYkxpbms6IHRydWUsXG4gIHRvZGF5Q2xhc3M6ICd0ZXh0LXByaW1hcnkgbWJzYy1jYWwtdG9kYXknLFxuICBvbk1hcmt1cEluc2VydGVkOiBmdW5jdGlvbiBvbk1hcmt1cEluc2VydGVkKGV2KSB7XG4gICAgdmFyIGR3ID0gJCQxKGV2LnRhcmdldCksXG4gICAgICAgIGNhbFRhYnMgPSAkJDEoJy5tYnNjLWNhbC10YWJzJywgZHcpO1xuICAgICQkMSgnLm1ic2MtZnItcG9wdXAnLCBkdykuYWRkQ2xhc3MoJ3BvcG92ZXInKTtcbiAgICAkJDEoJy5tYnNjLWZyLXcnLCBkdykuYWRkQ2xhc3MoJ3BvcG92ZXItY29udGVudCcpO1xuICAgICQkMSgnLm1ic2MtZnItaGRyJywgZHcpLmFkZENsYXNzKCdwb3BvdmVyLXRpdGxlIHBvcG92ZXItaGVhZGVyJyk7XG4gICAgJCQxKCcubWJzYy1mci1hcnItaScsIGR3KS5hZGRDbGFzcygncG9wb3ZlcicpO1xuICAgICQkMSgnLm1ic2MtZnItYXJyJywgZHcpLmFkZENsYXNzKCdhcnJvdycpO1xuICAgICQkMSgnLm1ic2MtZnItYnRuJywgZHcpLmFkZENsYXNzKCdidG4gYnRuLWRlZmF1bHQgYnRuLXNlY29uZGFyeScpO1xuICAgICQkMSgnLm1ic2MtZnItYnRuLXMgLm1ic2MtZnItYnRuJywgZHcpLnJlbW92ZUNsYXNzKCdidG4tZGVmYXVsdCBidG4tc2Vjb25kYXJ5JykuYWRkQ2xhc3MoJ2J0biBidG4tcHJpbWFyeScpOyAvLyBDYWxlbmRhciB0YWJzXG5cbiAgICBjYWxUYWJzLmFkZENsYXNzKCduYXYgbmF2LXRhYnMnKTtcbiAgICBjYWxUYWJzLmZpbmQoJy5tYnNjLWNhbC10YWInKS5hZGRDbGFzcygnbmF2LWl0ZW0nKTsgLy8gNC54XG5cbiAgICBjYWxUYWJzLmZpbmQoJ2EnKS5hZGRDbGFzcygnbmF2LWxpbmsnKTsgLy8gNC54XG5cbiAgICBjYWxUYWJzLmZpbmQoJy5tYnNjLWNhbC10YWIuYWN0aXZlIC5uYXYtbGluaycpLmFkZENsYXNzKCdhY3RpdmUnKTsgLy8gNC54XG4gICAgLy8gQ2FsZW5kYXIgeWVhci9tb250aCBzZWxlY3RvclxuXG4gICAgJCQxKCcubWJzYy1jYWwtcGlja2VyJywgZHcpLmFkZENsYXNzKCdwb3BvdmVyJyk7IC8vIFJhbmdlcGlja2VyIHN0YXJ0L2VuZCBidXR0b25zXG5cbiAgICAkJDEoJy5tYnNjLXJhbmdlLWJ0bicsIGR3KS5hZGRDbGFzcygnYnRuIGJ0bi1zbSBidG4tc21hbGwgYnRuLWRlZmF1bHQnKTsgLy8gTnVtcGFkIFxuXG4gICAgJCQxKCcubWJzYy1ucC1idG4nLCBkdykuYWRkQ2xhc3MoJ2J0biBidG4tZGVmYXVsdCcpOyAvLyBTZWxlY3QgZmlsdGVyXG5cbiAgICAkJDEoJy5tYnNjLXNlbC1maWx0ZXItY29udCcsIGR3KS5yZW1vdmVDbGFzcygnbWJzYy1pbnB1dCcpO1xuICAgICQkMSgnLm1ic2Mtc2VsLWZpbHRlci1pbnB1dCcsIGR3KS5hZGRDbGFzcygnZm9ybS1jb250cm9sJyk7XG4gIH0sXG4gIG9uVGFiQ2hhbmdlOiBmdW5jdGlvbiBvblRhYkNoYW5nZShldiwgaW5zdCkge1xuICAgICQkMSgnLm1ic2MtY2FsLXRhYnMgLm5hdi1saW5rJywgaW5zdC5fbWFya3VwKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgJCQxKCcubWJzYy1jYWwtdGFiLmFjdGl2ZSAubmF2LWxpbmsnLCBpbnN0Ll9tYXJrdXApLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgfSxcbiAgb25Qb3NpdGlvbjogZnVuY3Rpb24gb25Qb3NpdGlvbihldikge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgJCQxKCcubWJzYy1mci1idWJibGUtdG9wLCAubWJzYy1mci1idWJibGUtdG9wIC5tYnNjLWZyLWFyci1pJywgZXYudGFyZ2V0KS5yZW1vdmVDbGFzcygnYm90dG9tIGJzLXBvcG92ZXItYm90dG9tJykuYWRkQ2xhc3MoJ3RvcCBicy1wb3BvdmVyLXRvcCcpO1xuICAgICAgJCQxKCcubWJzYy1mci1idWJibGUtYm90dG9tLCAubWJzYy1mci1idWJibGUtYm90dG9tIC5tYnNjLWZyLWFyci1pJywgZXYudGFyZ2V0KS5yZW1vdmVDbGFzcygndG9wIGJzLXBvcG92ZXItdG9wJykuYWRkQ2xhc3MoJ2JvdHRvbSAgYnMtcG9wb3Zlci1ib3R0b20nKTtcbiAgICB9LCAxMCk7XG4gIH1cbn07XG50aGVtZXMkMi5zY3JvbGxlci5ib290c3RyYXAgPSBleHRlbmQkMSh7fSwgdGhlbWVzJDIuZnJhbWUuYm9vdHN0cmFwLCB7XG4gIGRhdGVEaXNwbGF5OiAnTWRkeXknLFxuICBidG5DYWxQcmV2Q2xhc3M6ICdtYnNjLWljIG1ic2MtaWMtYXJyb3ctbGVmdDUnLFxuICAvLyBjYWxlbmRhclxuICBidG5DYWxOZXh0Q2xhc3M6ICdtYnNjLWljIG1ic2MtaWMtYXJyb3ctcmlnaHQ1JyxcbiAgLy8gY2FsZW5kYXJcbiAgYnRuUGx1c0NsYXNzOiAnbWJzYy1pYyBtYnNjLWljLWFycm93LWRvd241IGJ0bi1saWdodCcsXG4gIC8vIHNjcm9sbGVyXG4gIGJ0bk1pbnVzQ2xhc3M6ICdtYnNjLWljIG1ic2MtaWMtYXJyb3ctdXA1IGJ0bi1saWdodCcsXG4gIC8vIHNjcm9sbGVyXG4gIHNlbGVjdGVkTGluZUhlaWdodDogdHJ1ZSxcbiAgb25FdmVudEJ1YmJsZVNob3c6IGZ1bmN0aW9uIG9uRXZlbnRCdWJibGVTaG93KGV2KSB7XG4gICAgdmFyIGV2YyA9ICQkMShldi5ldmVudExpc3QpO1xuICAgICQkMSgnLm1ic2MtY2FsLWV2ZW50LWxpc3QnLCBldmMpLmFkZENsYXNzKCdsaXN0LWdyb3VwJyk7XG4gICAgJCQxKCcubWJzYy1jYWwtZXZlbnQnLCBldmMpLmFkZENsYXNzKCdsaXN0LWdyb3VwLWl0ZW0nKTtcbiAgfVxufSk7XG50aGVtZXMkMi5uYXZpZ2F0aW9uLmJvb3RzdHJhcCA9IHtcbiAgd3JhcHBlckNsYXNzOiAncG9wb3ZlciBwYW5lbCBwYW5lbC1kZWZhdWx0JyxcbiAgZ3JvdXBDbGFzczogJ2J0bi1ncm91cCcsXG4gIGFjdGl2ZUNsYXNzOiAnYnRuLXByaW1hcnknLFxuICBkaXNhYmxlZENsYXNzOiAnZGlzYWJsZWQnLFxuICBpdGVtQ2xhc3M6ICdidG4gYnRuLWRlZmF1bHQnXG59O1xudGhlbWVzJDIuZm9ybS5ib290c3RyYXAgPSB7fTtcblxubW9iaXNjcm9sbC5jdXN0b21UaGVtZSgnbW9iaXNjcm9sbC1kYXJrJywgJ21vYmlzY3JvbGwnKTtcblxuZnVuY3Rpb24gX2FkZFJpcHBsZSgkY29udHJvbCwgZXYpIHtcbiAgdmFyIHggPSBnZXRDb29yZChldiwgJ1gnLCB0cnVlKSxcbiAgICAgIHkgPSBnZXRDb29yZChldiwgJ1knLCB0cnVlKSxcbiAgICAgIGNvbnRyb2wgPSAkY29udHJvbFswXSxcbiAgICAgIHJlY3QgPSAkY29udHJvbC5vZmZzZXQoKSxcbiAgICAgIGxlZnQgPSB4IC0gcmVjdC5sZWZ0LFxuICAgICAgdG9wID0geSAtIHJlY3QudG9wLFxuICAgICAgd2lkdGggPSBNYXRoLm1heChsZWZ0LCBjb250cm9sLm9mZnNldFdpZHRoIC0gbGVmdCksXG4gICAgICBoZWlnaHQgPSBNYXRoLm1heCh0b3AsIGNvbnRyb2wub2Zmc2V0SGVpZ2h0IC0gdG9wKSxcbiAgICAgIHNpemUgPSAyICogTWF0aC5zcXJ0KE1hdGgucG93KHdpZHRoLCAyKSArIE1hdGgucG93KGhlaWdodCwgMikpO1xuXG4gIF9yZW1vdmVSaXBwbGUoJHJpcHBsZSk7XG5cbiAgJHJpcHBsZSA9ICQkMSgnPHNwYW4gY2xhc3M9XCJtYnNjLXJpcHBsZVwiPjwvc3Bhbj4nKS5jc3Moe1xuICAgIGJhY2tncm91bmRDb2xvcjogZ2V0Q29tcHV0ZWRTdHlsZShjb250cm9sKS5jb2xvcixcbiAgICB3aWR0aDogc2l6ZSxcbiAgICBoZWlnaHQ6IHNpemUsXG4gICAgdG9wOiB5IC0gcmVjdC50b3AgLSBzaXplIC8gMixcbiAgICBsZWZ0OiB4IC0gcmVjdC5sZWZ0IC0gc2l6ZSAvIDJcbiAgfSkuYXBwZW5kVG8oJGNvbnRyb2wpO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAkcmlwcGxlLmFkZENsYXNzKCdtYnNjLXJpcHBsZS1zY2FsZWQgbWJzYy1yaXBwbGUtdmlzaWJsZScpO1xuICB9LCAxMCk7XG59XG5cbmZ1bmN0aW9uIF9yZW1vdmVSaXBwbGUoJHIpIHtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCRyKSB7XG4gICAgICAkci5yZW1vdmVDbGFzcygnbWJzYy1yaXBwbGUtdmlzaWJsZScpO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICRyLnJlbW92ZSgpO1xuICAgICAgfSwgMjAwMCk7XG4gICAgfVxuICB9LCAxMDApO1xufVxuXG5mdW5jdGlvbiBpbml0UmlwcGxlKCRtYXJrdXAsIHNlbGVjdG9yLCBkaXNhYmxlZCwgbm9obCkge1xuICB2YXIgc3RhcnRYLFxuICAgICAgc3RhcnRZLFxuICAgICAgbWFya3VwID0gJG1hcmt1cFswXTtcblxuICBmdW5jdGlvbiBvblN0YXJ0KGV2KSB7XG4gICAgdmFyIHRhcmdldCA9IGNsb3Nlc3QobWFya3VwLCBldi50YXJnZXQsIHNlbGVjdG9yKTtcblxuICAgIGlmICh0YXJnZXQgJiYgdGVzdFRvdWNoKGV2LCB0YXJnZXQpKSB7XG4gICAgICBzdGFydFggPSBnZXRDb29yZChldiwgJ1gnKTtcbiAgICAgIHN0YXJ0WSA9IGdldENvb3JkKGV2LCAnWScpO1xuICAgICAgJGFjdGl2ZSQxID0gJCQxKHRhcmdldCk7XG5cbiAgICAgIGlmICghJGFjdGl2ZSQxLmhhc0NsYXNzKGRpc2FibGVkKSAmJiAhJGFjdGl2ZSQxLmhhc0NsYXNzKG5vaGwpKSB7XG4gICAgICAgIF9hZGRSaXBwbGUoJGFjdGl2ZSQxLCBldik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkYWN0aXZlJDEgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uTW92ZShldikge1xuICAgIGlmICgkYWN0aXZlJDEgJiYgTWF0aC5hYnMoZ2V0Q29vcmQoZXYsICdYJykgLSBzdGFydFgpID4gOSB8fCBNYXRoLmFicyhnZXRDb29yZChldiwgJ1knKSAtIHN0YXJ0WSkgPiA5KSB7XG4gICAgICBfcmVtb3ZlUmlwcGxlKCRyaXBwbGUpO1xuXG4gICAgICAkYWN0aXZlJDEgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRW5kKCkge1xuICAgIGlmICgkYWN0aXZlJDEpIHtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfcmVtb3ZlUmlwcGxlKCRyaXBwbGUpO1xuICAgICAgfSwgMTAwKTtcbiAgICAgICRhY3RpdmUkMSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1hcmt1cCkge1xuICAgIGlmIChtYXJrdXAuX19tYnNjUmlwcGxlT2ZmKSB7XG4gICAgICBtYXJrdXAuX19tYnNjUmlwcGxlT2ZmKCk7XG4gICAgfVxuXG4gICAgbGlzdGVuKG1hcmt1cCwgJ3RvdWNoc3RhcnQnLCBvblN0YXJ0LCB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG4gICAgbGlzdGVuKG1hcmt1cCwgJ21vdXNlZG93bicsIG9uU3RhcnQpO1xuICAgIGxpc3RlbihtYXJrdXAsICd0b3VjaG1vdmUnLCBvbk1vdmUsIHtcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICBsaXN0ZW4obWFya3VwLCAnbW91c2Vtb3ZlJywgb25Nb3ZlKTtcbiAgICBsaXN0ZW4obWFya3VwLCAndG91Y2hlbmQnLCBvbkVuZCk7XG4gICAgbGlzdGVuKG1hcmt1cCwgJ3RvdWNoY2FuY2VsJywgb25FbmQpO1xuICAgIGxpc3RlbihtYXJrdXAsICdtb3VzZWxlYXZlJywgb25FbmQpO1xuICAgIGxpc3RlbihtYXJrdXAsICdtb3VzZXVwJywgb25FbmQpO1xuXG4gICAgbWFya3VwLl9fbWJzY1JpcHBsZU9mZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHVubGlzdGVuKG1hcmt1cCwgJ3RvdWNoc3RhcnQnLCBvblN0YXJ0LCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdW5saXN0ZW4obWFya3VwLCAnbW91c2Vkb3duJywgb25TdGFydCk7XG4gICAgICB1bmxpc3RlbihtYXJrdXAsICd0b3VjaG1vdmUnLCBvbk1vdmUsIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB1bmxpc3RlbihtYXJrdXAsICdtb3VzZW1vdmUnLCBvbk1vdmUpO1xuICAgICAgdW5saXN0ZW4obWFya3VwLCAndG91Y2hlbmQnLCBvbkVuZCk7XG4gICAgICB1bmxpc3RlbihtYXJrdXAsICd0b3VjaGNhbmNlbCcsIG9uRW5kKTtcbiAgICAgIHVubGlzdGVuKG1hcmt1cCwgJ21vdXNlbGVhdmUnLCBvbkVuZCk7XG4gICAgICB1bmxpc3RlbihtYXJrdXAsICdtb3VzZXVwJywgb25FbmQpO1xuICAgICAgZGVsZXRlIG1hcmt1cC5fX21ic2NSaXBwbGVPZmY7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgJGFjdGl2ZSQxLFxuICAgICRyaXBwbGUsXG4gICAgdGhlbWVzJDMgPSBtb2Jpc2Nyb2xsLnRoZW1lcztcbnRoZW1lcyQzLmZyYW1lLm1hdGVyaWFsID0ge1xuICBoZWFkZXJUZXh0OiBmYWxzZSxcbiAgYnRuV2lkdGg6IGZhbHNlLFxuICBkZWxldGVJY29uOiAnbWF0ZXJpYWwtYmFja3NwYWNlJyxcbiAgb25NYXJrdXBSZWFkeTogZnVuY3Rpb24gb25NYXJrdXBSZWFkeShldikge1xuICAgIGluaXRSaXBwbGUoJCQxKGV2LnRhcmdldCksICcubWJzYy1mci1idG4tZScsICdtYnNjLWRpc2FibGVkJywgJ21ic2MtZnItYnRuLW5obCcpO1xuICB9XG59O1xudGhlbWVzJDMuc2Nyb2xsZXIubWF0ZXJpYWwgPSBleHRlbmQkMSh7fSwgdGhlbWVzJDMuZnJhbWUubWF0ZXJpYWwsIHtcbiAgc2hvd0xhYmVsOiBmYWxzZSxcbiAgc2VsZWN0ZWRMaW5lQm9yZGVyOiAyLFxuICB3ZWVrRGF5czogJ21pbicsXG4gIGljb246IHtcbiAgICBmaWxsZWQ6ICdtYXRlcmlhbC1zdGFyJyxcbiAgICBlbXB0eTogJ21hdGVyaWFsLXN0YXItb3V0bGluZSdcbiAgfSxcbiAgY2hlY2tJY29uOiAnbWF0ZXJpYWwtY2hlY2snLFxuICBidG5QbHVzQ2xhc3M6ICdtYnNjLWljIG1ic2MtaWMtbWF0ZXJpYWwta2V5Ym9hcmQtYXJyb3ctZG93bicsXG4gIGJ0bk1pbnVzQ2xhc3M6ICdtYnNjLWljIG1ic2MtaWMtbWF0ZXJpYWwta2V5Ym9hcmQtYXJyb3ctdXAnLFxuICBidG5DYWxQcmV2Q2xhc3M6ICdtYnNjLWljIG1ic2MtaWMtbWF0ZXJpYWwta2V5Ym9hcmQtYXJyb3ctbGVmdCcsXG4gIGJ0bkNhbE5leHRDbGFzczogJ21ic2MtaWMgbWJzYy1pYy1tYXRlcmlhbC1rZXlib2FyZC1hcnJvdy1yaWdodCdcbn0pO1xudGhlbWVzJDMubGlzdHZpZXcubWF0ZXJpYWwgPSB7XG4gIGxlZnRBcnJvd0NsYXNzOiAnbWJzYy1pYy1tYXRlcmlhbC1rZXlib2FyZC1hcnJvdy1sZWZ0JyxcbiAgcmlnaHRBcnJvd0NsYXNzOiAnbWJzYy1pYy1tYXRlcmlhbC1rZXlib2FyZC1hcnJvdy1yaWdodCcsXG4gIG9uSXRlbUFjdGl2YXRlOiBmdW5jdGlvbiBvbkl0ZW1BY3RpdmF0ZShldikge1xuICAgIF9hZGRSaXBwbGUoJCQxKGV2LnRhcmdldCksIGV2LmRvbUV2ZW50KTtcbiAgfSxcbiAgb25JdGVtRGVhY3RpdmF0ZTogZnVuY3Rpb24gb25JdGVtRGVhY3RpdmF0ZSgpIHtcbiAgICBfcmVtb3ZlUmlwcGxlKCRyaXBwbGUpO1xuICB9LFxuICBvblNsaWRlU3RhcnQ6IGZ1bmN0aW9uIG9uU2xpZGVTdGFydChldikge1xuICAgICQkMSgnLm1ic2MtcmlwcGxlJywgZXYudGFyZ2V0KS5yZW1vdmUoKTtcbiAgfSxcbiAgb25Tb3J0U3RhcnQ6IGZ1bmN0aW9uIG9uU29ydFN0YXJ0KGV2KSB7XG4gICAgJCQxKCcubWJzYy1yaXBwbGUnLCBldi50YXJnZXQpLnJlbW92ZSgpO1xuICB9XG59O1xudGhlbWVzJDMubmF2aWdhdGlvbi5tYXRlcmlhbCA9IHtcbiAgb25Jbml0OiBmdW5jdGlvbiBvbkluaXQoKSB7XG4gICAgaW5pdFJpcHBsZSgkJDEodGhpcyksICcubWJzYy1tcy1pdGVtLm1ic2MtYnRuLWUnLCAnbWJzYy1kaXNhYmxlZCcsICdtYnNjLWJ0bi1uaGwnKTtcbiAgfSxcbiAgb25NYXJrdXBJbml0OiBmdW5jdGlvbiBvbk1hcmt1cEluaXQoKSB7XG4gICAgJCQxKCcubWJzYy1yaXBwbGUnLCB0aGlzKS5yZW1vdmUoKTtcbiAgfSxcbiAgb25EZXN0cm95OiBmdW5jdGlvbiBvbkRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX19tYnNjUmlwcGxlT2ZmKSB7XG4gICAgICB0aGlzLl9fbWJzY1JpcHBsZU9mZigpO1xuICAgIH1cbiAgfVxufTtcbnRoZW1lcyQzLmZvcm0ubWF0ZXJpYWwgPSB7XG4gIGFkZFJpcHBsZTogZnVuY3Rpb24gYWRkUmlwcGxlKGVsbSwgZXYpIHtcbiAgICBfYWRkUmlwcGxlKGVsbSwgZXYpO1xuICB9LFxuICByZW1vdmVSaXBwbGU6IGZ1bmN0aW9uIHJlbW92ZVJpcHBsZSgpIHtcbiAgICBfcmVtb3ZlUmlwcGxlKCRyaXBwbGUpO1xuICB9XG59O1xuXG5tb2Jpc2Nyb2xsLmN1c3RvbVRoZW1lKCdtYXRlcmlhbC1kYXJrJywgJ21hdGVyaWFsJyk7XG5cbm1vYmlzY3JvbGwuY3VzdG9tVGhlbWUoJ2lvcy1kYXJrJywgJ2lvcycpO1xuXG52YXIgdGhlbWVzJDQgPSBtb2Jpc2Nyb2xsLnRoZW1lcztcbnRoZW1lcyQ0LmZyYW1lLndpbmRvd3MgPSB7XG4gIGhlYWRlclRleHQ6IGZhbHNlLFxuICBkZWxldGVJY29uOiAnYmFja3NwYWNlNCcsXG4gIC8vc2V0SWNvbjogJ21hdGVyaWFsLWNoZWNrJyxcbiAgLy9jYW5jZWxJY29uOiAnbWF0ZXJpYWwtY2xvc2UnLFxuICAvL2Nsb3NlSWNvbjogJ21hdGVyaWFsLWNsb3NlJyxcbiAgLy9jbGVhckljb246ICdtYXRlcmlhbC1jbG9zZScsXG4gIC8vb2tJY29uOiAnbWF0ZXJpYWwtY2hlY2snLFxuICAvL25vd0ljb246ICdsb29wMicsXG4gIC8vc3RhcnRJY29uOiAncGxheTMnLFxuICAvL3N0b3BJY29uOiAncGF1c2UyJyxcbiAgLy9yZXNldEljb246ICdzdG9wMicsXG4gIC8vbGFwSWNvbjogJ2xvb3AyJyxcbiAgLy9idG5XaWR0aDogZmFsc2UsXG4gIGJ0blJldmVyc2U6IHRydWVcbn07XG50aGVtZXMkNC5zY3JvbGxlci53aW5kb3dzID0gZXh0ZW5kJDEoe30sIHRoZW1lcyQ0LmZyYW1lLndpbmRvd3MsIHtcbiAgcm93czogNixcbiAgLy8gc2Nyb2xsZXJcbiAgbWluV2lkdGg6IDg4LFxuICBoZWlnaHQ6IDQ0LFxuICBidG5QbHVzQ2xhc3M6ICdtYnNjLWljIG1ic2MtaWMtYXJyb3ctZG93bjUnLFxuICBidG5NaW51c0NsYXNzOiAnbWJzYy1pYyBtYnNjLWljLWFycm93LXVwNScsXG4gIGNoZWNrSWNvbjogJ21hdGVyaWFsLWNoZWNrJyxcbiAgZGF0ZURpc3BsYXk6ICdNTWR5eScsXG4gIC8vIGRhdGVcbiAgc2hvd0xhYmVsOiBmYWxzZSxcbiAgc2hvd1Njcm9sbEFycm93czogdHJ1ZSxcbiAgYnRuQ2FsUHJldkNsYXNzOiAnbWJzYy1pYyBtYnNjLWljLWFycm93LWxlZnQ1JyxcbiAgLy8gY2FsZW5kYXJcbiAgYnRuQ2FsTmV4dENsYXNzOiAnbWJzYy1pYyBtYnNjLWljLWFycm93LXJpZ2h0NScsXG4gIC8vIGNhbGVuZGFyXG4gIGRheU5hbWVzU2hvcnQ6IFsnU3UnLCAnTW8nLCAnVHUnLCAnV2UnLCAnVGgnLCAnRnInLCAnU2EnXSxcbiAgdXNlU2hvcnRMYWJlbHM6IHRydWUgLy8gdGltZXNwYW4vdGltZXJcblxufSk7XG50aGVtZXMkNC5mb3JtLndpbmRvd3MgPSB7fTtcblxubW9iaXNjcm9sbC5jdXN0b21UaGVtZSgnd2luZG93cy1kYXJrJywgJ3dpbmRvd3MnKTtcblxubW9iaXNjcm9sbC5jdXN0b21UaGVtZSgnZm9ybXMyJywgJ2lvcycpO1xuXG5tb2Jpc2Nyb2xsLmN1c3RvbVRoZW1lKCduYXZiYXJtZW51JywgJ2lvcycpO1xuXG5tb2Jpc2Nyb2xsLmN1c3RvbVRoZW1lKCduZXd0aGVtZScsICdpb3MnKTtcblxudmFyIHRoZW1lcyQ1ID0gbW9iaXNjcm9sbC50aGVtZXM7XG52YXIgdGhlbWUgPSAnbW9iaXNjcm9sbCc7XG5cbmlmIChvcyA9PSAnYW5kcm9pZCcpIHtcbiAgdGhlbWUgPSAnbWF0ZXJpYWwnO1xufSBlbHNlIGlmIChvcyA9PSAnaW9zJykge1xuICB0aGVtZSA9ICdpb3MnO1xufSBlbHNlIGlmIChvcyA9PSAnd3AnKSB7XG4gIHRoZW1lID0gJ3dpbmRvd3MnO1xufVxuXG4kJDEuZWFjaCh0aGVtZXMkNS5mcmFtZSwgZnVuY3Rpb24gKGtleSwgc2V0dGluZ3MpIHtcbiAgLy8gU3RvcCBhdCB0aGUgZmlyc3QgY3VzdG9tIHRoZW1lIHdpdGggdGhlIE9TIGJhc2UgdGhlbWVcbiAgaWYgKHRoZW1lICYmIHNldHRpbmdzLmJhc2VUaGVtZSA9PSB0aGVtZSAmJiBrZXkgIT0gdGhlbWUgKyAnLWRhcmsnKSB7XG4gICAgbW9iaXNjcm9sbC5hdXRvVGhlbWUgPSBrZXk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKGtleSA9PSB0aGVtZSkge1xuICAgIG1vYmlzY3JvbGwuYXV0b1RoZW1lID0ga2V5O1xuICB9XG59KTtcblxuZXhwb3J0IHsgTWJzY0FjY29yZGlvbiwgTWJzY0F2YXRhciwgTWJzY0JvdHRvbU5hdiwgTWJzY0J1dHRvbiwgTWJzY0NhbGVuZGFyLCBNYnNjQ2FsZW5kYXJDb21wb25lbnQsIE1ic2NDYWxlbmRhck1vZHVsZSwgTWJzY0NhcmQsIE1ic2NDYXJkQ29tcG9uZW50LCBNYnNjQ2FyZENvbnRlbnQsIE1ic2NDYXJkRm9vdGVyLCBNYnNjQ2FyZEhlYWRlciwgTWJzY0NhcmRNb2R1bGUsIE1ic2NDYXJkU3VidGl0bGUsIE1ic2NDYXJkVGl0bGUsIE1ic2NDaGVja2JveCwgTWJzY0NvbG9yLCBNYnNjQ29sb3JDb21wb25lbnQsIE1ic2NDb2xvck1vZHVsZSwgTWJzY0RhdGUsIE1ic2NEYXRlQ29tcG9uZW50LCBNYnNjRGF0ZXRpbWUsIE1ic2NEYXRldGltZUNvbXBvbmVudCwgTWJzY0RhdGV0aW1lTW9kdWxlLCBNYnNjRGlzdGFuY2UsIE1ic2NEaXN0YW5jZUNvbXBvbmVudCwgTWJzY0Ryb3Bkb3duLCBNYnNjRXZlbnRjYWxlbmRhciwgTWJzY0V2ZW50Y2FsZW5kYXJDb21wb25lbnQsIE1ic2NFdmVudGNhbGVuZGFyTW9kdWxlLCBNYnNjRm9yY2UsIE1ic2NGb3JjZUNvbXBvbmVudCwgTWJzY0Zvcm0sIE1ic2NGb3JtR3JvdXAsIE1ic2NGb3JtR3JvdXBDb250ZW50LCBNYnNjRm9ybUdyb3VwVGl0bGUsIE1ic2NGb3Jtc01vZHVsZSwgTWJzY0hhbWJ1cmdlck5hdiwgTWJzY0ltYWdlLCBNYnNjSW1hZ2VDb21wb25lbnQsIE1ic2NJbWFnZUl0ZW0sIE1ic2NJbWFnZU1vZHVsZSwgTWJzY0lucHV0LCBNYnNjSW5wdXRNb2R1bGUsIE1ic2NMaXN0dmlldywgTWJzY0xpc3R2aWV3SGVhZGVyLCBNYnNjTGlzdHZpZXdJdGVtLCBNYnNjTGlzdHZpZXdNb2R1bGUsIE1ic2NMaXN0dmlld1N1Ymxpc3QsIE1ic2NNYXNzLCBNYnNjTWFzc0NvbXBvbmVudCwgTWJzY01lYXN1cmVtZW50LCBNYnNjTWVhc3VyZW1lbnRDb21wb25lbnQsIE1ic2NNZWFzdXJlbWVudE1vZHVsZSwgTWJzY01vZHVsZSwgTWJzY05hdiwgTWJzY05hdkl0ZW0sIE1ic2NOYXZpZ2F0aW9uTW9kdWxlLCBNYnNjTm90ZSwgTWJzY051bWJlciwgTWJzY051bWJlckNvbXBvbmVudCwgTWJzY051bWJlck1vZHVsZSwgTWJzY051bXBhZCwgTWJzY051bXBhZENvbXBvbmVudCwgTWJzY051bXBhZERhdGUsIE1ic2NOdW1wYWREYXRlQ29tcG9uZW50LCBNYnNjTnVtcGFkRGVjaW1hbCwgTWJzY051bXBhZERlY2ltYWxDb21wb25lbnQsIE1ic2NOdW1wYWRNb2R1bGUsIE1ic2NOdW1wYWRUaW1lLCBNYnNjTnVtcGFkVGltZUNvbXBvbmVudCwgTWJzY051bXBhZFRpbWVzcGFuLCBNYnNjTnVtcGFkVGltZXNwYW5Db21wb25lbnQsIE1ic2NPcHRpb25JdGVtLCBNYnNjT3B0aW9ubGlzdCwgTWJzY09wdGlvbmxpc3RNb2R1bGUsIE1ic2NQYWdlLCBNYnNjUGFnZU1vZHVsZSwgTWJzY1BvcHVwLCBNYnNjUG9wdXBNb2R1bGUsIE1ic2NQcm9ncmVzcywgTWJzY1JhZGlvLCBNYnNjUmFkaW9Hcm91cCwgTWJzY1JhbmdlLCBNYnNjUmFuZ2VDb21wb25lbnQsIE1ic2NSYW5nZUVuZENvbXBvbmVudCwgTWJzY1JhbmdlTW9kdWxlLCBNYnNjUmFuZ2VTdGFydENvbXBvbmVudCwgTWJzY1JhdGluZywgTWJzY1JvdXRlclRva2VuLCBNYnNjU2Nyb2xsVmlldywgTWJzY1Njcm9sbFZpZXdDb21wb25lbnQsIE1ic2NTY3JvbGxWaWV3SXRlbSwgTWJzY1Njcm9sbFZpZXdJdGVtQ29tcG9uZW50LCBNYnNjU2Nyb2xsVmlld01vZHVsZSwgTWJzY1Njcm9sbGVyLCBNYnNjU2Nyb2xsZXJDb21wb25lbnQsIE1ic2NTY3JvbGxlck1vZHVsZSwgTWJzY1NlZ21lbnRlZCwgTWJzY1NlZ21lbnRlZEdyb3VwLCBNYnNjU2VsZWN0LCBNYnNjU2VsZWN0Q29tcG9uZW50LCBNYnNjU2VsZWN0TW9kdWxlLCBNYnNjU2xpZGVyLCBNYnNjU3BlZWQsIE1ic2NTcGVlZENvbXBvbmVudCwgTWJzY1N0ZXBwZXIsIE1ic2NTd2l0Y2gsIE1ic2NUYWJOYXYsIE1ic2NUZW1wZXJhdHVyZSwgTWJzY1RlbXBlcmF0dXJlQ29tcG9uZW50LCBNYnNjVGV4dGFyZWEsIE1ic2NUaW1lLCBNYnNjVGltZUNvbXBvbmVudCwgTWJzY1RpbWVyLCBNYnNjVGltZXJDb21wb25lbnQsIE1ic2NUaW1lck1vZHVsZSwgTWJzY1RpbWVzcGFuLCBNYnNjVGltZXNwYW5Db21wb25lbnQsIE1ic2NUaW1lc3Bhbk1vZHVsZSwgTWJzY1RyZWVsaXN0LCBNYnNjVHJlZWxpc3RDb21wb25lbnQsIE1ic2NUcmVlbGlzdE1vZHVsZSwgTWJzY1dpZGdldCwgbW9iaXNjcm9sbCwgTWJzY09wdGlvbnNTZXJ2aWNlIGFzIMm1YSwgTWJzY0lucHV0U2VydmljZSBhcyDJtWIsIE1ic2NDYWxCYXNlTW9kdWxlIGFzIMm1YmEsIE1ic2NEYXRldGltZUJhc2UgYXMgybViYiwgTWJzY0RhdGV0aW1lQmFzZU1vZHVsZSBhcyDJtWJjLCBNYnNjTmF2SXRlbUJhc2UgYXMgybViZCwgTWJzY05hdmlnYXRpb25CYXNlIGFzIMm1YmUsIE1ic2NOYXZpZ2F0aW9uQmFzZU1vZHVsZSBhcyDJtWJmLCBNYnNjTm90aWZ5SXRlbVNlcnZpY2UgYXMgybViZywgTWJzY1Njcm9sbEl0ZW1CYXNlIGFzIMm1YmgsIE1ic2NTY3JvbGxWaWV3QmFzZSBhcyDJtWJpLCBNYnNjU2Nyb2xsVmlld0Jhc2VNb2R1bGUgYXMgybViaiwgTWJzY0xpc3RTZXJ2aWNlIGFzIMm1YywgTWJzY0Jhc2UgYXMgybVkLCBNYnNjVmFsdWVCYXNlIGFzIMm1ZSwgTWJzY0Nsb25lQmFzZSBhcyDJtWYsIE1ic2NDb250cm9sQmFzZSBhcyDJtWcsIE1ic2NGcmFtZUJhc2UgYXMgybVoLCBNYnNjU2Nyb2xsZXJCYXNlIGFzIMm1aSwgTWJzY0Jhc2VNb2R1bGUgYXMgybVqLCBNYnNjRnJhbWVCYXNlTW9kdWxlIGFzIMm1aywgTWJzY1Njcm9sbGVyQmFzZU1vZHVsZSBhcyDJtWwsIElOUFVUX1RFTVBMQVRFIGFzIMm1bSwgTWJzY0RhdGVCYXNlIGFzIMm1biwgTWJzY0Zvcm1CYXNlIGFzIMm1bywgTWJzY0Zvcm1WYWx1ZUJhc2UgYXMgybVwLCBNYnNjSW5wdXRCYXNlIGFzIMm1cSwgTWJzY1JhZGlvU2VydmljZSBhcyDJtXIsIE1ic2NSYWRpb0dyb3VwQmFzZSBhcyDJtXMsIE1ic2NMaXN0dmlld1NlcnZpY2UgYXMgybV0LCBNYnNjU3VibGlzdFNlcnZpY2UgYXMgybV1LCBNYnNjTGlzdGl0ZW1TZXJ2aWNlIGFzIMm1diwgTWJzY01lYXN1cmVtZW50QmFzZSBhcyDJtXcsIE1ic2NNZWFzdXJlbWVudENoaWxkIGFzIMm1eCwgTWJzY051bXBhZEJhc2UgYXMgybV5LCBNYnNjQ2FsQmFzZSBhcyDJtXogfTtcbiJdfQ==","map":null,"metadata":{},"sourceType":"module"}