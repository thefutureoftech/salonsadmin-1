{"ast":null,"code":"import { Injectable, RendererFactory2 } from '@angular/core';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @enum {number} */\n\nimport * as ɵngcc0 from '@angular/core';\nconst DOC_ORIENTATION = {\n  Up: 1,\n  Down: 3,\n  Right: 6,\n  Left: 8,\n  UpMirrored: 2,\n  DownMirrored: 4,\n  LeftMirrored: 5,\n  RightMirrored: 7,\n  NotJpeg: -1,\n  NotDefined: -2\n};\nDOC_ORIENTATION[DOC_ORIENTATION.Up] = 'Up';\nDOC_ORIENTATION[DOC_ORIENTATION.Down] = 'Down';\nDOC_ORIENTATION[DOC_ORIENTATION.Right] = 'Right';\nDOC_ORIENTATION[DOC_ORIENTATION.Left] = 'Left';\nDOC_ORIENTATION[DOC_ORIENTATION.UpMirrored] = 'UpMirrored';\nDOC_ORIENTATION[DOC_ORIENTATION.DownMirrored] = 'DownMirrored';\nDOC_ORIENTATION[DOC_ORIENTATION.LeftMirrored] = 'LeftMirrored';\nDOC_ORIENTATION[DOC_ORIENTATION.RightMirrored] = 'RightMirrored';\nDOC_ORIENTATION[DOC_ORIENTATION.NotJpeg] = 'NotJpeg';\nDOC_ORIENTATION[DOC_ORIENTATION.NotDefined] = 'NotDefined';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nclass ImageCompress {\n  /**\n   * Get the correct Orientation value from tags, in order to write correctly in our canvas\n   * @param {?} file\n   * @param {?} callback\n   * @return {?}\n   */\n  static getOrientation(file, callback) {\n    /** @type {?} */\n    const reader = new FileReader();\n\n    try {\n      reader.onload =\n      /**\n      * @param {?} $event\n      * @return {?}\n      */\n      function ($event) {\n        /** @type {?} */\n        const view = new DataView(\n        /** @type {?} */\n        reader.result);\n\n        if (view.getUint16(0, false) !== 0xFFD8) {\n          return callback(-2);\n        }\n        /** @type {?} */\n\n\n        const length = view.byteLength;\n        /** @type {?} */\n\n        let offset = 2;\n\n        while (offset < length) {\n          /** @type {?} */\n          const marker = view.getUint16(offset, false);\n          offset += 2;\n\n          if (marker === 0xFFE1) {\n            if (view.getUint32(offset += 2, false) !== 0x45786966) {\n              return callback(-1);\n            }\n            /** @type {?} */\n\n\n            const little = view.getUint16(offset += 6, false) === 0x4949;\n            offset += view.getUint32(offset + 4, little);\n            /** @type {?} */\n\n            const tags = view.getUint16(offset, little);\n            offset += 2;\n\n            for (let i = 0; i < tags; i++) {\n              if (view.getUint16(offset + i * 12, little) === 0x0112) {\n                return callback(view.getUint16(offset + i * 12 + 8, little));\n              }\n            }\n          } else if ((marker & 0xFF00) !== 0xFF00) {\n            break;\n          } else {\n            offset += view.getUint16(offset, false);\n          }\n        }\n\n        return callback(-1);\n      };\n\n      reader.readAsArrayBuffer(file);\n    } catch (e) {\n      return callback(0);\n    }\n  }\n  /**\n   * return a promise with the new image data and image orientation\n   * @param {?} render\n   * @return {?}\n   */\n\n\n  static uploadFile(render) {\n    /** @type {?} */\n    const promise = new Promise(\n    /**\n    * @param {?} resolve\n    * @param {?} reject\n    * @return {?}\n    */\n    function (resolve, reject) {\n      /** @type {?} */\n      const inputElement = render.createElement('input');\n      render.setStyle(inputElement, 'display', 'none');\n      render.setProperty(inputElement, 'type', 'file');\n      render.setProperty(inputElement, 'accept', 'image/*');\n      render.listen(inputElement, 'click',\n      /**\n      * @param {?} $event\n      * @return {?}\n      */\n      $event => {\n        //console.log('MouseEvent:', $event);\n        //console.log('Input:', $event.target);\n        $event.target.value = null;\n      });\n      render.listen(inputElement, 'change',\n      /**\n      * @param {?} $event\n      * @return {?}\n      */\n      $event => {\n        /** @type {?} */\n        const file = $event.target.files[0];\n        /** @type {?} */\n\n        const myReader = new FileReader();\n\n        myReader.onloadend =\n        /**\n        * @param {?} e\n        * @return {?}\n        */\n        e => {\n          try {\n            ImageCompress.getOrientation(file,\n            /**\n            * @param {?} orientation\n            * @return {?}\n            */\n            orientation => {\n              resolve({\n                image:\n                /** @type {?} */\n                myReader.result,\n                orientation\n              });\n            });\n          } catch (e) {\n            //console.log(`ngx-image-compress error ${e}`);\n            reject(e);\n          }\n        };\n\n        try {\n          myReader.readAsDataURL(file);\n        } catch (e) {\n          console.warn(`ngx-image-compress - probably no file have been selected: ${e}`);\n          reject(\"No file selected\");\n        }\n      });\n      inputElement.click();\n    });\n    return promise;\n  }\n  /**\n   * @param {?} imageDataUrlSource\n   * @param {?} orientation\n   * @param {?} render\n   * @param {?=} ratio\n   * @param {?=} quality\n   * @return {?}\n   */\n\n\n  static compress(imageDataUrlSource, orientation, render, ratio = 50, quality = 50) {\n    /** @type {?} */\n    const promise = new Promise(\n    /**\n    * @param {?} resolve\n    * @param {?} reject\n    * @return {?}\n    */\n    function (resolve, reject) {\n      quality = quality / 100;\n      ratio = ratio / 100;\n      /** @type {?} */\n\n      const sourceImage = new Image(); // important for safari: we need to wait for onload event\n\n      sourceImage.onload =\n      /**\n      * @return {?}\n      */\n      function () {\n        /** @type {?} */\n        const canvas = render.createElement('canvas');\n        /** @type {?} */\n\n        const ctx = canvas.getContext('2d');\n        /** @type {?} */\n\n        let w;\n        /** @type {?} */\n\n        let h;\n        w = sourceImage.naturalWidth;\n        h = sourceImage.naturalHeight;\n\n        if (orientation === DOC_ORIENTATION.Right || orientation === DOC_ORIENTATION.Left) {\n          /** @type {?} */\n          const t = w;\n          w = h;\n          h = t;\n        }\n\n        canvas.width = w * ratio;\n        canvas.height = h * ratio;\n        /** @type {?} */\n\n        const TO_RADIANS = Math.PI / 180;\n\n        if (orientation === DOC_ORIENTATION.Up) {\n          ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);\n        } else if (orientation === DOC_ORIENTATION.Right) {\n          ctx.save();\n          ctx.rotate(90 * TO_RADIANS);\n          ctx.translate(0, -canvas.width);\n          ctx.drawImage(sourceImage, 0, 0, canvas.height, canvas.width);\n          ctx.restore();\n        } else if (orientation === DOC_ORIENTATION.Left) {\n          ctx.save();\n          ctx.rotate(-90 * TO_RADIANS);\n          ctx.translate(-canvas.width, 0);\n          ctx.drawImage(sourceImage, 0, 0, canvas.height, canvas.width);\n          ctx.restore();\n        } else if (orientation === DOC_ORIENTATION.Down) {\n          ctx.save();\n          ctx.rotate(180 * TO_RADIANS);\n          ctx.translate(-canvas.width, -canvas.height);\n          ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);\n          ctx.restore();\n        } else {\n          //console.warn('ngx-image-compress - no orientation value found');\n          // same as default UP\n          ctx.drawImage(sourceImage, 0, 0, canvas.width, canvas.height);\n        }\n        /** @type {?} */\n\n\n        const mime = imageDataUrlSource.substr(5, imageDataUrlSource.split(';')[0].length - 5); // TODO test on mime\n\n        /** @type {?} */\n\n        const result = canvas.toDataURL(mime, quality);\n        resolve(result);\n      };\n\n      sourceImage.src = imageDataUrlSource;\n    });\n    return promise;\n  }\n  /**\n   * helper to evaluate the compression rate\n   * @param {?} s the image in base64 string format\n   * @return {?}\n   */\n\n\n  static byteCount(s) {\n    return encodeURI(s).split(/%..|./).length - 1;\n  }\n\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nlet NgxImageCompressService = /*#__PURE__*/(() => {\n  class NgxImageCompressService {\n    /**\n     * @param {?} rendererFactory\n     */\n    constructor(rendererFactory) {\n      this.DOC_ORIENTATION = DOC_ORIENTATION;\n      this.render = rendererFactory.createRenderer(null, null);\n    }\n    /**\n     * @param {?} image\n     * @return {?}\n     */\n\n\n    byteCount(image) {\n      return ImageCompress.byteCount(image);\n    }\n    /**\n     * @return {?}\n     */\n\n\n    uploadFile() {\n      return ImageCompress.uploadFile(this.render);\n    }\n    /**\n     * @param {?} image\n     * @param {?} orientation\n     * @param {?=} ratio\n     * @param {?=} quality\n     * @return {?}\n     */\n\n\n    compressFile(image, orientation, ratio = 50, quality = 50) {\n      return ImageCompress.compress(image, orientation, this.render, ratio, quality);\n    }\n\n  }\n\n  NgxImageCompressService.ɵfac = function NgxImageCompressService_Factory(t) {\n    return new (t || NgxImageCompressService)(ɵngcc0.ɵɵinject(ɵngcc0.RendererFactory2));\n  };\n\n  NgxImageCompressService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: NgxImageCompressService,\n    factory: NgxImageCompressService.ɵfac\n  });\n  /** @nocollapse */\n\n  return NgxImageCompressService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  NgxImageCompressService.prototype.render;\n  /** @type {?} */\n\n  NgxImageCompressService.prototype.DOC_ORIENTATION;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nexport { DOC_ORIENTATION, NgxImageCompressService }; //# sourceMappingURL=ngx-image-compress.js.map","map":null,"metadata":{},"sourceType":"module"}