{"ast":null,"code":"!function (t, e) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? e(exports) : \"function\" == typeof define && define.amd ? define([\"exports\"], e) : e((t = \"undefined\" != typeof globalThis ? globalThis : t || self).window = t.window || {});\n}(this, function (t) {\n  \"use strict\";\n\n  const e = \"0123456789bcdefghjkmnpqrstuvwxyz\";\n\n  function n(t) {\n    return t * Math.PI / 180;\n  }\n\n  function i(t, n = !1) {\n    let i;\n    if (\"string\" != typeof t) i = \"geohash must be a string\";else if (0 === t.length) i = \"geohash cannot be the empty string\";else for (const n of t) -1 === e.indexOf(n) && (i = \"geohash cannot contain '\" + n + \"'\");\n    if (void 0 === i || n) return !i;\n    throw new Error(\"Invalid geohash '\" + t + \"': \" + i);\n  }\n\n  function r(t, e = !1) {\n    const n = [];\n    if (t) {\n      if (void 0 === t.lat) n.push(\"Latitude must exist on coordinates\");else if (void 0 === t.lng) n.push(\"Longitude must exist on coordinates\");else {\n        const e = t.lat,\n              i = t.lng;\n        \"number\" != typeof e || isNaN(e) ? n.push(\"Latitude must be a number.\") : e < -90 || e > 90 ? n.push(\"Latitude must be within the range [-90, 90].\") : \"number\" != typeof i || isNaN(i) ? n.push(\"Longitude must be a number\") : (i < -180 || i > 180) && n.push(\"Longitude must be within the range [-180, 180]\");\n      }\n    } else n.push(\"Coordinates must exist.\");\n    if (n.length > 0 && !e) throw new Error(\"Invalid coordinates: \" + n.join(\" \"));\n    return !n;\n  }\n\n  function o(t, n = 10) {\n    if (r(t), \"number\" != typeof n || isNaN(n)) throw new Error(\"Precision must be a number\");\n    if (n <= 0) throw new Error(\"Precision must be greater than 0\");\n    if (n > 22) throw new Error(\"Precision cannot be greater than 22\");\n    if (Math.round(n) !== n) throw new Error(\"Precision must be an integer\");\n    const i = [-90, 90],\n          o = [-180, 180];\n    let s = \"\",\n        c = 0,\n        a = 0,\n        u = 1;\n\n    for (; s.length < n;) {\n      const n = u ? t.lng : t.lat,\n            r = u ? o : i,\n            h = (r[0] + r[1]) / 2;\n      n > h ? (c = 1 + (c << 1), r[0] = h) : (c = 0 + (c << 1), r[1] = h), u = !u, a < 4 ? a++ : (a = 0, s += e.charAt(c), c = 0);\n    }\n\n    return s;\n  }\n\n  function s(t, e = !1) {\n    let n;\n    if (\"[object Object]\" !== Object.prototype.toString.call(t) ? n = \"no document found\" : \"g\" in t ? (n = i(t.g.geohash, !0) ? n : \"invalid geohash on object\", n = a(t.g.geopoint, !0) ? n : \"invalid location on object\") : n = \"no `g` field found in object\", void 0 === n || e) return !n;\n    throw new Error(\"Invalid GeoFirestore object: \" + n);\n  }\n\n  function c(t, e = !1) {\n    let n;\n    if (\"number\" != typeof t || isNaN(t) ? n = \"limit must be a number\" : t < 0 && (n = \"limit must be greater than or equal to 0\"), void 0 === n || e) return !n;\n    throw new Error(n);\n  }\n\n  function a(t, e = !1) {\n    let n;\n    if (t) {\n      if (void 0 === t.latitude) n = \"latitude must exist on GeoPoint\";else if (void 0 === t.longitude) n = \"longitude must exist on GeoPoint\";else {\n        const e = t.latitude,\n              i = t.longitude;\n        \"number\" != typeof e || isNaN(e) ? n = \"latitude must be a number\" : e < -90 || e > 90 ? n = \"latitude must be within the range [-90, 90]\" : \"number\" != typeof i || isNaN(i) ? n = \"longitude must be a number\" : (i < -180 || i > 180) && (n = \"longitude must be within the range [-180, 180]\");\n      }\n    } else n = \"GeoPoint must exist\";\n    if (void 0 === n || e) return !n;\n    throw new Error(\"Invalid location: \" + n);\n  }\n\n  function u(t, e = !1) {\n    if (\"object\" != typeof t) throw new Error(\"QueryCriteria must be an object\");\n    if (void 0 === t.center && void 0 === t.radius) throw new Error(\"radius and/or center must be specified\");\n    if (e && (void 0 === t.center || void 0 === t.radius)) throw new Error(\"QueryCriteria for a new query must contain both a center and a radius\");\n    const n = Object.keys(t);\n\n    for (const t of n) if (![\"center\", \"radius\", \"limit\"].includes(t)) throw new Error(\"Unexpected attribute '\" + t + \"' found in query criteria\");\n\n    if (void 0 !== t.center && a(t.center), void 0 !== t.radius) {\n      if (\"number\" != typeof t.radius || isNaN(t.radius)) throw new Error(\"radius must be a number\");\n      if (t.radius < 0) throw new Error(\"radius must be greater than or equal to 0\");\n    }\n\n    void 0 !== t.limit && c(t.limit);\n  }\n\n  const h = \"0123456789bcdefghjkmnpqrstuvwxyz\",\n        d = 110574;\n\n  function l(t, e) {\n    const n = e / d,\n          i = Math.min(90, t.latitude + n),\n          r = Math.max(-90, t.latitude - n),\n          o = 2 * Math.floor((s = e, Math.min(p(20003930 / s), 110)));\n    var s;\n    const c = 2 * Math.floor(b(e, i)) - 1,\n          a = 2 * Math.floor(b(e, r)) - 1;\n    return Math.min(o, c, a, 110);\n  }\n\n  function f(t, e) {\n    return a(t), a(e), function (t, e, i = \"km\") {\n      r(t), r(e);\n      const o = \"miles\" === i.toLowerCase() ? 3963 : 6371,\n            s = n(e.lat - t.lat),\n            c = n(e.lng - t.lng),\n            a = n(t.lat),\n            u = n(e.lat),\n            h = Math.sin(s / 2) * Math.sin(s / 2) + Math.sin(c / 2) * Math.sin(c / 2) * Math.cos(a) * Math.cos(u);\n      return o * (2 * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h)));\n    }({\n      lat: t.latitude,\n      lng: t.longitude\n    }, {\n      lat: e.latitude,\n      lng: e.longitude\n    });\n  }\n\n  function _(t, e, n = !1) {\n    let i, r;\n    if ((e = e || \"coordinates\") in t) r = t[e];else {\n      const n = e.split(\".\");\n      r = t;\n\n      for (const e of n) {\n        if (!(e in r)) {\n          r = t.coordinates;\n          break;\n        }\n\n        r = r[e];\n      }\n    }\n    if (r || (i = \"could not find GeoPoint\"), r && !a(r, !0) && (i = \"invalid GeoPoint\"), i && !n) throw new Error(\"Invalid GeoFirestore document: \" + i);\n    return r;\n  }\n\n  function m(t, e) {\n    const n = function (t, e) {\n      if (s(t, !0)) return {\n        data: () => t,\n        distance: e ? f(t.g.geopoint, e) : null\n      };\n      return {\n        data: () => t,\n        distance: null\n      };\n    }(t.data(), e);\n\n    return Object.assign({\n      exists: t.exists,\n      id: t.id\n    }, n);\n  }\n\n  function g(t, e) {\n    let n = function (t, e) {\n      a(t);\n\n      const n = Math.max(1, l(t, e)),\n            r = Math.ceil(n / 5),\n            s = function (t, e) {\n        const n = e / d,\n              i = Math.min(90, t.latitude + n),\n              r = Math.max(-90, t.latitude - n),\n              o = y(e, i),\n              s = y(e, r),\n              c = Math.max(o, s);\n        return [v(t.latitude, t.longitude), v(t.latitude, j(t.longitude - c)), v(t.latitude, j(t.longitude + c)), v(i, t.longitude), v(i, j(t.longitude - c)), v(i, j(t.longitude + c)), v(r, t.longitude), v(r, j(t.longitude - c)), v(r, j(t.longitude + c))];\n      }(t, e).map(t => function (t, e) {\n        i(t);\n        const n = Math.ceil(e / 5);\n        if (t.length < n) return [t, t + \"~\"];\n        const r = t.substring(0, n),\n              o = r.substring(0, r.length - 1),\n              s = h.indexOf(r.charAt(r.length - 1)),\n              c = e - 5 * o.length,\n              a = 5 - c,\n              u = s >> a << a,\n              d = u + (1 << a);\n        return d > 31 ? [o + h[u], o + \"~\"] : [o + h[u], o + h[d]];\n      }(o({\n        lat: t.latitude,\n        lng: t.longitude\n      }, r), n));\n\n      return s.filter((t, e) => !s.some((n, i) => e > i && t[0] === n[0] && t[1] === n[1]));\n    }(e.center, 1e3 * e.radius).map(w);\n\n    return n = n.filter((t, e) => n.indexOf(t) === e), n.map(e => {\n      const n = function (t) {\n        const e = t.split(\":\");\n        if (2 !== e.length) throw new Error(\"Invalid internal state! Not a valid geohash query: \" + t);\n        return e;\n      }(e);\n\n      return t.orderBy(\"g.geohash\").startAt(n[0]).endAt(n[1]);\n    });\n  }\n\n  function p(t) {\n    return Math.log(t) / Math.log(2);\n  }\n\n  function b(t, e) {\n    const n = y(t, e);\n    return Math.abs(n) > 1e-6 ? Math.max(1, p(360 / n)) : 1;\n  }\n\n  function y(t, e) {\n    const n = function (t) {\n      if (\"number\" != typeof t || isNaN(t)) throw new Error(\"Error: degrees must be a number\");\n      return t * Math.PI / 180;\n    }(e),\n          i = 6378137 * Math.cos(n) * Math.PI / 180 * (1 / Math.sqrt(1 - .00669447819799 * Math.sin(n) * Math.sin(n)));\n\n    return i < 1e-12 ? t > 0 ? 360 : 0 : Math.min(360, t / i);\n  }\n\n  function w(t) {\n    if (2 !== t.length) throw new Error(\"Not a valid geohash query: \" + t);\n    return t[0] + \":\" + t[1];\n  }\n\n  function v(t, e) {\n    const n = {\n      latitude: t,\n      longitude: e\n    };\n    return a(n), n;\n  }\n\n  function j(t) {\n    if (t <= 180 && t >= -180) return t;\n    const e = t + 180;\n    return e > 0 ? e % 360 - 180 : 180 - -e % 360;\n  }\n\n  function q(t, e) {\n    if (\"[object Object]\" !== Object.prototype.toString.call(t)) throw new Error(\"document must be an object\");\n\n    const n = _(t, e && e.customKey, e && (e.merge || !!e.mergeFields));\n\n    return n ? x(n, t) : t;\n  }\n\n  function E(t, e) {\n    if (\"[object Object]\" !== Object.prototype.toString.call(t)) throw new Error(\"document must be an object\");\n\n    const n = _(t, e, !0);\n\n    return n ? x(n, t) : t;\n  }\n\n  function x(t, e) {\n    a(t);\n    const n = o({\n      lat: t.latitude,\n      lng: t.longitude\n    });\n    return Object.assign(Object.assign({}, e), {\n      g: {\n        geopoint: t,\n        geohash: n\n      }\n    });\n  }\n\n  class M {\n    constructor(t, e) {\n      this._querySnapshot = t, this._center = e, e && a(e), this._docs = t.docs.map(t => m(t, e));\n    }\n\n    get native() {\n      return this._querySnapshot;\n    }\n\n    get docs() {\n      return this._docs;\n    }\n\n    get size() {\n      return this._docs.length;\n    }\n\n    get empty() {\n      return !this._docs.length;\n    }\n\n    docChanges() {\n      return (Array.isArray(this._querySnapshot.docChanges) ? this._querySnapshot.docChanges : this._querySnapshot.docChanges()).map(t => ({\n        doc: m(t.doc, this._center),\n        newIndex: t.newIndex,\n        oldIndex: t.oldIndex,\n        type: t.type\n      }));\n    }\n\n    forEach(t, e) {\n      this.docs.forEach(t, e);\n    }\n\n  }\n\n  class C {\n    constructor(t, e) {\n      if (this._queryCriteria = e, this._docs = new Map(), u(e), t.forEach(t => {\n        t.docs.forEach(t => {\n          const e = f(this._queryCriteria.center, t.data().g.geopoint);\n          this._queryCriteria.radius >= e && this._docs.set(t.id, t);\n        });\n      }), this._queryCriteria.limit && this._docs.size > this._queryCriteria.limit) {\n        const t = Array.from(this._docs.values()).map(t => ({\n          distance: f(this._queryCriteria.center, t.data().g.geopoint),\n          id: t.id\n        })).sort((t, e) => t.distance - e.distance);\n\n        for (let e = this._queryCriteria.limit; e < t.length; e++) this._docs.delete(t[e].id);\n      }\n    }\n\n    getGeoQuerySnapshot() {\n      const t = Array.from(this._docs.values());\n      return new M({\n        docs: t,\n        docChanges: () => t.map((t, e) => ({\n          doc: t,\n          newIndex: e,\n          oldIndex: -1,\n          type: \"added\"\n        }))\n      }, this._queryCriteria.center);\n    }\n\n  }\n\n  class O {\n    constructor(t, e, n, i = () => {}) {\n      this._queries = t, this._queryCriteria = e, this._onNext = n, this._onError = i, this._docs = new Map(), this._firstRoundResolved = !1, this._firstEmitted = !1, this._newValues = !1, this._subscriptions = [], this._queriesResolved = [], u(e), this._queriesResolved = new Array(t.length).fill(0), t.forEach((t, e) => {\n        const n = t.onSnapshot(t => this._processSnapshot(t, e), t => this._error = t);\n\n        this._subscriptions.push(n);\n      }), this._interval = setInterval(() => this._emit(), 100);\n    }\n\n    unsubscribe() {\n      return () => {\n        clearInterval(this._interval), this._subscriptions.forEach(t => t());\n      };\n    }\n\n    _next() {\n      if (this._queryCriteria.limit && this._docs.size > this._queryCriteria.limit) {\n        const t = Array.from(this._docs.values()).sort((t, e) => t.distance - e.distance);\n\n        for (let e = this._queryCriteria.limit; e < t.length; e++) if (t[e].emitted) {\n          const n = {\n            change: Object.assign({}, t[e].change),\n            distance: t[e].distance,\n            emitted: t[e].emitted\n          };\n          n.change.type = \"removed\", this._docs.set(n.change.doc.id, n);\n        } else this._docs.delete(t[e].change.doc.id);\n      }\n\n      let t = 0;\n      const e = Array.from(this._docs.values()).map((e, n) => {\n        const i = {\n          type: e.change.type,\n          doc: e.change.doc,\n          oldIndex: e.emitted ? e.change.newIndex : -1,\n          newIndex: \"removed\" !== e.change.type ? n - t : -1\n        };\n        return \"removed\" === i.type ? (t--, this._docs.delete(i.doc.id)) : this._docs.set(i.doc.id, {\n          change: i,\n          distance: e.distance,\n          emitted: !0\n        }), i;\n      }),\n            n = e.reduce((t, e) => (e.newIndex >= 0 ? t.push(e.doc) : this._docs.delete(e.doc.id), t), []);\n      this._firstEmitted = !0, this._onNext(new M({\n        docs: n,\n        docChanges: () => e.reduce((t, e) => (-1 !== e.oldIndex && \"added\" === e.type || t.push(e), t), [])\n      }, this._queryCriteria.center));\n    }\n\n    _emit() {\n      this._error ? (this._onError(this._error), this.unsubscribe()()) : this._newValues && this._firstRoundResolved ? (this._newValues = !1, this._next()) : this._firstRoundResolved || (this._firstRoundResolved = this._queriesResolved.reduce((t, e) => t + e, 0) === this._queries.length);\n    }\n\n    _processSnapshot(t, e) {\n      const n = Array.isArray(t.docChanges) ? t.docChanges : t.docChanges();\n      this._firstRoundResolved || (this._queriesResolved[e] = 1), n.length ? n.forEach(t => {\n        const e = t.doc.data(),\n              n = s(e, !0) ? e.g.geopoint : null,\n              i = n ? f(this._queryCriteria.center, n) : null,\n              r = t.doc.id,\n              o = this._docs.get(r),\n              c = {\n          change: {\n            doc: t.doc,\n            oldIndex: o && this._firstEmitted ? o.change.oldIndex : -1,\n            newIndex: o && this._firstEmitted ? o.change.newIndex : -1,\n            type: o && this._firstEmitted ? t.type : \"added\"\n          },\n          distance: i,\n          emitted: !!this._firstEmitted && !!o\n        };\n\n        if (this._queryCriteria.radius >= i) {\n          if (!o && \"removed\" === c.change.type) return;\n          o || \"modified\" !== c.change.type || (c.change.type = \"added\"), this._newValues = !0, this._docs.set(r, c);\n        } else o ? (c.change.type = \"removed\", this._newValues = !0, this._docs.set(r, c)) : o || this._firstRoundResolved || (this._newValues = !0);\n      }) : this._firstRoundResolved || (this._newValues = !0);\n    }\n\n  }\n\n  class S {\n    constructor(t, e) {\n      if (this._query = t, \"[object Object]\" !== Object.prototype.toString.call(t)) throw new Error(\"Query must be an instance of a Firestore Query\");\n      this._isWeb = \"[object Function]\" === Object.prototype.toString.call(t.firestore.enablePersistence), e && (\"number\" == typeof e.limit && (this._limit = e.limit), e.center && \"number\" == typeof e.radius && (u(e), this._center = e.center, this._radius = e.radius));\n    }\n\n    get native() {\n      return this._query;\n    }\n\n    get firestore() {\n      return new R(this._query.firestore);\n    }\n\n    get onSnapshot() {\n      return t = this._query, e = this._queryCriteria, (n, i = () => {}) => e.center && \"number\" == typeof e.radius ? new O(g(t, e), e, n, i).unsubscribe() : (t = e.limit ? t.limit(e.limit) : t).onSnapshot(t => n(new M(t)), i);\n      var t, e;\n    }\n\n    get(t = {\n      source: \"default\"\n    }) {\n      return function (t, e, n = {\n        source: \"default\"\n      }) {\n        const i = \"[object Function]\" === Object.prototype.toString.call(t.firestore.enablePersistence);\n\n        if (e.center && \"number\" == typeof e.radius) {\n          const r = g(t, e).map(t => i ? t.get(n) : t.get());\n          return Promise.all(r).then(t => new C(t, e).getGeoQuerySnapshot());\n        }\n\n        return t = e.limit ? t.limit(e.limit) : t, (i ? t.get(n) : t.get()).then(t => new M(t));\n      }(this._query, this._queryCriteria, t);\n    }\n\n    limit(t) {\n      return c(t), this._limit = t, new S(this._query, this._queryCriteria);\n    }\n\n    near(t) {\n      return u(t, !0), this._center = t.center, this._radius = t.radius, new S(this._query, this._queryCriteria);\n    }\n\n    where(t, e, n) {\n      return new S(this._query.where(t, e, n), this._queryCriteria);\n    }\n\n    get _queryCriteria() {\n      return {\n        center: this._center,\n        limit: this._limit,\n        radius: this._radius\n      };\n    }\n\n  }\n\n  class I {\n    constructor(t, e) {\n      if (this._writeBatch = t, this._customKey = e, \"[object Object]\" !== Object.prototype.toString.call(t)) throw new Error(\"WriteBatch must be an instance of a Firestore WriteBatch\");\n    }\n\n    get native() {\n      return this._writeBatch;\n    }\n\n    set(t, e, n = {}) {\n      const i = t instanceof P ? t._document : t;\n      return n.customKey = n.customKey || this._customKey, this._writeBatch.set(i, q(e, n), N(n)), this;\n    }\n\n    update(t, e, n = this._customKey) {\n      const i = t instanceof P ? t._document : t;\n      return this._writeBatch.update(i, E(e, n)), this;\n    }\n\n    delete(t) {\n      const e = t instanceof P ? t._document : t;\n      return this._writeBatch.delete(e), this;\n    }\n\n    commit() {\n      return this._writeBatch.commit();\n    }\n\n  }\n\n  class R {\n    constructor(t) {\n      if (this._firestore = t, \"[object Object]\" !== Object.prototype.toString.call(t)) throw new Error(\"Firestore must be an instance of Firestore\");\n    }\n\n    get native() {\n      return this._firestore;\n    }\n\n    batch(t) {\n      return new I(this._firestore.batch(), t);\n    }\n\n    collection(t, e) {\n      return new F(this._firestore.collection(t), e);\n    }\n\n    collectionGroup(t) {\n      return new S(this._firestore.collectionGroup(t));\n    }\n\n    doc(t) {\n      return new P(this._firestore.doc(t));\n    }\n\n    runTransaction(t) {\n      return this._firestore.runTransaction(t);\n    }\n\n  }\n\n  function N(t) {\n    const e = Object.assign({}, t);\n    return delete e.customKey, e;\n  }\n\n  class G {\n    constructor(t) {\n      if (this._snapshot = t, \"[object Object]\" !== Object.prototype.toString.call(t)) throw new Error(\"DocumentSnapshot must be an instance of a Firestore DocumentSnapshot\");\n      this._isWeb = \"[object Function]\" === Object.prototype.toString.call(t.ref.firestore.enablePersistence);\n    }\n\n    get native() {\n      return this._snapshot;\n    }\n\n    get exists() {\n      return this._snapshot.exists;\n    }\n\n    get id() {\n      return this._snapshot.id;\n    }\n\n    get ref() {\n      return new P(this._snapshot.ref);\n    }\n\n    data(t) {\n      return this._isWeb && t ? this._snapshot.data(t) : this._snapshot.data();\n    }\n\n    get(t, e) {\n      return this._isWeb && e ? this._snapshot.get(t, e) : this._snapshot.get(t);\n    }\n\n    isEqual(t) {\n      const e = t instanceof G ? t._snapshot : t;\n      return this._snapshot.isEqual(e);\n    }\n\n  }\n\n  class P {\n    constructor(t) {\n      if (this._document = t, \"[object Object]\" !== Object.prototype.toString.call(t)) throw new Error(\"DocumentReference must be an instance of a Firestore DocumentReference\");\n      this._isWeb = \"[object Function]\" === Object.prototype.toString.call(t.firestore.enablePersistence);\n    }\n\n    get native() {\n      return this._document;\n    }\n\n    get id() {\n      return this._document.id;\n    }\n\n    get firestore() {\n      return new R(this._document.firestore);\n    }\n\n    get onSnapshot() {\n      return (t, e = () => {}) => this._document.onSnapshot(e => t(new G(e)), t => e(t));\n    }\n\n    get parent() {\n      return new F(this._document.parent);\n    }\n\n    get path() {\n      return this._document.path;\n    }\n\n    collection(t) {\n      return new F(this._document.collection(t));\n    }\n\n    delete() {\n      return this._document.delete().then(() => null);\n    }\n\n    get(t = {\n      source: \"default\"\n    }) {\n      return (this._isWeb ? this._document.get(t) : this._document.get()).then(t => new G(t));\n    }\n\n    isEqual(t) {\n      const e = t instanceof P ? t._document : t;\n      return this._document.isEqual(e);\n    }\n\n    set(t, e) {\n      return this._document.set(q(t, e), N(e)).then(() => null);\n    }\n\n    update(t, e) {\n      return this._document.update(E(t, e)).then(() => null);\n    }\n\n  }\n\n  class F extends S {\n    constructor(t, e) {\n      super(t), this._collection = t, this._customKey = e;\n    }\n\n    get native() {\n      return this._collection;\n    }\n\n    get id() {\n      return this._collection.id;\n    }\n\n    get parent() {\n      return this._collection.parent ? new P(this._collection.parent) : null;\n    }\n\n    get path() {\n      return this._collection.path;\n    }\n\n    add(t, e = this._customKey) {\n      return this._collection.add(function (t, e) {\n        if (\"[object Object]\" !== Object.prototype.toString.call(t)) throw new Error(\"document must be an object\");\n        return x(_(t, e), t);\n      }(t, e)).then(t => new P(t));\n    }\n\n    doc(t) {\n      return new P(t ? this._collection.doc(t) : this._collection.doc());\n    }\n\n  }\n\n  t.GeoCollectionReference = F, t.GeoDocumentReference = P, t.GeoDocumentSnapshot = G, t.GeoFirestore = R, t.GeoQuery = S, t.GeoTransaction = class {\n    constructor(t, e) {\n      if (this._transaction = t, this._customKey = e, \"[object Object]\" !== Object.prototype.toString.call(t)) throw new Error(\"Transaction must be an instance of a Firestore Transaction\");\n    }\n\n    get native() {\n      return this._transaction;\n    }\n\n    delete(t) {\n      const e = t instanceof P ? t._document : t;\n      return this._transaction.delete(e), this;\n    }\n\n    get(t) {\n      const e = t instanceof P ? t._document : t;\n      return this._transaction.get(e).then(t => new G(t));\n    }\n\n    set(t, e, n = {}) {\n      const i = t instanceof P ? t._document : t;\n      return n.customKey = n.customKey || this._customKey, this._transaction.set(i, q(e, n), N(n)), this;\n    }\n\n    update(t, e, n = this._customKey) {\n      const i = t instanceof P ? t._document : t;\n      return this._transaction.update(i, E(e, n)), this;\n    }\n\n  }, t.GeoWriteBatch = I, t.initializeApp = function (t) {\n    return new R(t);\n  }, Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n});","map":null,"metadata":{},"sourceType":"script"}